(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"@protobufjs/aspromise":1,"@protobufjs/inquire":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){
// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity(x) {
  return x;
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function quantile(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],12:[function(require,module,exports){
// https://d3js.org/d3-axis/ v1.0.12 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = Array.prototype.slice;

function identity(x) {
  return x;
}

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],13:[function(require,module,exports){
// https://d3js.org/d3-brush/ v1.1.5 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function(target) {
    return d3Selection.touch(target, d3Selection.event.touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) { return xy == null ? null : number2(xy); },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

// Like d3.local, but with the name __brush rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

function brush() {
  return brush$1(XY);
}

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      touchable = defaultTouchable,
      keys = true,
      listeners = d3Dispatch.dispatch("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          d3Selection.select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mousedown.brush", started)
      .filter(touchable)
        .on("touchstart.brush", started)
        .on("touchmove.brush", touchmoved)
        .on("touchend.brush touchcancel.brush", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = d3Interpolate.interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && selection1 === null ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 !== null && selection1 !== null ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            d3Transition.interrupt(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  brush.clear = function(group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = d3Selection.select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    return (!clean && that.__brush.emitter) || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      else this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !d3Selection.event.touches) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3Selection.event.target.__data__.type,
        mode = (keys && d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && d3Selection.event.shiftKey,
        lockX,
        lockY,
        pointer = d3Selection.event.touches ? toucher(d3Selection.event.changedTouches[0].identifier) : d3Selection.mouse,
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = d3Selection.select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3Selection.event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = d3Selection.select(d3Selection.event.view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);
      if (keys) view
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true);

      d3Drag.dragDisable(d3Selection.event.view);
    }

    nopropagation();
    d3Transition.interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (d3Selection.event.touches) {
        if (d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      } else {
        d3Drag.dragEnable(d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3Selection.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush) : touchable;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

exports.brush = brush;
exports.brushSelection = brushSelection;
exports.brushX = brushX;
exports.brushY = brushY;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":18,"d3-drag":19,"d3-interpolate":27,"d3-selection":34,"d3-transition":39}],14:[function(require,module,exports){
// https://d3js.org/d3-chord/ v1.0.6 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-path')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Array,d3Path) { 'use strict';

var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

function chord() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = d3Array.range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3Array.range(n));
      k += x;
    }

    // Sort groups
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max(0, tau - padAngle * n) / k;
    dx = k ? padAngle : tau / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

var slice = Array.prototype.slice;

function constant(x) {
  return function() {
    return x;
  };
}

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function ribbon() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi,
        sa1 = endAngle.apply(this, argv) - halfPi,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi,
        ta1 = endAngle.apply(this, argv) - halfPi;

    if (!context) context = buffer = d3Path.path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
}

exports.chord = chord;
exports.ribbon = ribbon;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":11,"d3-path":28}],15:[function(require,module,exports){
// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],16:[function(require,module,exports){
// https://d3js.org/d3-color/ v1.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.cubehelix = cubehelix;
exports.gray = gray;
exports.hcl = hcl;
exports.hsl = hsl;
exports.lab = lab;
exports.lch = lch;
exports.rgb = rgb;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],17:[function(require,module,exports){
// https://d3js.org/d3-contour/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Array) { 'use strict';

var array = Array.prototype;

var slice = array.slice;

function ascending(a, b) {
  return a - b;
}

function area(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}

function constant(x) {
  return function() {
    return x;
  };
}

function contains(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
}

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function noop() {}

var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

function contours() {
  var dx = 1,
      dy = 1,
      threshold = d3Array.thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
      tz = d3Array.tickStep(start, stop, tz);
      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

function density() {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = constant(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (+x(d, i, data) + o) >> k,
          yi = (+y(d, i, data) + o) >> k,
          wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });

    // TODO Optimize.
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = d3Array.max(values0);
      tz = d3Array.tickStep(0, stop, tz);
      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
  };

  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant(+_), density) : weight;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
}

exports.contours = contours;
exports.contourDensity = density;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":11}],18:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],19:[function(require,module,exports){
// https://d3js.org/d3-drag/ v1.2.5 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-selection')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Selection) { 'use strict';

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

function nodrag(view) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant(x) {
  return function() {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = d3Dispatch.dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
    if (!gesture) return;
    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(d3Selection.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = d3Selection.event.clientX;
    mousedowny = d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(d3Selection.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

exports.drag = drag;
exports.dragDisable = nodrag;
exports.dragEnable = yesdrag;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":18,"d3-selection":34}],20:[function(require,module,exports){
// https://d3js.org/d3-dsv/ v1.2.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

function dsv(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(), number, m;
    if (!value) value = null;
    else if (value === "true") value = true;
    else if (value === "false") value = false;
    else if (value === "NaN") value = NaN;
    else if (!isNaN(number = +value)) value = number;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    }
    else continue;
    object[key] = value;
  }
  return object;
}

// https://github.com/d3/d3-dsv/issues/45
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

exports.autoType = autoType;
exports.csvFormat = csvFormat;
exports.csvFormatBody = csvFormatBody;
exports.csvFormatRow = csvFormatRow;
exports.csvFormatRows = csvFormatRows;
exports.csvFormatValue = csvFormatValue;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.dsvFormat = dsv;
exports.tsvFormat = tsvFormat;
exports.tsvFormatBody = tsvFormatBody;
exports.tsvFormatRow = tsvFormatRow;
exports.tsvFormatRows = tsvFormatRows;
exports.tsvFormatValue = tsvFormatValue;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],21:[function(require,module,exports){
// https://d3js.org/d3-ease/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackInOut = backInOut;
exports.easeBackOut = backOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceInOut = bounceInOut;
exports.easeBounceOut = bounceOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleInOut = circleInOut;
exports.easeCircleOut = circleOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicInOut = cubicInOut;
exports.easeCubicOut = cubicOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticInOut = elasticInOut;
exports.easeElasticOut = elasticOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpInOut = expInOut;
exports.easeExpOut = expOut;
exports.easeLinear = linear;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyInOut = polyInOut;
exports.easePolyOut = polyOut;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadInOut = quadInOut;
exports.easeQuadOut = quadOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinInOut = sinInOut;
exports.easeSinOut = sinOut;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],22:[function(require,module,exports){
// https://d3js.org/d3-fetch/ v1.1.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dsv')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dsv'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Dsv) { 'use strict';

function responseBlob(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.blob();
}

function blob(input, init) {
  return fetch(input, init).then(responseBlob);
}

function responseArrayBuffer(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}

function buffer(input, init) {
  return fetch(input, init).then(responseArrayBuffer);
}

function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

function text(input, init) {
  return fetch(input, init).then(responseText);
}

function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return text(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = d3Dsv.dsvFormat(delimiter);
  return text(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3Dsv.csvParse);
var tsv = dsvParse(d3Dsv.tsvParse);

function image(input, init) {
  return new Promise(function(resolve, reject) {
    var image = new Image;
    for (var key in init) image[key] = init[key];
    image.onerror = reject;
    image.onload = function() { resolve(image); };
    image.src = input;
  });
}

function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.json();
}

function json(input, init) {
  return fetch(input, init).then(responseJson);
}

function parser(type) {
  return function(input, init)  {
    return text(input, init).then(function(text$$1) {
      return (new DOMParser).parseFromString(text$$1, type);
    });
  };
}

var xml = parser("application/xml");

var html = parser("text/html");

var svg = parser("image/svg+xml");

exports.blob = blob;
exports.buffer = buffer;
exports.dsv = dsv;
exports.csv = csv;
exports.tsv = tsv;
exports.image = image;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.html = html;
exports.svg = svg;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dsv":20}],23:[function(require,module,exports){
// https://d3js.org/d3-force/ v1.2.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-quadtree'), require('d3-collection'), require('d3-dispatch'), require('d3-timer')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

function center(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function constant(x) {
  return function() {
    return x;
  };
}

function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function collide(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  return force;
}

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function link(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = d3Collection.map(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
  };

  return force;
}

function x$1(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function simulation(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = d3Collection.map(),
      stepper = d3Timer.timer(step),
      event = d3Dispatch.dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.each(function (force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function manyBody() {
  var nodes,
      node,
      alpha,
      strength = constant(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function radial(radius, x, y) {
  var nodes,
      strength = constant(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function x$2(x) {
  var strength = constant(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
  };

  return force;
}

function y$2(y) {
  var strength = constant(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
  };

  return force;
}

exports.forceCenter = center;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceRadial = radial;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-collection":15,"d3-dispatch":18,"d3-quadtree":30,"d3-timer":38}],24:[function(require,module,exports){
// https://d3js.org/d3-format/ v1.4.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;

        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.FormatSpecifier = FormatSpecifier;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],25:[function(require,module,exports){
// https://d3js.org/d3-geo/ v1.11.9 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Array) { 'use strict';

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

function adder() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}

function noop() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

function geoStream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

var areaRingSum = adder();

var areaSum = adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop;
  },
  sphere: function() {
    areaSum.add(tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos(phi),
      sinPhi = sin(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos(adLambda),
      v = k * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function area(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
}

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00$1, phi00$1, // first point
    p0, // previous 3D point
    deltaSum = adder(),
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon) phi1 = 90;
    else if (deltaSum < -epsilon) phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  },
  sphere: function() {
    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees * sign,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function bounds(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
}

var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00$2, phi00$2, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: noop,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroid(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
}

function constant(x) {
  return function() {
    return x;
  };
}

function compose(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}

function rotationIdentity(lambda, phi) {
  return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi),
      sinDeltaPhi = sin(deltaPhi),
      cosDeltaGamma = cos(deltaGamma),
      sinDeltaGamma = sin(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };

  return forward;
}

// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius),
      sinRadius = sin(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

function circle() {
  var center = constant([0, 0]),
      radius = constant(90),
      precision = constant(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees, x[1] *= degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
  };

  return circle;
}

function clipBuffer() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var sum = adder();

function longitude(point) {
  if (abs(point[0]) <= pi)
    return point[0];
  else
    return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
}

function polygonContains(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = sin(phi),
      normal = [sin(lambda), -cos(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  if (sinPhi === 1) phi = halfPi + epsilon;
  else if (sinPhi === -1) phi = -halfPi - epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin(phi0),
        cosPhi0 = cos(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin(phi1),
          cosPhi1 = cos(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > pi,
          k = sinPhi0 * sinPhi1;

      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle += antimeridian ? delta + sign * tau : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
}

function clip(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = d3Array.merge(segments);
        var startInside = polygonContains(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon
      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

function clipCircle(radius) {
  var cr = cos(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi) < epsilon,
        meridian = polar || delta < epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}

function clipLine(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = d3Array.merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

function extent() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

var lengthSum = adder(),
    lambda0$2,
    sinPhi0$1,
    cosPhi0$1;

var lengthStream = {
  sphere: noop,
  point: noop,
  lineStart: lengthLineStart,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin(phi),
      cosPhi = cos(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos(delta),
      sinDelta = sin(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

function length(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
}

var coordinates = [null, null],
    object = {type: "LineString", coordinates: coordinates};

function distance(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length(object);
}

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ao, bo, ab;
  for (var i = 0, n = coordinates.length; i < n; i++) {
    bo = distance(coordinates[i], point);
    if (bo === 0) return true;
    if (i > 0) {
      ab = distance(coordinates[i], coordinates[i - 1]);
      if (
        ab > 0 &&
        ao <= ab &&
        bo <= ab &&
        (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
      )
        return true;
    }
    ao = bo;
  }
  return false;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

function contains(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
}

function graticuleX(y0, y1, dy) {
  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}

function graticule10() {
  return graticule()();
}

function interpolate(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos(y0),
      sy0 = sin(y0),
      cy1 = cos(y1),
      sy1 = sin(y1),
      kx0 = cy0 * cos(x0),
      ky0 = cy0 * sin(x0),
      kx1 = cy1 * cos(x1),
      ky1 = cy1 * sin(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin(d);

  var interpolate = d ? function(t) {
    var B = sin(t *= d) / k,
        A = sin(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees,
      atan2(z, sqrt(x * x + y * y)) * degrees
    ];
  } : function() {
    return [x0 * degrees, y0 * degrees];
  };

  interpolate.distance = d;

  return interpolate;
}

function identity(x) {
  return x;
}

var areaSum$1 = adder(),
    areaRingSum$1 = adder(),
    x00,
    y00,
    x0$1,
    y0$1;

var areaStream$1 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity,
    y0$2 = x0$2,
    x1 = -x0$2,
    y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0,
    Y0$1 = 0,
    Z0$1 = 0,
    X1$1 = 0,
    Y1$1 = 0,
    Z1$1 = 0,
    X2$1 = 0,
    Y2$1 = 0,
    Z2$1 = 0,
    x00$1,
    y00$1,
    x0$3,
    y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

var lengthSum$1 = adder(),
    lengthRing,
    x00$2,
    y00$2,
    x0$4,
    y0$4;

var lengthStream$1 = {
  point: noop,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

function index(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

function transform(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy) {
  function transform(x, y) {
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k, (dy - y) / k];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, alpha) {
  var cosAlpha = cos(alpha),
      sinAlpha = sin(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate
      theta = null, preclip = clipAntimeridian, // pre-clip angle
      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * radians, point[1] * radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * degrees, point[1] * degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose(project, transform);
    projectRotateTransform = compose(rotate, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin(y)) / n;
    return [r * sin(x *= n), r0 - r * cos(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}

function albers() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
function albersUsa() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos(x),
        cy = cos(y),
        k = scale(cx * cy);
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin(c),
        cc = cos(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi];
};

function mercator() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau);
}

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
    var r = f / pow(tany(y), n);
    return [r * sin(n * x), f - r * cos(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
  };

  return project;
}

function conicConformal() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function equirectangular() {
  return projection(equirectangularRaw)
      .scale(152.63);
}

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin(nx), g - gy * cos(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

function conicEquidistant() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}

var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = sqrt(3) / 2,
    iterations = 12;

function equalEarthRaw(lambda, phi) {
  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}

equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs(delta) < epsilon2) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
    asin(sin(l) / M)
  ];
};

function equalEarth() {
  return projection(equalEarthRaw)
      .scale(177.158);
}

function gnomonicRaw(x, y) {
  var cy = cos(y), k = cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

function gnomonic() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}

function scaleTranslate$1(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function identity$1() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = identity,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    },
    fitWidth: function(width, object) {
      return fitWidth(projection, width, object);
    },
    fitHeight: function(height, object) {
      return fitHeight(projection, height, object);
    }
  };
}

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

function naturalEarth1() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
}

function orthographicRaw(x, y) {
  return [cos(y) * sin(x), sin(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

function orthographic() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon);
}

function stereographicRaw(x, y) {
  var cy = cos(y), k = 1 + cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

function stereographic() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi];
};

function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}

exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoArea = area;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipAntimeridian = clipAntimeridian;
exports.geoClipCircle = clipCircle;
exports.geoClipExtent = extent;
exports.geoClipRectangle = clipRectangle;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoContains = contains;
exports.geoDistance = distance;
exports.geoEqualEarth = equalEarth;
exports.geoEqualEarthRaw = equalEarthRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoIdentity = identity$1;
exports.geoInterpolate = interpolate;
exports.geoLength = length;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoNaturalEarth1 = naturalEarth1;
exports.geoNaturalEarth1Raw = naturalEarth1Raw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoPath = index;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoRotation = rotation;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoStream = geoStream;
exports.geoTransform = transform;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-array":11}],26:[function(require,module,exports){
// https://d3js.org/d3-hierarchy/ v1.1.9 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Dont include the roots parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function siblings(circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant(x) {
  return function() {
    return x;
  };
}

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function index() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix = "$", // Protect against keys like __proto__.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$1() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);

exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index;
exports.packEnclose = enclose;
exports.packSiblings = siblings;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$1;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapResquarify = resquarify;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],27:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ v1.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function array(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : isNumberArray(b) ? numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue) {
  return function(start, end) {
    var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue) {
  return function(start, end) {
    var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateHue = hue$1;
exports.interpolateLab = lab;
exports.interpolateNumber = number;
exports.interpolateNumberArray = numberArray;
exports.interpolateObject = object;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":16}],28:[function(require,module,exports){
// https://d3js.org/d3-path/ v1.0.9 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],29:[function(require,module,exports){
// https://d3js.org/d3-polygon/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function area(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}

function centroid(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function hull(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}

function contains(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}

function length(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}

exports.polygonArea = area;
exports.polygonCentroid = centroid;
exports.polygonContains = contains;
exports.polygonHull = hull;
exports.polygonLength = length;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],30:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],31:[function(require,module,exports){
// https://d3js.org/d3-random/ v1.1.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function defaultSource() {
  return Math.random();
}

var uniform = (function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
})(defaultSource);

var normal = (function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(defaultSource);

var logNormal = (function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
})(defaultSource);

var irwinHall = (function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
})(defaultSource);

var bates = (function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
})(defaultSource);

var exponential = (function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
})(defaultSource);

exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],32:[function(require,module,exports){
// https://d3js.org/d3-scale-chromatic/ v1.5.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-interpolate'), require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
}(this, function (exports, d3Interpolate, d3Color) { 'use strict';

function colors(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

function ramp(scheme) {
  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
}

var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors);

var BrBG = ramp(scheme);

var scheme$1 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors);

var PRGn = ramp(scheme$1);

var scheme$2 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors);

var PiYG = ramp(scheme$2);

var scheme$3 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors);

var PuOr = ramp(scheme$3);

var scheme$4 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors);

var RdBu = ramp(scheme$4);

var scheme$5 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors);

var RdGy = ramp(scheme$5);

var scheme$6 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors);

var RdYlBu = ramp(scheme$6);

var scheme$7 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors);

var RdYlGn = ramp(scheme$7);

var scheme$8 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors);

var Spectral = ramp(scheme$8);

var scheme$9 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors);

var BuGn = ramp(scheme$9);

var scheme$a = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors);

var BuPu = ramp(scheme$a);

var scheme$b = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors);

var GnBu = ramp(scheme$b);

var scheme$c = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors);

var OrRd = ramp(scheme$c);

var scheme$d = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors);

var PuBuGn = ramp(scheme$d);

var scheme$e = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors);

var PuBu = ramp(scheme$e);

var scheme$f = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors);

var PuRd = ramp(scheme$f);

var scheme$g = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors);

var RdPu = ramp(scheme$g);

var scheme$h = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors);

var YlGnBu = ramp(scheme$h);

var scheme$i = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors);

var YlGn = ramp(scheme$i);

var scheme$j = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors);

var YlOrBr = ramp(scheme$j);

var scheme$k = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors);

var YlOrRd = ramp(scheme$k);

var scheme$l = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors);

var Blues = ramp(scheme$l);

var scheme$m = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors);

var Greens = ramp(scheme$m);

var scheme$n = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors);

var Greys = ramp(scheme$n);

var scheme$o = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors);

var Purples = ramp(scheme$o);

var scheme$p = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors);

var Reds = ramp(scheme$p);

var scheme$q = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors);

var Oranges = ramp(scheme$q);

function cividis(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb("
      + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
      + ")";
}

var cubehelix = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var c = d3Color.cubehelix();

function rainbow(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

var c$1 = d3Color.rgb(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;

function sinebow(t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c$1.r = 255 * (x = Math.sin(t)) * x;
  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c$1 + "";
}

function turbo(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb("
      + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
      + ")";
}

function ramp$1(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

exports.interpolateBlues = Blues;
exports.interpolateBrBG = BrBG;
exports.interpolateBuGn = BuGn;
exports.interpolateBuPu = BuPu;
exports.interpolateCividis = cividis;
exports.interpolateCool = cool;
exports.interpolateCubehelixDefault = cubehelix;
exports.interpolateGnBu = GnBu;
exports.interpolateGreens = Greens;
exports.interpolateGreys = Greys;
exports.interpolateInferno = inferno;
exports.interpolateMagma = magma;
exports.interpolateOrRd = OrRd;
exports.interpolateOranges = Oranges;
exports.interpolatePRGn = PRGn;
exports.interpolatePiYG = PiYG;
exports.interpolatePlasma = plasma;
exports.interpolatePuBu = PuBu;
exports.interpolatePuBuGn = PuBuGn;
exports.interpolatePuOr = PuOr;
exports.interpolatePuRd = PuRd;
exports.interpolatePurples = Purples;
exports.interpolateRainbow = rainbow;
exports.interpolateRdBu = RdBu;
exports.interpolateRdGy = RdGy;
exports.interpolateRdPu = RdPu;
exports.interpolateRdYlBu = RdYlBu;
exports.interpolateRdYlGn = RdYlGn;
exports.interpolateReds = Reds;
exports.interpolateSinebow = sinebow;
exports.interpolateSpectral = Spectral;
exports.interpolateTurbo = turbo;
exports.interpolateViridis = viridis;
exports.interpolateWarm = warm;
exports.interpolateYlGn = YlGn;
exports.interpolateYlGnBu = YlGnBu;
exports.interpolateYlOrBr = YlOrBr;
exports.interpolateYlOrRd = YlOrRd;
exports.schemeAccent = Accent;
exports.schemeBlues = scheme$l;
exports.schemeBrBG = scheme;
exports.schemeBuGn = scheme$9;
exports.schemeBuPu = scheme$a;
exports.schemeCategory10 = category10;
exports.schemeDark2 = Dark2;
exports.schemeGnBu = scheme$b;
exports.schemeGreens = scheme$m;
exports.schemeGreys = scheme$n;
exports.schemeOrRd = scheme$c;
exports.schemeOranges = scheme$q;
exports.schemePRGn = scheme$1;
exports.schemePaired = Paired;
exports.schemePastel1 = Pastel1;
exports.schemePastel2 = Pastel2;
exports.schemePiYG = scheme$2;
exports.schemePuBu = scheme$e;
exports.schemePuBuGn = scheme$d;
exports.schemePuOr = scheme$3;
exports.schemePuRd = scheme$f;
exports.schemePurples = scheme$o;
exports.schemeRdBu = scheme$4;
exports.schemeRdGy = scheme$5;
exports.schemeRdPu = scheme$g;
exports.schemeRdYlBu = scheme$6;
exports.schemeRdYlGn = scheme$7;
exports.schemeReds = scheme$p;
exports.schemeSet1 = Set1;
exports.schemeSet2 = Set2;
exports.schemeSet3 = Set3;
exports.schemeSpectral = scheme$8;
exports.schemeTableau10 = Tableau10;
exports.schemeYlGn = scheme$i;
exports.schemeYlGnBu = scheme$h;
exports.schemeYlOrBr = scheme$j;
exports.schemeYlOrRd = scheme$k;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":16,"d3-interpolate":27}],33:[function(require,module,exports){
// https://d3js.org/d3-scale/ v2.2.2 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-collection'), require('d3-array'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-collection', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Collection,d3Array,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.interpolator(domain); break;
    default: this.interpolator(interpolator).domain(domain); break;
  }
  return this;
}

var array = Array.prototype;

var map = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal() {
  var index = d3Collection.map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

function constant(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3Interpolate.interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}

function tickFormat(start, stop, count, specifier) {
  var step = d3Array.tickStep(start, stop, count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(identity, identity);

  scale.copy = function() {
    return copy(scale, linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function identity$1(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity$1(domain).unknown(unknown);
  };

  domain = arguments.length ? map.call(domain, number) : [0, 1];

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(identity, identity),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function utcTime() {
  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

function transformer$1() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy$1(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(transformer$1()(identity));

  scale.copy = function() {
    return copy$1(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);

  scale.copy = function() {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

function transformer$2() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = linearish(transformer$2()(identity));

  scale.copy = function() {
    return copy$1(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return copy$1(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity$1;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleSymlog = symlog;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.scaleSequential = sequential;
exports.scaleSequentialLog = sequentialLog;
exports.scaleSequentialPow = sequentialPow;
exports.scaleSequentialSqrt = sequentialSqrt;
exports.scaleSequentialSymlog = sequentialSymlog;
exports.scaleSequentialQuantile = sequentialQuantile;
exports.scaleDiverging = diverging;
exports.scaleDivergingLog = divergingLog;
exports.scaleDivergingPow = divergingPow;
exports.scaleDivergingSqrt = divergingSqrt;
exports.scaleDivergingSymlog = divergingSymlog;
exports.tickFormat = tickFormat;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":11,"d3-collection":15,"d3-format":24,"d3-interpolate":27,"d3-time":37,"d3-time-format":36}],34:[function(require,module,exports){
// https://d3js.org/d3-selection/ v1.4.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.clientPoint = point;
exports.create = create;
exports.creator = creator;
exports.customEvent = customEvent;
exports.local = local;
exports.matcher = matcher;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],35:[function(require,module,exports){
// https://d3js.org/d3-shape/ v1.3.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-path')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Path) { 'use strict';

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$1 = x,
      y$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$1 = x,
      y$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link) : x$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link) : y$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop() {}

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$1(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
}

function appearance(series) {
  var peaks = series.map(peak);
  return none$1(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
}

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

function ascending(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$1(series) {
  return ascending(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$1(series).reverse();
}

exports.arc = arc;
exports.area = area;
exports.areaRadial = areaRadial;
exports.curveBasis = basis;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBundle = bundle;
exports.curveCardinal = cardinal;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCatmullRom = catmullRom;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveLinear = curveLinear;
exports.curveLinearClosed = linearClosed;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.line = line;
exports.lineRadial = lineRadial$1;
exports.linkHorizontal = linkHorizontal;
exports.linkRadial = linkRadial;
exports.linkVertical = linkVertical;
exports.pie = pie;
exports.pointRadial = pointRadial;
exports.radialArea = areaRadial;
exports.radialLine = lineRadial$1;
exports.stack = stack;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetExpand = expand;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAppearance = appearance;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;
exports.symbol = symbol;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.symbols = symbols;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-path":28}],36:[function(require,module,exports){
// https://d3js.org/d3-time-format/ v2.2.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.isoFormat = formatIso;
exports.isoParse = parseIso;
exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-time":37}],37:[function(require,module,exports){
// https://d3js.org/d3-time/ v1.1.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeDay = day;
exports.timeDays = days;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeYear = year;
exports.timeYears = years;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],38:[function(require,module,exports){
// https://d3js.org/d3-timer/ v1.0.10 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

exports.interval = interval$1;
exports.now = now;
exports.timeout = timeout$1;
exports.timer = timer;
exports.timerFlush = timerFlush;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],39:[function(require,module,exports){
// https://d3js.org/d3-transition/ v1.3.2 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-timer'), require('d3-interpolate'), require('d3-color'), require('d3-ease')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) { 'use strict';

var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = d3Timer.timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return d3Timer.timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    d3Timer.timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? d3Interpolate.interpolateNumber
      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
      : d3Interpolate.interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = d3Selection.namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = d3Selection.matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = d3Selection.selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name),
        string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and were done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return d3Selection.selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3Selection.selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = d3Timer.now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

d3Selection.selection.prototype.interrupt = selection_interrupt;
d3Selection.selection.prototype.transition = selection_transition;

var root = [null];

function active(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}

exports.active = active;
exports.interrupt = interrupt;
exports.transition = transition;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":16,"d3-dispatch":18,"d3-ease":21,"d3-interpolate":27,"d3-selection":34,"d3-timer":38}],40:[function(require,module,exports){
// https://d3js.org/d3-voronoi/ v1.1.4 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// LiangBarsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there werent any edges, have the closest site cover the extent.
  // It doesnt matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon
      && Math.abs(y - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon
      && Math.abs(y - rArc.circle.cy) < epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

function voronoi() {
  var x$$1 = x,
      y$$1 = y,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

exports.voronoi = voronoi;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],41:[function(require,module,exports){
// https://d3js.org/d3-zoom/ v1.8.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta() {
  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode === 1 ? 0.05 : d3Selection.event.deltaMode ? 1 : 0.002);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

function zoom() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3Interpolate.interpolateZoom,
      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = d3Selection.mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      d3Transition.interrupt(this);
      g.start();
    }

    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = d3Selection.mouse(this),
        x0 = d3Selection.event.clientX,
        y0 = d3Selection.event.clientY;

    d3Drag.dragDisable(d3Selection.event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    d3Transition.interrupt(this);
    g.start();

    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      d3Drag.dragEnable(d3Selection.event.view, g.moved);
      noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = d3Selection.mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent();
    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
    else d3Selection.select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.touches,
        n = touches.length,
        g = gesture(this, arguments, d3Selection.event.changedTouches.length === n),
        started, i, t, p;

    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      d3Transition.interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t;

    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = d3Selection.select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}

exports.zoom = zoom;
exports.zoomIdentity = identity;
exports.zoomTransform = transform;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":18,"d3-drag":19,"d3-interpolate":27,"d3-selection":34,"d3-transition":39}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3Array = require('d3-array');
var d3Axis = require('d3-axis');
var d3Brush = require('d3-brush');
var d3Chord = require('d3-chord');
var d3Collection = require('d3-collection');
var d3Color = require('d3-color');
var d3Contour = require('d3-contour');
var d3Dispatch = require('d3-dispatch');
var d3Drag = require('d3-drag');
var d3Dsv = require('d3-dsv');
var d3Ease = require('d3-ease');
var d3Fetch = require('d3-fetch');
var d3Force = require('d3-force');
var d3Format = require('d3-format');
var d3Geo = require('d3-geo');
var d3Hierarchy = require('d3-hierarchy');
var d3Interpolate = require('d3-interpolate');
var d3Path = require('d3-path');
var d3Polygon = require('d3-polygon');
var d3Quadtree = require('d3-quadtree');
var d3Random = require('d3-random');
var d3Scale = require('d3-scale');
var d3ScaleChromatic = require('d3-scale-chromatic');
var d3Selection = require('d3-selection');
var d3Shape = require('d3-shape');
var d3Time = require('d3-time');
var d3TimeFormat = require('d3-time-format');
var d3Timer = require('d3-timer');
var d3Transition = require('d3-transition');
var d3Voronoi = require('d3-voronoi');
var d3Zoom = require('d3-zoom');

var version = "5.15.0";

Object.keys(d3Array).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Array[k];
		}
	});
});
Object.keys(d3Axis).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Axis[k];
		}
	});
});
Object.keys(d3Brush).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Brush[k];
		}
	});
});
Object.keys(d3Chord).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Chord[k];
		}
	});
});
Object.keys(d3Collection).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Collection[k];
		}
	});
});
Object.keys(d3Color).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Color[k];
		}
	});
});
Object.keys(d3Contour).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Contour[k];
		}
	});
});
Object.keys(d3Dispatch).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Dispatch[k];
		}
	});
});
Object.keys(d3Drag).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Drag[k];
		}
	});
});
Object.keys(d3Dsv).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Dsv[k];
		}
	});
});
Object.keys(d3Ease).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Ease[k];
		}
	});
});
Object.keys(d3Fetch).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Fetch[k];
		}
	});
});
Object.keys(d3Force).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Force[k];
		}
	});
});
Object.keys(d3Format).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Format[k];
		}
	});
});
Object.keys(d3Geo).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Geo[k];
		}
	});
});
Object.keys(d3Hierarchy).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Hierarchy[k];
		}
	});
});
Object.keys(d3Interpolate).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Interpolate[k];
		}
	});
});
Object.keys(d3Path).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Path[k];
		}
	});
});
Object.keys(d3Polygon).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Polygon[k];
		}
	});
});
Object.keys(d3Quadtree).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Quadtree[k];
		}
	});
});
Object.keys(d3Random).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Random[k];
		}
	});
});
Object.keys(d3Scale).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Scale[k];
		}
	});
});
Object.keys(d3ScaleChromatic).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3ScaleChromatic[k];
		}
	});
});
Object.keys(d3Selection).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Selection[k];
		}
	});
});
Object.keys(d3Shape).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Shape[k];
		}
	});
});
Object.keys(d3Time).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Time[k];
		}
	});
});
Object.keys(d3TimeFormat).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3TimeFormat[k];
		}
	});
});
Object.keys(d3Timer).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Timer[k];
		}
	});
});
Object.keys(d3Transition).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Transition[k];
		}
	});
});
Object.keys(d3Voronoi).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Voronoi[k];
		}
	});
});
Object.keys(d3Zoom).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Zoom[k];
		}
	});
});
exports.version = version;

},{"d3-array":11,"d3-axis":12,"d3-brush":13,"d3-chord":14,"d3-collection":15,"d3-color":16,"d3-contour":17,"d3-dispatch":18,"d3-drag":19,"d3-dsv":20,"d3-ease":21,"d3-fetch":22,"d3-force":23,"d3-format":24,"d3-geo":25,"d3-hierarchy":26,"d3-interpolate":27,"d3-path":28,"d3-polygon":29,"d3-quadtree":30,"d3-random":31,"d3-scale":33,"d3-scale-chromatic":32,"d3-selection":34,"d3-shape":35,"d3-time":37,"d3-time-format":36,"d3-timer":38,"d3-transition":39,"d3-voronoi":40,"d3-zoom":41}],43:[function(require,module,exports){
// full library entry point.

"use strict";
module.exports = require("./src/index");

},{"./src/index":52}],44:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],45:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"./enum":48,"./util":70}],46:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"./enum":48,"./types":69,"./util":70}],47:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

},{"./enum":48,"./types":69,"./util":70}],48:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"./namespace":56,"./object":57,"./util":70}],49:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"./enum":48,"./object":57,"./types":69,"./util":70}],50:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"./converter":45,"./decoder":46,"./encoder":47,"./enum":48,"./field":49,"./index-minimal":51,"./mapfield":53,"./message":54,"./method":55,"./namespace":56,"./object":57,"./oneof":58,"./root":62,"./service":66,"./type":68,"./types":69,"./util":70,"./verifier":73,"./wrappers":74}],51:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"./reader":60,"./reader_buffer":61,"./roots":63,"./rpc":64,"./util/minimal":72,"./writer":75,"./writer_buffer":76}],52:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-light");

protobuf.build = "full";

// Parser
protobuf.tokenize         = require("./tokenize");
protobuf.parse            = require("./parse");
protobuf.common           = require("./common");

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"./common":44,"./index-light":50,"./parse":59,"./tokenize":67}],53:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"./field":49,"./types":69,"./util":70}],54:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"./util/minimal":72}],55:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"./object":57,"./util":70}],56:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require("./field"),
    util     = require("./util");

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

},{"./field":49,"./object":57,"./util":70}],57:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"./util":70}],58:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"./field":49,"./object":57,"./util":70}],59:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require("./tokenize"),
    Root      = require("./root"),
    Type      = require("./type"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    OneOf     = require("./oneof"),
    Enum      = require("./enum"),
    Service   = require("./service"),
    Method    = require("./method"),
    types     = require("./types"),
    util      = require("./util");

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        var option = name;
        var propName;

        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            option = name;
            token = peek();
            if (fqTypeRefRe.test(token)) {
                propName = token.substr(1); //remove '.' before property name
                name += token;
                next();
            }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            var result = {};
            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                var value;
                var propName = token;
                if (peek() === "{")
                    value = parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        value = parseOptionValue(parent, name + "." + token);
                    else {
                        value = readValue(true);
                        setOption(parent, name + "." + token, value);
                    }
                }
                var prevValue = result[propName];
                if (prevValue)
                    value = [].concat(prevValue).concat(value);
                result[propName] = value;
                skip(",", true);
            }
            return result;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        // Get the comment of the preceding line now (if one exists) in case the
        // method is defined across multiple lines.
        var commentText = cmnt();

        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"./enum":48,"./field":49,"./mapfield":53,"./method":55,"./oneof":58,"./root":62,"./service":66,"./tokenize":67,"./type":68,"./types":69,"./util":70}],60:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":72}],61:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"./reader":60,"./util/minimal":72}],62:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

},{"./enum":48,"./field":49,"./namespace":56,"./oneof":58,"./util":70}],63:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],64:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":65}],65:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":72}],66:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"./method":55,"./namespace":56,"./rpc":64,"./util":70}],67:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false,
        commentIsLeading = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @param {boolean} isLeading set if a leading comment
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                    isLeadingComment = true;
                    ++line;
                }
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1, isLeadingComment);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset, isLeadingComment);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2, isLeadingComment);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentIsLeading ? commentText : null;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentIsLeading ? null : commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],68:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"./converter":45,"./decoder":46,"./encoder":47,"./enum":48,"./field":49,"./mapfield":53,"./message":54,"./namespace":56,"./oneof":58,"./reader":60,"./service":66,"./util":70,"./verifier":73,"./wrappers":74,"./writer":75}],69:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"./util":70}],70:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});

},{"./enum":48,"./root":62,"./roots":63,"./type":68,"./util/minimal":72,"@protobufjs/codegen":3,"@protobufjs/fetch":5,"@protobufjs/path":8}],71:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":72}],72:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./longbits":71,"@protobufjs/aspromise":1,"@protobufjs/base64":2,"@protobufjs/eventemitter":4,"@protobufjs/float":6,"@protobufjs/inquire":7,"@protobufjs/pool":9,"@protobufjs/utf8":10}],73:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"./enum":48,"./util":70}],74:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.substr(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"./message":54}],75:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"./util/minimal":72}],76:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"./util/minimal":72,"./writer":75}],77:[function(require,module,exports){
const quickSelect = require('./src/quickSelect')

module.exports = quickSelect

},{"./src/quickSelect":78}],78:[function(require,module,exports){
const randIntBetween = (min, max) => Math.floor(Math.random() * max) + min

const defaultAccessor = element => element

const checkArguments = (array, k, accessor) => {
  if (!Array.isArray(array)) throw new Error('The first argument should be a javascript array!')
  if (typeof k !== 'number') throw new Error('The second argument should be a javascript number!')
  if (typeof accessor !== 'function') throw new Error('The third argument should be a javascript function!')
  if (array.length < k) {
    throw new Error('K should not be greater than array length!')
  }
}

/**
 * Quickselect
 * https://en.wikipedia.org/wiki/Quickselect
 * @param {Array} array - Data
 * @param {Number} k - Position of smallest element (starts from 0)
 * @param {Function} accessor - Function which return value for processing (optional)
 */
const quickSelect = (array, k, accessor = defaultAccessor) => {
  checkArguments(array, k, accessor)
  if (array.length === 1 && k === 0) return array[0]

  while (true) {
    const pivot = accessor(array[randIntBetween(0, array.length - 1)])
    const lows = []
    const highs = []
    const pivots = []
    for (let i = 0; i < array.length; i += 1) {
      if (accessor(array[i]) < pivot) lows.push(array[i])
      if (accessor(array[i]) > pivot) highs.push(array[i])
      if (accessor(array[i]) === pivot) pivots.push(array[i])
    }

    /* eslint-disable no-param-reassign */
    if (k < lows.length) {
      array = lows
    } else if (k < lows.length + pivots.length) {
      return pivots[0]
    } else {
      array = highs
      k = k - lows.length - pivots.length
    }
    /* eslint-enable no-param-reassign */
  }
}

module.exports = quickSelect

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./Components/BaseWidget");
const Toolbar_1 = require("./Components/Toolbar");
const Plot2dPathsWidget_1 = require("./Components/Plot2dPathsWidget");
const MetricDistributionWidget_1 = require("./Components/MetricDistributionWidget");
const ImageSelectionWidget_1 = require("./Components/ImageSelectionWidget");
const LayoutFramework_1 = require("./LayoutFramework");
const types_1 = require("./types");
const DataEvents_1 = require("./DataModel/DataEvents");
const DetailedDistributionWidget_1 = require("./Components/DetailedDistributionWidget");
const DevlibTSUtil_1 = require("./devlib/DevlibTSUtil");
class App {
    constructor(container, fromCsvObject, derivedTrackDataFunctions, derivedPointDataFunctions) {
        this._container = container;
        this._componentList = [];
        this._layoutFramework = new LayoutFramework_1.LayoutFramework(container);
        this._dataFromCSVObject = fromCsvObject;
        this._trackDerivationFunctions = derivedTrackDataFunctions;
        this._pointDerivationFunctions = derivedPointDataFunctions;
        document.addEventListener(DataEvents_1.DataEvents.brushChange, (e) => { this.onBrushChange(); });
    }
    get data() {
        return this._data;
    }
    get container() {
        return this._container;
    }
    get componentList() {
        return this._componentList;
    }
    get layoutFramework() {
        return this._layoutFramework;
    }
    get componentContainers() {
        return this._componentContainers;
    }
    get dataFromCSVObject() {
        return this._dataFromCSVObject;
    }
    get trackDerivationFunctions() {
        return this._trackDerivationFunctions;
    }
    get pointDerivationFunctions() {
        return this._pointDerivationFunctions;
    }
    InitializeLayout(frame) {
        // console.log(frame);
        this._componentContainers = this.layoutFramework.InitializeLayout(frame);
        DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
        for (let [container, componentInfo] of this.componentContainers) {
            this.InitializeComponent(componentInfo, container);
        }
    }
    InitializeComponent(compontentInfo, container) {
        let newComponent;
        let componentType;
        let initArgs = null;
        if (typeof (compontentInfo) === "string") {
            componentType = compontentInfo;
        }
        else {
            componentType = compontentInfo.type;
            initArgs = compontentInfo.initArgs;
        }
        switch (componentType) {
            case types_1.ComponentType.Plot2dPathsWidget:
                let squareAspectRatio = true;
                if (typeof (initArgs.squareAspectRatio) !== 'undefined') {
                    squareAspectRatio = initArgs.squareAspectRatio;
                }
                const defaultOption = 0;
                newComponent = new Plot2dPathsWidget_1.Plot2dPathsWidget(container, initArgs.quickPickOptions, defaultOption, squareAspectRatio);
                break;
            case types_1.ComponentType.MetricDistributionWidget:
                newComponent = new MetricDistributionWidget_1.MetricDistributionWidget(container, initArgs.metricDistributionCollectionLevel);
                break;
            case types_1.ComponentType.ImageSelectionWidget:
                newComponent = new ImageSelectionWidget_1.ImageSelectionWidget(container);
                break;
            case types_1.ComponentType.DetailedDistribution:
                newComponent = new DetailedDistributionWidget_1.DetailedDistributionWidget(container, initArgs.metricDistributionCollectionLevel, initArgs.attributeKey);
                break;
            case types_1.ComponentType.Toolbar:
                newComponent = new Toolbar_1.Toolbar(container);
                break;
            default:
                console.error(`Cannot Initialize Component of type: ${componentType}`);
                break;
        }
        this.componentList.push(newComponent);
    }
    LoadDataset(datasetId) {
        this.fetchJson(`${datasetId}.json`);
    }
    async fetchJson(filename) {
        await d3.json("../../../data/" + filename).then((data) => {
            this.fetchCsv(`${data.googleDriveId}/massOverTime.csv`, data);
        });
    }
    async fetchCsv(filename, dataSpec) {
        await d3.csv("../../../data/" + filename).then(data => {
            // console.log(data);
            let newData = this.dataFromCSVObject(data, this.trackDerivationFunctions, this.pointDerivationFunctions, dataSpec);
            // console.log(newData);
            this.SetData(newData);
        });
    }
    SetData(newData) {
        console.log("App.SetData: ");
        console.log(newData);
        this._data = newData;
        for (let component of this.componentList) {
            if (component instanceof BaseWidget_1.BaseWidget) {
                component.SetData(newData);
            }
        }
    }
    OnWindowResize() {
        for (let component of this.componentList) {
            component.Resize();
        }
    }
    onBrushChange() {
        this.data.OnBrushChange();
        for (let component of this.componentList) {
            if (component instanceof BaseWidget_1.BaseWidget) {
                component.OnBrushChange();
            }
        }
    }
}
exports.App = App;

},{"./Components/BaseWidget":81,"./Components/DetailedDistributionWidget":82,"./Components/ImageSelectionWidget":85,"./Components/MetricDistributionWidget":88,"./Components/Plot2dPathsWidget":90,"./Components/Toolbar":93,"./DataModel/DataEvents":101,"./LayoutFramework":110,"./devlib/DevlibTSUtil":113,"./types":115,"d3":42}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BaseComponent {
    constructor(container, ...props) {
        this._container = container;
        this._componentIndex = BaseComponent._componentCount;
        BaseComponent._componentCount++;
        this.initProps(props);
        this.setWidthHeight();
        this.init();
    }
    get container() {
        return this._container;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get ComponentId() {
        return this.constructor.name + "_" + this._componentIndex;
    }
    initProps(props) {
    }
    init() {
        let notImplementDiv = document.createElement("div");
        notImplementDiv.textContent = `Class ${this.constructor.name} has not implement 'init' function`;
        notImplementDiv.classList.add("notImplementedWarning");
        this.container.innerHTML = null;
        this.container.appendChild(notImplementDiv);
    }
    Resize() {
        this.setWidthHeight();
        this.OnResize();
    }
    setWidthHeight() {
        this._width = this.container.clientWidth;
        this._height = this.container.clientHeight;
    }
    OnResize() {
        this.container.innerHTML = null;
        let notImplementDiv = document.createElement("div");
        notImplementDiv.textContent = `Resized to: (${this.width}, ${this.height})
override ${this.constructor.name}.OnResizeDraw() to ensure content is resized correctly`;
        notImplementDiv.classList.add("notImplementedWarning");
        this.container.appendChild(notImplementDiv);
    }
}
exports.BaseComponent = BaseComponent;
BaseComponent._componentCount = 0;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseComponent_1 = require("./BaseComponent");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const GroupByWidget_1 = require("./GroupByWidget");
class BaseWidget extends BaseComponent_1.BaseComponent {
    constructor(container, canFacet = false, ...props) {
        super(container, ...props);
        this._canFacet = canFacet;
        if (canFacet) {
            this.addFacetButton();
        }
        this.initButtonListContainer();
        this._dataSuperset = null;
        document.addEventListener('groupByChanged', (e) => {
            if (this.showingFacetPopup) {
                this.drawFacetedData(e.detail.groupIndex);
            }
        });
        this._showingFacetPopup = false;
    }
    get data() {
        return this._data;
    }
    get dataSuperset() {
        return this._dataSuperset;
    }
    get fullData() {
        if (this._dataSuperset) {
            return this.dataSuperset;
        }
        return this.data;
    }
    get margin() {
        return this._margin;
    }
    get vizWidth() {
        return this._vizWidth;
    }
    get vizHeight() {
        return this._vizHeight;
    }
    get canFacet() {
        return this._canFacet;
    }
    set canFacet(v) {
        if (!v) {
            this.removeFacetButton();
        }
        this._canFacet = v;
    }
    get showingFacetPopup() {
        return this._showingFacetPopup;
    }
    get buttonList() {
        if (!this._buttonList) {
            this._buttonList = [];
        }
        return this._buttonList;
    }
    get buttonListContainer() {
        return this._buttonListContainer;
    }
    get facetButton() {
        return this._facetButton;
    }
    get largePopupOuter() {
        if (this._largePopupOuter) {
            return this._largePopupOuter;
        }
        let largePopupOuter = document.getElementById('largePopupContainerOuter');
        if (largePopupOuter) {
            this._largePopupOuter = largePopupOuter;
            return this._largePopupOuter;
        }
        this.initLargePopup();
        return this._largePopupOuter;
    }
    get largePopup() {
        if (this._largePopup) {
            return this._largePopup;
        }
        let largePopup = document.getElementById('largePopupContainer');
        if (largePopup) {
            this._largePopup = largePopup;
            return this._largePopup;
        }
        this.initLargePopup();
        return this._largePopup;
    }
    get largePopupContent() {
        return this._largePopupContent;
    }
    initProps(props) {
        this.setMargin();
    }
    setMargin() {
        this._margin = {
            top: 20,
            right: 20,
            bottom: 20,
            left: 20
        };
    }
    SetData(data, dataSuperset) {
        this._data = data;
        if (dataSuperset) {
            this._dataSuperset = dataSuperset;
        }
        let facetOptions = data.GetFacetOptions();
        if (facetOptions.length === 0) {
            this.canFacet = false;
        }
        this.OnDataChange();
    }
    OnBrushChange() {
        console.log('base: OnBrushChange');
    }
    setWidthHeight() {
        super.setWidthHeight();
        this._vizWidth = this.width - this.margin.left - this.margin.right;
        this._vizHeight = this.height - this.margin.top - this.margin.bottom;
    }
    initButtonListContainer() {
        this._buttonListContainer = document.createElement('div');
        this.buttonListContainer.classList.add('noDisp');
        let style = this.buttonListContainer.style;
        style.position = 'absolute';
        style.right = '0px';
        style.top = '0px';
        style.pointerEvents = 'none';
        style.display = 'flex';
        style.flexDirection = 'row-reverse';
        this.container.addEventListener('mouseenter', this.onMouseEnter());
        this.container.addEventListener('mouseleave', this.onMouseLeave());
        this.container.appendChild(this.buttonListContainer);
        for (let button of this.buttonList) {
            this.buttonListContainer.appendChild(button);
        }
    }
    addFacetButton() {
        this._facetButton = this.AddButton('layer-group', () => {
            this.drawFacetContent();
        });
    }
    AddButton(iconKey, callback) {
        let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(iconKey, callback);
        button.style.pointerEvents = 'all';
        this.buttonList.unshift(button);
        return button;
    }
    removeFacetButton() {
        if (this.facetButton) {
            this.buttonListContainer.removeChild(this.facetButton);
        }
    }
    onMouseEnter() {
        return () => DevlibTSUtil_1.DevlibTSUtil.show(this.buttonListContainer);
    }
    onMouseLeave() {
        return () => DevlibTSUtil_1.DevlibTSUtil.hide(this.buttonListContainer);
    }
    drawFacetContent() {
        this.largePopup.innerHTML = null;
        DevlibTSUtil_1.DevlibTSUtil.show(this.largePopupOuter);
        this._showingFacetPopup = true;
        const groupByWidget = new GroupByWidget_1.GroupByWidget(d3.select(this.largePopup));
        groupByWidget.updateGroupByOptions(this.data);
        let contentContainer = document.createElement('div');
        contentContainer.classList.add('largePopupContent');
        this.largePopup.appendChild(contentContainer);
        this._largePopupContent = contentContainer;
        this.drawFacetedData(groupByWidget.currentSelectionIndexList);
    }
    drawFacetedData(facetOptionIndexList) {
        this.drawFacetedDataDefaultRecurse(facetOptionIndexList);
    }
    drawFacetedDataDefaultRecurse(remainingSubFacetIndices, width = '500px', height = '250px', titleSoFar, facet) {
        if (remainingSubFacetIndices.length === 0) {
            this.drawFacetedDataDefault(titleSoFar, facet.data, width, height);
            return;
        }
        let data;
        if (facet) {
            data = facet.data;
        }
        else {
            data = this.data;
            this.largePopupContent.innerHTML = null;
        }
        let facetOptions = data.GetFacetOptions();
        let thisFacetOption = facetOptions[remainingSubFacetIndices[0]];
        for (let childFacet of thisFacetOption.GetFacets()) {
            let nextTitle = titleSoFar ? titleSoFar + ', ' + childFacet.name : childFacet.name;
            this.drawFacetedDataDefaultRecurse(remainingSubFacetIndices.slice(1), width, height, nextTitle, childFacet);
        }
    }
    drawFacetedDataDefault(title, data, width, height) {
        let outerContainer = document.createElement('div');
        outerContainer.classList.add('outerFacetContainer');
        outerContainer.style.width = width;
        outerContainer.style.height = height;
        let titleContainer = document.createElement('div');
        titleContainer.classList.add('facetTitle');
        titleContainer.innerText = title;
        outerContainer.appendChild(titleContainer);
        let newContainer = document.createElement('div');
        newContainer.classList.add('facetContainer');
        outerContainer.appendChild(newContainer);
        this.largePopupContent.appendChild(outerContainer);
        this.initSubWidget(newContainer, title, data);
    }
    initSubWidget(newContainer, name, data) {
        let subWidget = this.Clone(newContainer);
        subWidget.canFacet = false;
        subWidget.SetData(data, this.data);
    }
    initLargePopup() {
        let largePopupOuter = document.createElement('div');
        largePopupOuter.id = "largePopupContainerOuter";
        largePopupOuter.classList.add('largePopupContainerOuter');
        largePopupOuter.addEventListener('click', () => {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.largePopupOuter);
            this._showingFacetPopup = false;
        });
        let largePopup = document.createElement('div');
        largePopup.id = 'largePopupContainer';
        largePopup.classList.add('largePopupContainer');
        largePopup.addEventListener('click', (ev) => {
            ev.stopPropagation();
        });
        this._largePopup = largePopup;
        largePopupOuter.appendChild(largePopup);
        DevlibTSUtil_1.DevlibTSUtil.hide(largePopupOuter);
        document.body.appendChild(largePopupOuter);
        this._largePopupOuter = largePopupOuter;
    }
}
exports.BaseWidget = BaseWidget;

},{"../devlib/DevlibTSUtil":113,"./BaseComponent":80,"./GroupByWidget":83,"d3":42}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const types_1 = require("../types");
class DetailedDistributionWidget extends BaseWidget_1.BaseWidget {
    constructor(container, metricDistributionCollectionLevel, attributeKey) {
        super(container, true);
        this._metricDistributionCollectionLevel = metricDistributionCollectionLevel;
        this._attributeKey = attributeKey;
        this.setLabel();
    }
    Clone(container) {
        let clone = new DetailedDistributionWidget(container, this.metricDistributionCollectionLevel, this.attributeKey);
        return clone;
    }
    get metricDistributionCollectionLevel() {
        return this._metricDistributionCollectionLevel;
    }
    get attributeKey() {
        return this._attributeKey;
    }
    get pointCollection() {
        return this._pointCollection;
    }
    get fullPointCollection() {
        return this._fullPointCollection;
    }
    get randomNoiseList() {
        return this._randomNoiseList;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleY() {
        return this._scaleY;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get canvasElement() {
        return this._canvasElement;
    }
    get totalBoxplotContainerSelect() {
        return this._totalBoxplotContainerSelect;
    }
    get filteredBoxplotContainerSelect() {
        return this._filteredBoxplotContainerSelect;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get boxplotStatsPopupSelect() {
        return this._boxplotStatsPopupSelect;
    }
    set boxplotStatsPopupSelect(v) {
        this._boxplotStatsPopupSelect = v;
    }
    get axisPadding() {
        return this._axisPadding;
    }
    get xAxisGroupSelect() {
        return this._xAxisGroupSelect;
    }
    get xLabelTextSelect() {
        return this._xLabelTextSelect;
    }
    get brush() {
        return this._brush;
    }
    get totalBoxplotStats() {
        return this._totalBoxplotStats;
    }
    get filteredBoxplotStats() {
        return this._filteredBoxplotStats;
    }
    get scatterplotPadding() {
        return this._scatterplotPadding;
    }
    get betweenBoxplotPadding() {
        return this._betweenBoxplotPadding;
    }
    setMargin() {
        this._margin = {
            top: 6,
            right: 8,
            bottom: 56,
            left: 8
        };
    }
    init() {
        this._scatterplotPadding = 8;
        const containerSelect = d3.select(this.container);
        this._canvasElement = containerSelect
            .append('xhtml:canvas')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight - 2 * this.scatterplotPadding)
            .attr('style', `position: absolute;
                transform: translate(${this.margin.left}px, ${this.margin.top + this.scatterplotPadding}px);
                z-index: -1`)
            .node();
        // I originally put the canvas inside the svg in a foreignObject. This didn't work because
        // of Chrome bug 148499
        // https://bugs.chromium.org/p/chromium/issues/detail?id=148499
        this._svgSelect = containerSelect.append("svg")
            .attr("width", this.width)
            .attr("height", this.height);
        this._boxplotStatsPopupSelect = containerSelect.append('div')
            .classed('boxplotStatsPopup', true);
        this.hideBoxplotStatsPopup();
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.scatterplotPadding})`);
        this._totalBoxplotContainerSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._filteredBoxplotContainerSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._brushGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed("brushContainer", true);
        this._axisPadding = 4;
        this._xAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .classed("labelColor", true);
        this._betweenBoxplotPadding = 4;
    }
    setLabel() {
        this._xLabelTextSelect = this.svgSelect.append('text')
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .classed('noDisp', true)
            .text(this.attributeKey);
        this.positionLabels();
    }
    positionLabels() {
        let bufferForAxis = 32 + this.axisPadding;
        ;
        this.xLabelTextSelect
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`);
    }
    OnDataChange() {
        switch (this.metricDistributionCollectionLevel) {
            case types_1.MetricDistributionCollectionLevel.Point:
                this._pointCollection = this.data;
                this._fullPointCollection = this.fullData;
                break;
            case types_1.MetricDistributionCollectionLevel.Curve:
                this._pointCollection = this.data.curveCollection;
                this._fullPointCollection = this.fullData.curveCollection;
                break;
            default:
                throw new Error("DetailedDistribution needs a valid MetricDistributionCollectionLevel");
                this._pointCollection = null;
                this._fullPointCollection = null;
                break;
        }
        this._randomNoiseList = [];
        for (let i = 0; i < this.pointCollection.length; i++) {
            this.randomNoiseList.push(Math.random());
        }
        this.updateTotalBoxplotStats();
        this.updateScales();
        this.draw();
        this.showLabel();
    }
    updateTotalBoxplotStats() {
        let validNumbers = this.pointCollection.Array
            .map(d => d.get(this.attributeKey)) // get actual value
            .filter(d => !isNaN(d)) // filter out NaN values.
            .sort((a, b) => a - b); // d3.quantile requires it to be sorted. This could technically be done faster without sorting.
        this._totalBoxplotStats = DetailedDistributionWidget.calculateBoxplotStats(validNumbers);
    }
    updateFilteredBoxplotStats() {
        let validBrushedNumbers = this.pointCollection.Array
            .filter(d => d.inBrush)
            .map(d => d.get(this.attributeKey)) // get actual value
            .filter(d => !isNaN(d)) // filter out NaN values.
            .sort((a, b) => a - b); // d3.quantile requires it to be sorted. This could technically be done faster without sorting.
        this._filteredBoxplotStats = DetailedDistributionWidget.calculateBoxplotStats(validBrushedNumbers);
    }
    static calculateBoxplotStats(numbers) {
        const median = d3.median(numbers);
        let lowQuartile = d3.quantile(numbers, 0.25);
        let highQuartile = d3.quantile(numbers, 0.75);
        const quartileRange = [lowQuartile, highQuartile];
        let interQuartileRange = highQuartile - lowQuartile;
        let lowWhisker = lowQuartile - 1.5 * interQuartileRange;
        let highWhisker = highQuartile + 1.5 * interQuartileRange;
        const whiskerRange = [lowWhisker, highWhisker];
        let boxplotStats = {
            median: median,
            quartileRange: quartileRange,
            whiskerRange: whiskerRange
        };
        return boxplotStats;
    }
    updateScales() {
        let distributionMinMax = this.fullPointCollection.getMinMax(this.attributeKey);
        this._scaleX = d3.scaleLinear()
            .domain(distributionMinMax)
            .range([0, this.vizWidth]);
        this._scaleY = d3.scaleLinear()
            .domain([0, 1]) // bounds of Math.random
            .range([this.vizHeight - 2 * this.scatterplotPadding, 0]);
    }
    draw() {
        // it's probably faster to filter out all the NaNs once than noDisp them all. There might be as many as 50% NaNs
        let validPoints = this.pointCollection.Array.filter(d => !isNaN(d.get(this.attributeKey)));
        // draw jittered scatterplot
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight - 2 * this.scatterplotPadding);
        canvasContext.fillStyle = 'black';
        canvasContext.globalAlpha = 0.6;
        for (let i = 0; i < validPoints.length; i++) {
            let point = validPoints[i];
            let x = this.scaleX(point.get(this.attributeKey));
            let y = this.scaleY(this.randomNoiseList[i]);
            canvasContext.beginPath();
            const radius = 0.5;
            canvasContext.arc(x, y, radius, 0, 2 * Math.PI);
            canvasContext.fill();
        }
        if (this.data.brushApplied) {
            const smallBoxplotHeight = (this.vizHeight - this.betweenBoxplotPadding) / 2;
            this.drawBoxplot(this.totalBoxplotContainerSelect, this.totalBoxplotStats, 0, smallBoxplotHeight);
            this.drawBoxplot(this.filteredBoxplotContainerSelect, this.filteredBoxplotStats, smallBoxplotHeight + this.betweenBoxplotPadding, smallBoxplotHeight);
            this.filteredBoxplotContainerSelect.classed('noDisp', false);
        }
        else {
            this.drawBoxplot(this.totalBoxplotContainerSelect, this.totalBoxplotStats, 0, this.vizHeight);
            this.filteredBoxplotContainerSelect.classed('noDisp', true);
        }
        this.drawAxis();
        this.positionLabels();
    }
    drawFacetedData(facetOptionIndexList) {
        this.drawFacetedDataDefaultRecurse(facetOptionIndexList, "95%", "170px");
    }
    showLabel() {
        this.xLabelTextSelect.classed('noDisp', false);
    }
    drawBoxplot(containerSelect, boxplotStats, top, height) {
        // Median
        containerSelect.selectAll('.boxplotMedianLine')
            .data([boxplotStats.median])
            .join('line')
            .attr('x1', d => this.scaleX(d))
            .attr('y1', top)
            .attr('x2', d => this.scaleX(d))
            .attr('y2', top + height)
            .classed('boxplotMedianLine', true);
        // IQR Box
        containerSelect.selectAll('rect')
            .data([boxplotStats.quartileRange])
            .join('rect')
            .classed('IQR-Box', true)
            .attr('x', d => this.scaleX(d[0]))
            .attr('y', top)
            .attr('width', d => this.scaleX(d[1]) - this.scaleX(d[0]))
            .attr('height', height)
            .on('mouseover', () => {
            this.showBoxplotStatsPopup(boxplotStats, containerSelect);
        })
            .on('mouseout', () => {
            this.hideBoxplotStatsPopup();
        });
        // Horizontal whisker lines
        const vertMiddle = top + (height / 2);
        containerSelect.selectAll('.boxplotWhiskers')
            .data([
            [boxplotStats.whiskerRange[0], boxplotStats.quartileRange[0]],
            [boxplotStats.whiskerRange[1], boxplotStats.quartileRange[1]]
        ])
            .join('line')
            .attr('x1', d => this.scaleX(d[0]))
            .attr('y1', vertMiddle)
            .attr('x2', d => this.scaleX(d[1]))
            .attr('y2', vertMiddle)
            .classed('boxplotWhiskers', true);
        // vertical whisker endpoints
        const relativeSize = 0.66; // height of whisker endpoints compared to box height
        const padSize = height * (1 - relativeSize) / 2;
        containerSelect.selectAll('.boxplotWhiskerEnds')
            .data(boxplotStats.whiskerRange)
            .join('line')
            .attr('x1', d => this.scaleX(d))
            .attr('y1', top + padSize)
            .attr('x2', d => this.scaleX(d))
            .attr('y2', top + height - padSize)
            .classed('boxplotWhiskerEnds', true);
    }
    showBoxplotStatsPopup(boxplotStats, boxplotContainer) {
        this.boxplotStatsPopupSelect.html(null);
        const boundRect = boxplotContainer.node().getBoundingClientRect();
        this.boxplotStatsPopupSelect
            .attr('style', `left: ${(boundRect.left + boundRect.right) / 2}px; top:${boundRect.bottom}px`);
        this.boxplotStatsPopupSelect.append('div')
            .attr('id', 'boxplotStatsPopup-q1')
            .text('Q1: ' + boxplotStats.quartileRange[0].toFixed(4));
        this.boxplotStatsPopupSelect.append('div')
            .attr('id', 'boxplotStatsPopup-median')
            .text('Median: ' + boxplotStats.median.toFixed(4));
        this.boxplotStatsPopupSelect.append('div')
            .attr('id', 'boxplotStatsPopup-q3')
            .text('Q3: ' + boxplotStats.quartileRange[1].toFixed(4));
        this.boxplotStatsPopupSelect.classed('noDisp', false);
    }
    hideBoxplotStatsPopup() {
        this.boxplotStatsPopupSelect.classed('noDisp', true);
    }
    drawAxis() {
        this.xAxisGroupSelect
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .call(d3.axisBottom(this.scaleX));
    }
    OnResize() {
        this.svgSelect
            .attr('width', this.width)
            .attr('height', this.height);
        d3.select(this.canvasElement)
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight - 2 * this.scatterplotPadding);
        this.updateScales();
        this.draw();
    }
    OnBrushChange() {
        this.updateFilteredBoxplotStats();
        this.draw();
    }
}
exports.DetailedDistributionWidget = DetailedDistributionWidget;

},{"../types":115,"./BaseWidget":81,"d3":42}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const OptionSelect_1 = require("./OptionSelect");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class GroupByWidget {
    constructor(container) {
        this._outerContainer = container;
        this._mainContainer = this.outerContainer.append('div')
            .classed('groupByMainContainer', true);
        this._innerComponentId = 'groupByInnerContainer_' + GroupByWidget._componentCount + '_';
        GroupByWidget._componentCount++;
        this._groupByInnerConainerIdList = [];
        this.addComponentId();
        this.drawLines([0]);
    }
    get outerContainer() {
        return this._outerContainer;
    }
    get innerComponentId() {
        return this._innerComponentId;
    }
    get mainContainer() {
        return this._mainContainer;
    }
    get groupByOuterContainerList() {
        return this._groupByOuterContainerList;
    }
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    get groupByInnerConainerIdList() {
        return this._groupByInnerConainerIdList;
    }
    get groupByOptionSelectList() {
        return this._groupByOptionSelectList;
    }
    get currentSelectionIndexList() {
        return this.groupByOptionSelectList.map(optionSelect => optionSelect.currentSelectionIndex);
    }
    drawLines(previousSelections) {
        this._groupByOuterContainerList = this.mainContainer.selectAll('.groupByElementContainer')
            .data(this.groupByInnerConainerIdList)
            .join('div')
            .classed('groupByElementContainer', true);
        this.groupByOuterContainerList.html(null);
        this.groupByOuterContainerList.append('div')
            .classed('groupByContainer', true)
            .attr('id', d => d);
        const self = this;
        this.groupByOuterContainerList
            .each(function (d, i) {
            let iconKey;
            let callback;
            if (i === 0) {
                iconKey = 'plus';
                callback = () => self.addGroupByLine();
            }
            else {
                iconKey = 'minus';
                callback = () => self.removeGroupByLine(i);
            }
            let iconButton = DevlibTSUtil_1.DevlibTSUtil.getIconButton(iconKey, callback);
            d3.select(this).node().appendChild(iconButton);
        });
        this._groupByOptionSelectList = [];
        for (let i = 0; i < this.groupByInnerConainerIdList.length; i++) {
            let containerId = this.groupByInnerConainerIdList[i];
            let selection;
            if (i < previousSelections.length) {
                selection = previousSelections[i];
            }
            else {
                selection = this.getFirstUnselectedOption(previousSelections);
            }
            let label;
            if (i === 0) {
                label = "Group by";
            }
            else {
                label = 'and';
            }
            let optionSelect = new OptionSelect_1.OptionSelect(containerId, label, selection);
            this.groupByOptionSelectList.push(optionSelect);
        }
        if (this.data) {
            this.updateGroupByOptions(this.data);
        }
    }
    getFirstUnselectedOption(selections) {
        let maxIndex;
        if (this.data) {
            maxIndex = this.data.GetFacetOptions().length;
        }
        else {
            maxIndex = 0;
        }
        let candidate = 0;
        while (selections.includes(candidate) && candidate <= maxIndex) {
            candidate++;
        }
        return candidate;
    }
    addGroupByLine() {
        const previousSelections = this.currentSelectionIndexList;
        const added = this.addComponentId();
        if (!added) {
            return;
        }
        this.drawLines(previousSelections);
    }
    addComponentId() {
        const numberOfExistingLines = this.groupByInnerConainerIdList.length;
        if (this.data) {
            let facetOptions = this.data.GetFacetOptions();
            if (facetOptions.length === numberOfExistingLines) {
                return false;
            }
        }
        const newId = this.innerComponentId + numberOfExistingLines;
        this.groupByInnerConainerIdList.push(newId);
        return true;
    }
    removeGroupByLine(lineIndex) {
        const previousSelections = this.currentSelectionIndexList;
        previousSelections.splice(lineIndex, 1);
        if (this.groupByInnerConainerIdList.length > 1) {
            this.groupByInnerConainerIdList.pop();
        }
        this.drawLines(previousSelections);
    }
    updateGroupByOptions(data, skipEventTrigger = false) {
        this._data = data;
        let facetOptions = data.GetFacetOptions();
        for (let i = 0; i < this.groupByOptionSelectList.length; i++) {
            let buttonPropsList = [];
            for (let facetOption of facetOptions) {
                let buttonProps = {
                    displayName: facetOption.name,
                    callback: () => this.onGroupSelection()
                };
                buttonPropsList.push(buttonProps);
            }
            this.groupByOptionSelectList[i].onDataChange(buttonPropsList);
        }
        if (!skipEventTrigger) {
            this.onGroupSelection();
        }
    }
    onGroupSelection() {
        const customEvent = new CustomEvent('groupByChanged', { detail: {
                groupIndex: this.currentSelectionIndexList
            } });
        document.dispatchEvent(customEvent);
    }
}
exports.GroupByWidget = GroupByWidget;
GroupByWidget._componentCount = 0;

},{"../devlib/DevlibTSUtil":113,"./OptionSelect":89,"d3":42}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class HistogramWidget extends BaseWidget_1.BaseWidget {
    constructor(container, valueKey, canBrush = true, includeExemplarTrackButton = false) {
        super(container, true, canBrush, includeExemplarTrackButton);
        this._valueKey = valueKey;
        this.setLabel();
    }
    Clone(container) {
        const canBrush = false;
        let clone = new HistogramWidget(container, this.valueKey, canBrush);
        return clone;
    }
    initProps(props) {
        super.initProps();
        this._canBrush = props[0];
        this._includeExemplarTrackButton = props[1];
    }
    get valueKey() {
        return this._valueKey;
    }
    get sortedData() {
        return this._sortedData;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get totalHistogramGroupSelect() {
        return this._totalHistogramGroupSelect;
    }
    get brushedHistogramGroupSelect() {
        return this._brushedHistogramGroupSelect;
    }
    get totalKDEGroupSelect() {
        return this._totalKDEGroupSelect;
    }
    get brushedKDEGroupSelect() {
        return this._brushedKDEGroupSelect;
    }
    get canBrush() {
        return this._canBrush;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get axisGroupSelect() {
        return this._axisGroupSelect;
    }
    get labelTextSelect() {
        return this._labelTextSelect;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleYHistogramAbsolute() {
        return this._scaleYHistogramAbsolute;
    }
    get scaleYHistogramRelative() {
        return this._scaleYHistogramRelative;
    }
    get scaleYKdeAbsolute() {
        return this._scaleYKdeAbsolute;
    }
    get scaleYKdeRelative() {
        return this._scaleYKdeRelative;
    }
    get allBins() {
        return this._allBins;
    }
    get brushedBins() {
        return this._brushedBins;
    }
    set brushedBins(v) {
        this._brushedBins = v;
    }
    get allPathPoints() {
        return this._allPathPoints;
    }
    get maxDensityAll() {
        return this._maxDensityAll;
    }
    get brushedPathPoints() {
        return this._brushedPathPoints;
    }
    get brushedPointsLength() {
        return this._brushedPointsLength;
    }
    get axisPadding() {
        return this._axisPadding;
    }
    get brush() {
        return this._brush;
    }
    get useHistogramButton() {
        return this._useHistogramButton;
    }
    get useKDEButton() {
        return this._useKDEButton;
    }
    static get useKdeInsteadOfHistogram() {
        return HistogramWidget._useKdeInsteadOfHistogram;
    }
    static set useKdeInsteadOfHistogram(v) {
        HistogramWidget._useKdeInsteadOfHistogram = v;
        let event = new Event('switchBetweenKdeAndHistogram');
        document.dispatchEvent(event);
    }
    get useAbsoluteButton() {
        return this._useAbsoluteButton;
    }
    get useRelativeButton() {
        return this._useRelativeButton;
    }
    static get useAbsoluteScaling() {
        return HistogramWidget._useAbsoluteScaling;
    }
    static set useAbsoluteScaling(v) {
        HistogramWidget._useAbsoluteScaling = v;
        let event = new Event('switchBetweenAbsoluteAndRelativeScaling');
        document.dispatchEvent(event);
    }
    get includeExemplarTrackButton() {
        return this._includeExemplarTrackButton;
    }
    set includeExemplarTrackButton(v) {
        this._includeExemplarTrackButton = v;
    }
    setMargin() {
        this._margin = {
            top: 6,
            right: 8,
            bottom: 50,
            left: 8
        };
    }
    init() {
        this.initKDEHIstogramToggle();
        this.initAbsoluteRelativeToggle();
        if (this.includeExemplarTrackButton) {
            this.initExemplarTrackButton();
        }
        this._svgSelect = d3.select(this.container).append("svg")
            .attr("width", this.width)
            .attr("height", this.height);
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        if (this.canBrush) {
            this._brushGroupSelect = this.svgSelect.append("g")
                .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
                .classed("brushContainer", true);
            this._brush = d3.brushX()
                .extent([[0, 0], [this.vizWidth, this.vizHeight]])
                .on("end", () => { this.brushHandler(); });
            this.brushGroupSelect.call(this.brush);
        }
        this._totalHistogramGroupSelect = this.mainGroupSelect.append('g');
        this._brushedHistogramGroupSelect = this.mainGroupSelect.append('g');
        this._totalKDEGroupSelect = this.mainGroupSelect.append('g');
        this._brushedKDEGroupSelect = this.mainGroupSelect.append('g');
        this._axisPadding = 2;
        this._axisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .classed('labelColor', true);
        document.addEventListener('exemplarAttributeChange', (e) => {
            let newExemplarAttribute = e.detail;
            if (newExemplarAttribute === this.valueKey) {
                this.container.classList.add('selected');
            }
            else {
                this.container.classList.remove('selected');
            }
        });
    }
    initKDEHIstogramToggle() {
        this._useHistogramButton = this.AddButton('chart-bar', () => {
            HistogramWidget.useKdeInsteadOfHistogram = false;
        });
        this._useKDEButton = this.AddButton('chart-area', () => {
            HistogramWidget.useKdeInsteadOfHistogram = true;
        });
        if (HistogramWidget.useKdeInsteadOfHistogram) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useKDEButton);
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useHistogramButton);
        }
        document.addEventListener('switchBetweenKdeAndHistogram', (e) => {
            if (HistogramWidget.useKdeInsteadOfHistogram) {
                DevlibTSUtil_1.DevlibTSUtil.show(this.useHistogramButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useKDEButton);
            }
            else {
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useHistogramButton);
                DevlibTSUtil_1.DevlibTSUtil.show(this.useKDEButton);
            }
            this.OnDataChange();
        });
    }
    initAbsoluteRelativeToggle() {
        this._useAbsoluteButton = this.AddButton('hashtag', () => {
            HistogramWidget.useAbsoluteScaling = true;
        });
        this._useRelativeButton = this.AddButton('percent', () => {
            HistogramWidget.useAbsoluteScaling = false;
        });
        if (HistogramWidget.useAbsoluteScaling) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useAbsoluteButton);
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useRelativeButton);
        }
        document.addEventListener('switchBetweenAbsoluteAndRelativeScaling', (e) => {
            if (this.container.classList.contains("noDisp")) {
                return;
            }
            if (HistogramWidget.useAbsoluteScaling) {
                DevlibTSUtil_1.DevlibTSUtil.show(this.useRelativeButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useAbsoluteButton);
            }
            else {
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useRelativeButton);
                DevlibTSUtil_1.DevlibTSUtil.show(this.useAbsoluteButton);
            }
            if (HistogramWidget.useKdeInsteadOfHistogram) {
                this.drawAllKDE(false);
            }
            else {
                this.drawAllHistograms([], true);
            }
        });
    }
    initExemplarTrackButton() {
        this.AddButton('rocket', async () => {
            let event = new CustomEvent('launchExemplarCurve', { detail: this.valueKey });
            DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
            await DevlibTSUtil_1.DevlibTSUtil.makeAsync(() => document.dispatchEvent(event));
        });
    }
    setLabel() {
        const bufferForAxis = 32 + this.axisPadding;
        this._labelTextSelect = this.svgSelect.append('text')
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`)
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .text(this.valueKey);
    }
    OnDataChange() {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        let validNumbers = this.data.Array.filter(d => !isNaN(d.get(this.valueKey)));
        this._allBins = this.calculateBins(validNumbers);
        this.updateScales(validNumbers.length);
        if (HistogramWidget._useKdeInsteadOfHistogram) {
            let shallowCopy = [...validNumbers];
            const key = this.valueKey;
            this._sortedData = shallowCopy.sort((a, b) => d3.ascending(a.get(key), b.get(key)));
            this._allPathPoints = this.kde(this.sortedData);
            this._maxDensityAll = d3.max(this.allPathPoints, d => d[1]);
            this.drawAllKDE(false);
            this.removeHistograms();
        }
        else {
            this.drawAllHistograms(validNumbers);
            this.removeKDEs();
        }
        this.drawAxis();
    }
    calculateBins(points) {
        let count = Math.round(Math.sqrt(this.fullData.length)) / 3;
        let minMax = this.fullData.getMinMax(this.valueKey);
        let x = d3.scaleLinear()
            .domain(minMax)
            .nice(count);
        let bins = d3.histogram()
            .domain(x.domain())
            .thresholds(x.ticks(count))
            .value(d => d.get(this.valueKey))(points);
        // account for degenerate last bin -_-
        let ultimateBin = bins[bins.length - 1];
        if (ultimateBin.x0 === ultimateBin.x1) {
            let penultimateBin = bins[bins.length - 2];
            if (penultimateBin) {
                for (let point of ultimateBin) {
                    penultimateBin.push(point);
                }
            }
        }
        return bins;
    }
    removeHistograms() {
        this.totalHistogramGroupSelect.html(null);
        this.brushedHistogramGroupSelect.html(null);
    }
    drawAllHistograms(validNumbers, skipRecalculation = false) {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        if (!skipRecalculation) {
            let brushedNumbers = validNumbers.filter(d => d.inBrush);
            if (validNumbers.length === brushedNumbers.length) {
                this.brushedHistogramGroupSelect.html(null);
                this._brushedBins = [];
            }
            else {
                this._brushedBins = this.calculateBins(brushedNumbers);
            }
            let biggestBinRelativeAll = d3.max(this.allBins, d => d.length / validNumbers.length);
            let biggestBinRelativeBrushed = d3.max(this.brushedBins, d => d.length / brushedNumbers.length);
            this._scaleYHistogramRelative = d3.scaleLinear()
                .domain([0, d3.max([biggestBinRelativeAll, biggestBinRelativeBrushed])])
                .range([0, this.vizHeight]);
        }
        this.drawHistogram(this.totalHistogramGroupSelect, this.allBins);
        this.drawHistogram(this.brushedHistogramGroupSelect, this.brushedBins, true);
    }
    drawHistogram(select, bins, inBrush = false) {
        if (bins.length === 0) {
            select.html(null);
            return;
        }
        let pathPoints = this.getHistogramSkyline(bins);
        let lineFunc = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .defined(d => d[0] !== null);
        select.selectAll('path')
            .data([lineFunc(pathPoints)])
            .join('path')
            .classed('kdePath', true)
            .classed('inBrush', inBrush)
            .transition()
            .attr('d', d => d);
    }
    getHistogramSkyline(bins, singleWidth = 18) {
        let pathPoints = [];
        if (bins.length === 1) {
            let left = (this.vizWidth - singleWidth) / 2;
            let right = (this.vizWidth + singleWidth) / 2;
            pathPoints.push([left, this.vizHeight]);
            pathPoints.push([left, 0]);
            pathPoints.push([right, 0]);
            pathPoints.push([right, this.vizHeight]);
            return pathPoints;
        }
        const totalCount = d3.sum(bins, bin => bin.length);
        for (let bin of bins) {
            let x1 = this.scaleX(bin.x0);
            let offset;
            if (HistogramWidget.useAbsoluteScaling) {
                offset = this.scaleYHistogramAbsolute(bin.length);
            }
            else {
                offset = this.scaleYHistogramRelative(bin.length / totalCount);
            }
            let y = this.vizHeight - offset;
            pathPoints.push([x1, y]);
            if (bin.length === 0) {
                let splitPoint = [null, null];
                pathPoints.push(splitPoint);
            }
            let x2 = this.scaleX(bin.x1);
            pathPoints.push([x2, y]);
        }
        pathPoints.unshift([0, this.vizHeight]);
        pathPoints.push([this.vizWidth, this.vizHeight]);
        return pathPoints;
    }
    removeKDEs() {
        this.totalKDEGroupSelect.html(null);
        this.brushedKDEGroupSelect.html(null);
    }
    drawAllKDE(filterChanged) {
        let brushedPoints = this.sortedData.filter(d => d.inBrush);
        this._brushedPathPoints = this.kde(brushedPoints);
        this._brushedPointsLength = brushedPoints.length;
        let maxDomain = this.maxDensityAll;
        if (!HistogramWidget.useAbsoluteScaling) {
            let maxValBrushed = d3.max(this.brushedPathPoints, d => d[1]);
            maxDomain = d3.max([maxDomain, maxValBrushed]);
        }
        this._scaleYKdeRelative = d3.scaleLinear()
            .domain([0, maxDomain])
            .range([this.vizHeight, 0]);
        if (!filterChanged || HistogramWidget.useAbsoluteScaling) {
            this.drawKDE(this.sortedData.length, this.allPathPoints, false, this.totalKDEGroupSelect);
        }
        if (this.brushedPointsLength === this.sortedData.length) {
            this.brushedKDEGroupSelect.html(null);
        }
        else {
            this.drawKDE(this.brushedPointsLength, this.brushedPathPoints, true, this.brushedKDEGroupSelect);
        }
    }
    drawKDE(numPoints, pathPoints, inBrush, select) {
        let yFunc;
        if (HistogramWidget.useAbsoluteScaling) {
            yFunc = d => this.scaleYKdeRelative((numPoints / this.sortedData.length) * d[1]);
        }
        else {
            yFunc = d => this.scaleYKdeRelative(d[1]);
        }
        let lineFunc = d3.line()
            // .curve(d3.curveBasis)
            .x(d => this.scaleX(d[0]))
            .y(yFunc);
        select.selectAll('path')
            .data([lineFunc(pathPoints)])
            .join('path')
            .classed('kdePath', true)
            .classed('inBrush', inBrush)
            .transition()
            .attr('d', d => d);
    }
    kde(points) {
        // Assumes that points is sorted based on valueKey
        const kernel = this.epanechnikov;
        let [low, high] = this.scaleX.domain();
        const bandwidth = 0.01 * (high - low);
        let ticks = this.scaleX.ticks(100);
        let pathPoints = [];
        for (let t of ticks) {
            // get index with value closest to t
            let compareFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(t, (point) => {
                return point.get(this.valueKey);
            });
            let startIndex;
            let searchResult = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(points, compareFunction);
            if (typeof searchResult === "number") {
                startIndex = searchResult;
            }
            else {
                const [idx1, idx2] = searchResult;
                if (typeof idx1 !== "undefined") {
                    startIndex = idx1;
                }
                else {
                    startIndex = idx2;
                }
            }
            let kernelSum = 0;
            // look forward
            for (let i = startIndex + 1; i < points.length; i++) {
                let point = points[i];
                let u = (t - point.get(this.valueKey)) / bandwidth;
                if (Math.abs(u) > 1) {
                    break;
                }
                kernelSum += kernel(u);
            }
            // look backward
            for (let i = startIndex; i >= 0; i--) {
                let point = points[i];
                let u = (t - point.get(this.valueKey)) / bandwidth;
                if (Math.abs(u) > 1) {
                    break;
                }
                kernelSum += kernel(u);
            }
            pathPoints.push([t, kernelSum / points.length]);
        }
        pathPoints.unshift([low, 0]);
        pathPoints.push([high, 0]);
        return pathPoints;
    }
    epanechnikov(u) {
        //https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use
        if (Math.abs(u) <= 1) {
            return 0.75 * (1 - u * u);
        }
        return 0;
    }
    updateScales(totalCount) {
        let minBinBoundary = this.allBins[0].x0;
        let maxBinBoundary = this.allBins[this.allBins.length - 1].x1;
        this._scaleX = d3.scaleLinear()
            .domain([minBinBoundary, maxBinBoundary])
            .range([0, this.vizWidth]);
        let biggestBinCount = d3.max(this.allBins, d => d.length);
        this._scaleYHistogramAbsolute = d3.scaleLinear()
            .domain([0, biggestBinCount])
            .range([0, this.vizHeight]);
    }
    MoveBrush(newRange) {
        if (newRange) {
            newRange[0] = this.scaleX(newRange[0]);
            newRange[1] = this.scaleX(newRange[1]);
        }
        this.brushGroupSelect.call(this.brush.move, newRange);
    }
    drawAxis() {
        this.axisGroupSelect
            .call(d3.axisBottom(this.scaleX).ticks(5));
    }
    OnResize() {
        this.OnDataChange();
    }
    brushHandler() {
        const selection = d3.event.selection;
        if (typeof selection === "undefined" || selection === null) {
            this.data.removeBrush(this.ComponentId);
            return;
        }
        let [minBound, maxBound] = selection;
        let minV = this.scaleX.invert(minBound);
        let maxV = this.scaleX.invert(maxBound);
        let valueFilter = {
            key: this.valueKey,
            bound: [minV, maxV]
        };
        this.data.addBrush(this.ComponentId, valueFilter);
    }
    OnBrushChange() {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        if (HistogramWidget._useKdeInsteadOfHistogram) {
            // this.drawBrushedKDE();
            this.drawAllKDE(true);
        }
        else {
            let validNumbers = this.data.Array.filter(d => !isNaN(d.get(this.valueKey)));
            this.drawAllHistograms(validNumbers);
        }
    }
}
exports.HistogramWidget = HistogramWidget;
HistogramWidget._useKdeInsteadOfHistogram = false;
HistogramWidget._useAbsoluteScaling = true;

},{"../devlib/DevlibAlgo":111,"../devlib/DevlibTSUtil":113,"./BaseWidget":81,"d3":42}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const ImageStackWidget_1 = require("./ImageStackWidget");
const ImageMetaData_1 = require("../DataModel/ImageMetaData");
const DevlibMath_1 = require("../devlib/DevlibMath");
const RichTooltip_1 = require("./RichTooltip");
const GroupByWidget_1 = require("./GroupByWidget");
const ImageStackDataRequest_1 = require("../DataModel/ImageStackDataRequest");
class ImageSelectionWidget extends BaseWidget_1.BaseWidget {
    Clone(container) {
        return new ImageSelectionWidget(container);
    }
    get imageMetaData() {
        return this._imageMetaData;
    }
    get imageStackDataRequest() {
        return this._imageStackDataRequest;
    }
    get innerContainer() {
        return this._innerContainer;
    }
    get imageTrackContainer() {
        return this._imageTrackContainer;
    }
    get locationSelectionContainer() {
        return this._locationSelectionContainer;
    }
    get groupByWidget() {
        return this._groupByWidget;
    }
    get locationListContainer() {
        return this._locationListContainer;
    }
    get imageStackContainer() {
        return this._imageStackContainer;
    }
    get imageStackWidget() {
        return this._imageStackWidget;
    }
    get selectedLocationId() {
        return this._selectedLocationId;
    }
    get hoveredLocationId() {
        return this._hoveredLocationId;
    }
    get frameTooltip() {
        return this._frameTooltip;
    }
    get frameHeight() {
        return this._frameHeight;
    }
    get frameHeightSelected() {
        return this._frameHeightSelected;
    }
    get frameMarginTopBot() {
        return this._frameMarginTopBot;
    }
    get frameScaleX() {
        return this._frameScaleX;
    }
    get frameScaleHeight() {
        return this._frameScaleHeight;
    }
    get hoveredLocFrame() {
        return this._hoveredLocFrame;
    }
    get selectedLocFrame() {
        return this._selectedLocFrame;
    }
    get hoveredLocId() {
        return this._hoveredLocId;
    }
    init() {
        this._frameHeight = 24; // hardcoded based on CSS
        this._frameHeightSelected = 40; // also based on CSS
        this._frameMarginTopBot = 8;
        this._frameTooltip = new RichTooltip_1.RichTooltip(0, 0);
        this._selectedLocFrame = [1, 1];
        this._hoveredLocFrame = null;
        this._hoveredLocId = null;
        this._innerContainer = d3.select(this.container).append('div');
        this.innerContainer.classed('imageSelectionContainer', true);
        this._imageTrackContainer = d3.select(this.container).append('div');
        this.imageTrackContainer
            .classed('imageTrackContainer', true);
        this._locationSelectionContainer = this.innerContainer.append('div')
            .classed('locationSelectionContainer', true);
        document.onkeydown = (event) => { this.handleKeyDown(event); };
        this._groupByWidget = new GroupByWidget_1.GroupByWidget(this.locationSelectionContainer);
        this._locationListContainer = this.locationSelectionContainer.append('div')
            .classed('locationListContainer', true);
        this._imageStackContainer = this.innerContainer.append('div')
            .classed('imageStackContainer', true)
            .classed('overflow-scroll', true);
        this._imageStackWidget = new ImageStackWidget_1.ImageStackWidget(this.imageStackContainer.node(), this.imageTrackContainer.node(), this.vizHeight);
        document.addEventListener('frameHoverChange', (e) => {
            const locId = e.detail.locationId;
            const frameId = e.detail.frameId;
            const cellId = e.detail.cellId;
            this.onHoverLocationFrame(locId, frameId, cellId, false);
        });
        document.addEventListener('locFrameClicked', (e) => {
            const locId = e.detail.locationId;
            const frameId = e.detail.frameId;
            this.onClickLocationFrame(locId, frameId);
        });
        document.addEventListener('groupByChanged', (e) => {
            this.draw();
        });
        document.addEventListener('modeChangeRedraw', (e) => {
            this.draw();
        });
        this.OnResize();
    }
    OnDataChange() {
        this._imageMetaData = ImageMetaData_1.ImageMetaData.fromPointCollection(this.data);
        this._imageStackDataRequest = new ImageStackDataRequest_1.ImageStackDataRequest(this.data.Specification.googleDriveId);
        this._selectedLocationId = this.imageMetaData.locationList[0].locationId;
        this._hoveredLocationId = null;
        this.setImageStackWidget();
        this.OnBrushChange();
        this.groupByWidget.updateGroupByOptions(this.data, true);
    }
    setImageStackWidget(skipImageTrackDraw = false) {
        const [locId, frameId] = this.selectedLocFrame;
        this.imageStackDataRequest.getImage(locId, frameId, (top, left, blob) => {
            this.imageStackWidget.SetImageProperties(skipImageTrackDraw, blob);
        });
        let currentLocation = this.imageMetaData.locationLookup.get(this.selectedLocationId);
        this.imageStackWidget.SetData(this.data, currentLocation, this.imageStackDataRequest, skipImageTrackDraw);
    }
    OnResize() {
        const topHeightMax = 0.5 * this.height;
        const botHeightMax = this.height - topHeightMax;
        this.imageStackWidget.OnResize(topHeightMax, botHeightMax, this.width);
        this.locationSelectionContainer
            .classed('overflow-scroll', true)
            .attr('style', `max-height: ${topHeightMax}px`);
        this.imageTrackContainer
            .attr('style', `max-width: ${this.width}px;
            max-height: ${botHeightMax}px;
            width: ${this.width}px;
            height: ${botHeightMax}px;`);
    }
    OnBrushChange() {
        this.imageMetaData.updateInBrushProp(this.data);
        this.draw();
        this.imageStackWidget.OnBrushChange();
    }
    draw() {
        this.locationListContainer.html(null);
        this.drawFacetRecurse(this.groupByWidget.currentSelectionIndexList);
        this.drawSelectedDots();
    }
    drawFacetRecurse(remainingSubFacetIndices, verticalPosition = 0, facet, containerSelection) {
        let container;
        if (containerSelection) {
            container = containerSelection;
        }
        else {
            container = this.locationListContainer;
        }
        if (remainingSubFacetIndices.length === 0) {
            this.drawTerminalFacet(container, facet.name, facet.data, verticalPosition, 0);
            return;
        }
        let data;
        if (facet) {
            data = facet.data;
        }
        else {
            data = this.data;
        }
        const facetIndex = remainingSubFacetIndices[0];
        let facetOptions = data.GetFacetOptions();
        let hardCodedOption = facetOptions[facetIndex];
        let facetList = hardCodedOption.GetFacets();
        let grouperDiv;
        if (facet) {
            grouperDiv = this.drawGrouperFacet(container, facet.name, verticalPosition, remainingSubFacetIndices.length);
        }
        let childPosition = verticalPosition;
        for (let childFacet of facetList) {
            childPosition++;
            this.drawFacetRecurse(remainingSubFacetIndices.slice(1), childPosition, childFacet, grouperDiv);
        }
    }
    drawGrouperFacet(containerSelection, name, verticalPosition, zIndex) {
        this.drawTitleElement(containerSelection, name, verticalPosition, zIndex);
        const grouperDiv = containerSelection.append('div')
            .classed('locationListGrouper', true);
        return grouperDiv;
    }
    drawTitleElement(containerSelection, name, verticalPosition, zIndex) {
        const topPos = (verticalPosition - 1) * 19;
        let styleString = `top: ${topPos}px;`;
        if (zIndex > 0) {
            styleString += ` z-index: ${zIndex};`;
        }
        containerSelection.append('div')
            .text(name)
            .classed('locationListCatTitle', true)
            .attr('style', styleString);
    }
    drawTerminalFacet(containerSelection, name, data, verticalPosition, zIndex) {
        this.drawTitleElement(containerSelection, name, verticalPosition, zIndex);
        const subListContainer = containerSelection.append('ul')
            .classed('subListContainer', true);
        let locationList = data.locationList;
        if (this.imageStackWidget.inCondensedMode) {
            locationList = locationList.filter(loc => this.imageStackWidget.exemplarLocations.has(loc));
        }
        const listElement = subListContainer.selectAll('li')
            .data(locationList)
            .join('li');
        listElement.html(null)
            .append('button')
            .text(d => d)
            .classed('locationButton', true)
            .classed('toggleButton', true)
            .classed('selected', d => d == this.selectedLocationId)
            .attr('id', d => 'imageLocation-' + d)
            .attr('style', d => {
            const location = this.imageMetaData.locationLookup.get(d);
            const stop = (1 - location.inBrushPercent) * 100;
            const barColor = '#EDCAC9'; // lighter firebrick
            return `background: linear-gradient(to left, rgba(255,255,255,0), rgba(255,255,255,0) ${stop}%, ${barColor}, ${stop}%, ${barColor})`;
        })
            .on('click', d => {
            this.onClickLocation(d);
        });
        const wraperSelection = listElement.append('div')
            .classed('frameListContainer', true);
        // getting the first one, they should all be the same
        const bbox = wraperSelection.node().getBoundingClientRect();
        const miniWidth = bbox.width;
        const svgSelection = wraperSelection.append('svg')
            .attr('width', miniWidth)
            .attr('height', d => d === this.selectedLocationId ? this.frameHeightSelected : this.frameHeight)
            .attr('id', d => 'frameTicksViz-' + d)
            .attr('data-locId', d => d)
            .on('mouseleave', () => {
            this._hoveredLocId = null;
            this.hideFrameTooltip();
            this.removeHoverDots(svgSelection);
            this.changeHoveredLocation(null);
        });
        const marginW = 4;
        const frameExtent = this.data.getMinMax('Frame ID');
        this._frameScaleX = d3.scaleLinear()
            .domain(frameExtent)
            .range([marginW, miniWidth - marginW]);
        const scaleLineWidth = d3.scaleLinear()
            .domain([0, 1])
            .range([1.0, 3.0]);
        this._frameScaleHeight = d3.scaleLinear()
            .domain([0, 1])
            .range([1, this.frameHeight - 2 * this.frameMarginTopBot]);
        svgSelection.selectAll('line')
            .data(d => this.getFrameList(d))
            .join('line')
            .attr('x1', d => this.frameScaleX(d.frameId))
            .attr('x2', d => this.frameScaleX(d.frameId))
            .attr('y1', d => (this.frameHeight - this.frameScaleHeight(d.inBrushPercent)) / 2)
            .attr('y2', d => this.frameHeight - (this.frameHeight - this.frameScaleHeight(d.inBrushPercent)) / 2)
            .attr('stroke-width', d => scaleLineWidth(d.inBrushPercent))
            .attr('stroke', d => d.inBrush ? 'firebrick' : 'black')
            .classed('tickMark', true);
        let svgList = svgSelection.nodes();
        for (let i = 0; i < svgList.length; i++) {
            const svgElement = svgList[i];
            const locId = +svgElement.dataset['locId'];
            svgElement.addEventListener('mousemove', (event) => {
                this._hoveredLocId = locId;
                const mouseX = event.offsetX;
                let frameId = this.frameScaleX.invert(mouseX);
                frameId = DevlibMath_1.DevlibMath.clamp(Math.round(frameId), frameExtent);
                this.onHoverLocationFrame(locId, frameId, null, true);
            });
            svgElement.addEventListener('click', (event) => {
                const mouseX = event.offsetX;
                let frameId = this.frameScaleX.invert(mouseX);
                frameId = DevlibMath_1.DevlibMath.clamp(Math.round(frameId), frameExtent);
                this.onClickLocationFrame(locId, frameId);
            });
        }
    }
    handleKeyDown(event) {
        let newIndex;
        const [locId, frameId] = this.hoveredLocFrame;
        const location = this.imageMetaData.locationLookup.get(locId);
        let nextFrameId;
        switch (event.keyCode) {
            case 37: // left
                if (this.hoveredLocId !== locId) {
                    return;
                }
                const minFrameId = location.frameList[0].frameId;
                nextFrameId = Math.max(frameId - 1, minFrameId);
                this.onHoverLocationFrame(locId, nextFrameId, null, true);
                break;
            case 39: // right
                if (this.hoveredLocId !== locId) {
                    return;
                }
                const maxFrameId = location.frameList[location.frameList.length - 1].frameId;
                nextFrameId = Math.min(frameId + 1, maxFrameId);
                this.onHoverLocationFrame(locId, nextFrameId, null, true);
                break;
            case 13: // enter
                if (this.hoveredLocId !== locId) {
                    return;
                }
                this.switchToHovered();
                break;
        }
    }
    onHoverLocationFrame(locationId, frameId, cellId, showTooltip) {
        this._hoveredLocFrame = [locationId, frameId];
        const lastSvgContainer = d3.select('#frameTicksViz-' + this.hoveredLocationId);
        this.removeHoverDots(lastSvgContainer);
        this.removeHoverBar(lastSvgContainer);
        const svgContainer = d3.select('#frameTicksViz-' + locationId);
        this.changeHoveredLocation(locationId);
        this.frameTooltip.Hide();
        if (frameId === null) {
            return;
        }
        if (showTooltip) {
            const bbox = svgContainer.node().getBoundingClientRect();
            const xPos = bbox.right;
            const yPos = bbox.top + bbox.height / 2;
            const htmlString = this.createTooltipContent(locationId, frameId);
            this.frameTooltip.Show(htmlString, xPos, yPos);
        }
        this.drawHoverDots(svgContainer, locationId, frameId);
        this.drawFrameRange(svgContainer, cellId);
    }
    switchToHovered() {
        const [locId, frameId] = this.hoveredLocFrame;
        this.onClickLocationFrame(locId, frameId);
    }
    drawFrameRange(svgContainer, cellId) {
        if (cellId === null) {
            this.removeHoverBar(svgContainer);
            return;
        }
        const curve = this.data.curveLookup.get(cellId);
        const firstPoint = curve.pointList[0];
        const lowFrameId = firstPoint.get("Frame ID");
        const locId = firstPoint.get('Location ID');
        const location = this.imageMetaData.locationLookup.get(locId);
        const frameLow = location.frameLookup.get(lowFrameId);
        const lastPoint = curve.pointList[curve.pointList.length - 1];
        const highFrameId = lastPoint.get("Frame ID");
        const frameHigh = location.frameLookup.get(highFrameId);
        const xLow = this.frameScaleX(lowFrameId);
        const xHigh = this.frameScaleX(highFrameId);
        const h1 = (this.frameScaleHeight(frameLow.inBrushPercent) + this.frameHeight) / 2;
        const h2 = (this.frameScaleHeight(frameHigh.inBrushPercent) + this.frameHeight) / 2;
        const betweenTickMargin = 2;
        const fromBottomMargin = 6;
        const y1 = h1 + betweenTickMargin;
        const y2 = this.frameHeightSelected - fromBottomMargin;
        const y3 = h2 + betweenTickMargin;
        const pointList = [
            [xLow, y1],
            [xLow, y2],
            [xHigh, y2],
            [xHigh, y3]
        ];
        const lineFunction = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveBasis);
        const path = lineFunction(pointList);
        svgContainer.selectAll('.hoverBar')
            .data([path])
            .join('path')
            .attr('d', path)
            .classed('hoverBar', true);
    }
    removeHoverBar(svgContainer) {
        svgContainer.selectAll('.hoverBar').remove();
    }
    drawHoverDots(svgContainer, locationId, frameId) {
        const xyPositions = this.getDotCenters(locationId, frameId);
        const dotR = 2;
        svgContainer.selectAll('.hoverDot')
            .data(xyPositions)
            .join('circle')
            .classed('hoverDot', true)
            .attr('cx', d => d[0])
            .attr('cy', d => d[1])
            .attr('fill', '#ECECEC')
            .attr('stroke', 'black')
            .attr('r', dotR)
            .attr('stroke-width', 0.5);
    }
    drawSelectedDots() {
        const [locationId, frameId] = this.selectedLocFrame;
        const xyPositions = this.getDotCenters(locationId, frameId);
        const dotR = 3;
        const svgContainer = d3.select('#frameTicksViz-' + locationId);
        svgContainer.selectAll('.selectedDot')
            .data(xyPositions)
            .join('circle')
            .classed('selectedDot', true)
            .attr('cx', d => d[0])
            .attr('cy', d => d[1])
            .attr('fill', 'black')
            .attr('stroke', 'black')
            .attr('r', dotR)
            .attr('stroke-width', 0.5);
    }
    getDotCenters(locationId, frameId) {
        const frame = this.imageMetaData.locationLookup.get(locationId).frameLookup.get(frameId);
        const xPos = this.frameScaleX(frameId);
        const tickHeight = this.frameScaleHeight(frame.inBrushPercent);
        const dotR = 2;
        const dotMargin = 3;
        const margin = (this.frameHeight - tickHeight) / 2;
        const yPos1 = margin - dotR - dotMargin;
        const yPos2 = margin + tickHeight + dotR + dotMargin;
        return [[xPos, yPos1], [xPos, yPos2]];
    }
    removeHoverDots(svgContainer) {
        svgContainer.selectAll('.hoverDot').remove();
    }
    removeCurrentSelectedDots() {
        const svgContainer = d3.select('#frameTicksViz-' + this.selectedLocFrame[0]);
        svgContainer.selectAll('.selectedDot').remove();
    }
    onClickLocation(locationId) {
        if (locationId === this.selectedLocationId) {
            return;
        }
        this.changeLocationSelection(locationId);
        const skipImageTrackDraw = true;
        this.setImageStackWidget(skipImageTrackDraw);
    }
    onClickLocationFrame(locationId, frameId) {
        let [oldLocId, oldFrameId] = this.selectedLocFrame;
        if (oldLocId === locationId && oldFrameId === frameId) {
            return;
        }
        this.onClickLocation(locationId);
        this.imageStackWidget.changeSelectedImage(frameId - 1); // matlab
        this.updateSelectedDots(locationId, frameId);
    }
    updateSelectedDots(locationId, frameId) {
        this.removeCurrentSelectedDots();
        this._selectedLocFrame = [locationId, frameId];
        this.drawSelectedDots();
    }
    createTooltipContent(locationId, frameId) {
        const labelValueList = [
            ['Location', locationId.toString()],
            ['Frame', frameId.toString()],
        ];
        return RichTooltip_1.RichTooltip.createLabelValueListContent(labelValueList);
    }
    hideFrameTooltip() {
        this.frameTooltip.Hide();
    }
    getFrameList(locationId) {
        const imageLocation = this.imageMetaData.locationLookup.get(locationId);
        return imageLocation.frameList;
    }
    changeLocationSelection(newId) {
        let lastSelected = d3.select("#imageLocation-" + this.selectedLocationId);
        lastSelected.classed('selected', false);
        let lastSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.selectedLocationId);
        lastSelectedFrameTickViz.attr('height', this.frameHeight);
        this._selectedLocationId = newId;
        let newSelected = d3.select("#imageLocation-" + this.selectedLocationId);
        newSelected.classed('selected', true);
        let newSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.selectedLocationId);
        newSelectedFrameTickViz.attr('height', this.frameHeightSelected);
    }
    changeHoveredLocation(newId) {
        if (this.hoveredLocationId !== null) {
            let lastSelected = d3.select("#imageLocation-" + this.hoveredLocationId);
            lastSelected.classed('hovered', false);
            if (this.hoveredLocationId !== this.selectedLocationId) {
                let lastSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.hoveredLocationId);
                lastSelectedFrameTickViz.attr('height', this.frameHeight);
            }
        }
        this._hoveredLocationId = newId;
        if (this.hoveredLocationId !== null) {
            let newSelected = d3.select("#imageLocation-" + this.hoveredLocationId);
            newSelected.classed('hovered', true);
            let newSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.hoveredLocationId);
            newSelectedFrameTickViz.attr('height', this.frameHeightSelected);
        }
    }
}
exports.ImageSelectionWidget = ImageSelectionWidget;

},{"../DataModel/ImageMetaData":106,"../DataModel/ImageStackDataRequest":107,"../devlib/DevlibMath":112,"./BaseWidget":81,"./GroupByWidget":83,"./ImageStackWidget":86,"./RichTooltip":91,"d3":42}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const quickSelect = require("quickselect.js");
const RichTooltip_1 = require("../Components/RichTooltip");
const ImageTrackWidget_1 = require("./ImageTrackWidget");
const ImageStackDataRequest_1 = require("../DataModel/ImageStackDataRequest");
class ImageStackWidget {
    constructor(container, imageTrackContainer, maxHeight) {
        this._container = container;
        this._imageTrackWidget = new ImageTrackWidget_1.ImageTrackWidget(imageTrackContainer, this);
        this._maxHeight = maxHeight;
        this.init();
        this._cellHovered = 0;
        this._selectedImgIndex = 0;
        console.log(d3);
        console.log(this);
        this._tooltip = new RichTooltip_1.RichTooltip();
        this._exemplarAttribute = 'Avg Mass'; // TODO change default
        this._inExemplarMode = true; // TODO
        this._inCondensedMode = true; // TODO mode
        this._condensedModeCount = 7;
        this._exemplarLocations = new Set();
    }
    get container() {
        return this._container;
    }
    get imageTrackWidget() {
        return this._imageTrackWidget;
    }
    get maxHeight() {
        return this._maxHeight;
    }
    get imageLocation() {
        return this._imageLocation;
    }
    get imageStackBlob() {
        return this._imageStackBlob;
    }
    get numPixelsInTile() {
        var _a, _b;
        return ((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth) * ((_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight);
    }
    get firstIndex() {
        return this.numPixelsInTile * this.selectedImgIndex;
    }
    get imageStackLabelUrl() {
        return this._imageStackLabelUrl;
    }
    get imageStackWidth() {
        return this._imageStackWidth;
    }
    get imageStackHeight() {
        return this._imageStackHeight;
    }
    get selectedImgIndex() {
        return this._selectedImgIndex;
    }
    get innerContainer() {
        return this._innerContainer;
    }
    get locationLabel() {
        return this._locationLabel;
    }
    get frameLabel() {
        return this._frameLabel;
    }
    get selectedImageContainer() {
        return this._selectedImageContainer;
    }
    get selectedImageCanvas() {
        return this._selectedImageCanvas;
    }
    get canvasContext() {
        return this._canvasContext;
    }
    get data() {
        return this._data;
    }
    get imageStackDataRequest() {
        return this._imageStackDataRequest;
    }
    get defaultCanvasState() {
        return this._defaultCanvasState;
    }
    get cellHovered() {
        return this._cellHovered;
    }
    get tooltip() {
        return this._tooltip;
    }
    get exemplarAttribute() {
        return this._exemplarAttribute;
    }
    get inExemplarMode() {
        return this._inExemplarMode;
    }
    get inCondensedMode() {
        return this._inCondensedMode;
    }
    get condensedModeCount() {
        return this._condensedModeCount;
    }
    get exemplarLocations() {
        return this._exemplarLocations;
    }
    init() {
        const containerSelect = d3.select(this.container);
        this._innerContainer = containerSelect.append('div')
            .classed('innerContainer', true);
        const locationFrameLabelContainer = this.innerContainer.append('div')
            .classed('locationFrameLabelContainer', true);
        const locationFrameLabel = locationFrameLabelContainer.append('h3')
            .classed('locationFrameLabel', true);
        locationFrameLabel.node().append('Location: ');
        this._locationLabel = locationFrameLabel.append('span')
            .classed('locationFrameLabelValue', true);
        locationFrameLabel.node().append('Frame: ');
        this._frameLabel = locationFrameLabel.append('span')
            .classed('locationFrameLabelValue', true);
        this._selectedImageContainer = this.innerContainer.append('div')
            .classed('noShrink', true);
        this._selectedImageCanvas = this.selectedImageContainer.append('canvas')
            .style('opacity', 0);
        this.selectedImageCanvas.node().addEventListener('mousemove', (e) => {
            this.onCanvasMouseMove(e);
        });
        this._canvasContext = this.selectedImageCanvas.node().getContext('2d');
        this.selectedImageContainer
            .on('mouseenter', () => this.brightenCanvas())
            .on('mouseleave', () => {
            this.hideSegmentHover();
            this.dimCanvas();
        });
        this.imageTrackWidget.init();
        document.addEventListener('launchExemplarCurve', (e) => {
            this._exemplarAttribute = e.detail;
            let buttonChangeEvent = new CustomEvent('changeModeSelect', { detail: 0 });
            document.dispatchEvent(buttonChangeEvent);
            let modeChangeEvent = new CustomEvent('modeChange', { detail: {
                    inCondensedMode: true,
                    inExemplarMode: true
                } });
            document.dispatchEvent(modeChangeEvent);
        });
        document.addEventListener('modeChange', (e) => {
            this._inExemplarMode = e.detail.inExemplarMode;
            this._inCondensedMode = e.detail.inCondensedMode;
            this.updateTracksCanvas();
            document.dispatchEvent(new CustomEvent('modeChangeRedraw'));
            document.dispatchEvent(new CustomEvent('exemplarAttributeChange', { detail: this.inExemplarMode ? this.exemplarAttribute : null }));
        });
        document.dispatchEvent(new CustomEvent('exemplarAttributeChange', { detail: this.inExemplarMode ? this.exemplarAttribute : null }));
    }
    dimCanvas() {
        this.selectedImageCanvas.style('opacity', 0.6);
    }
    brightenCanvas() {
        this.selectedImageCanvas.style('opacity', 1);
    }
    SetData(data, imageLocation, imageStackDataRequest, skipImageTrackDraw = false) {
        this._data = data;
        this._imageStackDataRequest = imageStackDataRequest;
        this._selectedImgIndex = 0;
        this._imageLocation = imageLocation;
        this.SetImageProperties(skipImageTrackDraw); // default values before image load
        this.draw(skipImageTrackDraw);
    }
    SetImageProperties(skipImageTrackDraw, blob, imageWidth, imageHeight, numColumns, scaleFactor) {
        // default values for when loading, or if image isn't found
        if (!imageWidth) {
            imageWidth = 256;
        }
        if (!imageHeight) {
            imageHeight = 256;
        }
        if (!numColumns) {
            numColumns = 10;
        }
        this._imageStackBlob = blob;
        this.draw(skipImageTrackDraw);
    }
    draw(skipImageTrackDraw = false) {
        this.drawSelectedImage(skipImageTrackDraw);
        this.updateLocationFrameLabel();
    }
    OnBrushChange() {
        this.draw(true);
        this.imageTrackWidget.OnBrushChange();
    }
    drawUpdate() {
        this.updateBackgroundPosition(this.selectedImgIndex);
        this.updateCanvas(this.inExemplarMode);
        this.updateLocationFrameLabel();
    }
    drawSelectedImage(skipImageTrackDraw = false) {
        this.setImageInlineStyle(this.selectedImgIndex);
        // this.selectedImageContainer.attr("style", styleString);
        this.updateCanvas(skipImageTrackDraw);
    }
    updateLocationFrameLabel() {
        this.locationLabel.text(this.getCurrentLocationId());
        this.frameLabel.text(this.getCurrentFrameId());
    }
    getCurrentLocationId() {
        return this.imageLocation.locationId;
    }
    getCurrentFrameId() {
        return this.selectedImgIndex + 1;
        // return this.imageLocation.frameList[this.selectedImgIndex].frameId;
    }
    updateCanvas(skipImageTrackDraw = false) {
        var _a, _b, _c;
        if (!this.imageStackDataRequest) {
            return;
        }
        this.selectedImageCanvas
            .attr('width', (_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth)
            .attr('height', (_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight);
        (_c = this.imageStackDataRequest) === null || _c === void 0 ? void 0 : _c.getLabel(this.getCurrentLocationId(), this.selectedImgIndex, (data, firstIndex) => {
            this.createOutlineImage(data, firstIndex);
            this.drawDefaultCanvas();
        });
        let locId = this.imageLocation.locationId;
        if (!skipImageTrackDraw) {
            this.updateTracksCanvas();
        }
    }
    updateTracksCanvas() {
        let curveList;
        if (this.inExemplarMode) {
            curveList = this.getExemplarCurves();
            this.exemplarLocations.clear();
            for (let curve of curveList) {
                const firstPoint = curve.pointList[0];
                this.exemplarLocations.add(firstPoint.get('Location ID'));
            }
        }
        else {
            curveList = this.getCurvesBasedOnPointsAtCurrentFrame();
            this.exemplarLocations.clear();
        }
        this.imageTrackWidget.draw(curveList);
    }
    getExemplarCurves() {
        let curveList = [];
        let facetOptions = this.data.GetFacetOptions();
        const firstFacetOption = facetOptions[0];
        const facetName = firstFacetOption.name;
        let facets = firstFacetOption.GetFacets();
        const trackLengthKey = 'Track Length';
        for (let facet of facets) {
            let facetData = facet.data;
            let maxLength = facetData.curveCollection.getMinMax(trackLengthKey)[1];
            let longTracks = facetData.curveList.filter(x => x.get(trackLengthKey) > (maxLength / 2.0));
            let numCurves = longTracks.length;
            let lowCurve = quickSelect(longTracks, 1, (curve) => curve.get(this.exemplarAttribute));
            let medianCurve = quickSelect(longTracks, Math.floor(numCurves / 2), (curve) => curve.get(this.exemplarAttribute));
            let highCurve = quickSelect(longTracks, numCurves - 1, (curve) => curve.get(this.exemplarAttribute));
            curveList.push(lowCurve);
            curveList.push(medianCurve);
            curveList.push(highCurve);
        }
        return curveList;
    }
    getCurvesBasedOnPointsAtCurrentFrame() {
        let curveList = [];
        const pointsAtFrame = this.data.GetCellsAtFrame(this.getCurrentLocationId(), this.getCurrentFrameId());
        for (let point of pointsAtFrame) {
            curveList.push(point.parent);
        }
        return curveList;
    }
    createOutlineImage(rowArray, firstIndex) {
        if (!this.imageStackDataRequest) {
            return;
        }
        let myImageData = this.canvasContext.createImageData(this.imageStackDataRequest.tileWidth, this.imageStackDataRequest.tileHeight);
        for (let rowIdx = firstIndex; rowIdx < firstIndex + this.imageStackDataRequest.tileHeight; rowIdx++) {
            let row = rowArray.rowList[rowIdx];
            for (let labelRun of row.row) {
                for (let colIdx = labelRun.start; colIdx < labelRun.start + labelRun.length; colIdx++) {
                    if (this.isBorder(labelRun.label, rowIdx, colIdx, rowArray)) {
                        let flatIdx = (rowIdx - firstIndex) * this.imageStackDataRequest.tileWidth + colIdx;
                        flatIdx *= 4;
                        let [cell, _index] = this.getCell(labelRun.label);
                        let [r, g, b] = this.getCellColor(cell);
                        myImageData.data[flatIdx] = r;
                        myImageData.data[flatIdx + 1] = g;
                        myImageData.data[flatIdx + 2] = b;
                        myImageData.data[flatIdx + 3] = 255;
                    }
                }
            }
        }
        this._defaultCanvasState = myImageData;
    }
    drawDefaultCanvas() {
        this.canvasContext.putImageData(this.defaultCanvasState, 0, 0);
    }
    isBorder(label, rowIdx, colIdx, rowArray) {
        let neighborIndices = [];
        // 4-neighbor
        neighborIndices.push([rowIdx - 1, colIdx]);
        neighborIndices.push([rowIdx + 1, colIdx]);
        neighborIndices.push([rowIdx, colIdx - 1]);
        neighborIndices.push([rowIdx, colIdx + 1]);
        // 8-neighbor
        neighborIndices.push([rowIdx - 1, colIdx - 1]);
        neighborIndices.push([rowIdx + 1, colIdx - 1]);
        neighborIndices.push([rowIdx + 1, colIdx - 1]);
        neighborIndices.push([rowIdx - 1, colIdx + 1]);
        // 12-neighbor
        neighborIndices.push([rowIdx - 2, colIdx]);
        neighborIndices.push([rowIdx + 2, colIdx]);
        neighborIndices.push([rowIdx, colIdx - 2]);
        neighborIndices.push([rowIdx, colIdx + 2]);
        for (let [rI, cI] of neighborIndices) {
            if (rI < 0
                || rI >= rowArray.rowList.length
                || cI < 0
                || cI >= this.imageStackDataRequest.tileWidth) {
                // neighbor out of bounds of tile
                continue;
            }
            let nVal = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rI, cI, rowArray);
            if (nVal !== label) {
                return true;
            }
        }
        return false;
    }
    onCanvasMouseMove(e) {
        if (!this.imageStackDataRequest || !this.defaultCanvasState) {
            return;
        }
        this.imageStackDataRequest.getLabel(this.getCurrentLocationId(), this.selectedImgIndex, (rowArray, firstIndex) => {
            const rowIdx = e.offsetY + firstIndex;
            const colIdx = e.offsetX;
            const label = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rowIdx, colIdx, rowArray);
            if (label === this.cellHovered) {
                return;
            }
            this._cellHovered = label;
            if (label === 0) {
                this.drawDefaultCanvas();
                this.tooltip.Hide();
                const customEvent = new CustomEvent('frameHoverChange', { detail: {
                        locationId: this.getCurrentLocationId(),
                        frameId: this.getCurrentFrameId(),
                        cellId: null
                    } });
                document.dispatchEvent(customEvent);
            }
            else {
                this.showSegmentHover(rowArray, label, firstIndex, false, e);
            }
        });
    }
    hideSegmentHover(hideTooltipImmediately = false) {
        this.drawDefaultCanvas();
        let delayOverride;
        if (hideTooltipImmediately) {
            delayOverride = 0;
        }
        this.tooltip.Hide(delayOverride);
    }
    showSegmentHover(rowArray, segmentId, firstIndex, showTooltipImmediately = false, event) {
        var _a, _b;
        this._cellHovered = segmentId;
        let [cell, index] = this.getCell(segmentId);
        let cellX = 0;
        let cellY = 0;
        let pageX = 0;
        let pageY = 0;
        if (cell) {
            let canvasBoundRect = this.selectedImageCanvas.node().getBoundingClientRect();
            cellX = (cell.get('X') + cell.get('xShift')) / this.imageStackDataRequest.scaleFactor;
            cellY = (cell.get('Y') + cell.get('yShift')) / this.imageStackDataRequest.scaleFactor;
            pageX = canvasBoundRect.x + cellX;
            pageY = canvasBoundRect.y + cellY;
            const customEvent = new CustomEvent('frameHoverChange', { detail: {
                    locationId: this.getCurrentLocationId(),
                    frameId: this.getCurrentFrameId(),
                    cellId: cell.parent.id
                } });
            document.dispatchEvent(customEvent);
        }
        else if (event) {
            pageX = event.pageX;
            pageY = event.pageY;
        }
        let myImageData = this.canvasContext.createImageData((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth, (_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight);
        myImageData.data.set(this.defaultCanvasState.data);
        for (let rowIdx = firstIndex; rowIdx < firstIndex + this.imageStackDataRequest.tileHeight; rowIdx++) {
            let row = rowArray.rowList[rowIdx];
            for (let labelRun of row.row) {
                if (labelRun.label === this.cellHovered) {
                    for (let colIdx = labelRun.start; colIdx < labelRun.start + labelRun.length; colIdx++) {
                        let flatIdx = (rowIdx - firstIndex) * this.imageStackDataRequest.tileWidth + colIdx;
                        flatIdx *= 4;
                        let [cell, _index] = this.getCell(labelRun.label);
                        let [r, g, b] = this.getCellColor(cell);
                        myImageData.data[flatIdx] = r;
                        myImageData.data[flatIdx + 1] = g;
                        myImageData.data[flatIdx + 2] = b;
                        myImageData.data[flatIdx + 3] = 200;
                    }
                }
            }
        }
        this.canvasContext.putImageData(myImageData, 0, 0);
        if (cell) {
            this.canvasContext.beginPath();
            this.canvasContext.arc(cellX, cellY, 5, 0, 2 * Math.PI);
            this.canvasContext.strokeStyle = 'black';
            this.canvasContext.stroke();
            this.canvasContext.fillStyle = '#FF00FF';
            this.canvasContext.fill();
        }
        let tooltipContent = this.getTooltipContent(segmentId, cell, index);
        let delayOverride;
        if (showTooltipImmediately) {
            delayOverride = 0;
        }
        this.tooltip.Show(tooltipContent, pageX, pageY, delayOverride);
    }
    getLabelIndexFromBigImgPixelXY(frameIndex, x, y) {
        var _a, _b, _c, _d;
        x = Math.round(x);
        y = Math.round(y);
        let colIdx = x % ((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth);
        let rowIdx = (y % ((_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight)) + (frameIndex % ((_c = this.imageStackDataRequest) === null || _c === void 0 ? void 0 : _c.tilesPerFile)) * ((_d = this.imageStackDataRequest) === null || _d === void 0 ? void 0 : _d.tileHeight);
        return [rowIdx, colIdx];
    }
    getTileIndexFromBigImgPixelXY(x, y) {
        var _a, _b, _c;
        let colIndex = Math.floor(x / ((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth));
        let rowIndex = Math.floor(y / ((_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight));
        return rowIndex * ((_c = this.imageStackDataRequest) === null || _c === void 0 ? void 0 : _c.numberOfColumns) + colIndex;
    }
    getTooltipContent(label, cell, index) {
        var _a, _b;
        let labelValuePairs = [
            ['Location', this.getCurrentLocationId().toString()],
            ['Frame', this.getCurrentFrameId().toString()],
            ['Segment', label.toString()]
        ];
        let cellId = (_b = (_a = cell) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.id;
        if (cellId) {
            labelValuePairs.push(['Cell', cellId]);
            labelValuePairs.push(['Row', index.toString()]);
        }
        else {
            labelValuePairs.push(['No cell linked', null]);
        }
        return RichTooltip_1.RichTooltip.createLabelValueListContent(labelValuePairs);
    }
    getCell(label) {
        return this.data.GetCellFromLabel(this.getCurrentLocationId(), this.getCurrentFrameId(), label);
    }
    getCellColor(cell) {
        let color = [0, 0, 0];
        if (!cell) {
            // SpringGreen
            color = [154, 205, 50];
        }
        else if (cell.inBrush) {
            // FireBrick
            color = [178, 34, 34];
        }
        else {
            // SteelBlue
            color = [70, 130, 180];
        }
        return color;
    }
    changeSelectedImage(newIndex) {
        this._selectedImgIndex = newIndex;
        this.drawUpdate();
    }
    setImageInlineStyle(index, includeFallback = true) {
        var _a;
        (_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.getImage(this.getCurrentLocationId(), index, (top, left, _blob, imageUrl) => {
            var _a, _b;
            let styleString = `
					background-position-x: ${-left}px;
					background-position-y: ${-top}px;
					width: ${(_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth}px;
					height: ${(_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight}px;
					`;
            if (imageUrl) {
                styleString += `background-image: url(${imageUrl});`;
            }
            if (includeFallback) {
                styleString += 'background-color: #ebebeb;';
            }
            this.selectedImageContainer.attr("style", styleString);
        });
    }
    updateBackgroundPosition(index) {
        var _a;
        this.setImageInlineStyle(index);
        return;
        const [top, left] = (_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.getTileTopLeft(index);
        this.selectedImageContainer.node().style.backgroundPositionX = -left + 'px';
        this.selectedImageContainer.node().style.backgroundPositionY = -top + 'px';
    }
    OnResize(newMaxHeight, imageTrackMaxHeight, newWidth) {
        this._maxHeight = newMaxHeight;
        this.container.setAttribute('style', `max-height: ${this.maxHeight}px;`);
        this.imageTrackWidget.OnResize(newWidth, imageTrackMaxHeight);
    }
}
exports.ImageStackWidget = ImageStackWidget;

},{"../Components/RichTooltip":91,"../DataModel/ImageStackDataRequest":107,"./ImageTrackWidget":87,"d3":42,"quickselect.js":77}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibMath_1 = require("../devlib/DevlibMath");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const ImageStackDataRequest_1 = require("../DataModel/ImageStackDataRequest");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class ImageTrackWidget {
    constructor(container, parent) {
        this._container = container;
        this._parentWidget = parent;
        this._verticalPad = 16;
        this._horizontalPad = 8;
        this._frameLabelPositions = [];
        this._cellLabelPositions = [];
        // hardcoded from css
        this._cellTimelineMargin = {
            top: 36,
            right: 4,
            bottom: 4,
            left: 72
        };
        this._latestScroll = [0, 0];
        this._scrollChangeTicking = false;
        this._sourceDestCell = [];
    }
    get container() {
        return this._container;
    }
    get parentWidget() {
        return this._parentWidget;
    }
    get innerContainer() {
        return this._innerContainer;
    }
    get innerContainerW() {
        return this._innerContainerW;
    }
    get innerContainerH() {
        return this._innerContainerH;
    }
    get titleContainer() {
        return this._titleContainer;
    }
    get svgContainer() {
        return this._svgContainer;
    }
    get cellLabelGroup() {
        return this._cellLabelGroup;
    }
    get frameLabelGroup() {
        return this._frameLabelGroup;
    }
    get selectedImageCanvas() {
        return this._selectedImageCanvas;
    }
    get canvasContext() {
        return this._canvasContext;
    }
    get trackList() {
        return this._trackList;
    }
    get verticalPad() {
        return this._verticalPad;
    }
    get horizontalPad() {
        return this._horizontalPad;
    }
    get frameLabelPositions() {
        return this._frameLabelPositions;
    }
    get cellLabelPositions() {
        return this._cellLabelPositions;
    }
    get cellTimelineMargin() {
        return this._cellTimelineMargin;
    }
    get scrollChangeTicking() {
        return this._scrollChangeTicking;
    }
    get latestScroll() {
        return this._latestScroll;
    }
    get latestMouseCanvasOffset() {
        return this._latestMouseCanvasOffset;
    }
    get sourceDestCell() {
        return this._sourceDestCell;
    }
    init() {
        const containerSelect = d3.select(this.container);
        this._titleContainer = containerSelect.append('div')
            .classed('trackModeTitleContainer', true)
            .classed('mediumText', true);
        this._svgContainer = containerSelect.append('svg');
        this._cellLabelGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top})`);
        this._frameLabelGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(${this.cellTimelineMargin.left}, 0)`);
        this._innerContainer = containerSelect.append('div')
            .classed('cellTimelineInnerContainer', true)
            .classed('overflow-scroll', true);
        this.innerContainer.node().addEventListener('scroll', (e) => {
            this.onCellTimelineScroll(e);
        });
        this._selectedImageCanvas = this.innerContainer.append('canvas');
        const canvasElement = this.selectedImageCanvas.node();
        canvasElement.addEventListener('mousemove', (e) => this.onCanvasMouseMove(e));
        canvasElement.addEventListener('click', (e) => this.onCanvasClick(e));
        this.selectedImageCanvas.on('mouseleave', () => this.onCanvasMouseLeave());
        this._canvasContext = canvasElement.getContext('2d');
        document.addEventListener('frameHoverChange', (e) => {
            const frameId = e.detail.frameId;
            const cellId = e.detail.cellId;
            if (frameId !== null && cellId !== null) {
                let frameIndex;
                if (this.parentWidget.inCondensedMode) {
                    let curve = this.parentWidget.data.curveLookup.get(cellId);
                    let pointIndex = curve.pointList.findIndex(point => point.get('Frame ID') === frameId);
                    let percent = pointIndex / (curve.pointList.length - 1);
                    frameIndex = percent * (this.parentWidget.condensedModeCount - 1);
                    let frameIndexRounded = Math.round(frameIndex);
                    const epsilon = (1 / (curve.pointList.length + 1)) * (this.parentWidget.condensedModeCount - 1);
                    if (Math.abs(frameIndex - frameIndexRounded) < epsilon) {
                        frameIndex = frameIndexRounded;
                    }
                    else {
                        frameIndex = -1;
                    }
                }
                else {
                    frameIndex = frameId - 1;
                }
                this.updateLabelsOnMouseMove(cellId, frameIndex);
            }
            else {
                this.updateLabelsOnMouseMove('', -1);
            }
        });
    }
    async draw(tracks) {
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        if (!this.parentWidget.imageStackDataRequest) {
            return;
        }
        if (tracks === this.trackList) {
            return;
        }
        DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
        this._trackList = tracks;
        this.updateTitle();
        await this.drawTrackList();
        this.drawLabels();
    }
    updateTitle() {
        if (this.parentWidget.inExemplarMode) {
            this.titleContainer.text('Exemplars of ' + this.parentWidget.exemplarAttribute);
        }
        else {
            this.titleContainer.text('Frame Extraction Mode');
        }
    }
    OnBrushChange() {
        this.drawOutlines();
    }
    async drawTrackList() {
        this._sourceDestCell = [];
        let listOfBoundingBoxLists = await this.getBoundingBoxLists(this.trackList);
        let maxHeightList = [];
        let maxWidth = d3.max(listOfBoundingBoxLists, (rectList) => {
            return d3.max(rectList, r => ImageTrackWidget.rectWidth(r));
        });
        for (let rectList of listOfBoundingBoxLists) {
            let thisHeight = d3.max(rectList, r => ImageTrackWidget.rectHeight(r));
            maxHeightList.push(thisHeight);
        }
        let minFrameId = d3.min(this.trackList, (track) => {
            return d3.min(track.pointList, point => point.get('Frame ID'));
        });
        let maxFrameId = d3.max(this.trackList, (track) => {
            return d3.max(track.pointList, point => point.get('Frame ID'));
        });
        let numFrames;
        if (this.parentWidget.inCondensedMode) {
            numFrames = this.parentWidget.condensedModeCount;
        }
        else {
            numFrames = maxFrameId - minFrameId + 1;
        }
        const canvasWidth = numFrames * maxWidth + this.horizontalPad * (numFrames + 1);
        const totalHeight = d3.sum(maxHeightList) + this.verticalPad * (this.trackList.length + 1);
        this.selectedImageCanvas
            .attr('width', canvasWidth)
            .attr('height', totalHeight);
        let verticalOffset = this.verticalPad;
        this._cellLabelPositions = [];
        let drawTrackPromises = [];
        for (let i = 0; i < this.trackList.length; i++) {
            let track = this.trackList[i];
            let boundingBoxList = listOfBoundingBoxLists[i];
            let trackHeight = maxHeightList[i];
            let done = this.drawTrack(track, boundingBoxList, maxWidth, trackHeight, minFrameId, verticalOffset);
            drawTrackPromises.push(done);
            this._cellLabelPositions.push([track.id, verticalOffset + trackHeight / 2]);
            verticalOffset += trackHeight + this.verticalPad;
        }
        this._frameLabelPositions = [];
        for (let i = 0; i < numFrames; i++) {
            let frameId = (i + minFrameId).toString();
            let offset = this.horizontalPad;
            offset += i * (maxWidth + this.horizontalPad);
            offset += maxWidth / 2;
            this._frameLabelPositions.push([frameId, offset]);
        }
        await Promise.allSettled(drawTrackPromises);
        DevlibTSUtil_1.DevlibTSUtil.stopSpinner();
        // this.drawOutlines();
    }
    async getBoundingBoxLists(trackList) {
        let listOfLists = [];
        for (let track of trackList) {
            let thisList = [];
            if (this.parentWidget.inCondensedMode) {
                for (let i = 0; i < this.parentWidget.condensedModeCount; i++) {
                    let point = this.getPointInCondensedMode(track, i);
                    const boundingBox = await this.getCellBoundingBox(point);
                    thisList.push(boundingBox);
                }
            }
            else {
                for (let point of track.pointList) {
                    const boundingBox = await this.getCellBoundingBox(point);
                    thisList.push(boundingBox);
                }
            }
            listOfLists.push(thisList);
        }
        return listOfLists;
    }
    getPointInCondensedMode(track, index) {
        let percent = index / (this.parentWidget.condensedModeCount - 1);
        let trackIndex = Math.min(Math.round(percent * track.pointList.length), track.pointList.length - 1);
        return track.pointList[trackIndex];
    }
    async drawTrack(trackData, boundingBoxList, maxWidth, maxHeight, minFrame, verticalOffset) {
        var _a, _b;
        // draw track background
        this.drawTrackBackground(trackData, maxWidth, maxHeight, minFrame, verticalOffset);
        let asyncFunctionList = [];
        let blobRequests = [];
        let offsetArray = [];
        for (let i = 0; i < boundingBoxList.length; i++) {
            // this is a bit painful. The biggest addition to the complexity
            // is accounting for edge cases in the tile of the tiled image.
            // if it gets to an edge only only copies what it can, then centers in
            // a rect of the same size as others in the cell.
            let point;
            if (this.parentWidget.inCondensedMode) {
                point = this.getPointInCondensedMode(trackData, i);
            }
            else {
                point = trackData.pointList[i];
            }
            const frameId = point.get('Frame ID');
            // const offsetIndex = frameId - minFrame;
            const frameIndex = frameId - 1;
            let blobRequest = this.parentWidget.imageStackDataRequest.getImagePromise(point.get('Location ID'), frameIndex);
            blobRequests.push(blobRequest);
        }
        let results = await Promise.all(blobRequests);
        // .then((results: [number, number, Blob, string][]) =>
        // {
        let sourceDestCell = [];
        let workerData = [];
        let webWorker = new Worker('/static/script/dist/ImageWorker.js');
        for (let j = 0; j < results.length; j++) {
            let [tileTop, tileLeft, blob, _url] = results[j];
            let bbox = boundingBoxList[j];
            const [sX, sY] = bbox[0];
            let width = ImageTrackWidget.rectWidth(bbox);
            let height = ImageTrackWidget.rectHeight(bbox);
            const extraX = Math.round((maxWidth - width) / 2);
            const extraY = Math.round((maxHeight - height) / 2);
            let point;
            if (this.parentWidget.inCondensedMode) {
                point = this.getPointInCondensedMode(trackData, j);
            }
            else {
                point = trackData.pointList[j];
            }
            const frameId = point.get('Frame ID');
            let offsetIndex;
            if (this.parentWidget.inCondensedMode) {
                offsetIndex = j;
            }
            else {
                offsetIndex = frameId - minFrame;
            }
            const tileBot = tileTop + ((_a = this.parentWidget.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileHeight);
            const tileRight = tileLeft + ((_b = this.parentWidget.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileWidth);
            const copyTop = DevlibMath_1.DevlibMath.clamp(sY - extraY, [tileTop, tileBot]);
            const copyLeft = DevlibMath_1.DevlibMath.clamp(sX - extraX, [tileLeft, tileRight]);
            const copyWidth = Math.min(maxWidth, tileRight - copyLeft);
            const copyHeight = Math.min(maxHeight, tileBot - copyTop);
            const offsetX = Math.round(this.horizontalPad + offsetIndex * (maxWidth + this.horizontalPad) + (maxWidth - copyWidth) / 2);
            const offsetY = Math.round(verticalOffset + (maxHeight - copyHeight) / 2);
            const destOffset = [offsetX, offsetY];
            offsetArray.push(destOffset);
            let sourceRect = [[copyLeft, copyTop], [copyLeft + copyWidth, copyTop + copyHeight]];
            this.sourceDestCell.push([sourceRect, destOffset, point]);
            sourceDestCell.push([sourceRect, destOffset, point]);
            workerData.push([blob, copyLeft, copyTop, copyWidth, copyHeight]);
        }
        webWorker.postMessage(workerData);
        return new Promise((resolve, reject) => {
            webWorker.onmessage = (event) => {
                let bitMapList = event.data;
                for (let i = 0; i < bitMapList.length; i++) {
                    const imgBitmap = bitMapList[i];
                    const frameId = trackData.pointList[i].get('Frame ID');
                    const currentFrame = frameId === this.parentWidget.getCurrentFrameId();
                    let offsetIndex = frameId - minFrame;
                    if (this.parentWidget.inCondensedMode) {
                        offsetIndex = i;
                    }
                    else {
                        offsetIndex = frameId - minFrame;
                    }
                    const frameX = this.horizontalPad + offsetIndex * (maxWidth + this.horizontalPad);
                    const frameY = verticalOffset;
                    const [offsetX, offsetY] = offsetArray[i];
                    this.canvasContext.beginPath();
                    this.canvasContext.rect(frameX, frameY, maxWidth, maxHeight);
                    if (currentFrame && !this.parentWidget.inExemplarMode) {
                        this.canvasContext.strokeStyle = 'MediumSeaGreen';
                        this.canvasContext.lineWidth = 8;
                    }
                    else {
                        this.canvasContext.strokeStyle = 'grey';
                        this.canvasContext.lineWidth = 1;
                    }
                    this.canvasContext.fillStyle = 'black';
                    this.canvasContext.stroke();
                    this.canvasContext.fill();
                    this.canvasContext.closePath();
                    if (imgBitmap.status === 'fulfilled') {
                        this.canvasContext.drawImage(imgBitmap.value, offsetX, offsetY);
                    }
                }
                resolve();
                this.drawOutlines(sourceDestCell);
                webWorker.terminate();
            };
        });
    }
    drawTrackBackground(trackData, maxWidth, maxHeight, minFrame, verticalOffset) {
        // draw track background
        let offsetIndex;
        if (this.parentWidget.inCondensedMode) {
            offsetIndex = 0;
        }
        else {
            offsetIndex = trackData.pointList[0].get('Frame ID') - minFrame;
        }
        const minDestX = this.horizontalPad + offsetIndex * (maxWidth + this.horizontalPad);
        if (this.parentWidget.inCondensedMode) {
            offsetIndex = this.parentWidget.condensedModeCount;
        }
        else {
            const lastIndex = trackData.pointList.length - 1;
            offsetIndex = trackData.pointList[lastIndex].get('Frame ID') - minFrame + 1;
        }
        const maxDestX = offsetIndex * (maxWidth + this.horizontalPad);
        const minDestY = verticalOffset;
        this.canvasContext.beginPath();
        const marginX = 4;
        const marginY = 4;
        this.canvasContext.rect(minDestX - marginX, minDestY - marginY, maxDestX - minDestX + 1 + 2 * marginX, maxHeight + 2 * marginY);
        this.canvasContext.strokeStyle = 'black';
        this.canvasContext.fillStyle = 'rgb(240,240,240)';
        this.canvasContext.stroke();
        this.canvasContext.fill();
        this.canvasContext.closePath();
    }
    static rectWidth(rect) {
        return rect[1][0] - rect[0][0] + 1;
    }
    static rectHeight(rect) {
        return rect[1][1] - rect[0][1] + 1;
    }
    async getCellBoundingBox(point) {
        const locId = point.get('Location ID');
        const frameId = point.get('Frame ID');
        const frameIndex = frameId - 1; // MatLab..        
        const segmentId = point.get('segmentLabel');
        const numPixelsInTile = this.parentWidget.numPixelsInTile;
        // const firstIndex = frameIndex * numPixelsInTile;
        let extent = [[Infinity, Infinity], [-Infinity, -Infinity]];
        let [rowArray, firstIndex] = await this.parentWidget.imageStackDataRequest.getLabelPromise(locId, frameIndex);
        for (let rowIdx = firstIndex; rowIdx < firstIndex + this.parentWidget.imageStackDataRequest.tileHeight; rowIdx++) {
            let row = rowArray.rowList[rowIdx];
            for (let labelRun of row.row) {
                let [top, left] = this.parentWidget.imageStackDataRequest.getTileTopLeft(frameIndex);
                let bigImgXMin = left + labelRun.start;
                let bigImgXMax = left + labelRun.start + labelRun.length;
                let bigImgY = top + (rowIdx % this.parentWidget.imageStackDataRequest.tileHeight);
                if (labelRun.label === segmentId) {
                    let [[minX, minY], [maxX, maxY]] = extent;
                    minX = Math.min(minX, bigImgXMin);
                    minY = Math.min(minY, bigImgY);
                    maxX = Math.max(maxX, bigImgXMax);
                    maxY = Math.max(maxY, bigImgY);
                    extent = [[minX, minY], [maxX, maxY]];
                }
            }
        }
        return extent;
    }
    onCellTimelineScroll(event) {
        let el = this.innerContainer.node();
        this._latestScroll = [el.scrollLeft, el.scrollTop];
        if (!this.scrollChangeTicking) {
            window.requestAnimationFrame(() => {
                this.drawLabels();
                this._scrollChangeTicking = false;
            });
            this._scrollChangeTicking = true;
        }
    }
    onCanvasClick(e) {
        if (!this.parentWidget.imageStackDataRequest) {
            return;
        }
        let xPos = e.offsetX;
        let yPos = e.offsetY;
        const cellId = ImageTrackWidget.getClosestLabel(this.cellLabelPositions, yPos);
        let curve = this.parentWidget.data.curveLookup.get(cellId);
        let frameId;
        const frameIndex = +ImageTrackWidget.getClosestLabel(this.frameLabelPositions, xPos) - 1;
        if (this.parentWidget.inCondensedMode) {
            let point = this.getPointInCondensedMode(curve, frameIndex);
            frameId = point.get('Frame ID');
        }
        else {
            frameId = frameIndex + 1;
        }
        let firstPoint = curve.pointList[0];
        const trackLocation = firstPoint.get('Location ID');
        let event = new CustomEvent('locFrameClicked', { detail: {
                locationId: trackLocation,
                frameId: frameId
            } });
        document.dispatchEvent(event);
    }
    onCanvasMouseMove(e) {
        if (!this.parentWidget.imageStackDataRequest) {
            return;
        }
        let xPos = e.offsetX;
        let yPos = e.offsetY;
        const cellId = ImageTrackWidget.getClosestLabel(this.cellLabelPositions, yPos);
        let curve = this.parentWidget.data.curveLookup.get(cellId);
        let frameId;
        const frameIndex = +ImageTrackWidget.getClosestLabel(this.frameLabelPositions, xPos) - 1;
        if (this.parentWidget.inCondensedMode) {
            let point = this.getPointInCondensedMode(curve, frameIndex);
            frameId = point.get('Frame ID');
        }
        else {
            frameId = frameIndex + 1;
        }
        this.parentWidget.selectedImgIndex;
        const displayedFrameId = this.parentWidget.getCurrentFrameId();
        let firstPoint = curve.pointList[0];
        const trackLocation = firstPoint.get('Location ID');
        const currentLocation = this.parentWidget.getCurrentLocationId();
        if (trackLocation == currentLocation) {
            let displayedPoint = curve.pointList.find(point => point.get('Frame ID') === displayedFrameId);
            this.parentWidget.imageStackDataRequest.getLabel(displayedPoint.get('Location ID'), displayedPoint.get('Frame ID') - 1, (rowArray, firstIndex) => {
                this.parentWidget.showSegmentHover(rowArray, displayedPoint.get('segmentLabel'), firstIndex, true);
            });
            this.parentWidget.brightenCanvas();
        }
        else {
            this.parentWidget.hideSegmentHover(true);
            this.parentWidget.dimCanvas();
        }
        this.updateLabelsOnMouseMove(cellId, frameIndex);
        let event = new CustomEvent('frameHoverChange', { detail: {
                locationId: trackLocation,
                frameId: frameId,
                cellId: cellId
            } });
        document.dispatchEvent(event);
    }
    onCanvasMouseLeave() {
        this.parentWidget.hideSegmentHover(true);
        this.parentWidget.dimCanvas();
        this.updateLabelsOnMouseMove('', -1);
        const locId = this.parentWidget.getCurrentLocationId();
        let event = new CustomEvent('frameHoverChange', { detail: {
                locationId: locId,
                frameId: null,
                cellId: null
            } });
        document.dispatchEvent(event);
    }
    static getClosestLabel(labelPositions, pos) {
        let compareFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(pos, labelPos => labelPos[1]);
        let indices = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(labelPositions, compareFunction);
        if (typeof indices === 'undefined') {
            console.log(pos);
            return '-1'; // todo
        }
        let labelIndex;
        if (typeof indices === 'number') {
            labelIndex = indices;
        }
        else {
            let [indexLow, indexHigh] = indices;
            if (typeof indexLow === 'undefined') {
                labelIndex = indexHigh;
            }
            else if (typeof indexHigh === 'undefined') {
                labelIndex = indexLow;
            }
            else {
                const [_labelLow, labelPosLow] = labelPositions[indexLow];
                const [_labelHeigh, labelPosHigh] = labelPositions[indexHigh];
                const distToLow = pos - labelPosLow;
                const distToHigh = labelPosHigh - pos;
                if (distToLow < distToHigh) {
                    labelIndex = indexLow;
                }
                else {
                    labelIndex = indexHigh;
                }
            }
        }
        return labelPositions[labelIndex][0];
    }
    async drawOutlines(sourceDestCell) {
        if (!sourceDestCell) {
            sourceDestCell = this.sourceDestCell;
        }
        for (let [sourceRect, [dX, dY], point] of sourceDestCell) {
            let width = ImageTrackWidget.rectWidth(sourceRect);
            let height = ImageTrackWidget.rectHeight(sourceRect);
            let [[sLeft, sTop], [sRight, sBot]] = sourceRect;
            let outlineTileData = this.canvasContext.getImageData(dX, dY, width, height);
            let labelToMatch = point.get('segmentLabel');
            let frameIndex = point.get('Frame ID') - 1;
            let rIdx = 0;
            let [labelArray, firstIndex] = await this.parentWidget.imageStackDataRequest.getLabelPromise(point.get('Location ID'), frameIndex);
            for (let y = sTop; y <= sBot; y++) {
                for (let x = sLeft; x <= sRight; x++) {
                    let [rowIdx, colIdx] = this.parentWidget.getLabelIndexFromBigImgPixelXY(frameIndex, x, y);
                    let label = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rowIdx, colIdx, labelArray);
                    if (label == labelToMatch) {
                        if (this.parentWidget.isBorder(label, rowIdx, colIdx, labelArray)) {
                            let [r, g, b] = this.parentWidget.getCellColor(point);
                            outlineTileData.data[rIdx] = r;
                            outlineTileData.data[rIdx + 1] = g;
                            outlineTileData.data[rIdx + 2] = b;
                            outlineTileData.data[rIdx + 3] = 255;
                        }
                    }
                    rIdx += 4;
                }
            }
            this.canvasContext.putImageData(outlineTileData, dX, dY);
        }
    }
    drawLabels() {
        // cell labels
        let pad = 10;
        const xAnchor = this.cellTimelineMargin.left - pad;
        let labelsInView = this.cellLabelPositions.filter((labelPos) => {
            const pos = labelPos[1] - this.latestScroll[1];
            return 0 <= pos && pos <= this.innerContainerH;
        });
        this.cellLabelGroup.selectAll('text')
            .data(labelsInView)
            .join('text')
            .text(d => d[0])
            .attr('x', xAnchor)
            .attr('y', d => d[1] - this.latestScroll[1])
            .classed('cellAxisLabel', true)
            .classed('left', true);
        // frame labels
        pad = 6;
        const yAnchor = this.cellTimelineMargin.top - pad;
        labelsInView = this.frameLabelPositions.filter((labelPos) => {
            const pos = labelPos[1] - this.latestScroll[0];
            return 0 <= pos && pos <= this.innerContainerW;
        });
        if (this.parentWidget.inCondensedMode) {
            labelsInView = labelsInView.map((labelPos) => {
                let index = +labelPos[0] - 1;
                let percent = index / (this.parentWidget.condensedModeCount - 1);
                return [percent.toFixed(2), labelPos[1]];
            });
        }
        const currentFrame = this.parentWidget.getCurrentFrameId();
        this.frameLabelGroup.selectAll('text')
            .data(labelsInView)
            .join('text')
            .text(d => d[0])
            .attr('x', d => d[1] - this.latestScroll[0])
            .attr('y', yAnchor)
            .classed('currentFrame', d => +d[0] === currentFrame && !this.parentWidget.inExemplarMode)
            .classed('cellAxisLabel', true)
            .classed('right', true);
    }
    updateLabelsOnMouseMove(cellId, frameIndex) {
        let svgSelection = this.cellLabelGroup.selectAll('text');
        let foundMatch = this.hoverNodeWithText(svgSelection.nodes(), cellId);
        svgSelection = this.frameLabelGroup.selectAll('text');
        if (!foundMatch) {
            this.hoverNodeWithText(svgSelection.nodes(), '');
            return;
        }
        let frameText;
        if (this.parentWidget.inCondensedMode) {
            let percent = frameIndex / (this.parentWidget.condensedModeCount - 1);
            frameText = percent.toFixed(2);
        }
        else {
            frameText = (frameIndex + 1).toString();
        }
        this.hoverNodeWithText(svgSelection.nodes(), frameText);
    }
    hoverNodeWithText(svgElementList, text) {
        let fountMatch = false;
        for (let node of svgElementList) {
            let nodeEl = node;
            if (nodeEl.textContent === text) {
                nodeEl.classList.add('hovered');
                fountMatch = true;
            }
            else {
                nodeEl.classList.remove('hovered');
            }
        }
        return fountMatch;
    }
    OnResize(width, height) {
        height -= 30; // hacky, but see .cellTimelineInnerContainer.top for explanation
        this.svgContainer
            .attr('height', height - 30)
            .attr('width', width);
        const innerW = width - this.cellTimelineMargin.left - this.cellTimelineMargin.right;
        this._innerContainerW = innerW;
        const innerH = height - this.cellTimelineMargin.top - this.cellTimelineMargin.bottom;
        this._innerContainerH = innerH;
        this.innerContainer
            .attr('style', `max-width: ${innerW}px;
            max-height: ${innerH}px;
            width: ${innerW}px;
            height: ${innerH}px;`);
    }
}
exports.ImageTrackWidget = ImageTrackWidget;

},{"../DataModel/ImageStackDataRequest":107,"../devlib/DevlibAlgo":111,"../devlib/DevlibMath":112,"../devlib/DevlibTSUtil":113,"d3":42}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const BaseWidget_1 = require("./BaseWidget");
const LayoutFramework_1 = require("../LayoutFramework");
const HistogramWidget_1 = require("./HistogramWidget");
const ScatterPlotWidget_1 = require("./ScatterPlotWidget");
const types_1 = require("../types");
class MetricDistributionWidget extends BaseWidget_1.BaseWidget {
    constructor(container, metricDistributionCollectionLevel) {
        super(container);
        this._metricDistributionCollectionLevel = metricDistributionCollectionLevel;
    }
    Clone(container) {
        return new MetricDistributionWidget(container, this.metricDistributionCollectionLevel);
    }
    get wrapperContainer() {
        return this._wrapperContainer;
    }
    get layoutFramework() {
        return this._layoutFramework;
    }
    get subComponentLookup() {
        return this._subComponentLookup;
    }
    get basisSelectContainerSelection() {
        return this._basisSelectContainerSelection;
    }
    get scatterPlotSelectContainerSelection() {
        return this._scatterPlotSelectContainerSelection;
    }
    get yAxisMatrixSelect() {
        return this._yAxisMatrixSelect;
    }
    get xAxisMatrixSelect() {
        return this._xAxisMatrixSelect;
    }
    get distributionPlotContainerSelection() {
        return this._distributionPlotContainerSelection;
    }
    get scatterPlotContainerSelection() {
        return this._scatterPlotContainerSelection;
    }
    get collapseButtonSelect() {
        return this._collapseButtonSelect;
    }
    get expandButtonSelect() {
        return this._expandButtonSelect;
    }
    get attributeToIndex() {
        return this._attributeToIndex;
    }
    get basisSelectionBooleans() {
        return this._basisSelectionBooleans;
    }
    get scatterplotSelectionBooleans() {
        return this._scatterplotSelectionBooleans;
    }
    get histogramWidgets() {
        return this._histogramWidgets;
    }
    get scatterPlotWidgets() {
        return this._scatterPlotWidgets;
    }
    get pointCollection() {
        return this._pointCollection;
    }
    get metricDistributionCollectionLevel() {
        return this._metricDistributionCollectionLevel;
    }
    get includeExemplarTrackButton() {
        return this._includeExemplarTrackButton;
    }
    init() {
        this._wrapperContainer = document.createElement("div");
        this.wrapperContainer.classList.add("frame", "dir-row", "wrapperContainer");
        this.container.appendChild(this.wrapperContainer);
        this._layoutFramework = new LayoutFramework_1.LayoutFramework(this.wrapperContainer, false);
        let layout = {
            direction: types_1.Direction.row,
            inside: [
                {
                    direction: types_1.Direction.column,
                    minSize: 80,
                    maxSize: 80,
                    inside: types_1.MetricDistributionSubComponentTypes.BasisSelect
                },
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.ScatterplotSelect
                },
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.DistributionPlot
                },
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.Scatterplot
                }
            ]
        };
        this._subComponentLookup = this.layoutFramework.InitializeLayout(layout);
        this.initSubComponents();
    }
    initSubComponents() {
        for (let [container, subComponent] of this.subComponentLookup) {
            switch (subComponent) {
                case types_1.MetricDistributionSubComponentTypes.BasisSelect:
                    this._basisSelectContainerSelection = this.initSubComponent(container, "toggleButtonContainer");
                    break;
                case types_1.MetricDistributionSubComponentTypes.ScatterplotSelect:
                    let wrapper = d3.select(container).append('div')
                        .classed("matrixWrapperContainer", true)
                        .attr("id", "matrixWrapperContainer");
                    this._yAxisMatrixSelect = this.initSubComponent(wrapper.node(), "yAxisMatrixContainer");
                    let rightWrapper = wrapper.append('div')
                        .classed("matrixRightWrapperContainer", true);
                    this._scatterPlotSelectContainerSelection = this.initSubComponent(rightWrapper.node(), "matrixContainer");
                    this._xAxisMatrixSelect = this.initSubComponent(rightWrapper.node(), "xAxisMatrixContainer");
                    let collapseExpandList = [
                        this.basisSelectContainerSelection.node().parentElement,
                        wrapper.node().parentElement
                    ];
                    this.hideElements(collapseExpandList); // collapsed by default
                    this.initCollapseButton(rightWrapper, collapseExpandList);
                    this.initExpandButton(collapseExpandList);
                    break;
                case types_1.MetricDistributionSubComponentTypes.DistributionPlot:
                    this._distributionPlotContainerSelection = this.initSubComponent(container, "distributionPlotContainer");
                    break;
                case types_1.MetricDistributionSubComponentTypes.Scatterplot:
                    this._scatterPlotContainerSelection = this.initSubComponent(container, "scatterPlotOuterContainer");
                    break;
                default:
                    break;
            }
        }
        this.resizeSubComponents();
    }
    initSubComponent(container, className) {
        return d3.select(container)
            .append("div")
            .classed(className, true)
            .classed("overflow-scroll", true)
            .attr("id", className);
    }
    initCollapseButton(containerSelect, toHide) {
        this._collapseButtonSelect =
            containerSelect.append('div')
                .classed('collapseContainer', true)
                .append('button')
                .classed('collapseButton', true)
                .classed('devlibButton', true)
                .attr("id", "MetricDistributionWidget-collapseButton")
                .text('Collapse')
                .on('click', () => {
                this.hideElements(toHide);
                this.expandButtonSelect.classed('noDisp', false);
            })
                .on('mouseenter', () => {
                for (let element of toHide) {
                    element.classList.add("hoveredArea");
                }
            })
                .on('mouseleave', () => {
                for (let element of toHide) {
                    element.classList.remove("hoveredArea");
                }
            });
    }
    hideElements(toHide) {
        for (let element of toHide) {
            element.classList.add("noDisp");
        }
    }
    initExpandButton(toShow) {
        this._expandButtonSelect = d3.select(this.container).append("button")
            .classed('expandButton', true)
            .classed('devlibButton', true)
            .classed('noDisp', true)
            .attr('id', 'MetricDistributionWidget-expandButton')
            .attr("title", "Open distribution selection widget.")
            .on('click', () => {
            this.expandButtonSelect.classed('noDisp', true);
            for (let element of toShow) {
                element.classList.remove('noDisp');
            }
        });
        let icon = DevlibTSUtil_1.DevlibTSUtil.getFontAwesomeIcon('th');
        this.expandButtonSelect.node().appendChild(icon);
    }
    OnDataChange() {
        switch (this.metricDistributionCollectionLevel) {
            case types_1.MetricDistributionCollectionLevel.Point:
                this._pointCollection = this.data;
                this._includeExemplarTrackButton = false;
                break;
            case types_1.MetricDistributionCollectionLevel.Curve:
                this._pointCollection = this.data.curveCollection;
                this._includeExemplarTrackButton = true;
                break;
            default:
                this._pointCollection = null;
                this._includeExemplarTrackButton = false;
                throw new Error('MetricDistributionCollectionLevel not set.');
                break;
        }
        this._attributeToIndex = new Map();
        for (let [index, attr] of this.pointCollection.attributeList.entries()) {
            this.attributeToIndex.set(attr, index);
        }
        this.updateUIData();
        this.drawBasisSelect();
        this.drawScatterPlotSelectContainerSelection();
        this.drawMatrixAxis();
        this.expandButtonSelect.classed('noDisp', false);
        this.drawHistograms();
        this.drawScatterPlots(this.getScatterOptionsMatrix());
    }
    OnBrushChange() {
        for (let hist of this.histogramWidgets) {
            hist.OnBrushChange();
        }
        for (let scatter of this.scatterPlotWidgets) {
            scatter.OnBrushChange();
        }
    }
    updateUIData() {
        this._basisSelectionBooleans = [];
        // Todo - it would be nice if this was configurable.
        const defaultIncluded = new Set(['Mass (pg)', 'Time (h)', 'Mass_norm', 'Track Length', 'Avg Mass', 'Growth Rate', 'Exponential Growth Constant']);
        const maxDefaultMatrixSize = 15;
        this._scatterplotSelectionBooleans = [];
        for (let [rowIndex, attr1] of this.pointCollection.attributeList.entries()) {
            this.basisSelectionBooleans.push(rowIndex < maxDefaultMatrixSize && defaultIncluded.has(attr1));
            let row = [];
            for (let [colIndex, attr2] of this.pointCollection.attributeList.entries()) {
                row.push({
                    value: attr1 === attr2,
                    index: [rowIndex, colIndex]
                });
            }
            this.scatterplotSelectionBooleans.push(row);
        }
        this.drawBasisSelect();
    }
    drawBasisSelect() {
        let thisWidget = this;
        let flatData = this.getScatterOptionsMatrix();
        this.basisSelectContainerSelection
            .selectAll("button")
            .data(this.pointCollection.attributeList)
            .join("button")
            .text(d => d)
            .attr('title', d => d)
            .classed("toggleButton", true)
            .classed("on", (d, i) => this.basisSelectionBooleans[i])
            .attr("id", d => "MetricDistributionWidget-varSelect-" + d)
            .on('click', function (d, i) {
            let buttonSelect = d3.select(this);
            let turnOn = !thisWidget.basisSelectionBooleans[i];
            buttonSelect.classed("on", turnOn);
            thisWidget.basisSelectionBooleans[i] = turnOn;
            thisWidget.drawScatterPlotSelectContainerSelection();
            thisWidget.drawMatrixAxis();
            thisWidget.updateHistograms();
            thisWidget.updateScatterPlots(flatData);
        });
    }
    drawMatrixAxis() {
        const buttonWidth = 80;
        const buttonHeight = 18;
        let options = this.getCurrentOptions();
        this.yAxisMatrixSelect.selectAll("button")
            .data(options)
            .join("button")
            .classed('axisButton', true)
            .classed('y', true)
            .attr("style", (d, i) => `
				width: ${buttonWidth}px;
				height: ${buttonHeight}px;`)
            .text(d => d)
            .attr('title', d => d)
            .on("click", (d) => {
            let rowIndex = this.attributeToIndex.get(d);
            let row = this.scatterplotSelectionBooleans[rowIndex];
            let allTrue = true;
            for (let cell of row) {
                if (this.basisSelectionBooleans[cell.index[1]]) {
                    if (!cell.value) {
                        allTrue = false;
                    }
                    cell.value = true;
                }
            }
            if (allTrue) {
                for (let cell of row) {
                    if (this.basisSelectionBooleans[cell.index[1]]) {
                        cell.value = false;
                    }
                }
            }
            this.afterMultipleMatrixChanges();
        })
            .on("mouseenter", function (d) {
            d3.select(this).classed("hovered", true);
        })
            .on("mouseleave", function (d) {
            d3.select(this).classed("hovered", false);
        });
        const halfWidth = buttonWidth / 2;
        const rotate = -90;
        const theta = Math.PI * rotate / 180;
        const xOffset = -0.5 * (buttonWidth + buttonWidth * Math.cos(-theta) + buttonHeight * Math.sin(-theta));
        const yOffset = 0.5 * (buttonWidth * Math.sin(-theta) + buttonHeight * Math.cos(-theta) - buttonHeight);
        let theta2 = 90 + rotate;
        theta2 = Math.PI * theta2 / 180;
        const horizontalPadding = 2;
        let stepSize = horizontalPadding + buttonHeight / Math.cos(theta2);
        this.xAxisMatrixSelect.selectAll("button")
            .data(options)
            .join("button")
            .classed('axisButton', true)
            .classed('x', true)
            .attr("style", (d, i) => `
				width: ${buttonWidth}px;
				height: ${buttonHeight}px;
				transform: translate( ${stepSize * (i + 1) + xOffset}px, ${yOffset}px) rotate(${rotate}deg);`)
            .text(d => d)
            .attr('title', d => d)
            .on("click", (d) => {
            let colIndex = this.attributeToIndex.get(d);
            let allTrue = true;
            for (let row of this.scatterplotSelectionBooleans) {
                for (let cell of row) {
                    let cellRowIndex = cell.index[0];
                    let cellColIndex = cell.index[1];
                    if (colIndex === cellColIndex && this.basisSelectionBooleans[cellRowIndex]) {
                        if (!cell.value) {
                            allTrue = false;
                        }
                        cell.value = true;
                    }
                }
            }
            if (allTrue) {
                for (let row of this.scatterplotSelectionBooleans) {
                    for (let cell of row) {
                        let cellRowIndex = cell.index[0];
                        let cellColIndex = cell.index[1];
                        if (colIndex === cellColIndex && this.basisSelectionBooleans[cellRowIndex]) {
                            cell.value = false;
                        }
                    }
                }
            }
            this.afterMultipleMatrixChanges();
        })
            .on("mouseenter", function (d) {
            d3.select(this).classed("hovered", true);
        })
            .on("mouseleave", function (d) {
            d3.select(this).classed("hovered", false);
        });
    }
    getCurrentOptions() {
        return this.pointCollection.attributeList.filter((d, i) => this.basisSelectionBooleans[i]);
    }
    afterMultipleMatrixChanges() {
        this.updateMatrixCellSelections();
        let flatData = this.getScatterOptionsMatrix();
        this.updateHistograms();
        this.updateScatterPlots(flatData);
    }
    updateMatrixCellSelections() {
        this.scatterPlotSelectContainerSelection
            .selectAll("div")
            .data(this.scatterplotSelectionBooleans)
            .join("div")
            .selectAll("button")
            .data(d => d)
            .join("button")
            .classed("on", d => d.value);
    }
    drawScatterPlotSelectContainerSelection() {
        let thisWidget = this;
        let flatData = this.getScatterOptionsMatrix();
        this.scatterPlotSelectContainerSelection
            .selectAll("div")
            .data(this.scatterplotSelectionBooleans)
            .join("div")
            .classed("rowContainer", true)
            .classed("noDisp", (d, i) => !thisWidget.basisSelectionBooleans[i])
            .selectAll("button")
            .data(d => d)
            .join("button")
            .classed("squareButton", true)
            .classed("on", d => d.value)
            .classed("noDisp", (d, i) => !thisWidget.basisSelectionBooleans[i])
            .attr("id", d => "MetricDistributionWidget-scatterSelect-" + d.index[0] + "-" + d.index[1])
            .on("click", function (d, i) {
            let buttonSelect = d3.select(this);
            let turnOn = !d.value;
            buttonSelect.classed("on", turnOn);
            thisWidget.scatterplotSelectionBooleans[d.index[0]][i].value = turnOn;
            if (i === d.index[0]) {
                thisWidget.updateHistograms();
            }
            else {
                thisWidget.updateScatterPlots(flatData);
            }
        })
            .on("mouseenter", function (d) {
            let [rowIdx, colIdx] = d.index;
            let buttonSelect = d3.select(this);
            buttonSelect.classed("hovered", true);
            let options = thisWidget.getCurrentOptions();
            let rowName = thisWidget.pointCollection.attributeList[rowIdx];
            let colName = thisWidget.pointCollection.attributeList[colIdx];
            thisWidget.yAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", d => d === rowName);
            thisWidget.xAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", d => d === colName);
        })
            .on("mouseleave", function (d) {
            let buttonSelect = d3.select(this);
            buttonSelect.classed("hovered", false);
            let options = thisWidget.getCurrentOptions();
            thisWidget.yAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", false);
            thisWidget.xAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", false);
        });
    }
    drawHistograms() {
        let thisWidget = this;
        this._histogramWidgets = [];
        let parentElement = this.distributionPlotContainerSelection.node().parentElement;
        parentElement.classList.remove("noDisp");
        this.distributionPlotContainerSelection.html(null)
            .classed("noDisp", false)
            .selectAll("div")
            .data(this.pointCollection.attributeList)
            .join("div")
            .classed("histogramContainer", true)
            .attr("id", d => "MetricDistributionWidget-histogramContainer-" + d)
            .each(function (d) {
            let container = this;
            const canBrush = true;
            let newWidget = new HistogramWidget_1.HistogramWidget(container, d, canBrush, thisWidget.includeExemplarTrackButton);
            thisWidget.histogramWidgets.push(newWidget);
        });
        this.updateHistograms();
    }
    updateHistograms() {
        let thisWidget = this;
        let allHidden = true;
        this.distributionPlotContainerSelection
            .selectAll(".histogramContainer")
            .data(this.pointCollection.attributeList)
            .classed("noDisp", (d, i) => {
            let shouldHide = this.shouldHide(i);
            if (!shouldHide) {
                allHidden = false;
            }
            return shouldHide;
        })
            .each(function (d, i) {
            let container = this;
            let histogramWidget = thisWidget.histogramWidgets[i];
            if (!thisWidget.shouldHide(i) && !histogramWidget.data) {
                histogramWidget.SetData(thisWidget.pointCollection);
            }
        });
        let parentElement = this.distributionPlotContainerSelection.node().parentElement;
        if (allHidden) {
            parentElement.classList.add("noDisp");
        }
        else {
            parentElement.classList.remove("noDisp");
        }
    }
    getScatterOptionsMatrix() {
        let flatData = this.scatterplotSelectionBooleans.flat();
        flatData = flatData.filter(d => d.index[0] !== d.index[1]);
        return flatData;
    }
    drawScatterPlots(flatData) {
        this._scatterPlotWidgets = [];
        let thisWidget = this;
        let parentElement = this.scatterPlotContainerSelection.node().parentElement;
        parentElement.classList.remove("noDisp");
        this.scatterPlotContainerSelection.html(null)
            .selectAll("div")
            .data(flatData)
            .join("div")
            .classed("scatterPlotContainer", true)
            .each(function (d) {
            let container = this;
            let xKey = thisWidget.pointCollection.attributeList[d.index[1]];
            let yKey = thisWidget.pointCollection.attributeList[d.index[0]];
            let newWidget = new ScatterPlotWidget_1.ScatterPlotWidget(container, xKey, yKey);
            thisWidget.scatterPlotWidgets.push(newWidget);
        });
        this.updateScatterPlots(flatData);
    }
    updateScatterPlots(flatData) {
        let thisWidget = this;
        let allHidden = true;
        this.scatterPlotContainerSelection
            .selectAll(".scatterPlotContainer")
            .data(flatData)
            .classed("noDisp", (d) => {
            let shouldHide = this.shouldHide(d);
            if (!shouldHide) {
                allHidden = false;
            }
            return shouldHide;
        })
            .each(function (d, i) {
            let scatterWidget = thisWidget.scatterPlotWidgets[i];
            if (!thisWidget.shouldHide(d) && !scatterWidget.data) {
                scatterWidget.SetData(thisWidget.pointCollection);
            }
        });
        let parentElement = this.scatterPlotContainerSelection.node().parentElement;
        if (allHidden) {
            parentElement.classList.add("noDisp");
        }
        else {
            parentElement.classList.remove("noDisp");
        }
    }
    shouldHide(d) {
        if (typeof d === "number") {
            if (!this.basisSelectionBooleans[d]) {
                return true;
            }
            return !this.scatterplotSelectionBooleans[d][d].value;
        }
        if (!this.basisSelectionBooleans[d.index[0]] || !this.basisSelectionBooleans[d.index[1]]) {
            return true;
        }
        return !d.value;
    }
    OnResize() {
        this.resizeSubComponents();
    }
    resizeSubComponents() {
        this.basisSelectContainerSelection.node().style.maxHeight = this.height + "px";
        this.scatterPlotSelectContainerSelection.node().style.maxHeight = this.height + "px";
        this.distributionPlotContainerSelection.node().style.maxHeight = this.height + "px";
        this.scatterPlotContainerSelection.node().style.maxHeight = this.height + "px";
    }
}
exports.MetricDistributionWidget = MetricDistributionWidget;

},{"../LayoutFramework":110,"../devlib/DevlibTSUtil":113,"../types":115,"./BaseWidget":81,"./HistogramWidget":84,"./ScatterPlotWidget":92,"d3":42}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
var OptionMode;
(function (OptionMode) {
    OptionMode[OptionMode["ButtonList"] = 0] = "ButtonList";
    OptionMode[OptionMode["Dropdown"] = 1] = "Dropdown";
})(OptionMode || (OptionMode = {}));
class OptionSelect {
    constructor(htmlContainerId, label, defaultSelectionIndex) {
        this._containerSelect = d3.select("#" + htmlContainerId);
        this._label = label;
        this._uniqueId = 'OptionSelectDropdown_' + OptionSelect._instanceCount++;
        this._currentSelectionIndex = null;
        if (typeof defaultSelectionIndex !== 'undefined') {
            this._currentSelectionIndex = defaultSelectionIndex;
        }
    }
    get data() {
        return this._data;
    }
    get containerSelect() {
        return this._containerSelect;
    }
    get label() {
        return this._label;
    }
    get mode() {
        return this._mode;
    }
    get uniqueId() {
        return this._uniqueId;
    }
    get currentSelectionIndex() {
        return this._currentSelectionIndex;
    }
    clearSelectedButton() {
        this.containerSelect.selectAll(".on")
            .classed("on", false);
    }
    onDataChange(data, defaultSelection) {
        this._data = data;
        console.log(data);
        this.containerSelect.html(null);
        if (this.data.length === 1) {
            if (this.label) {
                this.containerSelect
                    .append('span')
                    .classed('optionSelectLabel', true)
                    .text(this.label);
            }
            this.containerSelect
                .append("span")
                .classed("valueHeader", true)
                .text(this.data[0].displayName);
            return;
        }
        this.updateButtons(defaultSelection);
    }
    updateButtons(defaultSelection) {
        if (typeof defaultSelection !== 'undefined') {
            this._currentSelectionIndex = defaultSelection;
        }
        if (this.data.length < 4) {
            this.drawQuickSelectButtons(this.currentSelectionIndex);
        }
        else {
            this.drawDropDownButtons(this.currentSelectionIndex);
        }
    }
    drawQuickSelectButtons(defaultSelection) {
        this._mode = OptionMode.ButtonList;
        let thisOptionSelect = this;
        this.containerSelect.html(null);
        if (this.label) {
            this.containerSelect
                .append('span')
                .classed('optionSelectLabel', true)
                .text(this.label);
        }
        this.containerSelect
            .selectAll("button")
            .data(this.data)
            .join("button")
            .text(d => d.displayName)
            .classed("toggleButton", true)
            .classed("on", (d, i) => defaultSelection === i)
            .on("click", function (buttonProps, index) {
            if (this.classList.contains("on")) {
                return;
            }
            thisOptionSelect._currentSelectionIndex = index;
            thisOptionSelect.clearSelectedButton();
            d3.select(this).classed("on", true);
            buttonProps.callback();
        });
    }
    drawDropDownButtons(defaultSelection) {
        this._mode = OptionMode.Dropdown;
        let thisOptionSelect = this;
        this.containerSelect.html(null);
        if (this.label) {
            this.containerSelect.append('label')
                .text(this.label)
                .classed('optionSelectLabel', true)
                .attr('for', this.uniqueId);
        }
        this.containerSelect
            .append('select')
            .attr('id', this.uniqueId)
            .classed('optionSelectSelect', true)
            .on('change', () => {
            let optionSelect = this.containerSelect.select('#' + this.uniqueId);
            let newIndex = +optionSelect.property('value');
            this.data[newIndex].callback();
            thisOptionSelect._currentSelectionIndex = newIndex;
        })
            .selectAll('option')
            .data(this.data)
            .join('option')
            .attr('value', (d, i) => i)
            .property('selected', (d, i) => defaultSelection === i)
            .text(d => d.displayName);
    }
    addButton(buttonProps, selectIndex) {
        this.data.push(buttonProps);
        this.updateButtons(selectIndex);
    }
    removeButton(displayName, callDefaultCallback = true) {
        if (!this.data) {
            return;
        }
        let removeIndex = this.data.findIndex((button) => button.displayName === displayName);
        if (removeIndex === -1) {
            return;
        }
        this.data.splice(removeIndex);
        let selectionIndex;
        if (callDefaultCallback && this.currentSelectionIndex === removeIndex) {
            selectionIndex = 0;
            this.data[0].callback();
        }
        else {
            selectionIndex = this.currentSelectionIndex;
        }
        this.updateButtons(selectionIndex);
        return;
    }
    replaceButton(oldButtonName, newButtonProps) {
        this.removeButton(oldButtonName, false);
        this.addButton(newButtonProps, this.currentSelectionIndex);
        if (this.currentSelectionIndex === this.data.length - 1) {
            this.data[this.currentSelectionIndex].callback();
        }
    }
}
exports.OptionSelect = OptionSelect;
OptionSelect._instanceCount = 0;

},{"d3":42}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const OptionSelect_1 = require("./OptionSelect");
class Plot2dPathsWidget extends BaseWidget_1.BaseWidget {
    constructor(container, quickPickOptions, initialQuickPickOptionIndex = 0, squareAspectRatio = true, canBrush = true) {
        super(container, true, quickPickOptions, initialQuickPickOptionIndex, canBrush);
        this._squareAspectRatio = squareAspectRatio;
        this.addLabel();
    }
    Clone(container) {
        const canBrush = false;
        return new Plot2dPathsWidget(container, this.quickPickOptions, this.quickPickOptionSelect.currentSelectionIndex, this.squareAspectRatio, canBrush);
    }
    initProps(props) {
        super.initProps();
        this._quickPickOptions = props[0];
        this._initialQuickPickOptionIndex = props[1];
        this._canBrush = props[2];
        this._xKey = this.quickPickOptions[this.initialQuickPickOptionIndex].xKey;
        this._yKey = this.quickPickOptions[this.initialQuickPickOptionIndex].yKey;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get canvasContainer() {
        return this._canvasContainer;
    }
    get canvasElement() {
        return this._canvasElement;
    }
    get canBrush() {
        return this._canBrush;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get xAxisGroupSelect() {
        return this._xAxisGroupSelect;
    }
    get xLabelTextSelect() {
        return this._xLabelTextSelect;
    }
    get yAxisGroupSelect() {
        return this._yAxisGroupSelect;
    }
    get yLabelTextSelect() {
        return this._yLabelTextSelect;
    }
    get quickPickContainerSelect() {
        return this._quickPickContainerSelect;
    }
    set quickPickContainerSelect(v) {
        this._quickPickContainerSelect = v;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleY() {
        return this._scaleY;
    }
    get xKey() {
        return this._xKey;
    }
    get yKey() {
        return this._yKey;
    }
    get quickPickOptions() {
        return this._quickPickOptions;
    }
    get initialQuickPickOptionIndex() {
        return this._initialQuickPickOptionIndex;
    }
    get quickPickOptionSelect() {
        return this._quickPickOptionSelect;
    }
    get squareAspectRatio() {
        return this._squareAspectRatio;
    }
    get brush() {
        return this._brush;
    }
    get lastXValueBrushBound() {
        return this._lastXValueBrushBound;
    }
    get lastYValueBrushBound() {
        return this._lastYValueBrushBound;
    }
    setMargin() {
        this._margin = {
            top: 20,
            right: 8,
            bottom: 42,
            left: 64
        };
    }
    init() {
        const containerSelect = d3.select(this.container);
        containerSelect
            .on('mouseenter', () => {
            if (this.data) {
                this.showQuickPickContainer();
            }
        })
            .on('mouseleave', () => {
            this.hideQuickPickContainer();
        });
        this._svgSelect = containerSelect.append("svg");
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._canvasContainer = this.mainGroupSelect
            .append('foreignObject')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight);
        this._canvasElement = this.canvasContainer.append('xhtml:canvas')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight)
            .node();
        if (this.canBrush) {
            this._brushGroupSelect = this.svgSelect.append("g")
                .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
                .classed("brushContainer", true);
            this.initBrush();
        }
        // this.svgSelect.attr("style", 'width: 100%; height: 100%;');
        this.svgSelect.attr('width', this.width);
        this.svgSelect.attr('height', this.height);
        this._xAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight})`)
            .classed("labelColor", true);
        this._yAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed("labelColor", true);
        this.initQuickPickOptions();
    }
    initQuickPickOptions() {
        const containerId = this.ComponentId + '-quickPickContainer';
        this._quickPickContainerSelect = d3.select(this.container).append('div')
            .classed('quickPickContainer', true)
            .attr('id', containerId);
        this._quickPickOptionSelect = new OptionSelect_1.OptionSelect(containerId, "Option");
        let buttonPropList = [];
        for (let quickPickOption of this.quickPickOptions) {
            let buttonProp = {
                displayName: quickPickOption.yKey + " v. " + quickPickOption.xKey,
                callback: () => this.changeAxes(quickPickOption.xKey, quickPickOption.yKey, quickPickOption.squareAspectRatio)
            };
            buttonPropList.push(buttonProp);
        }
        this.hideQuickPickContainer();
        this.quickPickOptionSelect.onDataChange(buttonPropList, this.initialQuickPickOptionIndex);
    }
    initBrush() {
        this._brush = d3.brush()
            .extent([[0, 0], [this.vizWidth, this.vizHeight]])
            .on("end", () => { this.brushHandler(); });
        this.brushGroupSelect.call(this.brush);
    }
    addLabel() {
        this._xLabelTextSelect = this.svgSelect.append('text')
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .classed('noDisp', true);
        this._yLabelTextSelect = this.svgSelect.append('text')
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .classed('noDisp', true);
        this.positionLabels();
    }
    positionLabels() {
        // X-Axis
        let bufferForAxis = 32;
        this.xLabelTextSelect
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`);
        bufferForAxis = 40;
        // Y-Axis
        let transX = this.margin.left - bufferForAxis;
        let transY = this.margin.top + this.vizHeight / 2;
        let transformText;
        transformText = `rotate(-90) translate(${-transY}, ${transX})`;
        this.yLabelTextSelect.attr('transform', transformText);
    }
    showQuickPickContainer() {
        this.quickPickContainerSelect.classed('noDisp', false);
    }
    hideQuickPickContainer() {
        this.quickPickContainerSelect.classed('noDisp', true);
    }
    OnDataChange() {
        this.updateScales();
        this.updatePaths();
        this.drawAxis();
        this.showLabel();
    }
    changeAxes(xKey, yKey, squareAspectRatio) {
        this._xKey = xKey;
        this._yKey = yKey;
        this._squareAspectRatio = squareAspectRatio;
        this.removeBrush();
        this.OnDataChange();
    }
    removeBrush() {
        this.brushGroupSelect.call(this.brush.move, null);
    }
    updateScales() {
        let [minX, maxX] = this.fullData.minMaxMap.get(this.xKey);
        let [minY, maxY] = this.fullData.minMaxMap.get(this.yKey);
        if (this.squareAspectRatio) {
            this.makeSquareAspectRatioScales(minX, maxX, minY, maxY);
        }
        else {
            this.makeStretchedAspectRatioScales(minX, maxX, minY, maxY);
        }
    }
    makeSquareAspectRatioScales(minX, maxX, minY, maxY) {
        // this code keeps the data aspect ratio square and keeps it centered and as large
        // as possible in it's container
        let containerRatio = this.vizHeight / this.vizWidth;
        let dataRatio = (maxY - minY) / (maxX - minX);
        if (containerRatio > dataRatio) {
            this._scaleX = d3.scaleLinear()
                .domain([minX, maxX])
                .range([0, this.vizWidth]);
            let [scaledMinY, scaledMaxY] = [this.scaleX(minY), this.scaleX(maxY)];
            let dataLength = scaledMaxY - scaledMinY;
            let offset = (this.vizHeight - dataLength) / 2.0 - scaledMinY;
            this._scaleY = d3.scaleLinear()
                .domain([minY, maxY])
                .range([scaledMaxY + offset, scaledMinY + offset]);
        }
        else {
            this._scaleY = d3.scaleLinear()
                .domain([minY, maxY])
                .range([this.vizHeight, 0]);
            let [scaledMinX, scaledMaxX] = [this.scaleY(minX), this.scaleY(maxX)];
            let dataLength = scaledMaxX - scaledMinX;
            let offset = (this.vizWidth - dataLength) / 2.0 - scaledMinX;
            this._scaleX = d3.scaleLinear()
                .domain([minX, maxX])
                .range([scaledMaxX + offset, scaledMinX + offset]);
        }
    }
    makeStretchedAspectRatioScales(minX, maxX, minY, maxY) {
        this._scaleX = d3.scaleLinear()
            .domain([minX, maxX])
            .range([0, this.vizWidth]);
        this._scaleY = d3.scaleLinear()
            .domain([minY, maxY])
            .range([this.vizHeight, 0]);
    }
    updatePaths() {
        let line = d3.line()
            .x((d, i) => { return this.scaleX(d.get(this.xKey)); })
            .y((d) => { return this.scaleY(d.get(this.yKey)); })
            .defined(d => d.inBrush);
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight);
        canvasContext.strokeStyle = 'black';
        canvasContext.lineWidth = 1;
        canvasContext.globalAlpha = 0.25;
        canvasContext.lineJoin = 'round';
        for (let curve of this.data.curveList) {
            const path = new Path2D(line(curve.pointList));
            canvasContext.stroke(path);
        }
    }
    drawAxis() {
        this.xAxisGroupSelect
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight})`)
            .call(d3.axisBottom(this.scaleX).ticks(5));
        this.yAxisGroupSelect
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .call(d3.axisLeft(this.scaleY).ticks(5));
    }
    showLabel() {
        this.xLabelTextSelect
            .text(this.xKey)
            .classed('noDisp', false);
        this.yLabelTextSelect
            .text(this.yKey)
            .classed('noDisp', false);
    }
    OnResize() {
        if (this.data) {
            this.svgSelect.attr('width', this.width);
            this.svgSelect.attr('height', this.height);
            this.canvasContainer
                .attr('width', this.vizWidth)
                .attr('height', this.vizHeight);
            d3.select(this.canvasElement)
                .attr('width', this.vizWidth)
                .attr('height', this.vizHeight);
            this.updateScales();
            this.updatePaths();
            this.positionLabels();
            this.drawAxis();
        }
        this.resizeBrush();
    }
    resizeBrush() {
        this.initBrush();
        if (this.lastYValueBrushBound == null || this.lastXValueBrushBound == null) {
            return;
        }
        let left = this.scaleX(this.lastXValueBrushBound[0]);
        let right = this.scaleX(this.lastXValueBrushBound[1]);
        let top = this.scaleY(this.lastYValueBrushBound[1]);
        let bottom = this.scaleY(this.lastYValueBrushBound[0]);
        this.brushGroupSelect.call(this.brush.move, [[left, top], [right, bottom]]);
    }
    brushHandler() {
        const selection = d3.event.selection;
        if (typeof selection === "undefined" || selection === null) {
            this.data.removeCurveBrush(this.ComponentId);
            this._lastXValueBrushBound = null;
            this._lastYValueBrushBound = null;
            return;
        }
        let [[left, top], [right, bottom]] = selection;
        let minX = this.scaleX.invert(left);
        let maxX = this.scaleX.invert(right);
        this._lastXValueBrushBound = [minX, maxX];
        let xValueFilter = {
            key: this.xKey,
            bound: this.lastXValueBrushBound
        };
        let minY = this.scaleY.invert(bottom);
        let maxY = this.scaleY.invert(top);
        this._lastYValueBrushBound = [minY, maxY];
        let yValueFilter = {
            key: this.yKey,
            bound: this.lastYValueBrushBound
        };
        this.data.addCurveBrush(this.ComponentId, [xValueFilter, yValueFilter]);
    }
    OnBrushChange() {
        this.updatePaths();
    }
}
exports.Plot2dPathsWidget = Plot2dPathsWidget;

},{"./BaseWidget":81,"./OptionSelect":89,"d3":42}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class RichTooltip {
    constructor(waitToShow = 350, waitToHide = 200) {
        this._waitToShow = waitToShow;
        this._waitToHide = waitToHide;
        this._container = document.createElement('div');
        DevlibTSUtil_1.DevlibTSUtil.hide(this.container);
        document.body.appendChild(this.container);
        this.container.classList.add('richTooltip');
        this._showTimerRunning = false;
        this._hideTimerRunning = false;
        this.container.addEventListener('mouseleave', () => {
            this.Hide();
        });
        this.container.addEventListener('mouseenter', () => {
            if (this.hideTimer && this.hideTimerRunning) {
                this.hideTimer.stop();
                this._hideTimerRunning = false;
            }
        });
        this._hideTimerRunning = false;
        this._showTimerRunning = false;
        this._hideCallback = () => {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.container);
            // shouldn't need this, but I was running into a problem where stop timer was getting stuck in a loop.
            // this appears to fix it.
            this.hideTimer.stop();
            this._hideTimerRunning = false;
        };
    }
    get waitToShow() {
        return this._waitToShow;
    }
    get waitToHide() {
        return this._waitToHide;
    }
    get container() {
        return this._container;
    }
    get showTimerRunning() {
        return this._showTimerRunning;
    }
    get showTimer() {
        return this._showTimer;
    }
    get hideTimer() {
        return this._hideTimer;
    }
    get hideTimerRunning() {
        return this._hideTimerRunning;
    }
    get hideCallback() {
        return this._hideCallback;
    }
    Show(htmlString, pageX, pageY, waitOverride) {
        const callbackFunc = () => this.drawTooltip(htmlString, pageX, pageY);
        if (this.showTimerRunning) {
            this.showTimer.stop();
        }
        let delay;
        if (typeof waitOverride !== 'undefined') {
            delay = waitOverride;
        }
        else {
            delay = this.waitToShow;
        }
        this._showTimer = d3.timeout(callbackFunc, delay);
        this._showTimerRunning = true;
        if (this.hideTimerRunning) {
            this.hideTimer.stop();
            this._hideTimerRunning = false;
        }
    }
    drawTooltip(htmlString, pageX, pageY) {
        this._showTimerRunning = false;
        this.container.innerHTML = htmlString;
        // need to display as hidden to get width
        this.container.style.visibility = 'hidden';
        DevlibTSUtil_1.DevlibTSUtil.show(this.container);
        let boundRect = this.container.getBoundingClientRect();
        let containerRect = document.body.getBoundingClientRect();
        // Priority for placement is right, below, left, above
        const offset = 20; // space between label and position
        const edgeMargin = 10; // whitespace required between label and edge of document.
        const pad = offset + edgeMargin;
        let spaceRight = containerRect.right - pageX;
        let spaceBelow = containerRect.bottom - pageY;
        let spaceLeft = containerRect.width - spaceRight;
        let spaceAbove = containerRect.height - spaceBelow;
        let w = boundRect.width;
        let h = boundRect.height;
        let w2 = w / 2.0;
        let h2 = h / 2.0;
        let [top, left] = [0, 0];
        if (spaceRight >= w + pad && spaceAbove >= h2 + edgeMargin && spaceBelow >= h2 + edgeMargin) {
            [top, left] = this.positionRight(pageX, pageY, boundRect, offset);
        }
        else if (spaceBelow >= h + pad && spaceRight >= h2 + edgeMargin && spaceLeft >= h2 + edgeMargin) {
            [top, left] = this.positionBelow(pageX, pageY, boundRect, offset);
        }
        else if (spaceLeft >= w + pad && spaceAbove >= h2 + edgeMargin && spaceBelow >= h2 + edgeMargin) {
            [top, left] = this.positionLeft(pageX, pageY, boundRect, offset);
        }
        else {
            [top, left] = this.positionAbove(pageX, pageY, boundRect, offset);
            // TODO This can still run into problems if the x and y are at corners, and this point get's reached.
        }
        this.container.style.top = top + 'px';
        this.container.style.left = left + 'px';
        this.container.style.visibility = 'visible';
    }
    positionRight(pageX, pageY, boundRect, offset) {
        let top = pageY - boundRect.height / 2.0;
        let left = pageX + offset;
        return [top, left];
    }
    positionBelow(pageX, pageY, boundRect, offset) {
        let top = pageY + offset;
        let left = pageX - boundRect.width / 2.0;
        return [top, left];
    }
    positionLeft(pageX, pageY, boundRect, offset) {
        let top = pageY - boundRect.height / 2.0;
        let left = pageX - offset - boundRect.width;
        return [top, left];
    }
    positionAbove(pageX, pageY, boundRect, offset) {
        let top = pageY - offset - boundRect.height;
        let left = pageX - boundRect.width / 2.0;
        return [top, left];
    }
    Hide(waitOverride) {
        if (this.showTimerRunning) {
            this.showTimer.stop();
            this._showTimerRunning = false;
        }
        if (this.hideTimer && this.hideTimerRunning) {
            return;
        }
        else {
            let delay;
            if (typeof waitOverride !== 'undefined') {
                delay = waitOverride;
            }
            else {
                delay = this.waitToHide;
            }
            this._hideTimer = d3.timeout(this.hideCallback, delay);
        }
        this._hideTimerRunning = true;
    }
    static createLabelValueListContent(labelValueList) {
        let innerContainer = document.createElement('div');
        innerContainer.classList.add('tooltipInnerContainer');
        d3.select(innerContainer).selectAll('p')
            .data(labelValueList)
            .join('p')
            .html(d => {
            if (d[1]) {
                return d[0] + ': <b>' + d[1] + '</b>';
            }
            return '<i>' + d[0] + '</i>';
        })
            .classed('tooltipDisplayRow', true);
        return innerContainer.outerHTML;
    }
}
exports.RichTooltip = RichTooltip;

},{"../devlib/DevlibTSUtil":113,"d3":42}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
class ScatterPlotWidget extends BaseWidget_1.BaseWidget {
    constructor(container, xKey, yKey, canBrush = true) {
        super(container, true, canBrush);
        this._xKey = xKey;
        this._yKey = yKey;
        this.setLabel();
    }
    Clone(container) {
        const canBrush = false;
        return new ScatterPlotWidget(container, this.xKey, this.yKey, canBrush);
    }
    initProps(props) {
        super.initProps();
        this._canBrush = props[0];
    }
    get xKey() {
        return this._xKey;
    }
    get yKey() {
        return this._yKey;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get canvasElement() {
        return this._canvasElement;
    }
    get canBrush() {
        return this._canBrush;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get xAxisGroupSelect() {
        return this._xAxisGroupSelect;
    }
    get xLabelTextSelect() {
        return this._xLabelTextSelect;
    }
    get yAxisGroupSelect() {
        return this._yAxisGroupSelect;
    }
    get yLabelTextSelect() {
        return this._yLabelTextSelect;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleY() {
        return this._scaleY;
    }
    get axisPadding() {
        return this._axisPadding;
    }
    get brush() {
        return this._brush;
    }
    setMargin() {
        this._margin = {
            top: 8,
            right: 8,
            bottom: 56,
            left: 56
        };
    }
    init() {
        this._svgSelect = d3.select(this.container).append("svg")
            .attr("width", this.width)
            .attr("height", this.height);
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._canvasElement = this.mainGroupSelect
            .append('foreignObject')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight)
            .append('xhtml:canvas')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight)
            .node();
        if (this.canBrush) {
            this._brushGroupSelect = this.svgSelect.append("g")
                .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
                .classed("brushContainer", true);
            this._brush = d3.brush()
                .extent([[0, 0], [this.vizWidth, this.vizHeight]])
                .on("end", () => { this.brushHandler(); });
            this.brushGroupSelect.call(this.brush);
        }
        this._axisPadding = 0;
        this._xAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .classed("labelColor", true);
        this._yAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left - this.axisPadding}, ${this.margin.top})`)
            .classed("labelColor", true);
    }
    setLabel() {
        const bufferForAxis = 32 + this.axisPadding;
        this._xLabelTextSelect = this.svgSelect.append('text')
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`)
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .text(this.xKey);
        let transX = this.margin.left - bufferForAxis;
        let transY = this.margin.top + this.vizHeight / 2;
        let transformText;
        if (this.yKey.length === 1) {
            transformText = `translate(${transX}, ${transY})`;
        }
        else {
            transformText = `rotate(-90) translate(${-transY}, ${transX})`;
        }
        this._yLabelTextSelect = this.svgSelect.append('text')
            .attr('transform', transformText)
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .text(this.yKey);
    }
    OnDataChange() {
        this.updateScales();
        this.drawPoints();
        this.drawAxis();
    }
    drawPoints() {
        let validPoints = this.data.Array.filter((point) => {
            return !isNaN(point.get(this.xKey))
                && !isNaN(point.get(this.yKey))
                && point.inBrush;
        });
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight);
        canvasContext.fillStyle = 'black';
        for (let i = 0; i < validPoints.length; i++) {
            let point = validPoints[i];
            let x = this.scaleX(point.get(this.xKey));
            let y = this.scaleY(point.get(this.yKey));
            canvasContext.beginPath();
            const radius = 0.5;
            canvasContext.arc(x, y, radius, 0, 2 * Math.PI);
            canvasContext.fill();
        }
    }
    drawFacetedData(facetOptionIndexList) {
        this.drawFacetedDataDefaultRecurse(facetOptionIndexList, "300px", "300px");
    }
    updateScales() {
        let minMaxX = this.fullData.getMinMax(this.xKey);
        this._scaleX = d3.scaleLinear()
            .domain(minMaxX)
            .range([0, this.vizWidth]);
        let minMaxY = this.fullData.getMinMax(this.yKey);
        this._scaleY = d3.scaleLinear()
            .domain(minMaxY)
            .range([this.vizHeight, 0]);
    }
    drawAxis() {
        this.xAxisGroupSelect
            .call(d3.axisBottom(this.scaleX).ticks(5));
        this.yAxisGroupSelect
            .call(d3.axisLeft(this.scaleY).ticks(5));
    }
    OnResize() {
        // resize is handled by css / HTML
    }
    brushHandler() {
        const selection = d3.event.selection;
        if (typeof selection === "undefined" || selection === null) {
            this.data.removeBrush(this.ComponentId);
            return;
        }
        let [[left, top], [right, bottom]] = selection;
        let minX = this.scaleX.invert(left);
        let maxX = this.scaleX.invert(right);
        let xValueFilter = {
            key: this.xKey,
            bound: [minX, maxX]
        };
        let minY = this.scaleY.invert(bottom);
        let maxY = this.scaleY.invert(top);
        let yValueFilter = {
            key: this.yKey,
            bound: [minY, maxY]
        };
        this.data.addBrush(this.ComponentId, xValueFilter, yValueFilter);
    }
    OnBrushChange() {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        // hide dynamically
        this.drawPoints();
    }
}
exports.ScatterPlotWidget = ScatterPlotWidget;

},{"./BaseWidget":81,"d3":42}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const BaseComponent_1 = require("./BaseComponent");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class Toolbar extends BaseComponent_1.BaseComponent {
    constructor(container) {
        super(container);
    }
    get uploadFileButtonWrapper() {
        return this._uploadFileButtonWrapper;
    }
    get toolbarElements() {
        return this._toolbarElements;
    }
    get wrapperDiv() {
        return this._wrapperDiv;
    }
    initToolbarElements() {
        this._toolbarElements = [
            {
                type: 'single',
                iconKey: 'home',
                callback: () => location.href = '/overview',
                tooltip: 'Return to overview screen'
            },
            {
                type: 'toggleButton',
                iconKeys: ['eye-slash', 'eye'],
                callback: (state) => console.log('toggle', state),
                tooltips: ['Only showing longer tracks, click to show all cells.', 'Showing all cells, click to show only long tracks.']
            },
            {
                type: 'optionSelect',
                iconKeys: ['bars', 'stream', 'clone'],
                defaultIndex: 0,
                callback: async (state) => {
                    let modeChangeEvent;
                    switch (state) {
                        case 0:
                            modeChangeEvent = new CustomEvent('modeChange', { detail: {
                                    inCondensedMode: true,
                                    inExemplarMode: true
                                } });
                            break;
                        case 1:
                            modeChangeEvent = new CustomEvent('modeChange', { detail: {
                                    inCondensedMode: false,
                                    inExemplarMode: true
                                } });
                            break;
                        case 2:
                            modeChangeEvent = new CustomEvent('modeChange', { detail: {
                                    inCondensedMode: false,
                                    inExemplarMode: false
                                } });
                            break;
                        default:
                            break;
                    }
                    DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
                    await DevlibTSUtil_1.DevlibTSUtil.makeAsync(() => document.dispatchEvent(modeChangeEvent));
                },
                tooltips: ['Condensed Mode', 'Expanded Mode', 'Frame Mode']
            }
        ];
    }
    init() {
        this._wrapperDiv = document.createElement("div");
        this.wrapperDiv.classList.add("wrapperDiv");
        this.container.appendChild(this.wrapperDiv);
        this.initToolbarElements();
        this.drawToolbarElements();
    }
    drawToolbarElements() {
        for (let toolbarElement of this.toolbarElements) {
            if (toolbarElement.type === 'single') {
                let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKey, toolbarElement.callback);
                button.classList.add('big');
                this.wrapperDiv.append(button);
            }
            else if (toolbarElement.type === 'toggleButton') {
                let buttonTrue = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKeys[0], null);
                buttonTrue.classList.add('big');
                this.wrapperDiv.append(buttonTrue);
                let buttonFalse = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKeys[1], null);
                buttonFalse.classList.add('big');
                this.wrapperDiv.append(buttonFalse);
                DevlibTSUtil_1.DevlibTSUtil.hide(buttonFalse);
                buttonTrue.onclick = () => {
                    DevlibTSUtil_1.DevlibTSUtil.hide(buttonTrue);
                    DevlibTSUtil_1.DevlibTSUtil.show(buttonFalse);
                    toolbarElement.callback(true);
                };
                buttonFalse.onclick = () => {
                    DevlibTSUtil_1.DevlibTSUtil.show(buttonTrue);
                    DevlibTSUtil_1.DevlibTSUtil.hide(buttonFalse);
                    toolbarElement.callback(false);
                };
            }
            else if (toolbarElement.type === 'optionSelect') {
                let grouperDiv = document.createElement('div');
                grouperDiv.classList.add('optionSelectGrouperDiv');
                let buttonList = [];
                for (let i = 0; i < toolbarElement.iconKeys.length; i++) {
                    let iconKey = toolbarElement.iconKeys[i];
                    let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(iconKey, null);
                    button.classList.add('big');
                    if (i === toolbarElement.defaultIndex) {
                        button.classList.add('selected');
                    }
                    buttonList.push(button);
                    grouperDiv.append(button);
                }
                const removeSelected = () => {
                    for (let button of buttonList) {
                        button.classList.remove('selected');
                    }
                };
                for (let i = 0; i < buttonList.length; i++) {
                    let button = buttonList[i];
                    button.onclick = () => {
                        removeSelected();
                        button.classList.add('selected');
                        toolbarElement.callback(i);
                    };
                }
                document.addEventListener('changeModeSelect', (e) => {
                    removeSelected();
                    buttonList[e.detail].classList.add('selected');
                });
                this.wrapperDiv.append(grouperDiv);
            }
        }
    }
    OnResize() {
        // do nothing
    }
}
exports.Toolbar = Toolbar;

},{"../devlib/DevlibTSUtil":113,"./BaseComponent":80}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollectionIterator_1 = require("./CurveCollectionIterator");
const PointCollection_1 = require("./PointCollection");
const CurveListFactory_1 = require("./CurveListFactory");
class CurveCollection extends PointCollection_1.PointCollection {
    constructor(curveList, spec) {
        super();
        this._length = curveList.curveList.length;
        this._curveList = curveList;
        this.Specification = spec;
    }
    get curveList() {
        return this._curveList;
    }
    OnBrushChange() { }
    getFacetList(locationMap) {
        let facetList = CurveListFactory_1.CurveListFactory.CreateFacetedDatasets(this.curveList, locationMap);
        for (let facet of facetList) {
            facet.data = facet.data.curveCollection;
        }
        return facetList;
    }
    [Symbol.iterator]() {
        return new CurveCollectionIterator_1.CurveCollectionIterator(this.curveList);
    }
}
exports.CurveCollection = CurveCollection;

},{"./CurveCollectionIterator":95,"./CurveListFactory":98,"./PointCollection":108}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CurveCollectionIterator {
    constructor(curveList) {
        this._index = 0;
        this._curveList = curveList;
    }
    get index() {
        return this._index;
    }
    get curveList() {
        return this._curveList;
    }
    next() {
        let curve = this.curveList.curveList[this.index];
        let isDone = this.index >= this.curveList.curveList.length;
        ++this._index;
        let iterResult = {
            value: curve,
            done: isDone
        };
        return iterResult;
    }
}
exports.CurveCollectionIterator = CurveCollectionIterator;

},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CurveIterator {
    constructor(pointList) {
        this._index = 0;
        this._pointList = pointList;
    }
    get index() {
        return this._index;
    }
    get pointList() {
        return this._pointList;
    }
    next() {
        let point = this.pointList[this.index];
        let isDone = this.index >= this.pointList.length;
        ++this._index;
        let iterResult = {
            value: point,
            done: isDone
        };
        return iterResult;
    }
}
exports.CurveIterator = CurveIterator;

},{}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const PointCollection_1 = require("./PointCollection");
const CurveListIterator_1 = require("./CurveListIterator");
const CurveCollection_1 = require("./CurveCollection");
const CurveListFactory_1 = require("./CurveListFactory");
class CurveList extends PointCollection_1.PointCollection {
    constructor(curveList, spec) {
        super();
        this._curveList = curveList;
        this._length = 0;
        let i = 0;
        this._curveLookup = new Map();
        for (let curve of this.curveList) {
            this.curveLookup.set(curve.id, curve);
            this._length += curve.length;
            for (let point of curve) {
                this[i] = point;
                ++i;
            }
        }
        this._minMaxMap = new Map();
        this._locationFrameSegmentLookup = new Map();
        // this._locationFrameSegmentLookup = new Map<string, [PointND, number]>();
        const locationSet = new Set();
        for (let i = 0; i < this.length; i++) {
            let point = this[i];
            let loc = point.get('Location ID');
            locationSet.add(loc);
            if (!this._locationFrameSegmentLookup.has(loc)) {
                this._locationFrameSegmentLookup.set(loc, new Map());
            }
            const locMap = this._locationFrameSegmentLookup.get(loc);
            let frame = point.get('Frame ID');
            if (!locMap.has(frame)) {
                locMap.set(frame, new Map());
            }
            const segMap = locMap.get(frame);
            let segmentLabel = point.get('segmentLabel');
            segMap.set(segmentLabel, [point, i + 1]);
        }
        this._locationList = Array.from(locationSet);
        this.locationList.sort(DevlibAlgo_1.DevlibAlgo.sortAscend);
        this._curveCollection = new CurveCollection_1.CurveCollection(this, spec);
        this._curveBrushList = new Map();
        this.Specification = spec;
    }
    get curveList() {
        return this._curveList;
    }
    get curveLookup() {
        return this._curveLookup;
    }
    get curveCollection() {
        return this._curveCollection;
    }
    set curveCollection(v) {
        this._curveCollection = v;
    }
    get inputKey() {
        return this._inputKey;
    }
    get minMaxMap() {
        if (this._minMaxMap.size === 0) {
            this.updateMinMaxMap();
        }
        return this._minMaxMap;
    }
    get locationList() {
        return this._locationList;
    }
    GetCellsAtFrame(locationId, frameId) {
        if (this._locationFrameSegmentLookup.has(locationId)) {
            const frameMap = this._locationFrameSegmentLookup.get(locationId);
            if (frameMap.has(frameId)) {
                const segMap = frameMap.get(frameId);
                const tuplelist = segMap.values();
                let pointList = [];
                for (let [point, _] of tuplelist) {
                    pointList.push(point);
                }
                return pointList;
            }
        }
        return [];
    }
    GetCellFromLabel(locationId, frameId, segmentLabel) {
        if (this._locationFrameSegmentLookup.has(locationId)) {
            const frameMap = this._locationFrameSegmentLookup.get(locationId);
            if (frameMap.has(frameId)) {
                const segMap = frameMap.get(frameId);
                if (segMap.has(segmentLabel)) {
                    return segMap.get(segmentLabel);
                }
            }
        }
        return [null, null];
    }
    get brushApplied() {
        return this._brushApplied;
    }
    set brushApplied(v) {
        this._brushApplied = v;
    }
    get curveBrushList() {
        return this._curveBrushList;
    }
    getFacetList(locationMap) {
        return CurveListFactory_1.CurveListFactory.CreateFacetedDatasets(this, locationMap);
    }
    OnBrushChange() {
        for (let curve of this.curveList) {
            curve.inBrush = true;
            for (let point of curve.pointList) {
                point.inBrush = true;
            }
        }
        // sets filter values at point level
        const pointBrushApplied = this.SetBrushValues();
        // set track to false if all the points in a track are also false
        for (let curve of this.curveList) {
            let allPointsHidden = true;
            for (let point of curve.pointList) {
                if (point.inBrush) {
                    allPointsHidden = false;
                    break;
                }
            }
            if (allPointsHidden) {
                curve.inBrush = false;
            }
        }
        // sets filter values at track level
        const curveCollectionBrushApplied = this.curveCollection.SetBrushValues();
        const curveBrushApplied = this.setCurveBrushValues();
        this._brushApplied = pointBrushApplied || curveBrushApplied || curveCollectionBrushApplied;
    }
    setCurveBrushValues() {
        let brushApplied = false;
        for (let curve of this.curveList) {
            let allPointsOutOfBrush = true;
            for (let point of curve.pointList) {
                if (this.isPointInCurveBrushList(point)) {
                    allPointsOutOfBrush = false;
                    break;
                }
            }
            if (allPointsOutOfBrush) {
                curve.inBrush = false;
                brushApplied = true;
            }
        }
        return brushApplied;
    }
    isPointInCurveBrushList(point) {
        for (let valueFilterList of this.curveBrushList.values()) {
            for (let valueFilter of valueFilterList) {
                if (!PointCollection_1.PointCollection.IsInBrush(point, valueFilter)) {
                    return false;
                }
            }
        }
        return true;
    }
    updateMinMaxMap() {
        for (let curve of this.curveList) {
            for (let point of curve.pointList) {
                for (let [key, value] of point.valueMap) {
                    let currentVal = this._minMaxMap.get(key);
                    let pointVal = point.get(key);
                    if (typeof currentVal === "undefined") {
                        this._minMaxMap.set(key, [pointVal, pointVal]);
                        continue;
                    }
                    let [c1, c2] = currentVal;
                    let newVal = [Math.min(c1, pointVal), Math.max(c2, pointVal)];
                    this._minMaxMap.set(key, newVal);
                }
            }
        }
    }
    initValue(key, value) {
        for (let curve of this.curveList) {
            curve.addValue(key, value);
        }
    }
    isKeySet(key) {
        for (let curve of this.curveList) {
            let value = curve.get(key);
            if (typeof value === "undefined") {
                return false;
            }
        }
        return true;
    }
    setInputKey(key) {
        this._inputKey = key;
        for (let curve of this.curveList) {
            curve.sort(key);
        }
    }
    removeCurveBrush(brushKey) {
        this.curveBrushList.delete(brushKey);
        this.updateBrush();
    }
    addCurveBrush(brushKey, filters) {
        this.curveBrushList.set(brushKey, filters);
        this.updateBrush();
    }
    sort(key, ascend = true) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.sortOnProperty((curve) => {
            return curve.get(key);
        }, ascend);
        this.curveList.sort(sortFunction);
    }
    getPointsAtInput(inputValue) {
        let pointList = [];
        for (let curve of this.curveList) {
            let point = curve.getPoint(inputValue);
            // console.log(point);
            if (point) {
                pointList.push(point);
            }
        }
        return pointList;
    }
    calculateDepth(depthKey, valueKey) {
        if (this.isKeySet(depthKey)) {
            // depth is already set
            return;
        }
        this.initValue(depthKey, 0);
        const allBands = CurveList.getAllPossible2Bands(this.curveList);
        for (let band of allBands) {
            for (let curve of this.curveList) {
                const depthContribution = this.getDepthContribution(curve, band, valueKey);
                const oldDepth = curve.get(depthKey);
                curve.addValue(depthKey, oldDepth + depthContribution);
            }
        }
        // todo - normalize
    }
    getDepthContribution(curve, [b1, b2], valueKey) {
        let depth = 0;
        for (let i = 0; i < curve.pointList.length; i++) {
            let point = curve.pointList[i];
            const t = point.get(this.inputKey);
            let thisVal = point.get(valueKey);
            let b1Val = b1.getPointValue(t, valueKey);
            let b2Val = b2.getPointValue(t, valueKey);
            let minVal = Math.min(b1Val, b2Val);
            let maxVal = Math.max(b1Val, b2Val);
            if (minVal <= thisVal && thisVal <= maxVal) {
                const weight = curve.getPointWeight(i);
                depth += weight;
            }
        }
        return depth;
    }
    static getAllPossible2Bands(list) {
        const bandList = [];
        for (let i = 0; i < list.length; i++) {
            for (let j = i + 1; j < list.length; j++) {
                let b = [list[i], list[j]];
                bandList.push(b);
            }
        }
        return bandList;
    }
    [Symbol.iterator]() {
        return new CurveListIterator_1.CurveListIterator(this.curveList);
    }
}
exports.CurveList = CurveList;

},{"../devlib/DevlibAlgo":111,"./CurveCollection":94,"./CurveListFactory":98,"./CurveListIterator":99,"./PointCollection":108}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibMath_1 = require("../devlib/DevlibMath");
const CurveList_1 = require("./CurveList");
const CurveND_1 = require("./CurveND");
const PointND_1 = require("./PointND");
class CurveListFactory {
    static CreateFacetedDatasets(fullData, locationMap) {
        let locToCat = new Map();
        for (let key of Object.keys(locationMap)) {
            let valueList = locationMap[key];
            if (valueList.length === 0) {
                throw new Error('LocationMap valueList should have at least one entry');
            }
            if (typeof valueList[0] === 'string') {
                // todo work for locationmaptemaplate type
            }
            else {
                for (let [low, high] of valueList) {
                    for (let i = +low; i <= +high; i++) {
                        locToCat.set(i, key);
                    }
                }
            }
        }
        let pointMap = new Map();
        for (let curve of fullData.curveList) {
            let firstPoint = curve.pointList[0];
            let location = firstPoint.get('Location ID');
            let category = locToCat.get(location);
            if (!pointMap.has(category)) {
                pointMap.set(category, []);
            }
            pointMap.get(category).push(curve);
        }
        let facetList = [];
        for (let [cat, listOfCurves] of pointMap) {
            let curveList = new CurveList_1.CurveList(listOfCurves, fullData.Specification);
            let facet = {
                name: cat,
                data: curveList
            };
            facetList.push(facet);
        }
        return facetList;
    }
    static CreateCurveListFromCSVObject(csvObject, derivedTrackDataFunctions, derivedPointDataFunctions, dataSpec, idkey = "id", tKeyOptions = ["Time (h)"]) {
        console.log(csvObject);
        const curveList = [];
        let tKey = null;
        for (let keyOption of tKeyOptions) {
            if (csvObject.columns.includes(keyOption)) {
                tKey = keyOption;
                break;
            }
        }
        if (tKey == null) {
            throw new Error("Dataset does not contain any tKey column. Allowed Keys: " + tKeyOptions.toString());
        }
        let pojoList = d3.nest()
            .key(d => d[idkey])
            .rollup((rows) => {
            const values = {};
            const points = [];
            for (let row of rows) {
                const tValue = row[tKey];
                if (!DevlibMath_1.DevlibMath.isNumber(tValue)) {
                    for (let key in row) {
                        if (key === idkey || key === tKey) {
                            continue;
                        }
                        const value = row[key];
                        if (!DevlibMath_1.DevlibMath.isNumber) {
                            continue;
                        }
                        values[tValue] = +value;
                        break;
                    }
                    continue;
                }
                const point = {};
                for (let key in row) {
                    if (key === idkey) {
                        continue;
                    }
                    point[key] = +row[key];
                }
                points.push(point);
            }
            // const sortFunction = DevlibMath.sortOnProperty<StringToNumberObj>(obj => obj[tKey]);
            // points.sort(sortFunction);
            values.points = points;
            CurveListFactory.calculateDerivedTrackValues(values, derivedTrackDataFunctions);
            CurveListFactory.calculateDerivedPointValues(values, derivedPointDataFunctions);
            // todo add point derived functions - also should pull this out into a function
            // for (let [attrNameList, func] of derivedTrackDataFunctions)
            // {
            // 	let valueList = func(points);
            // 	for (let i = 0; i < attrNameList.length; i++)
            // 	{
            // 		let attrName = attrNameList[i];
            // 		let val = valueList[i];
            // 		values[attrName] = val;
            // 	}
            // }
            return values;
        })
            .entries(csvObject);
        for (let plainCurve of pojoList) {
            let numericKey = +plainCurve.key;
            // js formats the number as '123.0', Instead I want '123'
            const curve = new CurveND_1.CurveND(numericKey.toString());
            for (let key in plainCurve.value) {
                let value = plainCurve.value[key];
                if (typeof value === "number") {
                    curve.addValue(key, value);
                    continue;
                }
                for (let pojoPoint of value) {
                    const point = new PointND_1.PointND(pojoPoint);
                    curve.addPoint(point);
                }
            }
            curveList.push(curve);
        }
        // console.log(curveList);
        const curveListObj = new CurveList_1.CurveList(curveList, dataSpec);
        curveListObj.setInputKey(tKey);
        return curveListObj;
    }
    static calculateDerivedTrackValues(values, derivedTrackDataFunctions) {
        let points = values.points;
        for (let [attrNameList, func] of derivedTrackDataFunctions) {
            let valueList = func(points);
            for (let i = 0; i < attrNameList.length; i++) {
                let attrName = attrNameList[i];
                let val = valueList[i];
                values[attrName] = val;
            }
        }
    }
    static calculateDerivedPointValues(values, derivedPointDataFunctions) {
        let points = values.points;
        for (let [attrNameList, func] of derivedPointDataFunctions) {
            let valueListOfLists = func(points);
            for (let i = 0; i < attrNameList.length; i++) {
                let attrName = attrNameList[i];
                let valueList = valueListOfLists[i];
                for (let j = 0; j < points.length; j++) {
                    points[j][attrName] = valueList[j];
                }
            }
        }
    }
}
exports.CurveListFactory = CurveListFactory;

},{"../devlib/DevlibMath":112,"./CurveList":97,"./CurveND":100,"./PointND":109,"d3":42}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CurveIterator_1 = require("./CurveIterator");
class CurveListIterator {
    constructor(curveList) {
        this._curveList = curveList;
        this.updateCurveIterator(0);
    }
    get index() {
        return this._index;
    }
    get curveList() {
        return this._curveList;
    }
    get currentCurveIterator() {
        return this._currentCurveIterator;
    }
    next() {
        let nextResult = this.currentCurveIterator.next();
        if (!nextResult.done) {
            return nextResult;
        }
        let newIndex = this.index + 1;
        if (newIndex >= this.curveList.length) {
            return {
                done: true,
                value: undefined
            };
        }
        this.updateCurveIterator(newIndex);
        return this.next();
    }
    updateCurveIterator(newIndex) {
        this._index = newIndex;
        let nextCurve = this.curveList[newIndex];
        if (nextCurve) {
            this._currentCurveIterator = new CurveIterator_1.CurveIterator(nextCurve.pointList);
        }
    }
}
exports.CurveListIterator = CurveListIterator;

},{"./CurveIterator":96}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PointND_1 = require("./PointND");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const PointCollection_1 = require("./PointCollection");
const CurveIterator_1 = require("./CurveIterator");
class CurveND extends PointCollection_1.PointCollection {
    constructor(id) {
        super();
        this._id = id;
        this._valueMap = new Map();
        this._pointList = [];
        this._inBrush = true;
    }
    get id() {
        return this._id;
    }
    get inputKey() {
        return this._inputKey;
    }
    get valueMap() {
        return this._valueMap;
    }
    get pointList() {
        return this._pointList;
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
        for (let point of this.pointList) {
            point.inBrush = v;
        }
    }
    getFacetList() {
        throw new Error('Not Implemented.');
    }
    OnBrushChange() { }
    addValue(key, value) {
        this.valueMap.set(key, value);
    }
    get(key) {
        return this.valueMap.get(key);
    }
    // finds the value of the property with given key. Will interpolate.
    getPointValue(inputValue, outputKey) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(inputValue, (point) => {
            return point.get(this.inputKey);
        });
        let pointIndex;
        pointIndex = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(this.pointList, sortFunction);
        if (typeof pointIndex === "number") {
            return this.pointList[pointIndex].get(outputKey);
        }
        const [idx1, idx2] = pointIndex;
        if (idx1 === undefined || idx2 === undefined) {
            // out of bounds
            return undefined;
        }
        const point1 = this.pointList[idx1];
        const point2 = this.pointList[idx2];
        const val1 = point1.get(outputKey);
        const val2 = point2.get(outputKey);
        const t1 = point1.get(this.inputKey);
        const t2 = point2.get(this.inputKey);
        const tDiff = t2 - t1;
        const portion = (inputValue - t1) / tDiff;
        const valDiff = val2 - val1;
        return val1 + valDiff * portion;
    }
    // finds point at given input time. Will construct a new point and interpolate all values if it is between points
    getPoint(inputValue) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(inputValue, (point) => {
            return point.get(this.inputKey);
        });
        let pointIndex;
        pointIndex = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(this.pointList, sortFunction);
        if (typeof pointIndex === "number") {
            return this.pointList[pointIndex];
        }
        const [idx1, idx2] = pointIndex;
        if (idx1 === undefined || idx2 === undefined) {
            // out of bounds
            return undefined;
        }
        const point1 = this.pointList[idx1];
        const point2 = this.pointList[idx2];
        const t1 = point1.get(this.inputKey);
        const t2 = point2.get(this.inputKey);
        const tDiff = t2 - t1;
        const portion = (inputValue - t1) / tDiff;
        let interpolatedPoint = new PointND_1.PointND();
        interpolatedPoint.addValue(this.inputKey, inputValue);
        for (let [key, value] of point1.valueMap) {
            let val1 = point1.get(key);
            let val2 = point2.get(key);
            let valDiff = val2 - val1;
            interpolatedPoint.addValue(key, val1 + valDiff * portion);
        }
        interpolatedPoint.inBrush = point1.inBrush && point2.inBrush;
        return interpolatedPoint;
    }
    getPointWeight(pointIndex) {
        const idxLeft = Math.max(pointIndex - 1, 0);
        const idxRight = Math.min(pointIndex + 1, this.pointList.length - 1);
        const tLeft = this.pointList[idxLeft].get(this.inputKey);
        const tRight = this.pointList[idxRight].get(this.inputKey);
        return (tRight - tLeft) / 2;
    }
    addPoint(point) {
        point.parent = this;
        this._pointList.push(point);
        this[this.length] = point;
        ++this._length;
    }
    sort(key) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.sortOnProperty((point) => {
            return point.get(key);
        });
        this.pointList.sort(sortFunction);
        this._inputKey = key;
    }
    [Symbol.iterator]() {
        return new CurveIterator_1.CurveIterator(this.pointList);
    }
}
exports.CurveND = CurveND;

},{"../devlib/DevlibAlgo":111,"./CurveIterator":96,"./PointCollection":108,"./PointND":109}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DataEvents;
(function (DataEvents) {
    DataEvents["brushChange"] = "brushChange";
})(DataEvents = exports.DataEvents || (exports.DataEvents = {}));

},{}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DerivedPointValueFunctions {
    static GetFunctionList() {
        let functionList = [];
        functionList.push([['Mass_norm'], (pointList) => this.normAttr('Mass (pg)', pointList, false)]);
        functionList.push([['Time_norm'], (pointList) => this.normAttr('Time (h)', pointList)]);
        return functionList;
    }
    static normAttr(attrKey, pointList, zeroNorm = true) {
        let newValues = [];
        if (pointList.length === 0) {
            return [newValues];
        }
        const firstVal = pointList[0][attrKey];
        for (let point of pointList) {
            let oldVal = point[attrKey];
            if (zeroNorm) {
                newValues.push(oldVal - firstVal);
            }
            else {
                newValues.push(oldVal / firstVal);
            }
        }
        return [newValues];
    }
}
exports.DerivedPointValueFunctions = DerivedPointValueFunctions;

},{}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DerivedTrackValueFunctions {
    static GetFunctionList() {
        let functionList = [];
        functionList.push([['Track Length'], this.trackLength]);
        functionList.push([['Avg Mass'], this.averageMass]);
        functionList.push([['Growth Rate', 'Intercept', 'Initial Mass', 'Exponential Growth Constant', 'r_squared'], this.growthRateStats]);
        return functionList;
    }
    static trackLength(pointList) {
        let firstTime = pointList[0]['Time (h)'];
        let lastTime = pointList[pointList.length - 1]['Time (h)'];
        return [lastTime - firstTime];
    }
    static averageMass(pointList) {
        let totalMass = 0;
        for (let point of pointList) {
            totalMass += point['Mass (pg)'];
        }
        return [totalMass / pointList.length];
    }
    static growthRateStats(pointList) {
        // Referenced math
        // https://en.wikipedia.org/wiki/Ordinary_least_squares#Simple_linear_regression_model
        let sumX = 0;
        let sumY = 0;
        let sumYY = 0;
        let sumXY = 0;
        let sumXX = 0;
        let N = pointList.length;
        if (N === 1) {
            return [NaN, NaN, NaN, NaN, NaN]; // calculating the slope of one point is actually point...less
        }
        for (let point of pointList) {
            let x = point['Time (h)'];
            let y = point['Mass (pg)'];
            sumX += x;
            sumY += y;
            sumYY += y * y;
            sumXY += x * y;
            sumXX += x * x;
        }
        let N_inv = 1 / N;
        let covariance = sumXY - N_inv * sumX * sumY;
        let variance = sumXX - N_inv * sumX * sumX;
        let slope = covariance / variance;
        let intercept = N_inv * (sumY - slope * sumX);
        let initialMass = pointList[0]['Time (h)'] * slope + intercept;
        let exponentialGrowthConstant = slope / initialMass;
        // r_squared equation from here
        // https://en.wikipedia.org/wiki/Simple_linear_regression#Fitting_the_regression_line
        let r_top = (N_inv * sumXY - N_inv * sumX * N_inv * sumY);
        let r_bot = Math.sqrt((N_inv * sumXX - N_inv * sumX * N_inv * sumX) * (N_inv * sumYY - N_inv * sumY * N_inv * sumY));
        let r_squared = Math.pow((r_top / r_bot), 2);
        return [slope, intercept, initialMass, exponentialGrowthConstant, r_squared];
    }
}
exports.DerivedTrackValueFunctions = DerivedTrackValueFunctions;

},{}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ImageFrame {
    constructor(frameId) {
        this._frameId = frameId;
        this._inBrush = true;
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
    }
    get inBrushCount() {
        return this._inBrushCount;
    }
    set inBrushCount(v) {
        this._inBrushCount = v;
    }
    get totalCount() {
        return this._totalCount;
    }
    set totalCount(v) {
        this._totalCount = v;
    }
    get inBrushPercent() {
        return this.inBrushCount / this.totalCount;
    }
    get frameId() {
        return this._frameId;
    }
}
exports.ImageFrame = ImageFrame;

},{}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ImageFrame_1 = require("./ImageFrame");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
class ImageLocation {
    constructor(locationId) {
        this._locationId = locationId;
        this._inBrush = true;
        this._frameList = [];
        this._frameLookup = new Map();
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
    }
    get inBrushCount() {
        return this._inBrushCount;
    }
    set inBrushCount(v) {
        this._inBrushCount = v;
    }
    get totalCount() {
        return this._totalCount;
    }
    set totalCount(v) {
        this._totalCount = v;
    }
    get inBrushPercent() {
        return this.inBrushCount / this.totalCount;
    }
    get locationId() {
        return this._locationId;
    }
    get frameList() {
        return this._frameList;
    }
    get frameLookup() {
        return this._frameLookup;
    }
    addFrame(frameId) {
        if (this.frameLookup.has(frameId)) {
            return;
        }
        let newFrame = new ImageFrame_1.ImageFrame(frameId);
        this.frameList.push(newFrame);
        this.frameLookup.set(frameId, newFrame);
    }
    sortFrames() {
        this.frameList.sort(DevlibAlgo_1.DevlibAlgo.sortOnProperty((frame) => frame.frameId));
    }
}
exports.ImageLocation = ImageLocation;

},{"../devlib/DevlibAlgo":111,"./ImageFrame":104}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ImageLocation_1 = require("./ImageLocation");
class ImageMetaData {
    constructor() {
        this._locationList = [];
        this._locationLookup = new Map();
    }
    get locationList() {
        return this._locationList;
    }
    get locationLookup() {
        return this._locationLookup;
    }
    get locationIdKey() {
        return this._locationIdKey;
    }
    get frameIdKey() {
        return this._frameIdKey;
    }
    getBrushedLocations() {
        return this.locationList.filter(loc => loc.inBrush).map(loc => loc.locationId);
    }
    getBrushedImageCount() {
        let count = 0;
        for (let loc of this.locationList) {
            count += loc.frameList.filter(frame => frame.inBrush).length;
        }
        return count;
    }
    updateInBrushProp(pointList) {
        this.resetAllToFalse();
        for (let point of pointList) {
            let locId = point.get(this.locationIdKey);
            let frameId = point.get(this.frameIdKey);
            let location = this.locationLookup.get(locId);
            let frame = location.frameLookup.get(frameId);
            location.totalCount++;
            frame.totalCount++;
            if (point.inBrush) {
                location.inBrushCount++;
                location.inBrush = true;
                frame.inBrushCount++;
                frame.inBrush = true;
            }
        }
    }
    resetAllToFalse() {
        for (let loc of this.locationList) {
            loc.inBrush = false;
            loc.inBrushCount = 0;
            loc.totalCount = 0;
            for (let frame of loc.frameList) {
                frame.inBrush = false;
                frame.inBrushCount = 0;
                frame.totalCount = 0;
            }
        }
    }
    static fromPointCollection(pointList, locationIdKey = 'Location ID', frameIdKey = 'Frame ID') {
        let imgMetaData = new ImageMetaData();
        imgMetaData._locationIdKey = locationIdKey;
        imgMetaData._frameIdKey = frameIdKey;
        for (let point of pointList) {
            let locId = point.get(locationIdKey);
            let frameId = point.get(frameIdKey);
            let imageLocation;
            if (imgMetaData.locationLookup.has(locId)) {
                imageLocation = imgMetaData.locationLookup.get(locId);
            }
            else {
                imageLocation = new ImageLocation_1.ImageLocation(locId);
                imgMetaData.locationList.push(imageLocation);
                imgMetaData.locationLookup.set(locId, imageLocation);
            }
            imageLocation.addFrame(frameId);
        }
        for (let imageLocation of imgMetaData.locationList) {
            imageLocation.sortFrames();
        }
        imgMetaData.updateInBrushProp(pointList);
        return imgMetaData;
    }
}
exports.ImageMetaData = ImageMetaData;

},{"./ImageLocation":105}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const protobufjs_1 = require("protobufjs");
class ImageStackDataRequest {
    constructor(driveId) {
        this._driveId = driveId;
        this._metaDataLoaded = false;
        d3.json(`/data/${driveId}/imageMetaData.json`).then((data) => {
            this._tileWidth = data.tileWidth;
            this._tileHeight = data.tileHeight;
            this._numberOfColumns = data.numberOfColumns;
            this._tilesPerFile = data.tilesPerFile;
            this._metaDataLoaded = true;
            if (data.scaleFactor) {
                this._scaleFactor = data.scaleFactor;
            }
            else {
                this._scaleFactor = 1;
            }
        });
        this._blobArray = [];
        this._labelArray = [];
        this._maxBlobCount = 100;
        this._nextBlobIndex = 0;
        this._nextLabelIndex = 0;
        this._maxLabelCount = 100;
    }
    get metaDataLoaded() {
        return this._metaDataLoaded;
    }
    get driveId() {
        return this._driveId;
    }
    get tileWidth() {
        return this._tileWidth;
    }
    get tileHeight() {
        return this._tileHeight;
    }
    get numberOfColumns() {
        return this._numberOfColumns;
    }
    get tilesPerFile() {
        return this._tilesPerFile;
    }
    get maxBlobCount() {
        return this._maxBlobCount;
    }
    get maxLabelCount() {
        return this._maxLabelCount;
    }
    get scaleFactor() {
        return this._scaleFactor;
    }
    get blobArray() {
        return this._blobArray;
    }
    get nextBlobIndex() {
        return this._nextBlobIndex;
    }
    get labelArray() {
        return this._labelArray;
    }
    get nextLabelIndex() {
        return this._nextLabelIndex;
    }
    ;
    getImage(location, frameIndex, callback) {
        if (!this.metaDataLoaded) {
            setTimeout(() => {
                this.getImage(location, frameIndex, callback);
            }, 50); // todo fallback
            return;
        }
        let [top, left] = this.getTileTopLeft(frameIndex);
        let bundleIndex = Math.floor(frameIndex / this.tilesPerFile);
        let key = [location, bundleIndex].join('-');
        let cachedElement = this.blobArray.find(d => d[1] === key);
        if (cachedElement) {
            this.runWithCachedImage(key, top, left, callback);
            return;
        }
        const imgUrl = `/data/${this.driveId}/img_${location}_${bundleIndex}.jpg`;
        const thisIndex = this.nextBlobIndex;
        this.blobArray[thisIndex] = [null, key, null];
        this._nextBlobIndex = (this.nextBlobIndex + 1) % this.maxBlobCount;
        let xhr = new XMLHttpRequest();
        xhr.responseType = 'blob';
        xhr.onload = () => {
            let blob = xhr.response;
            let url = window.URL.createObjectURL(blob);
            this.blobArray[thisIndex] = [blob, key, url];
            callback(top, left, blob, url);
        };
        xhr.onerror = (e) => {
            console.warn('Error Fetching: ' + imgUrl);
            console.warn(e);
        };
        xhr.open('GET', imgUrl);
        xhr.send();
        return;
    }
    runWithCachedImage(key, top, left, callback) {
        let cachedElement = this.blobArray.find(d => d[1] === key);
        if (cachedElement[0]) {
            callback(top, left, cachedElement[0], cachedElement[2]);
        }
        else {
            // loading, try again later
            setTimeout(() => {
                this.runWithCachedImage(key, top, left, callback);
            }, 50);
        }
    }
    getImagePromise(location, frameIndex) {
        return new Promise((resolve, reject) => {
            try {
                this.getImage(location, frameIndex, (top, left, blob, imageUrl) => {
                    resolve([top, left, blob, imageUrl]);
                });
            }
            catch (error) {
                console.error(error);
                reject();
            }
        });
    }
    getTileTopLeft(frameIndex) {
        const left = (frameIndex % this.numberOfColumns) * this.tileWidth;
        let top = Math.floor((frameIndex % this.tilesPerFile) / this.numberOfColumns) * this.tileHeight;
        return [top, left];
    }
    getLabel(location, frameIndex, callback) {
        if (!this.metaDataLoaded) {
            setTimeout(() => {
                this.getLabel(location, frameIndex, callback);
            }, 50); // todo fallback
            return;
        }
        // let [top, left] = this.getTileTopLeft(frameIndex);
        let firstIndex = (frameIndex % this.tilesPerFile) * this.tileHeight;
        let bundleIndex = Math.floor(frameIndex / this.tilesPerFile);
        let key = [location, bundleIndex].join('-');
        let cachedElement = this.labelArray.find(d => d[1] === key);
        if (cachedElement) {
            // todo - similar runWithCached logic
            this.runWithCachedLabel(key, firstIndex, callback);
            return;
        }
        const thisIndex = this.nextLabelIndex;
        this._nextLabelIndex = (this.nextLabelIndex + 1) % this.maxBlobCount;
        this.labelArray[thisIndex] = [null, key];
        const labelUrl = `/data/${this.driveId}/label_${location}_${bundleIndex}.pb`;
        protobufjs_1.load("/static/protoDefs/RLE.proto", async (err, root) => {
            if (err) {
                throw err;
            }
            // Obtain a message type
            let ImageLabelsMessage = root.lookupType("imageLabels.ImageLabels");
            let buffer = await d3.buffer(labelUrl);
            // Decode an Uint8Array (browser) or Buffer (node) to a message
            let message = ImageLabelsMessage.decode(new Uint8Array(buffer));
            this.labelArray[thisIndex] = [message, key];
            console.log(message);
            callback(message, firstIndex);
        });
        return;
    }
    runWithCachedLabel(key, firstIndex, callback) {
        let cachedElement = this.labelArray.find(d => d[1] === key);
        if (cachedElement[0]) {
            callback(cachedElement[0], firstIndex);
        }
        else {
            // loading, try again later
            setTimeout(() => {
                this.runWithCachedLabel(key, firstIndex, callback);
            }, 50);
        }
    }
    getLabelPromise(location, frameIndex) {
        return new Promise((resolve, reject) => {
            this.getLabel(location, frameIndex, (rowData, firstIndex) => {
                resolve([rowData, firstIndex]);
            });
        });
    }
    static getLabelValue(rowIdx, colIdx, rowArray) {
        // if this is a bottleneck, this could be improved with quicksearch.
        let row = rowArray.rowList[rowIdx];
        for (let labelRun of row.row) {
            if (labelRun.start <= colIdx && colIdx < labelRun.start + labelRun.length) {
                return labelRun.label;
            }
        }
        return 0;
    }
}
exports.ImageStackDataRequest = ImageStackDataRequest;

},{"d3":42,"protobufjs":43}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DataEvents_1 = require("./DataEvents");
class PointCollection {
    constructor(pointList = []) {
        this._attributeList = [];
        this._length = pointList.length;
        this._Array = pointList;
        this._minMaxCache = new Map();
        this._brushList = new Map();
    }
    get Specification() {
        return this._Specification;
    }
    set Specification(v) {
        this._Specification = v;
    }
    get sourceKey() {
        return this._sourceKey;
    }
    set sourceKey(v) {
        this._sourceKey = v;
    }
    get postfixKey() {
        return this._postfixKey;
    }
    set postfixKey(v) {
        this._postfixKey = v;
    }
    get length() {
        return this._length;
    }
    get attributeList() {
        if (this._attributeList.length === 0) {
            this.initAttributeList();
        }
        return this._attributeList;
    }
    get Array() {
        if (this._Array.length === 0) {
            this._Array = Array.from(this);
        }
        return this._Array;
    }
    get minMaxCache() {
        return this._minMaxCache;
    }
    get brushList() {
        return this._brushList;
    }
    GetFacetOptions() {
        if (!this.Specification.locationMaps) {
            return [];
        }
        let facetOptionList = [];
        for (let key of Object.keys(this.Specification.locationMaps)) {
            let locationMap = this.Specification.locationMaps[key];
            let facetOption = {
                name: key,
                GetFacets: () => { return this.getFacetList(locationMap); }
            };
            facetOptionList.push(facetOption);
        }
        return facetOptionList;
    }
    initAttributeList() {
        let pointList = [...this];
        if (pointList.length > 0) {
            let point = pointList[0];
            for (let key of point.valueMap.keys()) {
                this._attributeList.push(key);
            }
        }
    }
    getMinMax(key) {
        if (this.minMaxCache.has(key)) {
            return this.minMaxCache.get(key);
        }
        let minN = Infinity;
        let maxN = -Infinity;
        for (let point of this) {
            let val = point.valueMap.get(key);
            if (val < minN) {
                minN = val;
            }
            if (val > maxN) {
                maxN = val;
            }
        }
        this.minMaxCache.set(key, [minN, maxN]);
        return [minN, maxN];
    }
    addBrush(brushKey, ...filters) {
        if (!this.brushList.has(brushKey)) {
            this.brushList.set(brushKey, new Map());
        }
        let thisMap = this.brushList.get(brushKey);
        for (let filter of filters) {
            thisMap.set(filter.key, filter.bound);
        }
        this.updateBrush();
    }
    removeBrush(brushKey) {
        this.brushList.delete(brushKey);
        this.updateBrush();
    }
    SetBrushValues() {
        let brushApplied = false;
        for (let point of this) {
            for (let valueFilterMap of this.brushList.values()) {
                for (let [key, bound] of valueFilterMap) {
                    let valueFilter = {
                        key: key,
                        bound: bound
                    };
                    if (!PointCollection.IsInBrush(point, valueFilter)) {
                        point.inBrush = false;
                        brushApplied = true;
                    }
                }
            }
        }
        return brushApplied;
    }
    static IsInBrush(point, valueFilter) {
        let v = point.get(valueFilter.key);
        let [low, high] = valueFilter.bound;
        return low <= v && v <= high && !isNaN(v);
    }
    updateBrush() {
        let event = new Event(DataEvents_1.DataEvents.brushChange);
        document.dispatchEvent(event);
    }
}
exports.PointCollection = PointCollection;

},{"./DataEvents":101}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PointND {
    constructor(pojo) {
        this._valueMap = new Map();
        for (let key in pojo) {
            const m = +pojo[key];
            this._valueMap.set(key, m);
        }
        this._inBrush = true;
        this._parent = null;
    }
    get valueMap() {
        return this._valueMap;
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
    }
    get parent() {
        return this._parent;
    }
    set parent(v) {
        this._parent = v;
    }
    addValue(key, value) {
        this.valueMap.set(key, value);
    }
    get(key) {
        return this.valueMap.get(key);
    }
}
exports.PointND = PointND;

},{}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
class LayoutFramework {
    constructor(container, includeBorders = true) {
        this._container = container;
        this._includeBorders = includeBorders;
    }
    get container() {
        return this._container;
    }
    get includeBorders() {
        return this._includeBorders;
    }
    InitializeLayout(frame) {
        let elementToComponentType = new Map();
        this.addFrame(this.container, frame, elementToComponentType, true);
        return elementToComponentType;
    }
    addFrame(container, frame, lookup, skipThisBorder) {
        container.classList.add("frame");
        if (this.includeBorders && !skipThisBorder) {
            container.classList.add('with-border');
        }
        let dirClass;
        let dirPostFix;
        if (frame.direction === types_1.Direction.column) {
            dirClass = "dir-col";
            dirPostFix = "width";
        }
        else if (frame.direction === types_1.Direction.row) {
            dirClass = "dir-row";
            dirPostFix = "height";
        }
        container.classList.add(dirClass);
        let inlineStyle = "";
        if (typeof frame.minSize !== "undefined") {
            inlineStyle += `min-${dirPostFix}: ${frame.minSize}px; `;
        }
        if (typeof frame.maxSize !== "undefined") {
            inlineStyle += `max-${dirPostFix}: ${frame.maxSize}px; `;
        }
        if (typeof frame.fraction === "undefined") {
            frame.fraction = 1;
        }
        inlineStyle += `flex-grow: ${frame.fraction}; `;
        container.setAttribute("style", inlineStyle);
        if (frame.inside instanceof Array) {
            let lastChildFrame = frame.inside[frame.inside.length - 1];
            for (let childFrame of frame.inside) {
                let childContainer = document.createElement("div");
                container.appendChild(childContainer);
                let isLastChild = childFrame === lastChildFrame;
                this.addFrame(childContainer, childFrame, lookup, isLastChild);
            }
        }
        else {
            lookup.set(container, frame.inside);
        }
    }
}
exports.LayoutFramework = LayoutFramework;

},{"./types":115}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DevlibAlgo {
    static BinarySearchIndex(list, compareFunction) {
        if (list.length === 0) {
            return [undefined, undefined];
        }
        let firstElement = list[0];
        let compareResult = compareFunction(firstElement);
        if (compareResult > 0) {
            return [undefined, 0];
        }
        let lastElement = list[list.length - 1];
        compareResult = compareFunction(lastElement);
        if (compareResult < 0) {
            return [list.length - 1, undefined];
        }
        return DevlibAlgo.BinarySearchRecurse(list, compareFunction, 0, list.length - 1);
    }
    static BinarySearchRecurse(list, compareFunction, idx1, idx2) {
        if (Math.abs(idx1 - idx2) === 1) {
            return [idx1, idx2];
        }
        // if (idx1 === idx2)
        // {
        // 	return [undefined, undefined]
        // }
        let midIndex = Math.floor((idx1 + idx2) / 2);
        let element = list[midIndex];
        let compareResult = compareFunction(element);
        if (compareResult === 0) {
            return midIndex;
        }
        else if (compareResult > 0) {
            return DevlibAlgo.BinarySearchRecurse(list, compareFunction, idx1, midIndex);
        }
        else if (compareResult < 0) {
            return DevlibAlgo.BinarySearchRecurse(list, compareFunction, midIndex, idx2);
        }
    }
    static compareProperty(num, propertyAccessor) {
        return (a) => {
            const aVal = propertyAccessor(a);
            return DevlibAlgo.compareValues(aVal, num);
        };
    }
    static sortOnProperty(propertyAccessor, ascend = true) {
        return (a, b) => {
            const aVal = propertyAccessor(a);
            const bVal = propertyAccessor(b);
            if (ascend) {
                return DevlibAlgo.sortAscend(aVal, bVal);
            }
            else {
                return DevlibAlgo.sortDescend(aVal, bVal);
            }
        };
    }
    static sortAscend(aVal, bVal) {
        return DevlibAlgo.compareValues(aVal, bVal);
    }
    static sortDescend(aVal, bVal) {
        return DevlibAlgo.compareValues(bVal, aVal);
    }
    static compareValues(a, b) {
        let diff = a - b;
        if (Math.abs(diff) > 0) {
            diff /= Math.abs(diff);
        }
        return diff;
    }
}
exports.DevlibAlgo = DevlibAlgo;

},{}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DevlibMath {
    static sumN(...numbers) {
        return numbers.reduce((a, b) => a + b);
    }
    static sum(arr) {
        return DevlibMath.sumN(...arr);
    }
    static averageN(...numbers) {
        const sum = DevlibMath.sum(numbers);
        return sum / numbers.length;
    }
    static average(arr) {
        return DevlibMath.averageN(...arr);
    }
    static meanSquaredError(numbers, v) {
        const squaredErrors = numbers.map((a) => Math.pow(a - v, 2));
        return DevlibMath.average(squaredErrors);
    }
    static varianceN(...numbers) {
        let avg = DevlibMath.average(numbers);
        return DevlibMath.meanSquaredError(numbers, avg);
    }
    static variance(numbers) {
        return DevlibMath.varianceN(...numbers);
    }
    // returns a number in the range [min, max] inclusive on both ends.
    static randomInt(min, max) {
        return Math.floor(Math.random() * (max + 1));
    }
    static nChooseTwo(n) {
        return n * (n - 1) / 2.0;
    }
    static isNumber(text) {
        if (text === "") {
            return false;
        }
        return !isNaN(Number(text));
    }
    static clamp(val, [minVal, maxVal]) {
        return Math.min(Math.max(val, minVal), maxVal);
    }
}
exports.DevlibMath = DevlibMath;

},{}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DevlibTSUtil {
    static async asyncSetTimeout(f, milliDelay) {
        return new Promise((resolve) => {
            setTimeout(() => {
                f();
                resolve();
            }, milliDelay);
        });
    }
    static async makeAsync(f) {
        return DevlibTSUtil.asyncSetTimeout(f, 0);
    }
    static getIconButton(iconKey, callback) {
        let btn = document.createElement('button');
        btn.classList.add('basicIconButton');
        let icon = DevlibTSUtil.getFontAwesomeIcon(iconKey);
        btn.appendChild(icon);
        btn.onclick = callback;
        return btn;
    }
    static getFontAwesomeIcon(iconKey) {
        // <i class="fas fa-{icon}"></i>
        let icon = document.createElement("i");
        icon.classList.add('fas');
        icon.classList.add('fa-' + iconKey);
        return icon;
    }
    static show(element) {
        element.classList.remove('noDisp');
    }
    static hide(element) {
        element.classList.add('noDisp');
    }
    static launchSpinner() {
        const outerId = 'loadingSpinnerContainer';
        if (!DevlibTSUtil.spinnerInDom()) {
            let outer = document.createElement('div');
            outer.classList.add('spinnerOuter');
            outer.id = outerId;
            let imgDiv = document.createElement('div');
            imgDiv.classList.add('spinnerWrapper');
            let inner = document.createElement('img');
            inner.classList.add('spinner');
            inner.src = '/spinner.gif';
            imgDiv.appendChild(inner);
            outer.appendChild(imgDiv);
            let attribution = document.createElement('a');
            attribution.classList.add('attributionLink');
            attribution.href = 'https://loading.io/asset/442473';
            attribution.innerText = "icon 'Double Ring' from loading.io";
            outer.appendChild(attribution);
            document.body.appendChild(outer);
        }
        if (!DevlibTSUtil.spinnerSpinning()) {
            DevlibTSUtil.show(document.getElementById(outerId));
        }
    }
    static stopSpinner() {
        let spinner = document.getElementById('loadingSpinnerContainer');
        if (spinner) {
            DevlibTSUtil.hide(spinner);
        }
    }
    static spinnerInDom() {
        return document.getElementById('loadingSpinnerContainer') !== null;
    }
    static spinnerSpinning() {
        let outer = document.getElementById('loadingSpinnerContainer');
        if (outer && !outer.classList.contains('noDisp')) {
            return true;
        }
        return false;
    }
}
exports.DevlibTSUtil = DevlibTSUtil;

},{}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const CurveListFactory_1 = require("../src/DataModel/CurveListFactory");
const DerivedTrackValueFunctions_1 = require("../src/DataModel/DerivedTrackValueFunctions");
const DerivedPointValueFunctions_1 = require("../src/DataModel/DerivedPointValueFunctions");
const App_1 = require("./App");
let metaContainer = document.querySelector('#metaContainer');
let derivedTrackDataFunctions = DerivedTrackValueFunctions_1.DerivedTrackValueFunctions.GetFunctionList();
let derivedPointDataFunctions = DerivedPointValueFunctions_1.DerivedPointValueFunctions.GetFunctionList();
let app = new App_1.App(metaContainer, CurveListFactory_1.CurveListFactory.CreateCurveListFromCSVObject, derivedTrackDataFunctions, derivedPointDataFunctions);
window.onresize = () => app.OnWindowResize();
d3.json('/static/layouts/defaultLayout.json').then((data) => {
    app.InitializeLayout(data);
    const datasetId = metaContainer.dataset.dataset;
    app.LoadDataset(datasetId);
});

},{"../src/DataModel/CurveListFactory":98,"../src/DataModel/DerivedPointValueFunctions":102,"../src/DataModel/DerivedTrackValueFunctions":103,"./App":79,"d3":42}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Direction;
(function (Direction) {
    Direction["row"] = "row";
    Direction["column"] = "col";
})(Direction = exports.Direction || (exports.Direction = {}));
var ComponentType;
(function (ComponentType) {
    ComponentType["Toolbar"] = "Toolbar";
    ComponentType["Plot2dPathsWidget"] = "Plot2dPathsWidget";
    ComponentType["MetricDistributionWidget"] = "MetricDistributionWidget";
    ComponentType["ImageSelectionWidget"] = "ImageSelectionWidget";
    ComponentType["ImageStackWidget"] = "ImageStackWidget";
    ComponentType["DetailedDistribution"] = "DetailedDistribution";
})(ComponentType = exports.ComponentType || (exports.ComponentType = {}));
var MetricDistributionSubComponentTypes;
(function (MetricDistributionSubComponentTypes) {
    MetricDistributionSubComponentTypes["BasisSelect"] = "BasisSelect";
    MetricDistributionSubComponentTypes["ScatterplotSelect"] = "ScatterplotSelect";
    MetricDistributionSubComponentTypes["DistributionPlot"] = "DistributionPlot";
    MetricDistributionSubComponentTypes["Scatterplot"] = "Scatterplot";
})(MetricDistributionSubComponentTypes = exports.MetricDistributionSubComponentTypes || (exports.MetricDistributionSubComponentTypes = {}));
var MetricDistributionCollectionLevel;
(function (MetricDistributionCollectionLevel) {
    MetricDistributionCollectionLevel["Point"] = "Point";
    MetricDistributionCollectionLevel["Curve"] = "Curve";
})(MetricDistributionCollectionLevel = exports.MetricDistributionCollectionLevel || (exports.MetricDistributionCollectionLevel = {}));
// export type LocationMapList = Map<string, [number, number][]>
// export type LocationMapTemplate = Map<string, string[]>

},{}]},{},[114])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9jb2RlZ2VuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mZXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3BhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWFycmF5L2Rpc3QvZDMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZDMtYXhpcy9kaXN0L2QzLWF4aXMuanMiLCJub2RlX21vZHVsZXMvZDMtYnJ1c2gvZGlzdC9kMy1icnVzaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1jaG9yZC9kaXN0L2QzLWNob3JkLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbGxlY3Rpb24vZGlzdC9kMy1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2Rpc3QvZDMtY29sb3IuanMiLCJub2RlX21vZHVsZXMvZDMtY29udG91ci9kaXN0L2QzLWNvbnRvdXIuanMiLCJub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvZGlzdC9kMy1kaXNwYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kcmFnL2Rpc3QvZDMtZHJhZy5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kc3YvZGlzdC9kMy1kc3YuanMiLCJub2RlX21vZHVsZXMvZDMtZWFzZS9kaXN0L2QzLWVhc2UuanMiLCJub2RlX21vZHVsZXMvZDMtZmV0Y2gvZGlzdC9kMy1mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1mb3JjZS9kaXN0L2QzLWZvcmNlLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9kaXN0L2QzLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1nZW8vZGlzdC9kMy1nZW8uanMiLCJub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzIiwibm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL2Rpc3QvZDMtaW50ZXJwb2xhdGUuanMiLCJub2RlX21vZHVsZXMvZDMtcGF0aC9kaXN0L2QzLXBhdGguanMiLCJub2RlX21vZHVsZXMvZDMtcG9seWdvbi9kaXN0L2QzLXBvbHlnb24uanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvZGlzdC9kMy1xdWFkdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1yYW5kb20vZGlzdC9kMy1yYW5kb20uanMiLCJub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL2Rpc3QvZDMtc2NhbGUtY2hyb21hdGljLmpzIiwibm9kZV9tb2R1bGVzL2QzLXNjYWxlL2Rpc3QvZDMtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2Rpc3QvZDMtc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXNoYXBlL2Rpc3QvZDMtc2hhcGUuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvZGlzdC9kMy10aW1lLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lL2Rpc3QvZDMtdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lci9kaXN0L2QzLXRpbWVyLmpzIiwibm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vZGlzdC9kMy10cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXZvcm9ub2kvZGlzdC9kMy12b3Jvbm9pLmpzIiwibm9kZV9tb2R1bGVzL2QzLXpvb20vZGlzdC9kMy16b29tLmpzIiwibm9kZV9tb2R1bGVzL2QzL2Rpc3QvZDMubm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9jb252ZXJ0ZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9lbmNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VudW0uanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tYXBmaWVsZC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9tZXNzYWdlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9uYW1lc3BhY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL29uZW9mLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3NlcnZpY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdG9rZW5pemUuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3ZlcmlmaWVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyYXBwZXJzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0LmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3F1aWNrc2VsZWN0LmpzL3NyYy9xdWlja1NlbGVjdC5qcyIsInN0YXRpYy9zY3JpcHQvc3JjL0FwcC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvQmFzZUNvbXBvbmVudC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvQmFzZVdpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvRGV0YWlsZWREaXN0cmlidXRpb25XaWRnZXQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL0dyb3VwQnlXaWRnZXQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL0hpc3RvZ3JhbVdpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvSW1hZ2VTZWxlY3Rpb25XaWRnZXQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL0ltYWdlU3RhY2tXaWRnZXQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL0ltYWdlVHJhY2tXaWRnZXQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL01ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvT3B0aW9uU2VsZWN0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9QbG90MmRQYXRoc1dpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvUmljaFRvb2x0aXAudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL1NjYXR0ZXJQbG90V2lkZ2V0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9Ub29sYmFyLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlQ29sbGVjdGlvbi50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9DdXJ2ZUNvbGxlY3Rpb25JdGVyYXRvci50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9DdXJ2ZUl0ZXJhdG9yLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlTGlzdC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9DdXJ2ZUxpc3RGYWN0b3J5LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlTGlzdEl0ZXJhdG9yLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlTkQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvRGF0YUV2ZW50cy50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9EZXJpdmVkUG9pbnRWYWx1ZUZ1bmN0aW9ucy50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9EZXJpdmVkVHJhY2tWYWx1ZUZ1bmN0aW9ucy50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9JbWFnZUZyYW1lLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0ltYWdlTG9jYXRpb24udHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvSW1hZ2VNZXRhRGF0YS50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9JbWFnZVN0YWNrRGF0YVJlcXVlc3QudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvUG9pbnRDb2xsZWN0aW9uLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL1BvaW50TkQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9MYXlvdXRGcmFtZXdvcmsudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9kZXZsaWIvRGV2bGliQWxnby50cyIsInN0YXRpYy9zY3JpcHQvc3JjL2RldmxpYi9EZXZsaWJNYXRoLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvZGV2bGliL0RldmxpYlRTVXRpbC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL21haW4udHMiLCJzdGF0aWMvc2NyaXB0L3NyYy90eXBlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3b0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3NURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNueEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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V0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQy9CLENBQUMsQ0FBQyxDQUFDOzs7OztBQ2RILElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNwQix3QkFBVyxDQUFBO0lBQ1gsMkJBQWMsQ0FBQTtBQUNmLENBQUMsRUFIVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQUdwQjtBQU9ELElBQVksYUFPWDtBQVBELFdBQVksYUFBYTtJQUN4QixvQ0FBbUIsQ0FBQTtJQUNuQix3REFBdUMsQ0FBQTtJQUN2QyxzRUFBcUQsQ0FBQTtJQUNyRCw4REFBNkMsQ0FBQTtJQUM3QyxzREFBcUMsQ0FBQTtJQUNyQyw4REFBNkMsQ0FBQTtBQUM5QyxDQUFDLEVBUFcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFPeEI7QUFNRCxJQUFZLG1DQUtYO0FBTEQsV0FBWSxtQ0FBbUM7SUFDOUMsa0VBQTJCLENBQUE7SUFDM0IsOEVBQXVDLENBQUE7SUFDdkMsNEVBQXFDLENBQUE7SUFDckMsa0VBQTJCLENBQUE7QUFDNUIsQ0FBQyxFQUxXLG1DQUFtQyxHQUFuQywyQ0FBbUMsS0FBbkMsMkNBQW1DLFFBSzlDO0FBRUQsSUFBWSxpQ0FHWDtBQUhELFdBQVksaUNBQWlDO0lBQzVDLG9EQUFlLENBQUE7SUFDZixvREFBZSxDQUFBO0FBQ2hCLENBQUMsRUFIVyxpQ0FBaUMsR0FBakMseUNBQWlDLEtBQWpDLHlDQUFpQyxRQUc1QztBQW1ERCxnRUFBZ0U7QUFDaEUsMERBQTBEIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBjb2RlZ2VuO1xyXG5cclxuLyoqXHJcbiAqIEJlZ2lucyBnZW5lcmF0aW5nIGEgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGZ1bmN0aW9uUGFyYW1zIEZ1bmN0aW9uIHBhcmFtZXRlciBuYW1lc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2Z1bmN0aW9uTmFtZV0gRnVuY3Rpb24gbmFtZSBpZiBub3QgYW5vbnltb3VzXHJcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBBcHBlbmRlciB0aGF0IGFwcGVuZHMgY29kZSB0byB0aGUgZnVuY3Rpb24ncyBib2R5XHJcbiAqL1xyXG5mdW5jdGlvbiBjb2RlZ2VuKGZ1bmN0aW9uUGFyYW1zLCBmdW5jdGlvbk5hbWUpIHtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0eXBlb2YgZnVuY3Rpb25QYXJhbXMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvblBhcmFtcztcclxuICAgICAgICBmdW5jdGlvblBhcmFtcyA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYm9keSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBjb2RlIHRvIHRoZSBmdW5jdGlvbidzIGJvZHkgb3IgZmluaXNoZXMgZ2VuZXJhdGlvbi5cclxuICAgICAqIEB0eXBlZGVmIENvZGVnZW5cclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbZm9ybWF0U3RyaW5nT3JTY29wZV0gRm9ybWF0IHN0cmluZyBvciwgdG8gZmluaXNoIHRoZSBmdW5jdGlvbiwgYW4gb2JqZWN0IG9mIGFkZGl0aW9uYWwgc2NvcGUgdmFyaWFibGVzLCBpZiBhbnlcclxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2Zvcm1hdFBhcmFtc10gRm9ybWF0IHBhcmFtZXRlcnNcclxuICAgICAqIEByZXR1cm5zIHtDb2RlZ2VufEZ1bmN0aW9ufSBJdHNlbGYgb3IgdGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpZiBmaW5pc2hlZFxyXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIGZvcm1hdCBwYXJhbWV0ZXIgY291bnRzIGRvIG5vdCBtYXRjaFxyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gQ29kZWdlbihmb3JtYXRTdHJpbmdPclNjb3BlKSB7XHJcbiAgICAgICAgLy8gbm90ZSB0aGF0IGV4cGxpY2l0IGFycmF5IGhhbmRsaW5nIGJlbG93IG1ha2VzIHRoaXMgfjUwJSBmYXN0ZXJcclxuXHJcbiAgICAgICAgLy8gZmluaXNoIHRoZSBmdW5jdGlvblxyXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0U3RyaW5nT3JTY29wZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlID0gdG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKGNvZGVnZW4udmVyYm9zZSlcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29kZWdlbjogXCIgKyBzb3VyY2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgc291cmNlID0gXCJyZXR1cm4gXCIgKyBzb3VyY2U7XHJcbiAgICAgICAgICAgIGlmIChmb3JtYXRTdHJpbmdPclNjb3BlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGVLZXlzICAgPSBPYmplY3Qua2V5cyhmb3JtYXRTdHJpbmdPclNjb3BlKSxcclxuICAgICAgICAgICAgICAgICAgICBzY29wZVBhcmFtcyA9IG5ldyBBcnJheShzY29wZUtleXMubGVuZ3RoICsgMSksXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVWYWx1ZXMgPSBuZXcgQXJyYXkoc2NvcGVLZXlzLmxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNjb3BlT2Zmc2V0IDwgc2NvcGVLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlUGFyYW1zW3Njb3BlT2Zmc2V0XSA9IHNjb3BlS2V5c1tzY29wZU9mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVWYWx1ZXNbc2NvcGVPZmZzZXRdID0gZm9ybWF0U3RyaW5nT3JTY29wZVtzY29wZUtleXNbc2NvcGVPZmZzZXQrK11dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2NvcGVQYXJhbXNbc2NvcGVPZmZzZXRdID0gc291cmNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLmFwcGx5KG51bGwsIHNjb3BlUGFyYW1zKS5hcHBseShudWxsLCBzY29wZVZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24oc291cmNlKSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBvdGhlcndpc2UgYXBwZW5kIHRvIGJvZHlcclxuICAgICAgICB2YXIgZm9ybWF0UGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgZm9ybWF0T2Zmc2V0ID0gMDtcclxuICAgICAgICB3aGlsZSAoZm9ybWF0T2Zmc2V0IDwgZm9ybWF0UGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgZm9ybWF0UGFyYW1zW2Zvcm1hdE9mZnNldF0gPSBhcmd1bWVudHNbKytmb3JtYXRPZmZzZXRdO1xyXG4gICAgICAgIGZvcm1hdE9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9ybWF0U3RyaW5nT3JTY29wZSA9IGZvcm1hdFN0cmluZ09yU2NvcGUucmVwbGFjZSgvJShbJWRmaWpzXSkvZywgZnVuY3Rpb24gcmVwbGFjZSgkMCwgJDEpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0UGFyYW1zW2Zvcm1hdE9mZnNldCsrXTtcclxuICAgICAgICAgICAgc3dpdGNoICgkMSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImRcIjogY2FzZSBcImZcIjogcmV0dXJuIFN0cmluZyhOdW1iZXIodmFsdWUpKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJpXCI6IHJldHVybiBTdHJpbmcoTWF0aC5mbG9vcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImpcIjogcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzXCI6IHJldHVybiBTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcIiVcIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZm9ybWF0T2Zmc2V0ICE9PSBmb3JtYXRQYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcInBhcmFtZXRlciBjb3VudCBtaXNtYXRjaFwiKTtcclxuICAgICAgICBib2R5LnB1c2goZm9ybWF0U3RyaW5nT3JTY29wZSk7XHJcbiAgICAgICAgcmV0dXJuIENvZGVnZW47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoZnVuY3Rpb25OYW1lT3ZlcnJpZGUpIHtcclxuICAgICAgICByZXR1cm4gXCJmdW5jdGlvbiBcIiArIChmdW5jdGlvbk5hbWVPdmVycmlkZSB8fCBmdW5jdGlvbk5hbWUgfHwgXCJcIikgKyBcIihcIiArIChmdW5jdGlvblBhcmFtcyAmJiBmdW5jdGlvblBhcmFtcy5qb2luKFwiLFwiKSB8fCBcIlwiKSArIFwiKXtcXG4gIFwiICsgYm9keS5qb2luKFwiXFxuICBcIikgKyBcIlxcbn1cIjtcclxuICAgIH1cclxuXHJcbiAgICBDb2RlZ2VuLnRvU3RyaW5nID0gdG9TdHJpbmc7XHJcbiAgICByZXR1cm4gQ29kZWdlbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEJlZ2lucyBnZW5lcmF0aW5nIGEgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvbiBjb2RlZ2VuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZnVuY3Rpb25OYW1lXSBGdW5jdGlvbiBuYW1lIGlmIG5vdCBhbm9ueW1vdXNcclxuICogQHJldHVybnMge0NvZGVnZW59IEFwcGVuZGVyIHRoYXQgYXBwZW5kcyBjb2RlIHRvIHRoZSBmdW5jdGlvbidzIGJvZHlcclxuICogQHZhcmlhdGlvbiAyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgY29kZWdlbiB3aWxsIGxvZyBnZW5lcmF0ZWQgY29kZSB0byBjb25zb2xlLiBVc2VmdWwgZm9yIGRlYnVnZ2luZy5cclxuICogQG5hbWUgdXRpbC5jb2RlZ2VuLnZlcmJvc2VcclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqL1xyXG5jb2RlZ2VuLnZlcmJvc2UgPSBmYWxzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoO1xyXG5cclxudmFyIGFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIiksXHJcbiAgICBpbnF1aXJlICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcclxuXHJcbnZhciBmcyA9IGlucXVpcmUoXCJmc1wiKTtcclxuXHJcbi8qKlxyXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuZmV0Y2h9LlxyXG4gKiBAdHlwZWRlZiBGZXRjaENhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHs/RXJyb3J9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcclxuICogQHBhcmFtIHtzdHJpbmd9IFtjb250ZW50c10gRmlsZSBjb250ZW50cywgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogT3B0aW9ucyBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmZldGNofS5cclxuICogQHR5cGVkZWYgRmV0Y2hPcHRpb25zXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2JpbmFyeT1mYWxzZV0gV2hldGhlciBleHBlY3RpbmcgYSBiaW5hcnkgcmVzcG9uc2VcclxuICogQHByb3BlcnR5IHtib29sZWFufSBbeGhyPWZhbHNlXSBJZiBgdHJ1ZWAsIGZvcmNlcyB0aGUgdXNlIG9mIFhNTEh0dHBSZXF1ZXN0XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIEZpbGUgcGF0aCBvciB1cmxcclxuICogQHBhcmFtIHtGZXRjaE9wdGlvbnN9IG9wdGlvbnMgRmV0Y2ggb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0ZldGNoQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBmZXRjaChmaWxlbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG5cclxuICAgIGlmICghY2FsbGJhY2spXHJcbiAgICAgICAgcmV0dXJuIGFzUHJvbWlzZShmZXRjaCwgdGhpcywgZmlsZW5hbWUsIG9wdGlvbnMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xyXG5cclxuICAgIC8vIGlmIGEgbm9kZS1saWtlIGZpbGVzeXN0ZW0gaXMgcHJlc2VudCwgdHJ5IGl0IGZpcnN0IGJ1dCBmYWxsIGJhY2sgdG8gWEhSIGlmIG5vdGhpbmcgaXMgZm91bmQuXHJcbiAgICBpZiAoIW9wdGlvbnMueGhyICYmIGZzICYmIGZzLnJlYWRGaWxlKVxyXG4gICAgICAgIHJldHVybiBmcy5yZWFkRmlsZShmaWxlbmFtZSwgZnVuY3Rpb24gZmV0Y2hSZWFkRmlsZUNhbGxiYWNrKGVyciwgY29udGVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVyciAmJiB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgICAgICAgID8gZmV0Y2gueGhyKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaylcclxuICAgICAgICAgICAgICAgIDogZXJyXHJcbiAgICAgICAgICAgICAgICA/IGNhbGxiYWNrKGVycilcclxuICAgICAgICAgICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3B0aW9ucy5iaW5hcnkgPyBjb250ZW50cyA6IGNvbnRlbnRzLnRvU3RyaW5nKFwidXRmOFwiKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLy8gdXNlIHRoZSBYSFIgdmVyc2lvbiBvdGhlcndpc2UuXHJcbiAgICByZXR1cm4gZmV0Y2gueGhyKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjayk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGZXRjaGVzIHRoZSBjb250ZW50cyBvZiBhIGZpbGUuXHJcbiAqIEBuYW1lIHV0aWwuZmV0Y2hcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEZpbGUgcGF0aCBvciB1cmxcclxuICogQHBhcmFtIHtGZXRjaENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKiBAdmFyaWF0aW9uIDJcclxuICovXHJcblxyXG4vKipcclxuICogRmV0Y2hlcyB0aGUgY29udGVudHMgb2YgYSBmaWxlLlxyXG4gKiBAbmFtZSB1dGlsLmZldGNoXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBGaWxlIHBhdGggb3IgdXJsXHJcbiAqIEBwYXJhbSB7RmV0Y2hPcHRpb25zfSBbb3B0aW9uc10gRmV0Y2ggb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8VWludDhBcnJheT59IFByb21pc2VcclxuICogQHZhcmlhdGlvbiAzXHJcbiAqL1xyXG5cclxuLyoqL1xyXG5mZXRjaC54aHIgPSBmdW5jdGlvbiBmZXRjaF94aHIoZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlIC8qIHdvcmtzIGV2ZXJ5d2hlcmUgKi8gPSBmdW5jdGlvbiBmZXRjaE9uUmVhZHlTdGF0ZUNoYW5nZSgpIHtcclxuXHJcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAvLyBsb2NhbCBjb3JzIHNlY3VyaXR5IGVycm9ycyByZXR1cm4gc3RhdHVzIDAgLyBlbXB0eSBzdHJpbmcsIHRvby4gYWZhaWsgdGhpcyBjYW5ub3QgYmVcclxuICAgICAgICAvLyByZWxpYWJseSBkaXN0aW5ndWlzaGVkIGZyb20gYW4gYWN0dWFsbHkgZW1wdHkgZmlsZSBmb3Igc2VjdXJpdHkgcmVhc29ucy4gZmVlbCBmcmVlXHJcbiAgICAgICAgLy8gdG8gc2VuZCBhIHB1bGwgcmVxdWVzdCBpZiB5b3UgYXJlIGF3YXJlIG9mIGEgc29sdXRpb24uXHJcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDAgJiYgeGhyLnN0YXR1cyAhPT0gMjAwKVxyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3IoXCJzdGF0dXMgXCIgKyB4aHIuc3RhdHVzKSk7XHJcblxyXG4gICAgICAgIC8vIGlmIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkLCBtYWtlIHN1cmUgdGhhdCBzb21lIHNvcnQgb2YgYXJyYXkgaXMgcmV0dXJuZWQsIGV2ZW4gaWZcclxuICAgICAgICAvLyBBcnJheUJ1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuIHRoZSBiaW5hcnkgc3RyaW5nIGZhbGxiYWNrLCBob3dldmVyLCBpcyB1bnNhZmUuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYmluYXJ5KSB7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSB4aHIucmVzcG9uc2U7XHJcbiAgICAgICAgICAgIGlmICghYnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh4aHIucmVzcG9uc2VUZXh0LmNoYXJDb2RlQXQoaSkgJiAyNTUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IG5ldyBVaW50OEFycmF5KGJ1ZmZlcikgOiBidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChvcHRpb25zLmJpbmFyeSkge1xyXG4gICAgICAgIC8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L1NlbmRpbmdfYW5kX1JlY2VpdmluZ19CaW5hcnlfRGF0YSNSZWNlaXZpbmdfYmluYXJ5X2RhdGFfaW5fb2xkZXJfYnJvd3NlcnNcclxuICAgICAgICBpZiAoXCJvdmVycmlkZU1pbWVUeXBlXCIgaW4geGhyKVxyXG4gICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIik7XHJcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuICAgIH1cclxuXHJcbiAgICB4aHIub3BlbihcIkdFVFwiLCBmaWxlbmFtZSk7XHJcbiAgICB4aHIuc2VuZCgpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgcGF0aCBtb2R1bGUgdG8gcmVzb2x2ZSBVbml4LCBXaW5kb3dzIGFuZCBVUkwgcGF0aHMgYWxpa2UuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBwYXRoID0gZXhwb3J0cztcclxuXHJcbnZhciBpc0Fic29sdXRlID1cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgcGF0aCBpcyBhYnNvbHV0ZS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcGF0aCBpcyBhYnNvbHV0ZVxyXG4gKi9cclxucGF0aC5pc0Fic29sdXRlID0gZnVuY3Rpb24gaXNBYnNvbHV0ZShwYXRoKSB7XHJcbiAgICByZXR1cm4gL14oPzpcXC98XFx3KzopLy50ZXN0KHBhdGgpO1xyXG59O1xyXG5cclxudmFyIG5vcm1hbGl6ZSA9XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3N0cmluZ30gTm9ybWFsaXplZCBwYXRoXHJcbiAqL1xyXG5wYXRoLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XHJcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxyXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIik7XHJcbiAgICB2YXIgcGFydHMgICAgPSBwYXRoLnNwbGl0KFwiL1wiKSxcclxuICAgICAgICBhYnNvbHV0ZSA9IGlzQWJzb2x1dGUocGF0aCksXHJcbiAgICAgICAgcHJlZml4ICAgPSBcIlwiO1xyXG4gICAgaWYgKGFic29sdXRlKVxyXG4gICAgICAgIHByZWZpeCA9IHBhcnRzLnNoaWZ0KCkgKyBcIi9cIjtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOykge1xyXG4gICAgICAgIGlmIChwYXJ0c1tpXSA9PT0gXCIuLlwiKSB7XHJcbiAgICAgICAgICAgIGlmIChpID4gMCAmJiBwYXJ0c1tpIC0gMV0gIT09IFwiLi5cIilcclxuICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZSgtLWksIDIpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChhYnNvbHV0ZSlcclxuICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGFydHNbaV0gPT09IFwiLlwiKVxyXG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICArK2k7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJlZml4ICsgcGFydHMuam9pbihcIi9cIik7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzb2x2ZXMgdGhlIHNwZWNpZmllZCBpbmNsdWRlIHBhdGggYWdhaW5zdCB0aGUgc3BlY2lmaWVkIG9yaWdpbiBwYXRoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luUGF0aCBQYXRoIHRvIHRoZSBvcmlnaW4gZmlsZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5jbHVkZVBhdGggSW5jbHVkZSBwYXRoIHJlbGF0aXZlIHRvIG9yaWdpbiBwYXRoXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FscmVhZHlOb3JtYWxpemVkPWZhbHNlXSBgdHJ1ZWAgaWYgYm90aCBwYXRocyBhcmUgYWxyZWFkeSBrbm93biB0byBiZSBub3JtYWxpemVkXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFBhdGggdG8gdGhlIGluY2x1ZGUgZmlsZVxyXG4gKi9cclxucGF0aC5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShvcmlnaW5QYXRoLCBpbmNsdWRlUGF0aCwgYWxyZWFkeU5vcm1hbGl6ZWQpIHtcclxuICAgIGlmICghYWxyZWFkeU5vcm1hbGl6ZWQpXHJcbiAgICAgICAgaW5jbHVkZVBhdGggPSBub3JtYWxpemUoaW5jbHVkZVBhdGgpO1xyXG4gICAgaWYgKGlzQWJzb2x1dGUoaW5jbHVkZVBhdGgpKVxyXG4gICAgICAgIHJldHVybiBpbmNsdWRlUGF0aDtcclxuICAgIGlmICghYWxyZWFkeU5vcm1hbGl6ZWQpXHJcbiAgICAgICAgb3JpZ2luUGF0aCA9IG5vcm1hbGl6ZShvcmlnaW5QYXRoKTtcclxuICAgIHJldHVybiAob3JpZ2luUGF0aCA9IG9yaWdpblBhdGgucmVwbGFjZSgvKD86XFwvfF4pW14vXSskLywgXCJcIikpLmxlbmd0aCA/IG5vcm1hbGl6ZShvcmlnaW5QYXRoICsgXCIvXCIgKyBpbmNsdWRlUGF0aCkgOiBpbmNsdWRlUGF0aDtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYXJyYXkvIHYxLjIuNCBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBiaXNlY3Rvcihjb21wYXJlKSB7XG4gIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSkgY29tcGFyZSA9IGFzY2VuZGluZ0NvbXBhcmF0b3IoY29tcGFyZSk7XG4gIHJldHVybiB7XG4gICAgbGVmdDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtcbiAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9LFxuICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7XG4gICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiBmdW5jdGlvbihkLCB4KSB7XG4gICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgfTtcbn1cblxudmFyIGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG52YXIgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG52YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuXG5mdW5jdGlvbiBwYWlycyhhcnJheSwgZikge1xuICBpZiAoZiA9PSBudWxsKSBmID0gcGFpcjtcbiAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcCA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IGYocCwgcCA9IGFycmF5WysraV0pO1xuICByZXR1cm4gcGFpcnM7XG59XG5cbmZ1bmN0aW9uIHBhaXIoYSwgYikge1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG5mdW5jdGlvbiBjcm9zcyh2YWx1ZXMwLCB2YWx1ZXMxLCByZWR1Y2UpIHtcbiAgdmFyIG4wID0gdmFsdWVzMC5sZW5ndGgsXG4gICAgICBuMSA9IHZhbHVlczEubGVuZ3RoLFxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4wICogbjEpLFxuICAgICAgaTAsXG4gICAgICBpMSxcbiAgICAgIGksXG4gICAgICB2YWx1ZTA7XG5cbiAgaWYgKHJlZHVjZSA9PSBudWxsKSByZWR1Y2UgPSBwYWlyO1xuXG4gIGZvciAoaTAgPSBpID0gMDsgaTAgPCBuMDsgKytpMCkge1xuICAgIGZvciAodmFsdWUwID0gdmFsdWVzMFtpMF0sIGkxID0gMDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWR1Y2UodmFsdWUwLCB2YWx1ZXMxW2kxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn1cblxuZnVuY3Rpb24gdmFyaWFuY2UodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSAwLFxuICAgICAgaSA9IC0xLFxuICAgICAgbWVhbiA9IDAsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRlbHRhLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtID4gMSkgcmV0dXJuIHN1bSAvIChtIC0gMSk7XG59XG5cbmZ1bmN0aW9uIGRldmlhdGlvbihhcnJheSwgZikge1xuICB2YXIgdiA9IHZhcmlhbmNlKGFycmF5LCBmKTtcbiAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xufVxuXG5mdW5jdGlvbiBleHRlbnQodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWluLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbnZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG52YXIgbWFwID0gYXJyYXkubWFwO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG52YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSxcbiAgICBlNSA9IE1hdGguc3FydCgxMCksXG4gICAgZTIgPSBNYXRoLnNxcnQoMik7XG5cbmZ1bmN0aW9uIHRpY2tzKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgcmV2ZXJzZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4sXG4gICAgICB0aWNrcyxcbiAgICAgIHN0ZXA7XG5cbiAgc3RvcCA9ICtzdG9wLCBzdGFydCA9ICtzdGFydCwgY291bnQgPSArY291bnQ7XG4gIGlmIChzdGFydCA9PT0gc3RvcCAmJiBjb3VudCA+IDApIHJldHVybiBbc3RhcnRdO1xuICBpZiAocmV2ZXJzZSA9IHN0b3AgPCBzdGFydCkgbiA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBuO1xuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xuXG4gIGlmIChzdGVwID4gMCkge1xuICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RvcCAtIHN0YXJ0ICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgKiBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgKiBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0YXJ0IC0gc3RvcCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgLSBpKSAvIHN0ZXA7XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgdGlja3MucmV2ZXJzZSgpO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcDAgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgc3RlcDEgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwMCkgLyBNYXRoLkxOMTApKSxcbiAgICAgIGVycm9yID0gc3RlcDAgLyBzdGVwMTtcbiAgaWYgKGVycm9yID49IGUxMCkgc3RlcDEgKj0gMTA7XG4gIGVsc2UgaWYgKGVycm9yID49IGU1KSBzdGVwMSAqPSA1O1xuICBlbHNlIGlmIChlcnJvciA+PSBlMikgc3RlcDEgKj0gMjtcbiAgcmV0dXJuIHN0b3AgPCBzdGFydCA/IC1zdGVwMSA6IHN0ZXAxO1xufVxuXG5mdW5jdGlvbiBzdHVyZ2VzKHZhbHVlcykge1xuICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcbn1cblxuZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIGRvbWFpbiA9IGV4dGVudCxcbiAgICAgIHRocmVzaG9sZCA9IHN0dXJnZXM7XG5cbiAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICB4LFxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcbiAgICAgICAgeDAgPSB4elswXSxcbiAgICAgICAgeDEgPSB4elsxXSxcbiAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICB0eiA9IHRpY2tTdGVwKHgwLCB4MSwgdHopO1xuICAgICAgdHogPSByYW5nZShNYXRoLmNlaWwoeDAgLyB0eikgKiB0eiwgeDEsIHR6KTsgLy8gZXhjbHVzaXZlXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSB0aHJlc2hvbGRzIG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICB2YXIgbSA9IHR6Lmxlbmd0aDtcbiAgICB3aGlsZSAodHpbMF0gPD0geDApIHR6LnNoaWZ0KCksIC0tbTtcbiAgICB3aGlsZSAodHpbbSAtIDFdID4geDEpIHR6LnBvcCgpLCAtLW07XG5cbiAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXG4gICAgICAgIGJpbjtcblxuICAgIC8vIEluaXRpYWxpemUgYmlucy5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG07ICsraSkge1xuICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgYmluLngwID0gaSA+IDAgPyB0eltpIC0gMV0gOiB4MDtcbiAgICAgIGJpbi54MSA9IGkgPCBtID8gdHpbaV0gOiB4MTtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ24gZGF0YSB0byBiaW5zIGJ5IHZhbHVlLCBpZ25vcmluZyBhbnkgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICBpZiAoeDAgPD0geCAmJiB4IDw9IHgxKSB7XG4gICAgICAgIGJpbnNbYmlzZWN0UmlnaHQodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHZhbHVlb2YgPSBudW1iZXI7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1swXSwgMCwgdmFsdWVzKTtcbiAgaWYgKHAgPj0gMSkgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICB2YXIgbixcbiAgICAgIGkgPSAobiAtIDEpICogcCxcbiAgICAgIGkwID0gTWF0aC5mbG9vcihpKSxcbiAgICAgIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLFxuICAgICAgdmFsdWUxID0gK3ZhbHVlb2YodmFsdWVzW2kwICsgMV0sIGkwICsgMSwgdmFsdWVzKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmZ1bmN0aW9uIGZyZWVkbWFuRGlhY29uaXModmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufVxuXG5mdW5jdGlvbiBzY290dCh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMy41ICogZGV2aWF0aW9uKHZhbHVlcykgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59XG5cbmZ1bmN0aW9uIG1heCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4O1xufVxuXG5mdW5jdGlvbiBtZWFuKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gbixcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtKSByZXR1cm4gc3VtIC8gbTtcbn1cblxuZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG51bWJlcnMgPSBbXTtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1YW50aWxlKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xufVxuXG5mdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLFxuICAgICAgbSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIGogPSAwLFxuICAgICAgbWVyZ2VkLFxuICAgICAgYXJyYXk7XG5cbiAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xuXG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKC0tbSA+PSAwKSB7XG4gICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXJnZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW47XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG5mdW5jdGlvbiBwZXJtdXRlKGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSBwZXJtdXRlc1tpXSA9IGFycmF5W2luZGV4ZXNbaV1dO1xuICByZXR1cm4gcGVybXV0ZXM7XG59XG5cbmZ1bmN0aW9uIHNjYW4odmFsdWVzLCBjb21wYXJlKSB7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgaiA9IDAsXG4gICAgICB4aSxcbiAgICAgIHhqID0gdmFsdWVzW2pdO1xuXG4gIGlmIChjb21wYXJlID09IG51bGwpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBpZiAoY29tcGFyZSh4aSA9IHZhbHVlc1tpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHtcbiAgICAgIHhqID0geGksIGogPSBpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wYXJlKHhqLCB4aikgPT09IDApIHJldHVybiBqO1xufVxuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBpMCwgaTEpIHtcbiAgdmFyIG0gPSAoaTEgPT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IGkxKSAtIChpMCA9IGkwID09IG51bGwgPyAwIDogK2kwKSxcbiAgICAgIHQsXG4gICAgICBpO1xuXG4gIHdoaWxlIChtKSB7XG4gICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdO1xuICAgIGFycmF5W2kgKyBpMF0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZXNbaV0pIHN1bSArPSB2YWx1ZTsgLy8gTm90ZTogemVybyBhbmQgbnVsbCBhcmUgZXF1aXZhbGVudC5cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSBzdW0gKz0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gdHJhbnNwb3NlKG1hdHJpeCkge1xuICBpZiAoIShuID0gbWF0cml4Lmxlbmd0aCkpIHJldHVybiBbXTtcbiAgZm9yICh2YXIgaSA9IC0xLCBtID0gbWluKG1hdHJpeCwgbGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOykge1xuICAgIGZvciAodmFyIGogPSAtMSwgbiwgcm93ID0gdHJhbnNwb3NlW2ldID0gbmV3IEFycmF5KG4pOyArK2ogPCBuOykge1xuICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhbnNwb3NlO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgoZCkge1xuICByZXR1cm4gZC5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHppcCgpIHtcbiAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xufVxuXG5leHBvcnRzLmJpc2VjdCA9IGJpc2VjdFJpZ2h0O1xuZXhwb3J0cy5iaXNlY3RSaWdodCA9IGJpc2VjdFJpZ2h0O1xuZXhwb3J0cy5iaXNlY3RMZWZ0ID0gYmlzZWN0TGVmdDtcbmV4cG9ydHMuYXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuZXhwb3J0cy5iaXNlY3RvciA9IGJpc2VjdG9yO1xuZXhwb3J0cy5jcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5kZXNjZW5kaW5nID0gZGVzY2VuZGluZztcbmV4cG9ydHMuZGV2aWF0aW9uID0gZGV2aWF0aW9uO1xuZXhwb3J0cy5leHRlbnQgPSBleHRlbnQ7XG5leHBvcnRzLmhpc3RvZ3JhbSA9IGhpc3RvZ3JhbTtcbmV4cG9ydHMudGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyA9IGZyZWVkbWFuRGlhY29uaXM7XG5leHBvcnRzLnRocmVzaG9sZFNjb3R0ID0gc2NvdHQ7XG5leHBvcnRzLnRocmVzaG9sZFN0dXJnZXMgPSBzdHVyZ2VzO1xuZXhwb3J0cy5tYXggPSBtYXg7XG5leHBvcnRzLm1lYW4gPSBtZWFuO1xuZXhwb3J0cy5tZWRpYW4gPSBtZWRpYW47XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1pbiA9IG1pbjtcbmV4cG9ydHMucGFpcnMgPSBwYWlycztcbmV4cG9ydHMucGVybXV0ZSA9IHBlcm11dGU7XG5leHBvcnRzLnF1YW50aWxlID0gcXVhbnRpbGU7XG5leHBvcnRzLnJhbmdlID0gcmFuZ2U7XG5leHBvcnRzLnNjYW4gPSBzY2FuO1xuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmV4cG9ydHMuc3VtID0gc3VtO1xuZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuZXhwb3J0cy50aWNrSW5jcmVtZW50ID0gdGlja0luY3JlbWVudDtcbmV4cG9ydHMudGlja1N0ZXAgPSB0aWNrU3RlcDtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy52YXJpYW5jZSA9IHZhcmlhbmNlO1xuZXhwb3J0cy56aXAgPSB6aXA7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWF4aXMvIHYxLjAuMTIgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxudmFyIHRvcCA9IDEsXG4gICAgcmlnaHQgPSAyLFxuICAgIGJvdHRvbSA9IDMsXG4gICAgbGVmdCA9IDQsXG4gICAgZXBzaWxvbiA9IDFlLTY7XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVgoeCkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAoeCArIDAuNSkgKyBcIiwwKVwiO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVZKHkpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyAoeSArIDAuNSkgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICtzY2FsZShkKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2VudGVyKHNjYWxlKSB7XG4gIHZhciBvZmZzZXQgPSBNYXRoLm1heCgwLCBzY2FsZS5iYW5kd2lkdGgoKSAtIDEpIC8gMjsgLy8gQWRqdXN0IGZvciAwLjVweCBvZmZzZXQuXG4gIGlmIChzY2FsZS5yb3VuZCgpKSBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCk7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICtzY2FsZShkKSArIG9mZnNldDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW50ZXJpbmcoKSB7XG4gIHJldHVybiAhdGhpcy5fX2F4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXMob3JpZW50LCBzY2FsZSkge1xuICB2YXIgdGlja0FyZ3VtZW50cyA9IFtdLFxuICAgICAgdGlja1ZhbHVlcyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTaXplSW5uZXIgPSA2LFxuICAgICAgdGlja1NpemVPdXRlciA9IDYsXG4gICAgICB0aWNrUGFkZGluZyA9IDMsXG4gICAgICBrID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBsZWZ0ID8gLTEgOiAxLFxuICAgICAgeCA9IG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT09IHJpZ2h0ID8gXCJ4XCIgOiBcInlcIixcbiAgICAgIHRyYW5zZm9ybSA9IG9yaWVudCA9PT0gdG9wIHx8IG9yaWVudCA9PT0gYm90dG9tID8gdHJhbnNsYXRlWCA6IHRyYW5zbGF0ZVk7XG5cbiAgZnVuY3Rpb24gYXhpcyhjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKSA6IHRpY2tWYWx1ZXMsXG4gICAgICAgIGZvcm1hdCA9IHRpY2tGb3JtYXQgPT0gbnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBpZGVudGl0eSkgOiB0aWNrRm9ybWF0LFxuICAgICAgICBzcGFjaW5nID0gTWF0aC5tYXgodGlja1NpemVJbm5lciwgMCkgKyB0aWNrUGFkZGluZyxcbiAgICAgICAgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpLFxuICAgICAgICByYW5nZTAgPSArcmFuZ2VbMF0gKyAwLjUsXG4gICAgICAgIHJhbmdlMSA9ICtyYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIDAuNSxcbiAgICAgICAgcG9zaXRpb24gPSAoc2NhbGUuYmFuZHdpZHRoID8gY2VudGVyIDogbnVtYmVyKShzY2FsZS5jb3B5KCkpLFxuICAgICAgICBzZWxlY3Rpb24gPSBjb250ZXh0LnNlbGVjdGlvbiA/IGNvbnRleHQuc2VsZWN0aW9uKCkgOiBjb250ZXh0LFxuICAgICAgICBwYXRoID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbbnVsbF0pLFxuICAgICAgICB0aWNrID0gc2VsZWN0aW9uLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEodmFsdWVzLCBzY2FsZSkub3JkZXIoKSxcbiAgICAgICAgdGlja0V4aXQgPSB0aWNrLmV4aXQoKSxcbiAgICAgICAgdGlja0VudGVyID0gdGljay5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKSxcbiAgICAgICAgbGluZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKSxcbiAgICAgICAgdGV4dCA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcblxuICAgIHBhdGggPSBwYXRoLm1lcmdlKHBhdGguZW50ZXIoKS5pbnNlcnQoXCJwYXRoXCIsIFwiLnRpY2tcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKSk7XG5cbiAgICB0aWNrID0gdGljay5tZXJnZSh0aWNrRW50ZXIpO1xuXG4gICAgbGluZSA9IGxpbmUubWVyZ2UodGlja0VudGVyLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcikpO1xuXG4gICAgdGV4dCA9IHRleHQubWVyZ2UodGlja0VudGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiY3VycmVudENvbG9yXCIpXG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAuYXR0cihcImR5XCIsIG9yaWVudCA9PT0gdG9wID8gXCIwZW1cIiA6IG9yaWVudCA9PT0gYm90dG9tID8gXCIwLjcxZW1cIiA6IFwiMC4zMmVtXCIpKTtcblxuICAgIGlmIChjb250ZXh0ICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHBhdGggPSBwYXRoLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0aWNrID0gdGljay50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgbGluZSA9IGxpbmUudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIHRleHQgPSB0ZXh0LnRyYW5zaXRpb24oY29udGV4dCk7XG5cbiAgICAgIHRpY2tFeGl0ID0gdGlja0V4aXQudHJhbnNpdGlvbihjb250ZXh0KVxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGlzRmluaXRlKGQgPSBwb3NpdGlvbihkKSkgPyB0cmFuc2Zvcm0oZCkgOiB0aGlzLmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTsgfSk7XG5cbiAgICAgIHRpY2tFbnRlclxuICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBlcHNpbG9uKVxuICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHsgdmFyIHAgPSB0aGlzLnBhcmVudE5vZGUuX19heGlzOyByZXR1cm4gdHJhbnNmb3JtKHAgJiYgaXNGaW5pdGUocCA9IHAoZCkpID8gcCA6IHBvc2l0aW9uKGQpKTsgfSk7XG4gICAgfVxuXG4gICAgdGlja0V4aXQucmVtb3ZlKCk7XG5cbiAgICBwYXRoXG4gICAgICAgIC5hdHRyKFwiZFwiLCBvcmllbnQgPT09IGxlZnQgfHwgb3JpZW50ID09IHJpZ2h0XG4gICAgICAgICAgICA/ICh0aWNrU2l6ZU91dGVyID8gXCJNXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiLFwiICsgcmFuZ2UwICsgXCJIMC41VlwiICsgcmFuZ2UxICsgXCJIXCIgKyBrICogdGlja1NpemVPdXRlciA6IFwiTTAuNSxcIiArIHJhbmdlMCArIFwiVlwiICsgcmFuZ2UxKVxuICAgICAgICAgICAgOiAodGlja1NpemVPdXRlciA/IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiVjAuNUhcIiArIHJhbmdlMSArIFwiVlwiICsgayAqIHRpY2tTaXplT3V0ZXIgOiBcIk1cIiArIHJhbmdlMCArIFwiLDAuNUhcIiArIHJhbmdlMSkpO1xuXG4gICAgdGlja1xuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNmb3JtKHBvc2l0aW9uKGQpKTsgfSk7XG5cbiAgICBsaW5lXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpO1xuXG4gICAgdGV4dFxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgIHNlbGVjdGlvbi5maWx0ZXIoZW50ZXJpbmcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJzYW5zLXNlcmlmXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgb3JpZW50ID09PSByaWdodCA/IFwic3RhcnRcIiA6IG9yaWVudCA9PT0gbGVmdCA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKTtcblxuICAgIHNlbGVjdGlvblxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHsgdGhpcy5fX2F4aXMgPSBwb3NpdGlvbjsgfSk7XG4gIH1cblxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlID0gXywgYXhpcykgOiBzY2FsZTtcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrQXJndW1lbnRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tBcmd1bWVudHMgPSBfID09IG51bGwgPyBbXSA6IHNsaWNlLmNhbGwoXyksIGF4aXMpIDogdGlja0FyZ3VtZW50cy5zbGljZSgpO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrVmFsdWVzID0gXyA9PSBudWxsID8gbnVsbCA6IHNsaWNlLmNhbGwoXyksIGF4aXMpIDogdGlja1ZhbHVlcyAmJiB0aWNrVmFsdWVzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tGb3JtYXQgPSBfLCBheGlzKSA6IHRpY2tGb3JtYXQ7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gdGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZUlubmVyO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemVPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVPdXRlcjtcbiAgfTtcblxuICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tQYWRkaW5nID0gK18sIGF4aXMpIDogdGlja1BhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXModG9wLCBzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNSaWdodChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhyaWdodCwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzQm90dG9tKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhsZWZ0LCBzY2FsZSk7XG59XG5cbmV4cG9ydHMuYXhpc1RvcCA9IGF4aXNUb3A7XG5leHBvcnRzLmF4aXNSaWdodCA9IGF4aXNSaWdodDtcbmV4cG9ydHMuYXhpc0JvdHRvbSA9IGF4aXNCb3R0b207XG5leHBvcnRzLmF4aXNMZWZ0ID0gYXhpc0xlZnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWJydXNoLyB2MS4xLjUgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy1kcmFnJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy10cmFuc2l0aW9uJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtZGlzcGF0Y2gnLCAnZDMtZHJhZycsICdkMy1pbnRlcnBvbGF0ZScsICdkMy1zZWxlY3Rpb24nLCAnZDMtdHJhbnNpdGlvbiddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNEaXNwYXRjaCwgZDNEcmFnLCBkM0ludGVycG9sYXRlLCBkM1NlbGVjdGlvbiwgZDNUcmFuc2l0aW9uKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIEJydXNoRXZlbnQodGFyZ2V0LCB0eXBlLCBzZWxlY3Rpb24pIHtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbm9ldmVudCgpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbnZhciBNT0RFX0RSQUcgPSB7bmFtZTogXCJkcmFnXCJ9LFxuICAgIE1PREVfU1BBQ0UgPSB7bmFtZTogXCJzcGFjZVwifSxcbiAgICBNT0RFX0hBTkRMRSA9IHtuYW1lOiBcImhhbmRsZVwifSxcbiAgICBNT0RFX0NFTlRFUiA9IHtuYW1lOiBcImNlbnRlclwifTtcblxuZnVuY3Rpb24gbnVtYmVyMShlKSB7XG4gIHJldHVybiBbK2VbMF0sICtlWzFdXTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyMihlKSB7XG4gIHJldHVybiBbbnVtYmVyMShlWzBdKSwgbnVtYmVyMShlWzFdKV07XG59XG5cbmZ1bmN0aW9uIHRvdWNoZXIoaWRlbnRpZmllcikge1xuICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgcmV0dXJuIGQzU2VsZWN0aW9uLnRvdWNoKHRhcmdldCwgZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcywgaWRlbnRpZmllcik7XG4gIH07XG59XG5cbnZhciBYID0ge1xuICBuYW1lOiBcInhcIixcbiAgaGFuZGxlczogW1wid1wiLCBcImVcIl0ubWFwKHR5cGUpLFxuICBpbnB1dDogZnVuY3Rpb24oeCwgZSkgeyByZXR1cm4geCA9PSBudWxsID8gbnVsbCA6IFtbK3hbMF0sIGVbMF1bMV1dLCBbK3hbMV0sIGVbMV1bMV1dXTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHkgJiYgW3h5WzBdWzBdLCB4eVsxXVswXV07IH1cbn07XG5cbnZhciBZID0ge1xuICBuYW1lOiBcInlcIixcbiAgaGFuZGxlczogW1wiblwiLCBcInNcIl0ubWFwKHR5cGUpLFxuICBpbnB1dDogZnVuY3Rpb24oeSwgZSkgeyByZXR1cm4geSA9PSBudWxsID8gbnVsbCA6IFtbZVswXVswXSwgK3lbMF1dLCBbZVsxXVswXSwgK3lbMV1dXTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHkgJiYgW3h5WzBdWzFdLCB4eVsxXVsxXV07IH1cbn07XG5cbnZhciBYWSA9IHtcbiAgbmFtZTogXCJ4eVwiLFxuICBoYW5kbGVzOiBbXCJuXCIsIFwid1wiLCBcImVcIiwgXCJzXCIsIFwibndcIiwgXCJuZVwiLCBcInN3XCIsIFwic2VcIl0ubWFwKHR5cGUpLFxuICBpbnB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5ID09IG51bGwgPyBudWxsIDogbnVtYmVyMih4eSk7IH0sXG4gIG91dHB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5OyB9XG59O1xuXG52YXIgY3Vyc29ycyA9IHtcbiAgb3ZlcmxheTogXCJjcm9zc2hhaXJcIixcbiAgc2VsZWN0aW9uOiBcIm1vdmVcIixcbiAgbjogXCJucy1yZXNpemVcIixcbiAgZTogXCJldy1yZXNpemVcIixcbiAgczogXCJucy1yZXNpemVcIixcbiAgdzogXCJldy1yZXNpemVcIixcbiAgbnc6IFwibndzZS1yZXNpemVcIixcbiAgbmU6IFwibmVzdy1yZXNpemVcIixcbiAgc2U6IFwibndzZS1yZXNpemVcIixcbiAgc3c6IFwibmVzdy1yZXNpemVcIlxufTtcblxudmFyIGZsaXBYID0ge1xuICBlOiBcIndcIixcbiAgdzogXCJlXCIsXG4gIG53OiBcIm5lXCIsXG4gIG5lOiBcIm53XCIsXG4gIHNlOiBcInN3XCIsXG4gIHN3OiBcInNlXCJcbn07XG5cbnZhciBmbGlwWSA9IHtcbiAgbjogXCJzXCIsXG4gIHM6IFwiblwiLFxuICBudzogXCJzd1wiLFxuICBuZTogXCJzZVwiLFxuICBzZTogXCJuZVwiLFxuICBzdzogXCJud1wiXG59O1xuXG52YXIgc2lnbnNYID0ge1xuICBvdmVybGF5OiArMSxcbiAgc2VsZWN0aW9uOiArMSxcbiAgbjogbnVsbCxcbiAgZTogKzEsXG4gIHM6IG51bGwsXG4gIHc6IC0xLFxuICBudzogLTEsXG4gIG5lOiArMSxcbiAgc2U6ICsxLFxuICBzdzogLTFcbn07XG5cbnZhciBzaWduc1kgPSB7XG4gIG92ZXJsYXk6ICsxLFxuICBzZWxlY3Rpb246ICsxLFxuICBuOiAtMSxcbiAgZTogbnVsbCxcbiAgczogKzEsXG4gIHc6IG51bGwsXG4gIG53OiAtMSxcbiAgbmU6IC0xLFxuICBzZTogKzEsXG4gIHN3OiArMVxufTtcblxuZnVuY3Rpb24gdHlwZSh0KSB7XG4gIHJldHVybiB7dHlwZTogdH07XG59XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFkM1NlbGVjdGlvbi5ldmVudC5jdHJsS2V5ICYmICFkM1NlbGVjdGlvbi5ldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFeHRlbnQoKSB7XG4gIHZhciBzdmcgPSB0aGlzLm93bmVyU1ZHRWxlbWVudCB8fCB0aGlzO1xuICBpZiAoc3ZnLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICBzdmcgPSBzdmcudmlld0JveC5iYXNlVmFsO1xuICAgIHJldHVybiBbW3N2Zy54LCBzdmcueV0sIFtzdmcueCArIHN2Zy53aWR0aCwgc3ZnLnkgKyBzdmcuaGVpZ2h0XV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtzdmcud2lkdGguYmFzZVZhbC52YWx1ZSwgc3ZnLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbi8vIExpa2UgZDMubG9jYWwsIGJ1dCB3aXRoIHRoZSBuYW1lIOKAnF9fYnJ1c2jigJ0gcmF0aGVyIHRoYW4gYXV0by1nZW5lcmF0ZWQuXG5mdW5jdGlvbiBsb2NhbChub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX2JydXNoKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICByZXR1cm4gbm9kZS5fX2JydXNoO1xufVxuXG5mdW5jdGlvbiBlbXB0eShleHRlbnQpIHtcbiAgcmV0dXJuIGV4dGVudFswXVswXSA9PT0gZXh0ZW50WzFdWzBdXG4gICAgICB8fCBleHRlbnRbMF1bMV0gPT09IGV4dGVudFsxXVsxXTtcbn1cblxuZnVuY3Rpb24gYnJ1c2hTZWxlY3Rpb24obm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl9fYnJ1c2g7XG4gIHJldHVybiBzdGF0ZSA/IHN0YXRlLmRpbS5vdXRwdXQoc3RhdGUuc2VsZWN0aW9uKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGJydXNoWCgpIHtcbiAgcmV0dXJuIGJydXNoJDEoWCk7XG59XG5cbmZ1bmN0aW9uIGJydXNoWSgpIHtcbiAgcmV0dXJuIGJydXNoJDEoWSk7XG59XG5cbmZ1bmN0aW9uIGJydXNoKCkge1xuICByZXR1cm4gYnJ1c2gkMShYWSk7XG59XG5cbmZ1bmN0aW9uIGJydXNoJDEoZGltKSB7XG4gIHZhciBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBrZXlzID0gdHJ1ZSxcbiAgICAgIGxpc3RlbmVycyA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJzdGFydFwiLCBcImJydXNoXCIsIFwiZW5kXCIpLFxuICAgICAgaGFuZGxlU2l6ZSA9IDYsXG4gICAgICB0b3VjaGVuZGluZztcblxuICBmdW5jdGlvbiBicnVzaChncm91cCkge1xuICAgIHZhciBvdmVybGF5ID0gZ3JvdXBcbiAgICAgICAgLnByb3BlcnR5KFwiX19icnVzaFwiLCBpbml0aWFsaXplKVxuICAgICAgLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpXG4gICAgICAuZGF0YShbdHlwZShcIm92ZXJsYXlcIildKTtcblxuICAgIG92ZXJsYXkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJvdmVybGF5XCIpXG4gICAgICAgIC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIilcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5vdmVybGF5KVxuICAgICAgLm1lcmdlKG92ZXJsYXkpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBleHRlbnQgPSBsb2NhbCh0aGlzKS5leHRlbnQ7XG4gICAgICAgICAgZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBleHRlbnRbMF1bMF0pXG4gICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBleHRlbnRbMF1bMV0pXG4gICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdKVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9KTtcblxuICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIilcbiAgICAgIC5kYXRhKFt0eXBlKFwic2VsZWN0aW9uXCIpXSlcbiAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdGlvblwiKVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzLnNlbGVjdGlvbilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzc3N1wiKVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwLjMpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiI2ZmZlwiKVxuICAgICAgICAuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLCBcImNyaXNwRWRnZXNcIik7XG5cbiAgICB2YXIgaGFuZGxlID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmhhbmRsZVwiKVxuICAgICAgLmRhdGEoZGltLmhhbmRsZXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZTsgfSk7XG5cbiAgICBoYW5kbGUuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgaGFuZGxlLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiaGFuZGxlIGhhbmRsZS0tXCIgKyBkLnR5cGU7IH0pXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGN1cnNvcnNbZC50eXBlXTsgfSk7XG5cbiAgICBncm91cFxuICAgICAgICAuZWFjaChyZWRyYXcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKVxuICAgICAgICAub24oXCJtb3VzZWRvd24uYnJ1c2hcIiwgc3RhcnRlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmJydXNoXCIsIHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS5icnVzaFwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5icnVzaCB0b3VjaGNhbmNlbC5icnVzaFwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICBicnVzaC5tb3ZlID0gZnVuY3Rpb24oZ3JvdXAsIHNlbGVjdGlvbikge1xuICAgIGlmIChncm91cC5zZWxlY3Rpb24pIHtcbiAgICAgIGdyb3VwXG4gICAgICAgICAgLm9uKFwic3RhcnQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7IGVtaXR0ZXIodGhpcywgYXJndW1lbnRzKS5iZWZvcmVzdGFydCgpLnN0YXJ0KCk7IH0pXG4gICAgICAgICAgLm9uKFwiaW50ZXJydXB0LmJydXNoIGVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHsgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmVuZCgpOyB9KVxuICAgICAgICAgIC50d2VlbihcImJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhhdC5fX2JydXNoLFxuICAgICAgICAgICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24gPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc2VsZWN0aW9uLCBzdGF0ZS5leHRlbnQpLFxuICAgICAgICAgICAgICAgIGkgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlKHNlbGVjdGlvbjAsIHNlbGVjdGlvbjEpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0d2Vlbih0KSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHQgPT09IDEgJiYgc2VsZWN0aW9uMSA9PT0gbnVsbCA/IG51bGwgOiBpKHQpO1xuICAgICAgICAgICAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICAgICAgICAgICAgZW1pdC5icnVzaCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uMCAhPT0gbnVsbCAmJiBzZWxlY3Rpb24xICE9PSBudWxsID8gdHdlZW4gOiB0d2VlbigxKTtcbiAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBcbiAgICAgICAgICAuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhhdC5fX2JydXNoLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjEgPSBkaW0uaW5wdXQodHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0aW9uLmFwcGx5KHRoYXQsIGFyZ3MpIDogc2VsZWN0aW9uLCBzdGF0ZS5leHRlbnQpLFxuICAgICAgICAgICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3MpLmJlZm9yZXN0YXJ0KCk7XG5cbiAgICAgICAgICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhhdCk7XG4gICAgICAgICAgICBzdGF0ZS5zZWxlY3Rpb24gPSBzZWxlY3Rpb24xID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbjE7XG4gICAgICAgICAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICAgICAgICAgIGVtaXQuc3RhcnQoKS5icnVzaCgpLmVuZCgpO1xuICAgICAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBicnVzaC5jbGVhciA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgYnJ1c2gubW92ZShncm91cCwgbnVsbCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgIHZhciBncm91cCA9IGQzU2VsZWN0aW9uLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgc2VsZWN0aW9uID0gbG9jYWwodGhpcykuc2VsZWN0aW9uO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcInhcIiwgc2VsZWN0aW9uWzBdWzBdKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBzZWxlY3Rpb25bMF1bMV0pXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBzZWxlY3Rpb25bMV1bMF0gLSBzZWxlY3Rpb25bMF1bMF0pXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgc2VsZWN0aW9uWzFdWzFdIC0gc2VsZWN0aW9uWzBdWzFdKTtcblxuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLmhhbmRsZVwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlW2QudHlwZS5sZW5ndGggLSAxXSA9PT0gXCJlXCIgPyBzZWxlY3Rpb25bMV1bMF0gLSBoYW5kbGVTaXplIC8gMiA6IHNlbGVjdGlvblswXVswXSAtIGhhbmRsZVNpemUgLyAyOyB9KVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGVbMF0gPT09IFwic1wiID8gc2VsZWN0aW9uWzFdWzFdIC0gaGFuZGxlU2l6ZSAvIDIgOiBzZWxlY3Rpb25bMF1bMV0gLSBoYW5kbGVTaXplIC8gMjsgfSlcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZSA9PT0gXCJuXCIgfHwgZC50eXBlID09PSBcInNcIiA/IHNlbGVjdGlvblsxXVswXSAtIHNlbGVjdGlvblswXVswXSArIGhhbmRsZVNpemUgOiBoYW5kbGVTaXplOyB9KVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZSA9PT0gXCJlXCIgfHwgZC50eXBlID09PSBcIndcIiA/IHNlbGVjdGlvblsxXVsxXSAtIHNlbGVjdGlvblswXVsxXSArIGhhbmRsZVNpemUgOiBoYW5kbGVTaXplOyB9KTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb24sLmhhbmRsZVwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXR0ZXIodGhhdCwgYXJncywgY2xlYW4pIHtcbiAgICByZXR1cm4gKCFjbGVhbiAmJiB0aGF0Ll9fYnJ1c2guZW1pdHRlcikgfHwgbmV3IEVtaXR0ZXIodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBFbWl0dGVyKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5zdGF0ZSA9IHRoYXQuX19icnVzaDtcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gIH1cblxuICBFbWl0dGVyLnByb3RvdHlwZSA9IHtcbiAgICBiZWZvcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkgdGhpcy5zdGF0ZS5lbWl0dGVyID0gdGhpcywgdGhpcy5zdGFydGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0aW5nKSB0aGlzLnN0YXJ0aW5nID0gZmFsc2UsIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgZWxzZSB0aGlzLmVtaXQoXCJicnVzaFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYnJ1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KFwiYnJ1c2hcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkgZGVsZXRlIHRoaXMuc3RhdGUuZW1pdHRlciwgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBkM1NlbGVjdGlvbi5jdXN0b21FdmVudChuZXcgQnJ1c2hFdmVudChicnVzaCwgdHlwZSwgZGltLm91dHB1dCh0aGlzLnN0YXRlLnNlbGVjdGlvbikpLCBsaXN0ZW5lcnMuYXBwbHksIGxpc3RlbmVycywgW3R5cGUsIHRoaXMudGhhdCwgdGhpcy5hcmdzXSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHN0YXJ0ZWQoKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nICYmICFkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzKSByZXR1cm47XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICB0eXBlID0gZDNTZWxlY3Rpb24uZXZlbnQudGFyZ2V0Ll9fZGF0YV9fLnR5cGUsXG4gICAgICAgIG1vZGUgPSAoa2V5cyAmJiBkM1NlbGVjdGlvbi5ldmVudC5tZXRhS2V5ID8gdHlwZSA9IFwib3ZlcmxheVwiIDogdHlwZSkgPT09IFwic2VsZWN0aW9uXCIgPyBNT0RFX0RSQUcgOiAoa2V5cyAmJiBkM1NlbGVjdGlvbi5ldmVudC5hbHRLZXkgPyBNT0RFX0NFTlRFUiA6IE1PREVfSEFORExFKSxcbiAgICAgICAgc2lnblggPSBkaW0gPT09IFkgPyBudWxsIDogc2lnbnNYW3R5cGVdLFxuICAgICAgICBzaWduWSA9IGRpbSA9PT0gWCA/IG51bGwgOiBzaWduc1lbdHlwZV0sXG4gICAgICAgIHN0YXRlID0gbG9jYWwodGhhdCksXG4gICAgICAgIGV4dGVudCA9IHN0YXRlLmV4dGVudCxcbiAgICAgICAgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICBXID0gZXh0ZW50WzBdWzBdLCB3MCwgdzEsXG4gICAgICAgIE4gPSBleHRlbnRbMF1bMV0sIG4wLCBuMSxcbiAgICAgICAgRSA9IGV4dGVudFsxXVswXSwgZTAsIGUxLFxuICAgICAgICBTID0gZXh0ZW50WzFdWzFdLCBzMCwgczEsXG4gICAgICAgIGR4ID0gMCxcbiAgICAgICAgZHkgPSAwLFxuICAgICAgICBtb3ZpbmcsXG4gICAgICAgIHNoaWZ0aW5nID0gc2lnblggJiYgc2lnblkgJiYga2V5cyAmJiBkM1NlbGVjdGlvbi5ldmVudC5zaGlmdEtleSxcbiAgICAgICAgbG9ja1gsXG4gICAgICAgIGxvY2tZLFxuICAgICAgICBwb2ludGVyID0gZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcyA/IHRvdWNoZXIoZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uaWRlbnRpZmllcikgOiBkM1NlbGVjdGlvbi5tb3VzZSxcbiAgICAgICAgcG9pbnQwID0gcG9pbnRlcih0aGF0KSxcbiAgICAgICAgcG9pbnQgPSBwb2ludDAsXG4gICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3VtZW50cywgdHJ1ZSkuYmVmb3Jlc3RhcnQoKTtcblxuICAgIGlmICh0eXBlID09PSBcIm92ZXJsYXlcIikge1xuICAgICAgaWYgKHNlbGVjdGlvbikgbW92aW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IFtcbiAgICAgICAgW3cwID0gZGltID09PSBZID8gVyA6IHBvaW50MFswXSwgbjAgPSBkaW0gPT09IFggPyBOIDogcG9pbnQwWzFdXSxcbiAgICAgICAgW2UwID0gZGltID09PSBZID8gRSA6IHcwLCBzMCA9IGRpbSA9PT0gWCA/IFMgOiBuMF1cbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHcwID0gc2VsZWN0aW9uWzBdWzBdO1xuICAgICAgbjAgPSBzZWxlY3Rpb25bMF1bMV07XG4gICAgICBlMCA9IHNlbGVjdGlvblsxXVswXTtcbiAgICAgIHMwID0gc2VsZWN0aW9uWzFdWzFdO1xuICAgIH1cblxuICAgIHcxID0gdzA7XG4gICAgbjEgPSBuMDtcbiAgICBlMSA9IGUwO1xuICAgIHMxID0gczA7XG5cbiAgICB2YXIgZ3JvdXAgPSBkM1NlbGVjdGlvbi5zZWxlY3QodGhhdClcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cbiAgICB2YXIgb3ZlcmxheSA9IGdyb3VwLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZV0pO1xuXG4gICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIGVtaXQubW92ZWQgPSBtb3ZlZDtcbiAgICAgIGVtaXQuZW5kZWQgPSBlbmRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldylcbiAgICAgICAgICAub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbW92ZWQsIHRydWUpXG4gICAgICAgICAgLm9uKFwibW91c2V1cC5icnVzaFwiLCBlbmRlZCwgdHJ1ZSk7XG4gICAgICBpZiAoa2V5cykgdmlld1xuICAgICAgICAgIC5vbihcImtleWRvd24uYnJ1c2hcIiwga2V5ZG93bmVkLCB0cnVlKVxuICAgICAgICAgIC5vbihcImtleXVwLmJydXNoXCIsIGtleXVwcGVkLCB0cnVlKTtcblxuICAgICAgZDNEcmFnLmRyYWdEaXNhYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpO1xuICAgIH1cblxuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBkM1RyYW5zaXRpb24uaW50ZXJydXB0KHRoYXQpO1xuICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgIGVtaXQuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgdmFyIHBvaW50MSA9IHBvaW50ZXIodGhhdCk7XG4gICAgICBpZiAoc2hpZnRpbmcgJiYgIWxvY2tYICYmICFsb2NrWSkge1xuICAgICAgICBpZiAoTWF0aC5hYnMocG9pbnQxWzBdIC0gcG9pbnRbMF0pID4gTWF0aC5hYnMocG9pbnQxWzFdIC0gcG9pbnRbMV0pKSBsb2NrWSA9IHRydWU7XG4gICAgICAgIGVsc2UgbG9ja1ggPSB0cnVlO1xuICAgICAgfVxuICAgICAgcG9pbnQgPSBwb2ludDE7XG4gICAgICBtb3ZpbmcgPSB0cnVlO1xuICAgICAgbm9ldmVudCgpO1xuICAgICAgbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmUoKSB7XG4gICAgICB2YXIgdDtcblxuICAgICAgZHggPSBwb2ludFswXSAtIHBvaW50MFswXTtcbiAgICAgIGR5ID0gcG9pbnRbMV0gLSBwb2ludDBbMV07XG5cbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIE1PREVfU1BBQ0U6XG4gICAgICAgIGNhc2UgTU9ERV9EUkFHOiB7XG4gICAgICAgICAgaWYgKHNpZ25YKSBkeCA9IE1hdGgubWF4KFcgLSB3MCwgTWF0aC5taW4oRSAtIGUwLCBkeCkpLCB3MSA9IHcwICsgZHgsIGUxID0gZTAgKyBkeDtcbiAgICAgICAgICBpZiAoc2lnblkpIGR5ID0gTWF0aC5tYXgoTiAtIG4wLCBNYXRoLm1pbihTIC0gczAsIGR5KSksIG4xID0gbjAgKyBkeSwgczEgPSBzMCArIGR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTU9ERV9IQU5ETEU6IHtcbiAgICAgICAgICBpZiAoc2lnblggPCAwKSBkeCA9IE1hdGgubWF4KFcgLSB3MCwgTWF0aC5taW4oRSAtIHcwLCBkeCkpLCB3MSA9IHcwICsgZHgsIGUxID0gZTA7XG4gICAgICAgICAgZWxzZSBpZiAoc2lnblggPiAwKSBkeCA9IE1hdGgubWF4KFcgLSBlMCwgTWF0aC5taW4oRSAtIGUwLCBkeCkpLCB3MSA9IHcwLCBlMSA9IGUwICsgZHg7XG4gICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgZHkgPSBNYXRoLm1heChOIC0gbjAsIE1hdGgubWluKFMgLSBuMCwgZHkpKSwgbjEgPSBuMCArIGR5LCBzMSA9IHMwO1xuICAgICAgICAgIGVsc2UgaWYgKHNpZ25ZID4gMCkgZHkgPSBNYXRoLm1heChOIC0gczAsIE1hdGgubWluKFMgLSBzMCwgZHkpKSwgbjEgPSBuMCwgczEgPSBzMCArIGR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTU9ERV9DRU5URVI6IHtcbiAgICAgICAgICBpZiAoc2lnblgpIHcxID0gTWF0aC5tYXgoVywgTWF0aC5taW4oRSwgdzAgLSBkeCAqIHNpZ25YKSksIGUxID0gTWF0aC5tYXgoVywgTWF0aC5taW4oRSwgZTAgKyBkeCAqIHNpZ25YKSk7XG4gICAgICAgICAgaWYgKHNpZ25ZKSBuMSA9IE1hdGgubWF4KE4sIE1hdGgubWluKFMsIG4wIC0gZHkgKiBzaWduWSkpLCBzMSA9IE1hdGgubWF4KE4sIE1hdGgubWluKFMsIHMwICsgZHkgKiBzaWduWSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlMSA8IHcxKSB7XG4gICAgICAgIHNpZ25YICo9IC0xO1xuICAgICAgICB0ID0gdzAsIHcwID0gZTAsIGUwID0gdDtcbiAgICAgICAgdCA9IHcxLCB3MSA9IGUxLCBlMSA9IHQ7XG4gICAgICAgIGlmICh0eXBlIGluIGZsaXBYKSBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlID0gZmxpcFhbdHlwZV1dKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMxIDwgbjEpIHtcbiAgICAgICAgc2lnblkgKj0gLTE7XG4gICAgICAgIHQgPSBuMCwgbjAgPSBzMCwgczAgPSB0O1xuICAgICAgICB0ID0gbjEsIG4xID0gczEsIHMxID0gdDtcbiAgICAgICAgaWYgKHR5cGUgaW4gZmxpcFkpIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGUgPSBmbGlwWVt0eXBlXV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247IC8vIE1heSBiZSBzZXQgYnkgYnJ1c2gubW92ZSFcbiAgICAgIGlmIChsb2NrWCkgdzEgPSBzZWxlY3Rpb25bMF1bMF0sIGUxID0gc2VsZWN0aW9uWzFdWzBdO1xuICAgICAgaWYgKGxvY2tZKSBuMSA9IHNlbGVjdGlvblswXVsxXSwgczEgPSBzZWxlY3Rpb25bMV1bMV07XG5cbiAgICAgIGlmIChzZWxlY3Rpb25bMF1bMF0gIT09IHcxXG4gICAgICAgICAgfHwgc2VsZWN0aW9uWzBdWzFdICE9PSBuMVxuICAgICAgICAgIHx8IHNlbGVjdGlvblsxXVswXSAhPT0gZTFcbiAgICAgICAgICB8fCBzZWxlY3Rpb25bMV1bMV0gIT09IHMxKSB7XG4gICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IFtbdzEsIG4xXSwgW2UxLCBzMV1dO1xuICAgICAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICAgICAgZW1pdC5icnVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgbm9wcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICAgICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQzRHJhZy5kcmFnRW5hYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcsIG1vdmluZyk7XG4gICAgICAgIHZpZXcub24oXCJrZXlkb3duLmJydXNoIGtleXVwLmJydXNoIG1vdXNlbW92ZS5icnVzaCBtb3VzZXVwLmJydXNoXCIsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ3JvdXAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpO1xuICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMub3ZlcmxheSk7XG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247IC8vIE1heSBiZSBzZXQgYnkgYnJ1c2gubW92ZSAob24gc3RhcnQpIVxuICAgICAgaWYgKGVtcHR5KHNlbGVjdGlvbikpIHN0YXRlLnNlbGVjdGlvbiA9IG51bGwsIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgZW1pdC5lbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlkb3duZWQoKSB7XG4gICAgICBzd2l0Y2ggKGQzU2VsZWN0aW9uLmV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxuICAgICAgICAgIHNoaWZ0aW5nID0gc2lnblggJiYgc2lnblk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxODogeyAvLyBBTFRcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9IQU5ETEUpIHtcbiAgICAgICAgICAgIGlmIChzaWduWCkgZTAgPSBlMSAtIGR4ICogc2lnblgsIHcwID0gdzEgKyBkeCAqIHNpZ25YO1xuICAgICAgICAgICAgaWYgKHNpZ25ZKSBzMCA9IHMxIC0gZHkgKiBzaWduWSwgbjAgPSBuMSArIGR5ICogc2lnblk7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9DRU5URVI7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzI6IHsgLy8gU1BBQ0U7IHRha2VzIHByaW9yaXR5IG92ZXIgQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEFORExFIHx8IG1vZGUgPT09IE1PREVfQ0VOVEVSKSB7XG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxIC0gZHg7IGVsc2UgaWYgKHNpZ25YID4gMCkgdzAgPSB3MSAtIGR4O1xuICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMSAtIGR5OyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjEgLSBkeTtcbiAgICAgICAgICAgIG1vZGUgPSBNT0RFX1NQQUNFO1xuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIG1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ldmVudCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwcGVkKCkge1xuICAgICAgc3dpdGNoIChkM1NlbGVjdGlvbi5ldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTY6IHsgLy8gU0hJRlRcbiAgICAgICAgICBpZiAoc2hpZnRpbmcpIHtcbiAgICAgICAgICAgIGxvY2tYID0gbG9ja1kgPSBzaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE4OiB7IC8vIEFMVFxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0NFTlRFUikge1xuICAgICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZTAgPSBlMTsgZWxzZSBpZiAoc2lnblggPiAwKSB3MCA9IHcxO1xuICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xO1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMyOiB7IC8vIFNQQUNFXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmIChkM1NlbGVjdGlvbi5ldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgaWYgKHNpZ25YKSBlMCA9IGUxIC0gZHggKiBzaWduWCwgdzAgPSB3MSArIGR4ICogc2lnblg7XG4gICAgICAgICAgICAgIGlmIChzaWduWSkgczAgPSBzMSAtIGR5ICogc2lnblksIG4wID0gbjEgKyBkeSAqIHNpZ25ZO1xuICAgICAgICAgICAgICBtb2RlID0gTU9ERV9DRU5URVI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XG4gICAgICAgICAgICAgIGlmIChzaWduWSA8IDApIHMwID0gczE7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMTtcbiAgICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZV0pO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICB9XG4gICAgICBub2V2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZCgpIHtcbiAgICBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykubW92ZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmVuZGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX19icnVzaCB8fCB7c2VsZWN0aW9uOiBudWxsfTtcbiAgICBzdGF0ZS5leHRlbnQgPSBudW1iZXIyKGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBzdGF0ZS5kaW0gPSBkaW07XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgYnJ1c2guZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQobnVtYmVyMihfKSksIGJydXNoKSA6IGV4dGVudDtcbiAgfTtcblxuICBicnVzaC5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBicnVzaCkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgYnJ1c2gudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYnJ1c2gpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGJydXNoLmhhbmRsZVNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaGFuZGxlU2l6ZSA9ICtfLCBicnVzaCkgOiBoYW5kbGVTaXplO1xuICB9O1xuXG4gIGJydXNoLmtleU1vZGlmaWVycyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gISFfLCBicnVzaCkgOiBrZXlzO1xuICB9O1xuXG4gIGJydXNoLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGJydXNoIDogdmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIGJydXNoO1xufVxuXG5leHBvcnRzLmJydXNoID0gYnJ1c2g7XG5leHBvcnRzLmJydXNoU2VsZWN0aW9uID0gYnJ1c2hTZWxlY3Rpb247XG5leHBvcnRzLmJydXNoWCA9IGJydXNoWDtcbmV4cG9ydHMuYnJ1c2hZID0gYnJ1c2hZO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNob3JkLyB2MS4wLjYgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1hcnJheScpLCByZXF1aXJlKCdkMy1wYXRoJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtYXJyYXknLCAnZDMtcGF0aCddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0FycmF5LGQzUGF0aCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBwaSA9IE1hdGguUEk7XG52YXIgaGFsZlBpID0gcGkgLyAyO1xudmFyIHRhdSA9IHBpICogMjtcbnZhciBtYXggPSBNYXRoLm1heDtcblxuZnVuY3Rpb24gY29tcGFyZVZhbHVlKGNvbXBhcmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZShcbiAgICAgIGEuc291cmNlLnZhbHVlICsgYS50YXJnZXQudmFsdWUsXG4gICAgICBiLnNvdXJjZS52YWx1ZSArIGIudGFyZ2V0LnZhbHVlXG4gICAgKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2hvcmQoKSB7XG4gIHZhciBwYWRBbmdsZSA9IDAsXG4gICAgICBzb3J0R3JvdXBzID0gbnVsbCxcbiAgICAgIHNvcnRTdWJncm91cHMgPSBudWxsLFxuICAgICAgc29ydENob3JkcyA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2hvcmQobWF0cml4KSB7XG4gICAgdmFyIG4gPSBtYXRyaXgubGVuZ3RoLFxuICAgICAgICBncm91cFN1bXMgPSBbXSxcbiAgICAgICAgZ3JvdXBJbmRleCA9IGQzQXJyYXkucmFuZ2UobiksXG4gICAgICAgIHN1Ymdyb3VwSW5kZXggPSBbXSxcbiAgICAgICAgY2hvcmRzID0gW10sXG4gICAgICAgIGdyb3VwcyA9IGNob3Jkcy5ncm91cHMgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShuICogbiksXG4gICAgICAgIGssXG4gICAgICAgIHgsXG4gICAgICAgIHgwLFxuICAgICAgICBkeCxcbiAgICAgICAgaSxcbiAgICAgICAgajtcblxuICAgIC8vIENvbXB1dGUgdGhlIHN1bS5cbiAgICBrID0gMCwgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgeCA9IDAsIGogPSAtMTsgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgeCArPSBtYXRyaXhbaV1bal07XG4gICAgICB9XG4gICAgICBncm91cFN1bXMucHVzaCh4KTtcbiAgICAgIHN1Ymdyb3VwSW5kZXgucHVzaChkM0FycmF5LnJhbmdlKG4pKTtcbiAgICAgIGsgKz0geDtcbiAgICB9XG5cbiAgICAvLyBTb3J0IGdyb3Vwc+KAplxuICAgIGlmIChzb3J0R3JvdXBzKSBncm91cEluZGV4LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHNvcnRHcm91cHMoZ3JvdXBTdW1zW2FdLCBncm91cFN1bXNbYl0pO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBzdWJncm91cHPigKZcbiAgICBpZiAoc29ydFN1Ymdyb3Vwcykgc3ViZ3JvdXBJbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIGQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBzb3J0U3ViZ3JvdXBzKG1hdHJpeFtpXVthXSwgbWF0cml4W2ldW2JdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gQ29udmVydCB0aGUgc3VtIHRvIHNjYWxpbmcgZmFjdG9yIGZvciBbMCwgMnBpXS5cbiAgICAvLyBUT0RPIEFsbG93IHN0YXJ0IGFuZCBlbmQgYW5nbGUgdG8gYmUgc3BlY2lmaWVkP1xuICAgIC8vIFRPRE8gQWxsb3cgcGFkZGluZyB0byBiZSBzcGVjaWZpZWQgYXMgcGVyY2VudGFnZT9cbiAgICBrID0gbWF4KDAsIHRhdSAtIHBhZEFuZ2xlICogbikgLyBrO1xuICAgIGR4ID0gayA/IHBhZEFuZ2xlIDogdGF1IC8gbjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGUgZm9yIGVhY2ggZ3JvdXAgYW5kIHN1Ymdyb3VwLlxuICAgIC8vIE5vdGU6IE9wZXJhIGhhcyBhIGJ1ZyByZW9yZGVyaW5nIG9iamVjdCBsaXRlcmFsIHByb3BlcnRpZXMhXG4gICAgeCA9IDAsIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHgwID0geCwgaiA9IC0xOyB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICB2YXIgZGkgPSBncm91cEluZGV4W2ldLFxuICAgICAgICAgICAgZGogPSBzdWJncm91cEluZGV4W2RpXVtqXSxcbiAgICAgICAgICAgIHYgPSBtYXRyaXhbZGldW2RqXSxcbiAgICAgICAgICAgIGEwID0geCxcbiAgICAgICAgICAgIGExID0geCArPSB2ICogaztcbiAgICAgICAgc3ViZ3JvdXBzW2RqICogbiArIGRpXSA9IHtcbiAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgc3ViaW5kZXg6IGRqLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZ3JvdXBzW2RpXSA9IHtcbiAgICAgICAgaW5kZXg6IGRpLFxuICAgICAgICBzdGFydEFuZ2xlOiB4MCxcbiAgICAgICAgZW5kQW5nbGU6IHgsXG4gICAgICAgIHZhbHVlOiBncm91cFN1bXNbZGldXG4gICAgICB9O1xuICAgICAgeCArPSBkeDtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBjaG9yZHMgZm9yIGVhY2ggKG5vbi1lbXB0eSkgc3ViZ3JvdXAtc3ViZ3JvdXAgbGluay5cbiAgICBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBqID0gaSAtIDE7IHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdWJncm91cHNbaiAqIG4gKyBpXSxcbiAgICAgICAgICAgIHRhcmdldCA9IHN1Ymdyb3Vwc1tpICogbiArIGpdO1xuICAgICAgICBpZiAoc291cmNlLnZhbHVlIHx8IHRhcmdldC52YWx1ZSkge1xuICAgICAgICAgIGNob3Jkcy5wdXNoKHNvdXJjZS52YWx1ZSA8IHRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICA/IHtzb3VyY2U6IHRhcmdldCwgdGFyZ2V0OiBzb3VyY2V9XG4gICAgICAgICAgICAgIDoge3NvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRDaG9yZHMgPyBjaG9yZHMuc29ydChzb3J0Q2hvcmRzKSA6IGNob3JkcztcbiAgfVxuXG4gIGNob3JkLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gbWF4KDAsIF8pLCBjaG9yZCkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBjaG9yZC5zb3J0R3JvdXBzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRHcm91cHMgPSBfLCBjaG9yZCkgOiBzb3J0R3JvdXBzO1xuICB9O1xuXG4gIGNob3JkLnNvcnRTdWJncm91cHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFN1Ymdyb3VwcyA9IF8sIGNob3JkKSA6IHNvcnRTdWJncm91cHM7XG4gIH07XG5cbiAgY2hvcmQuc29ydENob3JkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBzb3J0Q2hvcmRzID0gbnVsbCA6IChzb3J0Q2hvcmRzID0gY29tcGFyZVZhbHVlKF8pKS5fID0gXywgY2hvcmQpIDogc29ydENob3JkcyAmJiBzb3J0Q2hvcmRzLl87XG4gIH07XG5cbiAgcmV0dXJuIGNob3JkO1xufVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U291cmNlKGQpIHtcbiAgcmV0dXJuIGQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VGFyZ2V0KGQpIHtcbiAgcmV0dXJuIGQudGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQucmFkaXVzO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiByaWJib24oKSB7XG4gIHZhciBzb3VyY2UgPSBkZWZhdWx0U291cmNlLFxuICAgICAgdGFyZ2V0ID0gZGVmYXVsdFRhcmdldCxcbiAgICAgIHJhZGl1cyA9IGRlZmF1bHRSYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlID0gZGVmYXVsdFN0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGRlZmF1bHRFbmRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJpYmJvbigpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICBhcmd2ID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzID0gc291cmNlLmFwcGx5KHRoaXMsIGFyZ3YpLFxuICAgICAgICB0ID0gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3YpLFxuICAgICAgICBzciA9ICtyYWRpdXMuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSBzLCBhcmd2KSksXG4gICAgICAgIHNhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGksXG4gICAgICAgIHNhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpLFxuICAgICAgICBzeDAgPSBzciAqIGNvcyhzYTApLFxuICAgICAgICBzeTAgPSBzciAqIHNpbihzYTApLFxuICAgICAgICB0ciA9ICtyYWRpdXMuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksXG4gICAgICAgIHRhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGksXG4gICAgICAgIHRhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcblxuICAgIGNvbnRleHQubW92ZVRvKHN4MCwgc3kwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCBzciwgc2EwLCBzYTEpO1xuICAgIGlmIChzYTAgIT09IHRhMCB8fCBzYTEgIT09IHRhMSkgeyAvLyBUT0RPIHNyICE9PSB0cj9cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbygwLCAwLCB0ciAqIGNvcyh0YTApLCB0ciAqIHNpbih0YTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRyLCB0YTAsIHRhMSk7XG4gICAgfVxuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbygwLCAwLCBzeDAsIHN5MCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgcmliYm9uLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcmliYm9uKSA6IHJhZGl1cztcbiAgfTtcblxuICByaWJib24uc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHJpYmJvbikgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHJpYmJvbi5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCByaWJib24pIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcmliYm9uLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3VyY2UgPSBfLCByaWJib24pIDogc291cmNlO1xuICB9O1xuXG4gIHJpYmJvbi50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFyZ2V0ID0gXywgcmliYm9uKSA6IHRhcmdldDtcbiAgfTtcblxuICByaWJib24uY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgcmliYm9uKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHJpYmJvbjtcbn1cblxuZXhwb3J0cy5jaG9yZCA9IGNob3JkO1xuZXhwb3J0cy5yaWJib24gPSByaWJib247XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNvbGxlY3Rpb24vIHYxLjAuNyBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHByZWZpeCA9IFwiJFwiO1xuXG5mdW5jdGlvbiBNYXAoKSB7fVxuXG5NYXAucHJvdG90eXBlID0gbWFwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE1hcCxcbiAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gKHByZWZpeCArIGtleSkgaW4gdGhpcztcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpc1twcmVmaXggKyBrZXldO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW3ByZWZpeCArIGtleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBwcmVmaXggKyBrZXk7XG4gICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgfSxcbiAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkga2V5cy5wdXNoKHByb3BlcnR5LnNsaWNlKDEpKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfSxcbiAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHZhbHVlcy5wdXNoKHRoaXNbcHJvcGVydHldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBlbnRyaWVzLnB1c2goe2tleTogcHJvcGVydHkuc2xpY2UoMSksIHZhbHVlOiB0aGlzW3Byb3BlcnR5XX0pO1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9LFxuICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpICsrc2l6ZTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfSxcbiAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIGVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZih0aGlzW3Byb3BlcnR5XSwgcHJvcGVydHkuc2xpY2UoMSksIHRoaXMpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBtYXAob2JqZWN0LCBmKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwO1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgbWFwLnNldChrZXksIHZhbHVlKTsgfSk7XG5cbiAgLy8gSW5kZXggYXJyYXkgYnkgbnVtZXJpYyBpbmRleCBvciBzcGVjaWZpZWQga2V5IGZ1bmN0aW9uLlxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgbztcblxuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmKG8gPSBvYmplY3RbaV0sIGksIG9iamVjdCksIG8pO1xuICB9XG5cbiAgLy8gQ29udmVydCBvYmplY3QgdG8gbWFwLlxuICBlbHNlIGlmIChvYmplY3QpIGZvciAodmFyIGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gbmVzdCgpIHtcbiAgdmFyIGtleXMgPSBbXSxcbiAgICAgIHNvcnRLZXlzID0gW10sXG4gICAgICBzb3J0VmFsdWVzLFxuICAgICAgcm9sbHVwLFxuICAgICAgbmVzdDtcblxuICBmdW5jdGlvbiBhcHBseShhcnJheSwgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSB7XG4gICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSB7XG4gICAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIHJvbGx1cCAhPSBudWxsID8gcm9sbHVwKGFycmF5KSA6IGFycmF5O1xuICAgIH1cblxuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGtleSA9IGtleXNbZGVwdGgrK10sXG4gICAgICAgIGtleVZhbHVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdmFsdWVzQnlLZXkgPSBtYXAoKSxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgXCJcIikpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNCeUtleS5lYWNoKGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cmllcyhtYXAkJDEsIGRlcHRoKSB7XG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcCQkMTtcbiAgICB2YXIgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xuICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aCkgYXJyYXkgPSBtYXAkJDEuZW50cmllcygpO1xuICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwJCQxLmVhY2goZnVuY3Rpb24odiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XG4gICAgcmV0dXJuIHNvcnRLZXkgIT0gbnVsbCA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5lc3QgPSB7XG4gICAgb2JqZWN0OiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcbiAgICBtYXA6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxuICAgIGtleTogZnVuY3Rpb24oZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRLZXlzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgcm9sbHVwOiBmdW5jdGlvbihmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBzZXRPYmplY3Qob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgcmV0dXJuIG1hcCgpO1xufVxuXG5mdW5jdGlvbiBzZXRNYXAobWFwJCQxLCBrZXksIHZhbHVlKSB7XG4gIG1hcCQkMS5zZXQoa2V5LCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIFNldCgpIHt9XG5cbnZhciBwcm90byA9IG1hcC5wcm90b3R5cGU7XG5cblNldC5wcm90b3R5cGUgPSBzZXQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2V0LFxuICBoYXM6IHByb3RvLmhhcyxcbiAgYWRkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhbHVlICs9IFwiXCI7XG4gICAgdGhpc1twcmVmaXggKyB2YWx1ZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBwcm90by5yZW1vdmUsXG4gIGNsZWFyOiBwcm90by5jbGVhcixcbiAgdmFsdWVzOiBwcm90by5rZXlzLFxuICBzaXplOiBwcm90by5zaXplLFxuICBlbXB0eTogcHJvdG8uZW1wdHksXG4gIGVhY2g6IHByb3RvLmVhY2hcbn07XG5cbmZ1bmN0aW9uIHNldChvYmplY3QsIGYpIHtcbiAgdmFyIHNldCA9IG5ldyBTZXQ7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFNldCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUpIHsgc2V0LmFkZCh2YWx1ZSk7IH0pO1xuXG4gIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl04oCZcyBhbiBhcnJheS5cbiAgZWxzZSBpZiAob2JqZWN0KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIHNldC5hZGQob2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKGYob2JqZWN0W2ldLCBpLCBvYmplY3QpKTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG5cbmZ1bmN0aW9uIGtleXMobWFwKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gdmFsdWVzKG1hcCkge1xuICB2YXIgdmFsdWVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIHZhbHVlcy5wdXNoKG1hcFtrZXldKTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuZnVuY3Rpb24gZW50cmllcyhtYXApIHtcbiAgdmFyIGVudHJpZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgZW50cmllcy5wdXNoKHtrZXk6IGtleSwgdmFsdWU6IG1hcFtrZXldfSk7XG4gIHJldHVybiBlbnRyaWVzO1xufVxuXG5leHBvcnRzLm5lc3QgPSBuZXN0O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmV4cG9ydHMuZW50cmllcyA9IGVudHJpZXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNvbG9yLyB2MS40LjAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZpbmUoY29uc3RydWN0b3IsIGZhY3RvcnksIHByb3RvdHlwZSkge1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG52YXIgZGFya2VyID0gMC43O1xudmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiLFxuICAgIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCIsXG4gICAgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCIsXG4gICAgcmVIZXggPSAvXiMoWzAtOWEtZl17Myw4fSkkLyxcbiAgICByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgY29weTogZnVuY3Rpb24oY2hhbm5lbHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcywgY2hhbm5lbHMpO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuZGlzcGxheWFibGUoKTtcbiAgfSxcbiAgaGV4OiBjb2xvcl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogY29sb3JfZm9ybWF0SGV4LFxuICBmb3JtYXRIc2w6IGNvbG9yX2Zvcm1hdEhzbCxcbiAgZm9ybWF0UmdiOiBjb2xvcl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiBjb2xvcl9mb3JtYXRSZ2Jcbn0pO1xuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdEhleCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRIc2woKSB7XG4gIHJldHVybiBoc2xDb252ZXJ0KHRoaXMpLmZvcm1hdEhzbCgpO1xufVxuXG5mdW5jdGlvbiBjb2xvcl9mb3JtYXRSZ2IoKSB7XG4gIHJldHVybiB0aGlzLnJnYigpLmZvcm1hdFJnYigpO1xufVxuXG5mdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG0sIGw7XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXguZXhlYyhmb3JtYXQpKSA/IChsID0gbVsxXS5sZW5ndGgsIG0gPSBwYXJzZUludChtWzFdLCAxNiksIGwgPT09IDYgPyByZ2JuKG0pIC8vICNmZjAwMDBcbiAgICAgIDogbCA9PT0gMyA/IG5ldyBSZ2IoKG0gPj4gOCAmIDB4ZikgfCAobSA+PiA0ICYgMHhmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkgLy8gI2YwMFxuICAgICAgOiBsID09PSA4ID8gbmV3IFJnYihtID4+IDI0ICYgMHhmZiwgbSA+PiAxNiAmIDB4ZmYsIG0gPj4gOCAmIDB4ZmYsIChtICYgMHhmZikgLyAweGZmKSAvLyAjZmYwMDAwMDBcbiAgICAgIDogbCA9PT0gNCA/IG5ldyBSZ2IoKG0gPj4gMTIgJiAweGYpIHwgKG0gPj4gOCAmIDB4ZjApLCAobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSkgLyAweGZmKSAvLyAjZjAwMFxuICAgICAgOiBudWxsKSAvLyBpbnZhbGlkIGhleFxuICAgICAgOiAobSA9IHJlUmdiSW50ZWdlci5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdLCBtWzJdLCBtWzNdLCAxKSAvLyByZ2IoMjU1LCAwLCAwKVxuICAgICAgOiAobSA9IHJlUmdiUGVyY2VudC5leGVjKGZvcm1hdCkpID8gbmV3IFJnYihtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCAxKSAvLyByZ2IoMTAwJSwgMCUsIDAlKVxuICAgICAgOiAobSA9IHJlUmdiYUludGVnZXIuZXhlYyhmb3JtYXQpKSA/IHJnYmEobVsxXSwgbVsyXSwgbVszXSwgbVs0XSkgLy8gcmdiYSgyNTUsIDAsIDAsIDEpXG4gICAgICA6IChtID0gcmVSZ2JhUGVyY2VudC5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdICogMjU1IC8gMTAwLCBtWzJdICogMjU1IC8gMTAwLCBtWzNdICogMjU1IC8gMTAwLCBtWzRdKSAvLyByZ2IoMTAwJSwgMCUsIDAlLCAxKVxuICAgICAgOiAobSA9IHJlSHNsUGVyY2VudC5leGVjKGZvcm1hdCkpID8gaHNsYShtWzFdLCBtWzJdIC8gMTAwLCBtWzNdIC8gMTAwLCAxKSAvLyBoc2woMTIwLCA1MCUsIDUwJSlcbiAgICAgIDogKG0gPSByZUhzbGFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIG1bNF0pIC8vIGhzbGEoMTIwLCA1MCUsIDUwJSwgMSlcbiAgICAgIDogbmFtZWQuaGFzT3duUHJvcGVydHkoZm9ybWF0KSA/IHJnYm4obmFtZWRbZm9ybWF0XSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIDogZm9ybWF0ID09PSBcInRyYW5zcGFyZW50XCIgPyBuZXcgUmdiKE5hTiwgTmFOLCBOYU4sIDApXG4gICAgICA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJnYm4obikge1xuICByZXR1cm4gbmV3IFJnYihuID4+IDE2ICYgMHhmZiwgbiA+PiA4ICYgMHhmZiwgbiAmIDB4ZmYsIDEpO1xufVxuXG5mdW5jdGlvbiByZ2JhKHIsIGcsIGIsIGEpIHtcbiAgaWYgKGEgPD0gMCkgciA9IGcgPSBiID0gTmFOO1xuICByZXR1cm4gbmV3IFJnYihyLCBnLCBiLCBhKTtcbn1cblxuZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIHJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gcmdiQ29udmVydChyKSA6IG5ldyBSZ2IociwgZywgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBSZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICB0aGlzLnIgPSArcjtcbiAgdGhpcy5nID0gK2c7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKFJnYiwgcmdiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBSZ2IodGhpcy5yICogaywgdGhpcy5nICogaywgdGhpcy5iICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoLTAuNSA8PSB0aGlzLnIgJiYgdGhpcy5yIDwgMjU1LjUpXG4gICAgICAgICYmICgtMC41IDw9IHRoaXMuZyAmJiB0aGlzLmcgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5iICYmIHRoaXMuYiA8IDI1NS41KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBoZXg6IHJnYl9mb3JtYXRIZXgsIC8vIERlcHJlY2F0ZWQhIFVzZSBjb2xvci5mb3JtYXRIZXguXG4gIGZvcm1hdEhleDogcmdiX2Zvcm1hdEhleCxcbiAgZm9ybWF0UmdiOiByZ2JfZm9ybWF0UmdiLFxuICB0b1N0cmluZzogcmdiX2Zvcm1hdFJnYlxufSkpO1xuXG5mdW5jdGlvbiByZ2JfZm9ybWF0SGV4KCkge1xuICByZXR1cm4gXCIjXCIgKyBoZXgodGhpcy5yKSArIGhleCh0aGlzLmcpICsgaGV4KHRoaXMuYik7XG59XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRSZ2IoKSB7XG4gIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIilcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcpIHx8IDApKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSlcbiAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG59XG5cbmZ1bmN0aW9uIGhleCh2YWx1ZSkge1xuICB2YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh2YWx1ZSkgfHwgMCkpO1xuICByZXR1cm4gKHZhbHVlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgdmFsdWUudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9LFxuICBmb3JtYXRIc2w6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gdGhpcy5vcGFjaXR5OyBhID0gaXNOYU4oYSkgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpO1xuICAgIHJldHVybiAoYSA9PT0gMSA/IFwiaHNsKFwiIDogXCJoc2xhKFwiKVxuICAgICAgICArICh0aGlzLmggfHwgMCkgKyBcIiwgXCJcbiAgICAgICAgKyAodGhpcy5zIHx8IDApICogMTAwICsgXCIlLCBcIlxuICAgICAgICArICh0aGlzLmwgfHwgMCkgKiAxMDAgKyBcIiVcIlxuICAgICAgICArIChhID09PSAxID8gXCIpXCIgOiBcIiwgXCIgKyBhICsgXCIpXCIpO1xuICB9XG59KSk7XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cblxudmFyIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwO1xudmFyIHJhZDJkZWcgPSAxODAgLyBNYXRoLlBJO1xuXG4vLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL2xhYi1hbmQtcmdiXG52YXIgSyA9IDE4LFxuICAgIFhuID0gMC45NjQyMixcbiAgICBZbiA9IDEsXG4gICAgWm4gPSAwLjgyNTIxLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBoY2wybGFiKG8pO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gcmdiMmxyZ2Ioby5yKSxcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxuICAgICAgYiA9IHJnYjJscmdiKG8uYiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGcgKyAwLjA2MDYxNjkgKiBiKSAvIFluKSwgeCwgejtcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcbiAgICB4ID0geHl6MmxhYigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGcgKyAwLjE0MzA4MDQgKiBiKSAvIFhuKTtcbiAgICB6ID0geHl6MmxhYigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGcgKyAwLjcxNDE3MzMgKiBiKSAvIFpuKTtcbiAgfVxuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGdyYXkobCwgb3BhY2l0eSkge1xuICByZXR1cm4gbmV3IExhYihsLCAwLCAwLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeSA9ICh0aGlzLmwgKyAxNikgLyAxMTYsXG4gICAgICAgIHggPSBpc05hTih0aGlzLmEpID8geSA6IHkgKyB0aGlzLmEgLyA1MDAsXG4gICAgICAgIHogPSBpc05hTih0aGlzLmIpID8geSA6IHkgLSB0aGlzLmIgLyAyMDA7XG4gICAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHogPSBabiAqIGxhYjJ4eXooeik7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBscmdiMnJnYiggMy4xMzM4NTYxICogeCAtIDEuNjE2ODY2NyAqIHkgLSAwLjQ5MDYxNDYgKiB6KSxcbiAgICAgIGxyZ2IycmdiKC0wLjk3ODc2ODQgKiB4ICsgMS45MTYxNDE1ICogeSArIDAuMDMzNDU0MCAqIHopLFxuICAgICAgbHJnYjJyZ2IoIDAuMDcxOTQ1MyAqIHggLSAwLjIyODk5MTQgKiB5ICsgMS40MDUyNDI3ICogeiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmZ1bmN0aW9uIHh5ejJsYWIodCkge1xuICByZXR1cm4gdCA+IHQzID8gTWF0aC5wb3codCwgMSAvIDMpIDogdCAvIHQyICsgdDA7XG59XG5cbmZ1bmN0aW9uIGxhYjJ4eXoodCkge1xuICByZXR1cm4gdCA+IHQxID8gdCAqIHQgKiB0IDogdDIgKiAodCAtIHQwKTtcbn1cblxuZnVuY3Rpb24gbHJnYjJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMmxyZ2IoeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIGlmIChvLmEgPT09IDAgJiYgby5iID09PSAwKSByZXR1cm4gbmV3IEhjbChOYU4sIDAgPCBvLmwgJiYgby5sIDwgMTAwID8gMCA6IE5hTiwgby5sLCBvLm9wYWNpdHkpO1xuICB2YXIgaCA9IE1hdGguYXRhbjIoby5iLCBvLmEpICogcmFkMmRlZztcbiAgcmV0dXJuIG5ldyBIY2woaCA8IDAgPyBoICsgMzYwIDogaCwgTWF0aC5zcXJ0KG8uYSAqIG8uYSArIG8uYiAqIG8uYiksIG8ubCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaGNsQ29udmVydChoKSA6IG5ldyBIY2woaCwgYywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5jID0gK2M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZnVuY3Rpb24gaGNsMmxhYihvKSB7XG4gIGlmIChpc05hTihvLmgpKSByZXR1cm4gbmV3IExhYihvLmwsIDAsIDAsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gby5oICogZGVnMnJhZDtcbiAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGhjbDJsYWIodGhpcykucmdiKCk7XG4gIH1cbn0pKTtcblxudmFyIEEgPSAtMC4xNDg2MSxcbiAgICBCID0gKzEuNzgyNzcsXG4gICAgQyA9IC0wLjI5MjI3LFxuICAgIEQgPSAtMC45MDY0OSxcbiAgICBFID0gKzEuOTcyOTQsXG4gICAgRUQgPSBFICogRCxcbiAgICBFQiA9IEUgKiBCLFxuICAgIEJDX0RBID0gQiAqIEMgLSBEICogQTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4Q29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgQ3ViZWhlbGl4KSByZXR1cm4gbmV3IEN1YmVoZWxpeChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBsID0gKEJDX0RBICogYiArIEVEICogciAtIEVCICogZykgLyAoQkNfREEgKyBFRCAtIEVCKSxcbiAgICAgIGJsID0gYiAtIGwsXG4gICAgICBrID0gKEUgKiAoZyAtIGwpIC0gQyAqIGJsKSAvIEQsXG4gICAgICBzID0gTWF0aC5zcXJ0KGsgKiBrICsgYmwgKiBibCkgLyAoRSAqIGwgKiAoMSAtIGwpKSwgLy8gTmFOIGlmIGw9MCBvciBsPTFcbiAgICAgIGggPSBzID8gTWF0aC5hdGFuMihrLCBibCkgKiByYWQyZGVnIC0gMTIwIDogTmFOO1xuICByZXR1cm4gbmV3IEN1YmVoZWxpeChoIDwgMCA/IGggKyAzNjAgOiBoLCBzLCBsLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGN1YmVoZWxpeENvbnZlcnQoaCkgOiBuZXcgQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShDdWJlaGVsaXgsIGN1YmVoZWxpeCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiBkZWcycmFkLFxuICAgICAgICBsID0gK3RoaXMubCxcbiAgICAgICAgYSA9IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zICogbCAqICgxIC0gbCksXG4gICAgICAgIGNvc2ggPSBNYXRoLmNvcyhoKSxcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgMjU1ICogKGwgKyBhICogKEEgKiBjb3NoICsgQiAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoRSAqIGNvc2gpKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuZXhwb3J0cy5jdWJlaGVsaXggPSBjdWJlaGVsaXg7XG5leHBvcnRzLmdyYXkgPSBncmF5O1xuZXhwb3J0cy5oY2wgPSBoY2w7XG5leHBvcnRzLmhzbCA9IGhzbDtcbmV4cG9ydHMubGFiID0gbGFiO1xuZXhwb3J0cy5sY2ggPSBsY2g7XG5leHBvcnRzLnJnYiA9IHJnYjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1jb250b3VyLyB2MS4zLjIgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1hcnJheScpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWFycmF5J10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNBcnJheSkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuZnVuY3Rpb24gYXJlYShyaW5nKSB7XG4gIHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBhcmVhID0gcmluZ1tuIC0gMV1bMV0gKiByaW5nWzBdWzBdIC0gcmluZ1tuIC0gMV1bMF0gKiByaW5nWzBdWzFdO1xuICB3aGlsZSAoKytpIDwgbikgYXJlYSArPSByaW5nW2kgLSAxXVsxXSAqIHJpbmdbaV1bMF0gLSByaW5nW2kgLSAxXVswXSAqIHJpbmdbaV1bMV07XG4gIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocmluZywgaG9sZSkge1xuICB2YXIgaSA9IC0xLCBuID0gaG9sZS5sZW5ndGgsIGM7XG4gIHdoaWxlICgrK2kgPCBuKSBpZiAoYyA9IHJpbmdDb250YWlucyhyaW5nLCBob2xlW2ldKSkgcmV0dXJuIGM7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiByaW5nQ29udGFpbnMocmluZywgcG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdLCBjb250YWlucyA9IC0xO1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBqID0gbiAtIDE7IGkgPCBuOyBqID0gaSsrKSB7XG4gICAgdmFyIHBpID0gcmluZ1tpXSwgeGkgPSBwaVswXSwgeWkgPSBwaVsxXSwgcGogPSByaW5nW2pdLCB4aiA9IHBqWzBdLCB5aiA9IHBqWzFdO1xuICAgIGlmIChzZWdtZW50Q29udGFpbnMocGksIHBqLCBwb2ludCkpIHJldHVybiAwO1xuICAgIGlmICgoKHlpID4geSkgIT09ICh5aiA+IHkpKSAmJiAoKHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKSkpIGNvbnRhaW5zID0gLWNvbnRhaW5zO1xuICB9XG4gIHJldHVybiBjb250YWlucztcbn1cblxuZnVuY3Rpb24gc2VnbWVudENvbnRhaW5zKGEsIGIsIGMpIHtcbiAgdmFyIGk7IHJldHVybiBjb2xsaW5lYXIoYSwgYiwgYykgJiYgd2l0aGluKGFbaSA9ICsoYVswXSA9PT0gYlswXSldLCBjW2ldLCBiW2ldKTtcbn1cblxuZnVuY3Rpb24gY29sbGluZWFyKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pID09PSAoY1swXSAtIGFbMF0pICogKGJbMV0gLSBhWzFdKTtcbn1cblxuZnVuY3Rpb24gd2l0aGluKHAsIHEsIHIpIHtcbiAgcmV0dXJuIHAgPD0gcSAmJiBxIDw9IHIgfHwgciA8PSBxICYmIHEgPD0gcDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBjYXNlcyA9IFtcbiAgW10sXG4gIFtbWzEuMCwgMS41XSwgWzAuNSwgMS4wXV1dLFxuICBbW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSxcbiAgW1tbMS41LCAxLjBdLCBbMC41LCAxLjBdXV0sXG4gIFtbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLFxuICBbW1sxLjAsIDEuNV0sIFswLjUsIDEuMF1dLCBbWzEuMCwgMC41XSwgWzEuNSwgMS4wXV1dLFxuICBbW1sxLjAsIDAuNV0sIFsxLjAsIDEuNV1dXSxcbiAgW1tbMS4wLCAwLjVdLCBbMC41LCAxLjBdXV0sXG4gIFtbWzAuNSwgMS4wXSwgWzEuMCwgMC41XV1dLFxuICBbW1sxLjAsIDEuNV0sIFsxLjAsIDAuNV1dXSxcbiAgW1tbMC41LCAxLjBdLCBbMS4wLCAwLjVdXSwgW1sxLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSxcbiAgW1tbMS41LCAxLjBdLCBbMS4wLCAwLjVdXV0sXG4gIFtbWzAuNSwgMS4wXSwgWzEuNSwgMS4wXV1dLFxuICBbW1sxLjAsIDEuNV0sIFsxLjUsIDEuMF1dXSxcbiAgW1tbMC41LCAxLjBdLCBbMS4wLCAxLjVdXV0sXG4gIFtdXG5dO1xuXG5mdW5jdGlvbiBjb250b3VycygpIHtcbiAgdmFyIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHRocmVzaG9sZCA9IGQzQXJyYXkudGhyZXNob2xkU3R1cmdlcyxcbiAgICAgIHNtb290aCA9IHNtb290aExpbmVhcjtcblxuICBmdW5jdGlvbiBjb250b3Vycyh2YWx1ZXMpIHtcbiAgICB2YXIgdHogPSB0aHJlc2hvbGQodmFsdWVzKTtcblxuICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR6KSkge1xuICAgICAgdmFyIGRvbWFpbiA9IGQzQXJyYXkuZXh0ZW50KHZhbHVlcyksIHN0YXJ0ID0gZG9tYWluWzBdLCBzdG9wID0gZG9tYWluWzFdO1xuICAgICAgdHogPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCB0eik7XG4gICAgICB0eiA9IGQzQXJyYXkucmFuZ2UoTWF0aC5mbG9vcihzdGFydCAvIHR6KSAqIHR6LCBNYXRoLmZsb29yKHN0b3AgLyB0eikgKiB0eiwgdHopO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eiA9IHR6LnNsaWNlKCkuc29ydChhc2NlbmRpbmcpO1xuICAgIH1cblxuICAgIHJldHVybiB0ei5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBjb250b3VyKHZhbHVlcywgdmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQWNjdW11bGF0ZSwgc21vb3RoIGNvbnRvdXIgcmluZ3MsIGFzc2lnbiBob2xlcyB0byBleHRlcmlvciByaW5ncy5cbiAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL3NoYXBlZmlsZS9ibG9iL3YwLjYuMi9zaHAvcG9seWdvbi5qc1xuICBmdW5jdGlvbiBjb250b3VyKHZhbHVlcywgdmFsdWUpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBbXSxcbiAgICAgICAgaG9sZXMgPSBbXTtcblxuICAgIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIGZ1bmN0aW9uKHJpbmcpIHtcbiAgICAgIHNtb290aChyaW5nLCB2YWx1ZXMsIHZhbHVlKTtcbiAgICAgIGlmIChhcmVhKHJpbmcpID4gMCkgcG9seWdvbnMucHVzaChbcmluZ10pO1xuICAgICAgZWxzZSBob2xlcy5wdXNoKHJpbmcpO1xuICAgIH0pO1xuXG4gICAgaG9sZXMuZm9yRWFjaChmdW5jdGlvbihob2xlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb25zLmxlbmd0aCwgcG9seWdvbjsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoY29udGFpbnMoKHBvbHlnb24gPSBwb2x5Z29uc1tpXSlbMF0sIGhvbGUpICE9PSAtMSkge1xuICAgICAgICAgIHBvbHlnb24ucHVzaChob2xlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk11bHRpUG9seWdvblwiLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgY29vcmRpbmF0ZXM6IHBvbHlnb25zXG4gICAgfTtcbiAgfVxuXG4gIC8vIE1hcmNoaW5nIHNxdWFyZXMgd2l0aCBpc29saW5lcyBzdGl0Y2hlZCBpbnRvIHJpbmdzLlxuICAvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vdG9wb2pzb24vdG9wb2pzb24tY2xpZW50L2Jsb2IvdjMuMC4wL3NyYy9zdGl0Y2guanNcbiAgZnVuY3Rpb24gaXNvcmluZ3ModmFsdWVzLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnJhZ21lbnRCeVN0YXJ0ID0gbmV3IEFycmF5LFxuICAgICAgICBmcmFnbWVudEJ5RW5kID0gbmV3IEFycmF5LFxuICAgICAgICB4LCB5LCB0MCwgdDEsIHQyLCB0MztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGZpcnN0IHJvdyAoeSA9IC0xLCB0MiA9IHQzID0gMCkuXG4gICAgeCA9IHkgPSAtMTtcbiAgICB0MSA9IHZhbHVlc1swXSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MSA8PCAxXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgdDAgPSB0MSwgdDEgPSB2YWx1ZXNbeCArIDFdID49IHZhbHVlO1xuICAgICAgY2FzZXNbdDAgfCB0MSA8PCAxXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfVxuICAgIGNhc2VzW3QxIDw8IDBdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIC8vIEdlbmVyYWwgY2FzZSBmb3IgdGhlIGludGVybWVkaWF0ZSByb3dzLlxuICAgIHdoaWxlICgrK3kgPCBkeSAtIDEpIHtcbiAgICAgIHggPSAtMTtcbiAgICAgIHQxID0gdmFsdWVzW3kgKiBkeCArIGR4XSA+PSB2YWx1ZTtcbiAgICAgIHQyID0gdmFsdWVzW3kgKiBkeF0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MSA8PCAxIHwgdDIgPDwgMl0uZm9yRWFjaChzdGl0Y2gpO1xuICAgICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t5ICogZHggKyBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgICAgdDMgPSB0MiwgdDIgPSB2YWx1ZXNbeSAqIGR4ICsgeCArIDFdID49IHZhbHVlO1xuICAgICAgICBjYXNlc1t0MCB8IHQxIDw8IDEgfCB0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgICAgfVxuICAgICAgY2FzZXNbdDEgfCB0MiA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0aGUgbGFzdCByb3cgKHkgPSBkeSAtIDEsIHQwID0gdDEgPSAwKS5cbiAgICB4ID0gLTE7XG4gICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgdDMgPSB0MiwgdDIgPSB2YWx1ZXNbeSAqIGR4ICsgeCArIDFdID49IHZhbHVlO1xuICAgICAgY2FzZXNbdDIgPDwgMiB8IHQzIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9XG4gICAgY2FzZXNbdDIgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuXG4gICAgZnVuY3Rpb24gc3RpdGNoKGxpbmUpIHtcbiAgICAgIHZhciBzdGFydCA9IFtsaW5lWzBdWzBdICsgeCwgbGluZVswXVsxXSArIHldLFxuICAgICAgICAgIGVuZCA9IFtsaW5lWzFdWzBdICsgeCwgbGluZVsxXVsxXSArIHldLFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleChzdGFydCksXG4gICAgICAgICAgZW5kSW5kZXggPSBpbmRleChlbmQpLFxuICAgICAgICAgIGYsIGc7XG4gICAgICBpZiAoZiA9IGZyYWdtZW50QnlFbmRbc3RhcnRJbmRleF0pIHtcbiAgICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5U3RhcnRbZW5kSW5kZXhdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgICAgaWYgKGYgPT09IGcpIHtcbiAgICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2cuZW5kXSA9IHtzdGFydDogZi5zdGFydCwgZW5kOiBnLmVuZCwgcmluZzogZi5yaW5nLmNvbmNhdChnLnJpbmcpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgZnJhZ21lbnRCeUVuZFtmLmVuZCA9IGVuZEluZGV4XSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0SW5kZXhdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XG4gICAgICAgICAgaWYgKGYgPT09IGcpIHtcbiAgICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IHtzdGFydDogZy5zdGFydCwgZW5kOiBmLmVuZCwgcmluZzogZy5yaW5nLmNvbmNhdChmLnJpbmcpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgICBmLnJpbmcudW5zaGlmdChzdGFydCk7XG4gICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnQgPSBzdGFydEluZGV4XSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtzdGFydEluZGV4XSA9IGZyYWdtZW50QnlFbmRbZW5kSW5kZXhdID0ge3N0YXJ0OiBzdGFydEluZGV4LCBlbmQ6IGVuZEluZGV4LCByaW5nOiBbc3RhcnQsIGVuZF19O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZGV4KHBvaW50KSB7XG4gICAgcmV0dXJuIHBvaW50WzBdICogMiArIHBvaW50WzFdICogKGR4ICsgMSkgKiA0O1xuICB9XG5cbiAgZnVuY3Rpb24gc21vb3RoTGluZWFyKHJpbmcsIHZhbHVlcywgdmFsdWUpIHtcbiAgICByaW5nLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHZhciB4ID0gcG9pbnRbMF0sXG4gICAgICAgICAgeSA9IHBvaW50WzFdLFxuICAgICAgICAgIHh0ID0geCB8IDAsXG4gICAgICAgICAgeXQgPSB5IHwgMCxcbiAgICAgICAgICB2MCxcbiAgICAgICAgICB2MSA9IHZhbHVlc1t5dCAqIGR4ICsgeHRdO1xuICAgICAgaWYgKHggPiAwICYmIHggPCBkeCAmJiB4dCA9PT0geCkge1xuICAgICAgICB2MCA9IHZhbHVlc1t5dCAqIGR4ICsgeHQgLSAxXTtcbiAgICAgICAgcG9pbnRbMF0gPSB4ICsgKHZhbHVlIC0gdjApIC8gKHYxIC0gdjApIC0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHkgPiAwICYmIHkgPCBkeSAmJiB5dCA9PT0geSkge1xuICAgICAgICB2MCA9IHZhbHVlc1soeXQgLSAxKSAqIGR4ICsgeHRdO1xuICAgICAgICBwb2ludFsxXSA9IHkgKyAodmFsdWUgLSB2MCkgLyAodjEgLSB2MCkgLSAwLjU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb250b3Vycy5jb250b3VyID0gY29udG91cjtcblxuICBjb250b3Vycy5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuICAgIHZhciBfMCA9IE1hdGguY2VpbChfWzBdKSwgXzEgPSBNYXRoLmNlaWwoX1sxXSk7XG4gICAgaWYgKCEoXzAgPiAwKSB8fCAhKF8xID4gMCkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2l6ZVwiKTtcbiAgICByZXR1cm4gZHggPSBfMCwgZHkgPSBfMSwgY29udG91cnM7XG4gIH07XG5cbiAgY29udG91cnMudGhyZXNob2xkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aHJlc2hvbGQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IEFycmF5LmlzQXJyYXkoXykgPyBjb25zdGFudChzbGljZS5jYWxsKF8pKSA6IGNvbnN0YW50KF8pLCBjb250b3VycykgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgY29udG91cnMuc21vb3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNtb290aCA9IF8gPyBzbW9vdGhMaW5lYXIgOiBub29wLCBjb250b3VycykgOiBzbW9vdGggPT09IHNtb290aExpbmVhcjtcbiAgfTtcblxuICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIFRPRE8gT3B0aW1pemUgZWRnZSBjYXNlcy5cbi8vIFRPRE8gT3B0aW1pemUgaW5kZXggY2FsY3VsYXRpb24uXG4vLyBUT0RPIE9wdGltaXplIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGJsdXJYKHNvdXJjZSwgdGFyZ2V0LCByKSB7XG4gIHZhciBuID0gc291cmNlLndpZHRoLFxuICAgICAgbSA9IHNvdXJjZS5oZWlnaHQsXG4gICAgICB3ID0gKHIgPDwgMSkgKyAxO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCBzciA9IDA7IGkgPCBuICsgcjsgKytpKSB7XG4gICAgICBpZiAoaSA8IG4pIHtcbiAgICAgICAgc3IgKz0gc291cmNlLmRhdGFbaSArIGogKiBuXTtcbiAgICAgIH1cbiAgICAgIGlmIChpID49IHIpIHtcbiAgICAgICAgaWYgKGkgPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZS5kYXRhW2kgLSB3ICsgaiAqIG5dO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5kYXRhW2kgLSByICsgaiAqIG5dID0gc3IgLyBNYXRoLm1pbihpICsgMSwgbiAtIDEgKyB3IC0gaSwgdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFRPRE8gT3B0aW1pemUgZWRnZSBjYXNlcy5cbi8vIFRPRE8gT3B0aW1pemUgaW5kZXggY2FsY3VsYXRpb24uXG4vLyBUT0RPIE9wdGltaXplIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGJsdXJZKHNvdXJjZSwgdGFyZ2V0LCByKSB7XG4gIHZhciBuID0gc291cmNlLndpZHRoLFxuICAgICAgbSA9IHNvdXJjZS5oZWlnaHQsXG4gICAgICB3ID0gKHIgPDwgMSkgKyAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGZvciAodmFyIGogPSAwLCBzciA9IDA7IGogPCBtICsgcjsgKytqKSB7XG4gICAgICBpZiAoaiA8IG0pIHtcbiAgICAgICAgc3IgKz0gc291cmNlLmRhdGFbaSArIGogKiBuXTtcbiAgICAgIH1cbiAgICAgIGlmIChqID49IHIpIHtcbiAgICAgICAgaWYgKGogPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZS5kYXRhW2kgKyAoaiAtIHcpICogbl07XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmRhdGFbaSArIChqIC0gcikgKiBuXSA9IHNyIC8gTWF0aC5taW4oaiArIDEsIG0gLSAxICsgdyAtIGosIHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2VpZ2h0KCkge1xuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gZGVuc2l0eSgpIHtcbiAgdmFyIHggPSBkZWZhdWx0WCxcbiAgICAgIHkgPSBkZWZhdWx0WSxcbiAgICAgIHdlaWdodCA9IGRlZmF1bHRXZWlnaHQsXG4gICAgICBkeCA9IDk2MCxcbiAgICAgIGR5ID0gNTAwLFxuICAgICAgciA9IDIwLCAvLyBibHVyIHJhZGl1c1xuICAgICAgayA9IDIsIC8vIGxvZzIoZ3JpZCBjZWxsIHNpemUpXG4gICAgICBvID0gciAqIDMsIC8vIGdyaWQgb2Zmc2V0LCB0byBwYWQgZm9yIGJsdXJcbiAgICAgIG4gPSAoZHggKyBvICogMikgPj4gaywgLy8gZ3JpZCB3aWR0aFxuICAgICAgbSA9IChkeSArIG8gKiAyKSA+PiBrLCAvLyBncmlkIGhlaWdodFxuICAgICAgdGhyZXNob2xkID0gY29uc3RhbnQoMjApO1xuXG4gIGZ1bmN0aW9uIGRlbnNpdHkoZGF0YSkge1xuICAgIHZhciB2YWx1ZXMwID0gbmV3IEZsb2F0MzJBcnJheShuICogbSksXG4gICAgICAgIHZhbHVlczEgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKTtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkLCBpLCBkYXRhKSB7XG4gICAgICB2YXIgeGkgPSAoK3goZCwgaSwgZGF0YSkgKyBvKSA+PiBrLFxuICAgICAgICAgIHlpID0gKCt5KGQsIGksIGRhdGEpICsgbykgPj4gayxcbiAgICAgICAgICB3aSA9ICt3ZWlnaHQoZCwgaSwgZGF0YSk7XG4gICAgICBpZiAoeGkgPj0gMCAmJiB4aSA8IG4gJiYgeWkgPj0gMCAmJiB5aSA8IG0pIHtcbiAgICAgICAgdmFsdWVzMFt4aSArIHlpICogbl0gKz0gd2k7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPIE9wdGltaXplLlxuICAgIGJsdXJYKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMwfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCByID4+IGspO1xuICAgIGJsdXJZKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMxfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCByID4+IGspO1xuICAgIGJsdXJYKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMwfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCByID4+IGspO1xuICAgIGJsdXJZKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMxfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCByID4+IGspO1xuICAgIGJsdXJYKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMwfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCByID4+IGspO1xuICAgIGJsdXJZKHt3aWR0aDogbiwgaGVpZ2h0OiBtLCBkYXRhOiB2YWx1ZXMxfSwge3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCByID4+IGspO1xuXG4gICAgdmFyIHR6ID0gdGhyZXNob2xkKHZhbHVlczApO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICB2YXIgc3RvcCA9IGQzQXJyYXkubWF4KHZhbHVlczApO1xuICAgICAgdHogPSBkM0FycmF5LnRpY2tTdGVwKDAsIHN0b3AsIHR6KTtcbiAgICAgIHR6ID0gZDNBcnJheS5yYW5nZSgwLCBNYXRoLmZsb29yKHN0b3AgLyB0eikgKiB0eiwgdHopO1xuICAgICAgdHouc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udG91cnMoKVxuICAgICAgICAudGhyZXNob2xkcyh0eilcbiAgICAgICAgLnNpemUoW24sIG1dKVxuICAgICAgKHZhbHVlczApXG4gICAgICAgIC5tYXAodHJhbnNmb3JtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybShnZW9tZXRyeSkge1xuICAgIGdlb21ldHJ5LnZhbHVlICo9IE1hdGgucG93KDIsIC0yICogayk7IC8vIERlbnNpdHkgaW4gcG9pbnRzIHBlciBzcXVhcmUgcGl4ZWwuXG4gICAgZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1Qb2x5Z29uKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2x5Z29uKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1SaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVJpbmcoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvaW50KTtcbiAgfVxuXG4gIC8vIFRPRE8gT3B0aW1pemUuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXNbMF0gPSBjb29yZGluYXRlc1swXSAqIE1hdGgucG93KDIsIGspIC0gbztcbiAgICBjb29yZGluYXRlc1sxXSA9IGNvb3JkaW5hdGVzWzFdICogTWF0aC5wb3coMiwgaykgLSBvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIG8gPSByICogMztcbiAgICBuID0gKGR4ICsgbyAqIDIpID4+IGs7XG4gICAgbSA9IChkeSArIG8gKiAyKSA+PiBrO1xuICAgIHJldHVybiBkZW5zaXR5O1xuICB9XG5cbiAgZGVuc2l0eS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgZGVuc2l0eSkgOiB4O1xuICB9O1xuXG4gIGRlbnNpdHkueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGRlbnNpdHkpIDogeTtcbiAgfTtcblxuICBkZW5zaXR5LndlaWdodCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3ZWlnaHQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgZGVuc2l0eSkgOiB3ZWlnaHQ7XG4gIH07XG5cbiAgZGVuc2l0eS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuICAgIHZhciBfMCA9IE1hdGguY2VpbChfWzBdKSwgXzEgPSBNYXRoLmNlaWwoX1sxXSk7XG4gICAgaWYgKCEoXzAgPj0gMCkgJiYgIShfMCA+PSAwKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaXplXCIpO1xuICAgIHJldHVybiBkeCA9IF8wLCBkeSA9IF8xLCByZXNpemUoKTtcbiAgfTtcblxuICBkZW5zaXR5LmNlbGxTaXplID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIDEgPDwgaztcbiAgICBpZiAoISgoXyA9ICtfKSA+PSAxKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjZWxsIHNpemVcIik7XG4gICAgcmV0dXJuIGsgPSBNYXRoLmZsb29yKE1hdGgubG9nKF8pIC8gTWF0aC5MTjIpLCByZXNpemUoKTtcbiAgfTtcblxuICBkZW5zaXR5LnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQoc2xpY2UuY2FsbChfKSkgOiBjb25zdGFudChfKSwgZGVuc2l0eSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgZGVuc2l0eS5iYW5kd2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KHIgKiAociArIDEpKTtcbiAgICBpZiAoISgoXyA9ICtfKSA+PSAwKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiYW5kd2lkdGhcIik7XG4gICAgcmV0dXJuIHIgPSBNYXRoLnJvdW5kKChNYXRoLnNxcnQoNCAqIF8gKiBfICsgMSkgLSAxKSAvIDIpLCByZXNpemUoKTtcbiAgfTtcblxuICByZXR1cm4gZGVuc2l0eTtcbn1cblxuZXhwb3J0cy5jb250b3VycyA9IGNvbnRvdXJzO1xuZXhwb3J0cy5jb250b3VyRGVuc2l0eSA9IGRlbnNpdHk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRpc3BhdGNoLyB2MS4wLjYgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9vcCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydHMuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kcmFnLyB2MS4yLjUgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1kaXNwYXRjaCcsICdkMy1zZWxlY3Rpb24nXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzLCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzRGlzcGF0Y2gsIGQzU2VsZWN0aW9uKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbigpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZXZlbnQoKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBub2RyYWcodmlldykge1xuICB2YXIgcm9vdCA9IHZpZXcuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2VsZWN0aW9uID0gZDNTZWxlY3Rpb24uc2VsZWN0KHZpZXcpLm9uKFwiZHJhZ3N0YXJ0LmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByb290Ll9fbm9zZWxlY3QgPSByb290LnN0eWxlLk1velVzZXJTZWxlY3Q7XG4gICAgcm9vdC5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gXCJub25lXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gRHJhZ0V2ZW50KHRhcmdldCwgdHlwZSwgc3ViamVjdCwgaWQsIGFjdGl2ZSwgeCwgeSwgZHgsIGR5LCBkaXNwYXRjaCkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgdGhpcy5pZGVudGlmaWVyID0gaWQ7XG4gIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLmR4ID0gZHg7XG4gIHRoaXMuZHkgPSBkeTtcbiAgdGhpcy5fID0gZGlzcGF0Y2g7XG59XG5cbkRyYWdFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlID09PSB0aGlzLl8gPyB0aGlzIDogdmFsdWU7XG59O1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoKSB7XG4gIHJldHVybiAhZDNTZWxlY3Rpb24uZXZlbnQuY3RybEtleSAmJiAhZDNTZWxlY3Rpb24uZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29udGFpbmVyKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3ViamVjdChkKSB7XG4gIHJldHVybiBkID09IG51bGwgPyB7eDogZDNTZWxlY3Rpb24uZXZlbnQueCwgeTogZDNTZWxlY3Rpb24uZXZlbnQueX0gOiBkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG91Y2hhYmxlKCkge1xuICByZXR1cm4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IChcIm9udG91Y2hzdGFydFwiIGluIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBkcmFnKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGNvbnRhaW5lciA9IGRlZmF1bHRDb250YWluZXIsXG4gICAgICBzdWJqZWN0ID0gZGVmYXVsdFN1YmplY3QsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJzdGFydFwiLCBcImRyYWdcIiwgXCJlbmRcIiksXG4gICAgICBhY3RpdmUgPSAwLFxuICAgICAgbW91c2Vkb3dueCxcbiAgICAgIG1vdXNlZG93bnksXG4gICAgICBtb3VzZW1vdmluZyxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgY2xpY2tEaXN0YW5jZTIgPSAwO1xuXG4gIGZ1bmN0aW9uIGRyYWcoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi5kcmFnXCIsIG1vdXNlZG93bmVkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuZHJhZ1wiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS5kcmFnXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLmRyYWcgdG91Y2hjYW5jZWwuZHJhZ1wiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGdlc3R1cmUgPSBiZWZvcmVzdGFydChcIm1vdXNlXCIsIGNvbnRhaW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBkM1NlbGVjdGlvbi5tb3VzZSwgdGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIWdlc3R1cmUpIHJldHVybjtcbiAgICBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZ1wiLCBtb3VzZW1vdmVkLCB0cnVlKS5vbihcIm1vdXNldXAuZHJhZ1wiLCBtb3VzZXVwcGVkLCB0cnVlKTtcbiAgICBub2RyYWcoZDNTZWxlY3Rpb24uZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIG1vdXNlbW92aW5nID0gZmFsc2U7XG4gICAgbW91c2Vkb3dueCA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFg7XG4gICAgbW91c2Vkb3dueSA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFk7XG4gICAgZ2VzdHVyZShcInN0YXJ0XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vtb3ZlZCgpIHtcbiAgICBub2V2ZW50KCk7XG4gICAgaWYgKCFtb3VzZW1vdmluZykge1xuICAgICAgdmFyIGR4ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WCAtIG1vdXNlZG93bngsIGR5ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WSAtIG1vdXNlZG93bnk7XG4gICAgICBtb3VzZW1vdmluZyA9IGR4ICogZHggKyBkeSAqIGR5ID4gY2xpY2tEaXN0YW5jZTI7XG4gICAgfVxuICAgIGdlc3R1cmVzLm1vdXNlKFwiZHJhZ1wiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNldXBwZWQoKSB7XG4gICAgZDNTZWxlY3Rpb24uc2VsZWN0KGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWcgbW91c2V1cC5kcmFnXCIsIG51bGwpO1xuICAgIHllc2RyYWcoZDNTZWxlY3Rpb24uZXZlbnQudmlldywgbW91c2Vtb3ZpbmcpO1xuICAgIG5vZXZlbnQoKTtcbiAgICBnZXN0dXJlcy5tb3VzZShcImVuZFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgYyA9IGNvbnRhaW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KHRvdWNoZXNbaV0uaWRlbnRpZmllciwgYywgZDNTZWxlY3Rpb24udG91Y2gsIHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbigpO1xuICAgICAgICBnZXN0dXJlKFwic3RhcnRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZCgpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9ldmVudCgpO1xuICAgICAgICBnZXN0dXJlKFwiZHJhZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKCkge1xuICAgIHZhciB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgNTAwKTsgLy8gR2hvc3QgY2xpY2tzIGFyZSBkZWxheWVkIVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJlbmRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3Jlc3RhcnQoaWQsIGNvbnRhaW5lciwgcG9pbnQsIHRoYXQsIGFyZ3MpIHtcbiAgICB2YXIgcCA9IHBvaW50KGNvbnRhaW5lciwgaWQpLCBzLCBkeCwgZHksXG4gICAgICAgIHN1Ymxpc3RlbmVycyA9IGxpc3RlbmVycy5jb3B5KCk7XG5cbiAgICBpZiAoIWQzU2VsZWN0aW9uLmN1c3RvbUV2ZW50KG5ldyBEcmFnRXZlbnQoZHJhZywgXCJiZWZvcmVzdGFydFwiLCBzLCBpZCwgYWN0aXZlLCBwWzBdLCBwWzFdLCAwLCAwLCBzdWJsaXN0ZW5lcnMpLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgoZDNTZWxlY3Rpb24uZXZlbnQuc3ViamVjdCA9IHMgPSBzdWJqZWN0LmFwcGx5KHRoYXQsIGFyZ3MpKSA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBkeCA9IHMueCAtIHBbMF0gfHwgMDtcbiAgICAgIGR5ID0gcy55IC0gcFsxXSB8fCAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkpIHJldHVybjtcblxuICAgIHJldHVybiBmdW5jdGlvbiBnZXN0dXJlKHR5cGUpIHtcbiAgICAgIHZhciBwMCA9IHAsIG47XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6IGdlc3R1cmVzW2lkXSA9IGdlc3R1cmUsIG4gPSBhY3RpdmUrKzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmRcIjogZGVsZXRlIGdlc3R1cmVzW2lkXSwgLS1hY3RpdmU7IC8vIG5vYnJlYWtcbiAgICAgICAgY2FzZSBcImRyYWdcIjogcCA9IHBvaW50KGNvbnRhaW5lciwgaWQpLCBuID0gYWN0aXZlOyBicmVhaztcbiAgICAgIH1cbiAgICAgIGQzU2VsZWN0aW9uLmN1c3RvbUV2ZW50KG5ldyBEcmFnRXZlbnQoZHJhZywgdHlwZSwgcywgaWQsIG4sIHBbMF0gKyBkeCwgcFsxXSArIGR5LCBwWzBdIC0gcDBbMF0sIHBbMV0gLSBwMFsxXSwgc3VibGlzdGVuZXJzKSwgc3VibGlzdGVuZXJzLmFwcGx5LCBzdWJsaXN0ZW5lcnMsIFt0eXBlLCB0aGF0LCBhcmdzXSk7XG4gICAgfTtcbiAgfVxuXG4gIGRyYWcuZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiBmaWx0ZXI7XG4gIH07XG5cbiAgZHJhZy5jb250YWluZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGFpbmVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBjb250YWluZXI7XG4gIH07XG5cbiAgZHJhZy5zdWJqZWN0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN1YmplY3QgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IHN1YmplY3Q7XG4gIH07XG5cbiAgZHJhZy50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICBkcmFnLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGRyYWcgOiB2YWx1ZTtcbiAgfTtcblxuICBkcmFnLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIGRyYWcpIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICByZXR1cm4gZHJhZztcbn1cblxuZXhwb3J0cy5kcmFnID0gZHJhZztcbmV4cG9ydHMuZHJhZ0Rpc2FibGUgPSBub2RyYWc7XG5leHBvcnRzLmRyYWdFbmFibGUgPSB5ZXNkcmFnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRzdi8gdjEuMi4wIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIEVPTCA9IHt9LFxuICAgIEVPRiA9IHt9LFxuICAgIFFVT1RFID0gMzQsXG4gICAgTkVXTElORSA9IDEwLFxuICAgIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdIHx8IFxcXCJcXFwiXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgd2lkdGgpIHtcbiAgdmFyIHMgPSB2YWx1ZSArIFwiXCIsIGxlbmd0aCA9IHMubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKDApICsgcyA6IHM7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciA8IDAgPyBcIi1cIiArIHBhZCgteWVhciwgNilcbiAgICA6IHllYXIgPiA5OTk5ID8gXCIrXCIgKyBwYWQoeWVhciwgNilcbiAgICA6IHBhZCh5ZWFyLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKSxcbiAgICAgIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IFwiSW52YWxpZCBEYXRlXCJcbiAgICAgIDogZm9ybWF0WWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ0RhdGUoKSwgMilcbiAgICAgICsgKG1pbGxpc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIi5cIiArIHBhZChtaWxsaXNlY29uZHMsIDMpICsgXCJaXCJcbiAgICAgIDogc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIlpcIlxuICAgICAgOiBtaW51dGVzIHx8IGhvdXJzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIlpcIlxuICAgICAgOiBcIlwiKTtcbn1cblxuZnVuY3Rpb24gZHN2KGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUodmFsdWUpXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh2YWx1ZSArPSBcIlwiKSA/IFwiXFxcIlwiICsgdmFsdWUucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXG4gICAgICAgIDogdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRCb2R5OiBmb3JtYXRCb2R5LFxuICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3MsXG4gICAgZm9ybWF0Um93OiBmb3JtYXRSb3csXG4gICAgZm9ybWF0VmFsdWU6IGZvcm1hdFZhbHVlXG4gIH07XG59XG5cbnZhciBjc3YgPSBkc3YoXCIsXCIpO1xuXG52YXIgY3N2UGFyc2UgPSBjc3YucGFyc2U7XG52YXIgY3N2UGFyc2VSb3dzID0gY3N2LnBhcnNlUm93cztcbnZhciBjc3ZGb3JtYXQgPSBjc3YuZm9ybWF0O1xudmFyIGNzdkZvcm1hdEJvZHkgPSBjc3YuZm9ybWF0Qm9keTtcbnZhciBjc3ZGb3JtYXRSb3dzID0gY3N2LmZvcm1hdFJvd3M7XG52YXIgY3N2Rm9ybWF0Um93ID0gY3N2LmZvcm1hdFJvdztcbnZhciBjc3ZGb3JtYXRWYWx1ZSA9IGNzdi5mb3JtYXRWYWx1ZTtcblxudmFyIHRzdiA9IGRzdihcIlxcdFwiKTtcblxudmFyIHRzdlBhcnNlID0gdHN2LnBhcnNlO1xudmFyIHRzdlBhcnNlUm93cyA9IHRzdi5wYXJzZVJvd3M7XG52YXIgdHN2Rm9ybWF0ID0gdHN2LmZvcm1hdDtcbnZhciB0c3ZGb3JtYXRCb2R5ID0gdHN2LmZvcm1hdEJvZHk7XG52YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xudmFyIHRzdkZvcm1hdFJvdyA9IHRzdi5mb3JtYXRSb3c7XG52YXIgdHN2Rm9ybWF0VmFsdWUgPSB0c3YuZm9ybWF0VmFsdWU7XG5cbmZ1bmN0aW9uIGF1dG9UeXBlKG9iamVjdCkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV0udHJpbSgpLCBudW1iZXIsIG07XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBudWxsO1xuICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInRydWVcIikgdmFsdWUgPSB0cnVlO1xuICAgIGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpIHZhbHVlID0gZmFsc2U7XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IFwiTmFOXCIpIHZhbHVlID0gTmFOO1xuICAgIGVsc2UgaWYgKCFpc05hTihudW1iZXIgPSArdmFsdWUpKSB2YWx1ZSA9IG51bWJlcjtcbiAgICBlbHNlIGlmIChtID0gdmFsdWUubWF0Y2goL14oWy0rXVxcZHsyfSk/XFxkezR9KC1cXGR7Mn0oLVxcZHsyfSk/KT8oVFxcZHsyfTpcXGR7Mn0oOlxcZHsyfShcXC5cXGR7M30pPyk/KFp8Wy0rXVxcZHsyfTpcXGR7Mn0pPyk/JC8pKSB7XG4gICAgICBpZiAoZml4dHogJiYgISFtWzRdICYmICFtWzddKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLy0vZywgXCIvXCIpLnJlcGxhY2UoL1QvLCBcIiBcIik7XG4gICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBjb250aW51ZTtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1kc3YvaXNzdWVzLzQ1XG52YXIgZml4dHogPSBuZXcgRGF0ZShcIjIwMTktMDEtMDFUMDA6MDBcIikuZ2V0SG91cnMoKSB8fCBuZXcgRGF0ZShcIjIwMTktMDctMDFUMDA6MDBcIikuZ2V0SG91cnMoKTtcblxuZXhwb3J0cy5hdXRvVHlwZSA9IGF1dG9UeXBlO1xuZXhwb3J0cy5jc3ZGb3JtYXQgPSBjc3ZGb3JtYXQ7XG5leHBvcnRzLmNzdkZvcm1hdEJvZHkgPSBjc3ZGb3JtYXRCb2R5O1xuZXhwb3J0cy5jc3ZGb3JtYXRSb3cgPSBjc3ZGb3JtYXRSb3c7XG5leHBvcnRzLmNzdkZvcm1hdFJvd3MgPSBjc3ZGb3JtYXRSb3dzO1xuZXhwb3J0cy5jc3ZGb3JtYXRWYWx1ZSA9IGNzdkZvcm1hdFZhbHVlO1xuZXhwb3J0cy5jc3ZQYXJzZSA9IGNzdlBhcnNlO1xuZXhwb3J0cy5jc3ZQYXJzZVJvd3MgPSBjc3ZQYXJzZVJvd3M7XG5leHBvcnRzLmRzdkZvcm1hdCA9IGRzdjtcbmV4cG9ydHMudHN2Rm9ybWF0ID0gdHN2Rm9ybWF0O1xuZXhwb3J0cy50c3ZGb3JtYXRCb2R5ID0gdHN2Rm9ybWF0Qm9keTtcbmV4cG9ydHMudHN2Rm9ybWF0Um93ID0gdHN2Rm9ybWF0Um93O1xuZXhwb3J0cy50c3ZGb3JtYXRSb3dzID0gdHN2Rm9ybWF0Um93cztcbmV4cG9ydHMudHN2Rm9ybWF0VmFsdWUgPSB0c3ZGb3JtYXRWYWx1ZTtcbmV4cG9ydHMudHN2UGFyc2UgPSB0c3ZQYXJzZTtcbmV4cG9ydHMudHN2UGFyc2VSb3dzID0gdHN2UGFyc2VSb3dzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWVhc2UvIHYxLjAuNiBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGxpbmVhcih0KSB7XG4gIHJldHVybiArdDtcbn1cblxuZnVuY3Rpb24gcXVhZEluKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufVxuXG5mdW5jdGlvbiBxdWFkT3V0KHQpIHtcbiAgcmV0dXJuIHQgKiAoMiAtIHQpO1xufVxuXG5mdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCA6IC0tdCAqICgyIC0gdCkgKyAxKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGN1YmljSW4odCkge1xuICByZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5mdW5jdGlvbiBjdWJpY091dCh0KSB7XG4gIHJldHVybiAtLXQgKiB0ICogdCArIDE7XG59XG5cbmZ1bmN0aW9uIGN1YmljSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyB0ICogdCAqIHQgOiAodCAtPSAyKSAqIHQgKiB0ICsgMikgLyAyO1xufVxuXG52YXIgZXhwb25lbnQgPSAzO1xuXG52YXIgcG9seUluID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5SW4odCkge1xuICAgIHJldHVybiBNYXRoLnBvdyh0LCBlKTtcbiAgfVxuXG4gIHBvbHlJbi5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seUluO1xufSkoZXhwb25lbnQpO1xuXG52YXIgcG9seU91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seU91dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gdCwgZSk7XG4gIH1cblxuICBwb2x5T3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5T3V0O1xufSkoZXhwb25lbnQpO1xuXG52YXIgcG9seUluT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5SW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KHQsIGUpIDogMiAtIE1hdGgucG93KDIgLSB0LCBlKSkgLyAyO1xuICB9XG5cbiAgcG9seUluT3V0LmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW5PdXQ7XG59KShleHBvbmVudCk7XG5cbnZhciBwaSA9IE1hdGguUEksXG4gICAgaGFsZlBpID0gcGkgLyAyO1xuXG5mdW5jdGlvbiBzaW5Jbih0KSB7XG4gIHJldHVybiAxIC0gTWF0aC5jb3ModCAqIGhhbGZQaSk7XG59XG5cbmZ1bmN0aW9uIHNpbk91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNpbih0ICogaGFsZlBpKTtcbn1cblxuZnVuY3Rpb24gc2luSW5PdXQodCkge1xuICByZXR1cm4gKDEgLSBNYXRoLmNvcyhwaSAqIHQpKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGV4cEluKHQpIHtcbiAgcmV0dXJuIE1hdGgucG93KDIsIDEwICogdCAtIDEwKTtcbn1cblxuZnVuY3Rpb24gZXhwT3V0KHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnBvdygyLCAtMTAgKiB0KTtcbn1cblxuZnVuY3Rpb24gZXhwSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCkgOiAyIC0gTWF0aC5wb3coMiwgMTAgLSAxMCAqIHQpKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNpcmNsZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbn1cblxuZnVuY3Rpb24gY2lyY2xlT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5cbmZ1bmN0aW9uIGNpcmNsZUluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpIDogTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSkgLyAyO1xufVxuXG52YXIgYjEgPSA0IC8gMTEsXG4gICAgYjIgPSA2IC8gMTEsXG4gICAgYjMgPSA4IC8gMTEsXG4gICAgYjQgPSAzIC8gNCxcbiAgICBiNSA9IDkgLyAxMSxcbiAgICBiNiA9IDEwIC8gMTEsXG4gICAgYjcgPSAxNSAvIDE2LFxuICAgIGI4ID0gMjEgLyAyMixcbiAgICBiOSA9IDYzIC8gNjQsXG4gICAgYjAgPSAxIC8gYjEgLyBiMTtcblxuZnVuY3Rpb24gYm91bmNlSW4odCkge1xuICByZXR1cm4gMSAtIGJvdW5jZU91dCgxIC0gdCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5jZU91dCh0KSB7XG4gIHJldHVybiAodCA9ICt0KSA8IGIxID8gYjAgKiB0ICogdCA6IHQgPCBiMyA/IGIwICogKHQgLT0gYjIpICogdCArIGI0IDogdCA8IGI2ID8gYjAgKiAodCAtPSBiNSkgKiB0ICsgYjcgOiBiMCAqICh0IC09IGI4KSAqIHQgKyBiOTtcbn1cblxuZnVuY3Rpb24gYm91bmNlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gYm91bmNlT3V0KDEgLSB0KSA6IGJvdW5jZU91dCh0IC0gMSkgKyAxKSAvIDI7XG59XG5cbnZhciBvdmVyc2hvb3QgPSAxLjcwMTU4O1xuXG52YXIgYmFja0luID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrSW4odCkge1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9XG5cbiAgYmFja0luLm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja0luO1xufSkob3ZlcnNob290KTtcblxudmFyIGJhY2tPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tPdXQodCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9XG5cbiAgYmFja091dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tPdXQ7XG59KShvdmVyc2hvb3QpO1xuXG52YXIgYmFja0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgKj0gMikgPCAxID8gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKSA6ICh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMikgLyAyO1xuICB9XG5cbiAgYmFja0luT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja0luT3V0O1xufSkob3ZlcnNob290KTtcblxudmFyIHRhdSA9IDIgKiBNYXRoLlBJLFxuICAgIGFtcGxpdHVkZSA9IDEsXG4gICAgcGVyaW9kID0gMC4zO1xuXG52YXIgZWxhc3RpY0luID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbih0KSB7XG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAxMCAqIC0tdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcCk7XG4gIH1cblxuICBlbGFzdGljSW4uYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW4ucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW47XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbnZhciBlbGFzdGljT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNPdXQodCkge1xuICAgIHJldHVybiAxIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqICh0ID0gK3QpKSAqIE1hdGguc2luKCh0ICsgcykgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNPdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY091dDtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxudmFyIGVsYXN0aWNJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuICAgIHJldHVybiAoKHQgPSB0ICogMiAtIDEpIDwgMFxuICAgICAgICA/IGEgKiBNYXRoLnBvdygyLCAxMCAqIHQpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApXG4gICAgICAgIDogMiAtIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKChzICsgdCkgLyBwKSkgLyAyO1xuICB9XG5cbiAgZWxhc3RpY0luT3V0LmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luT3V0LnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG5leHBvcnRzLmVhc2VCYWNrID0gYmFja0luT3V0O1xuZXhwb3J0cy5lYXNlQmFja0luID0gYmFja0luO1xuZXhwb3J0cy5lYXNlQmFja0luT3V0ID0gYmFja0luT3V0O1xuZXhwb3J0cy5lYXNlQmFja091dCA9IGJhY2tPdXQ7XG5leHBvcnRzLmVhc2VCb3VuY2UgPSBib3VuY2VPdXQ7XG5leHBvcnRzLmVhc2VCb3VuY2VJbiA9IGJvdW5jZUluO1xuZXhwb3J0cy5lYXNlQm91bmNlSW5PdXQgPSBib3VuY2VJbk91dDtcbmV4cG9ydHMuZWFzZUJvdW5jZU91dCA9IGJvdW5jZU91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZSA9IGNpcmNsZUluT3V0O1xuZXhwb3J0cy5lYXNlQ2lyY2xlSW4gPSBjaXJjbGVJbjtcbmV4cG9ydHMuZWFzZUNpcmNsZUluT3V0ID0gY2lyY2xlSW5PdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGVPdXQgPSBjaXJjbGVPdXQ7XG5leHBvcnRzLmVhc2VDdWJpYyA9IGN1YmljSW5PdXQ7XG5leHBvcnRzLmVhc2VDdWJpY0luID0gY3ViaWNJbjtcbmV4cG9ydHMuZWFzZUN1YmljSW5PdXQgPSBjdWJpY0luT3V0O1xuZXhwb3J0cy5lYXNlQ3ViaWNPdXQgPSBjdWJpY091dDtcbmV4cG9ydHMuZWFzZUVsYXN0aWMgPSBlbGFzdGljT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpY0luID0gZWxhc3RpY0luO1xuZXhwb3J0cy5lYXNlRWxhc3RpY0luT3V0ID0gZWxhc3RpY0luT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpY091dCA9IGVsYXN0aWNPdXQ7XG5leHBvcnRzLmVhc2VFeHAgPSBleHBJbk91dDtcbmV4cG9ydHMuZWFzZUV4cEluID0gZXhwSW47XG5leHBvcnRzLmVhc2VFeHBJbk91dCA9IGV4cEluT3V0O1xuZXhwb3J0cy5lYXNlRXhwT3V0ID0gZXhwT3V0O1xuZXhwb3J0cy5lYXNlTGluZWFyID0gbGluZWFyO1xuZXhwb3J0cy5lYXNlUG9seSA9IHBvbHlJbk91dDtcbmV4cG9ydHMuZWFzZVBvbHlJbiA9IHBvbHlJbjtcbmV4cG9ydHMuZWFzZVBvbHlJbk91dCA9IHBvbHlJbk91dDtcbmV4cG9ydHMuZWFzZVBvbHlPdXQgPSBwb2x5T3V0O1xuZXhwb3J0cy5lYXNlUXVhZCA9IHF1YWRJbk91dDtcbmV4cG9ydHMuZWFzZVF1YWRJbiA9IHF1YWRJbjtcbmV4cG9ydHMuZWFzZVF1YWRJbk91dCA9IHF1YWRJbk91dDtcbmV4cG9ydHMuZWFzZVF1YWRPdXQgPSBxdWFkT3V0O1xuZXhwb3J0cy5lYXNlU2luID0gc2luSW5PdXQ7XG5leHBvcnRzLmVhc2VTaW5JbiA9IHNpbkluO1xuZXhwb3J0cy5lYXNlU2luSW5PdXQgPSBzaW5Jbk91dDtcbmV4cG9ydHMuZWFzZVNpbk91dCA9IHNpbk91dDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mZXRjaC8gdjEuMS4yIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtZHN2JykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtZHN2J10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNEc3YpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXNwb25zZUJsb2IocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG59XG5cbmZ1bmN0aW9uIGJsb2IoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlQmxvYik7XG59XG5cbmZ1bmN0aW9uIHJlc3BvbnNlQXJyYXlCdWZmZXIocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xufVxuXG5mdW5jdGlvbiBidWZmZXIoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlQXJyYXlCdWZmZXIpO1xufVxuXG5mdW5jdGlvbiByZXNwb25zZVRleHQocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIHRleHQoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGRzdlBhcnNlKHBhcnNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCwgcm93KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkc3YoZGVsaW1pdGVyLCBpbnB1dCwgaW5pdCwgcm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gIHZhciBmb3JtYXQgPSBkM0Rzdi5kc3ZGb3JtYXQoZGVsaW1pdGVyKTtcbiAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZm9ybWF0LnBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICB9KTtcbn1cblxudmFyIGNzdiA9IGRzdlBhcnNlKGQzRHN2LmNzdlBhcnNlKTtcbnZhciB0c3YgPSBkc3ZQYXJzZShkM0Rzdi50c3ZQYXJzZSk7XG5cbmZ1bmN0aW9uIGltYWdlKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2U7XG4gICAgZm9yICh2YXIga2V5IGluIGluaXQpIGltYWdlW2tleV0gPSBpbml0W2tleV07XG4gICAgaW1hZ2Uub25lcnJvciA9IHJlamVjdDtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHsgcmVzb2x2ZShpbWFnZSk7IH07XG4gICAgaW1hZ2Uuc3JjID0gaW5wdXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNwb25zZUpzb24ocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbmZ1bmN0aW9uIGpzb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlSnNvbik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlcih0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCkgIHtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbih0ZXh0JCQxKSB7XG4gICAgICByZXR1cm4gKG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyh0ZXh0JCQxLCB0eXBlKTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIHhtbCA9IHBhcnNlcihcImFwcGxpY2F0aW9uL3htbFwiKTtcblxudmFyIGh0bWwgPSBwYXJzZXIoXCJ0ZXh0L2h0bWxcIik7XG5cbnZhciBzdmcgPSBwYXJzZXIoXCJpbWFnZS9zdmcreG1sXCIpO1xuXG5leHBvcnRzLmJsb2IgPSBibG9iO1xuZXhwb3J0cy5idWZmZXIgPSBidWZmZXI7XG5leHBvcnRzLmRzdiA9IGRzdjtcbmV4cG9ydHMuY3N2ID0gY3N2O1xuZXhwb3J0cy50c3YgPSB0c3Y7XG5leHBvcnRzLmltYWdlID0gaW1hZ2U7XG5leHBvcnRzLmpzb24gPSBqc29uO1xuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmV4cG9ydHMueG1sID0geG1sO1xuZXhwb3J0cy5odG1sID0gaHRtbDtcbmV4cG9ydHMuc3ZnID0gc3ZnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mb3JjZS8gdjEuMi4xIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtcXVhZHRyZWUnKSwgcmVxdWlyZSgnZDMtY29sbGVjdGlvbicpLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy10aW1lcicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXF1YWR0cmVlJywgJ2QzLWNvbGxlY3Rpb24nLCAnZDMtZGlzcGF0Y2gnLCAnZDMtdGltZXInXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1F1YWR0cmVlLGQzQ29sbGVjdGlvbixkM0Rpc3BhdGNoLGQzVGltZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjZW50ZXIoeCwgeSkge1xuICB2YXIgbm9kZXM7XG5cbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpIHkgPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBub2RlLFxuICAgICAgICBzeCA9IDAsXG4gICAgICAgIHN5ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgc3ggKz0gbm9kZS54LCBzeSArPSBub2RlLnk7XG4gICAgfVxuXG4gICAgZm9yIChzeCA9IHN4IC8gbiAtIHgsIHN5ID0gc3kgLyBuIC0geSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54IC09IHN4LCBub2RlLnkgLT0gc3k7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gamlnZ2xlKCkge1xuICByZXR1cm4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMWUtNjtcbn1cblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLnggKyBkLnZ4O1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueSArIGQudnk7XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGUocmFkaXVzKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIHJhZGlpLFxuICAgICAgc3RyZW5ndGggPSAxLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQocmFkaXVzID09IG51bGwgPyAxIDogK3JhZGl1cyk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHhpLFxuICAgICAgICB5aSxcbiAgICAgICAgcmksXG4gICAgICAgIHJpMjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICB0cmVlID0gZDNRdWFkdHJlZS5xdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xuICAgICAgICB4aSA9IG5vZGUueCArIG5vZGUudng7XG4gICAgICAgIHlpID0gbm9kZS55ICsgbm9kZS52eTtcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBkYXRhID0gcXVhZC5kYXRhLCByaiA9IHF1YWQuciwgciA9IHJpICsgcmo7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pbmRleCA+IG5vZGUuaW5kZXgpIHtcbiAgICAgICAgICB2YXIgeCA9IHhpIC0gZGF0YS54IC0gZGF0YS52eCxcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcbiAgICAgICAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgaWYgKGwgPCByICogcikge1xuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUoKSwgbCArPSB4ICogeDtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKCksIGwgKz0geSAqIHk7XG4gICAgICAgICAgICBsID0gKHIgLSAobCA9IE1hdGguc3FydChsKSkpIC8gbCAqIHN0cmVuZ3RoO1xuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xuICAgICAgICAgICAgbm9kZS52eSArPSAoeSAqPSBsKSAqIHI7XG4gICAgICAgICAgICBkYXRhLnZ4IC09IHggKiAociA9IDEgLSByKTtcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gciB8fCB5MCA+IHlpICsgciB8fCB5MSA8IHlpIC0gcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcbiAgICBpZiAocXVhZC5kYXRhKSByZXR1cm4gcXVhZC5yID0gcmFkaWlbcXVhZC5kYXRhLmluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gcXVhZC5yID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XG4gICAgICAgIHF1YWQuciA9IHF1YWRbaV0ucjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHJhZGlpW25vZGUuaW5kZXhdID0gK3JhZGl1cyhub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG5cbmZ1bmN0aW9uIGluZGV4KGQpIHtcbiAgcmV0dXJuIGQuaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGZpbmQobm9kZUJ5SWQsIG5vZGVJZCkge1xuICB2YXIgbm9kZSA9IG5vZGVCeUlkLmdldChub2RlSWQpO1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGxpbmsobGlua3MpIHtcbiAgdmFyIGlkID0gaW5kZXgsXG4gICAgICBzdHJlbmd0aCA9IGRlZmF1bHRTdHJlbmd0aCxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlID0gY29uc3RhbnQoMzApLFxuICAgICAgZGlzdGFuY2VzLFxuICAgICAgbm9kZXMsXG4gICAgICBjb3VudCxcbiAgICAgIGJpYXMsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAobGlua3MgPT0gbnVsbCkgbGlua3MgPSBbXTtcblxuICBmdW5jdGlvbiBkZWZhdWx0U3RyZW5ndGgobGluaykge1xuICAgIHJldHVybiAxIC8gTWF0aC5taW4oY291bnRbbGluay5zb3VyY2UuaW5kZXhdLCBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBrID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpbmssIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCBsLCBiOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tpXSwgc291cmNlID0gbGluay5zb3VyY2UsIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICB4ID0gdGFyZ2V0LnggKyB0YXJnZXQudnggLSBzb3VyY2UueCAtIHNvdXJjZS52eCB8fCBqaWdnbGUoKTtcbiAgICAgICAgeSA9IHRhcmdldC55ICsgdGFyZ2V0LnZ5IC0gc291cmNlLnkgLSBzb3VyY2UudnkgfHwgamlnZ2xlKCk7XG4gICAgICAgIGwgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgIGwgPSAobCAtIGRpc3RhbmNlc1tpXSkgLyBsICogYWxwaGEgKiBzdHJlbmd0aHNbaV07XG4gICAgICAgIHggKj0gbCwgeSAqPSBsO1xuICAgICAgICB0YXJnZXQudnggLT0geCAqIChiID0gYmlhc1tpXSk7XG4gICAgICAgIHRhcmdldC52eSAtPSB5ICogYjtcbiAgICAgICAgc291cmNlLnZ4ICs9IHggKiAoYiA9IDEgLSBiKTtcbiAgICAgICAgc291cmNlLnZ5ICs9IHkgKiBiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG0gPSBsaW5rcy5sZW5ndGgsXG4gICAgICAgIG5vZGVCeUlkID0gZDNDb2xsZWN0aW9uLm1hcChub2RlcywgaWQpLFxuICAgICAgICBsaW5rO1xuXG4gICAgZm9yIChpID0gMCwgY291bnQgPSBuZXcgQXJyYXkobik7IGkgPCBtOyArK2kpIHtcbiAgICAgIGxpbmsgPSBsaW5rc1tpXSwgbGluay5pbmRleCA9IGk7XG4gICAgICBpZiAodHlwZW9mIGxpbmsuc291cmNlICE9PSBcIm9iamVjdFwiKSBsaW5rLnNvdXJjZSA9IGZpbmQobm9kZUJ5SWQsIGxpbmsuc291cmNlKTtcbiAgICAgIGlmICh0eXBlb2YgbGluay50YXJnZXQgIT09IFwib2JqZWN0XCIpIGxpbmsudGFyZ2V0ID0gZmluZChub2RlQnlJZCwgbGluay50YXJnZXQpO1xuICAgICAgY291bnRbbGluay5zb3VyY2UuaW5kZXhdID0gKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSB8fCAwKSArIDE7XG4gICAgICBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0gPSAoY291bnRbbGluay50YXJnZXQuaW5kZXhdIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBiaWFzID0gbmV3IEFycmF5KG0pOyBpIDwgbTsgKytpKSB7XG4gICAgICBsaW5rID0gbGlua3NbaV0sIGJpYXNbaV0gPSBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gLyAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdICsgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgICB9XG5cbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVTdHJlbmd0aCgpO1xuICAgIGRpc3RhbmNlcyA9IG5ldyBBcnJheShtKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplU3RyZW5ndGgoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9ICtzdHJlbmd0aChsaW5rc1tpXSwgaSwgbGlua3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVEaXN0YW5jZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgZGlzdGFuY2VzW2ldID0gK2Rpc3RhbmNlKGxpbmtzW2ldLCBpLCBsaW5rcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxpbmtzID0gXywgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBsaW5rcztcbiAgfTtcblxuICBmb3JjZS5pZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IF8sIGZvcmNlKSA6IGlkO1xuICB9O1xuXG4gIGZvcmNlLml0ZXJhdGlvbnMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaXRlcmF0aW9ucyA9ICtfLCBmb3JjZSkgOiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemVTdHJlbmd0aCgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplRGlzdGFuY2UoKSwgZm9yY2UpIDogZGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuXG5mdW5jdGlvbiB4JDEoZCkge1xuICByZXR1cm4gZC54O1xufVxuXG5mdW5jdGlvbiB5JDEoZCkge1xuICByZXR1cm4gZC55O1xufVxuXG52YXIgaW5pdGlhbFJhZGl1cyA9IDEwLFxuICAgIGluaXRpYWxBbmdsZSA9IE1hdGguUEkgKiAoMyAtIE1hdGguc3FydCg1KSk7XG5cbmZ1bmN0aW9uIHNpbXVsYXRpb24obm9kZXMpIHtcbiAgdmFyIHNpbXVsYXRpb24sXG4gICAgICBhbHBoYSA9IDEsXG4gICAgICBhbHBoYU1pbiA9IDAuMDAxLFxuICAgICAgYWxwaGFEZWNheSA9IDEgLSBNYXRoLnBvdyhhbHBoYU1pbiwgMSAvIDMwMCksXG4gICAgICBhbHBoYVRhcmdldCA9IDAsXG4gICAgICB2ZWxvY2l0eURlY2F5ID0gMC42LFxuICAgICAgZm9yY2VzID0gZDNDb2xsZWN0aW9uLm1hcCgpLFxuICAgICAgc3RlcHBlciA9IGQzVGltZXIudGltZXIoc3RlcCksXG4gICAgICBldmVudCA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJ0aWNrXCIsIFwiZW5kXCIpO1xuXG4gIGlmIChub2RlcyA9PSBudWxsKSBub2RlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgdGljaygpO1xuICAgIGV2ZW50LmNhbGwoXCJ0aWNrXCIsIHNpbXVsYXRpb24pO1xuICAgIGlmIChhbHBoYSA8IGFscGhhTWluKSB7XG4gICAgICBzdGVwcGVyLnN0b3AoKTtcbiAgICAgIGV2ZW50LmNhbGwoXCJlbmRcIiwgc2ltdWxhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGljayhpdGVyYXRpb25zKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG5cbiAgICBpZiAoaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSBpdGVyYXRpb25zID0gMTtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICBhbHBoYSArPSAoYWxwaGFUYXJnZXQgLSBhbHBoYSkgKiBhbHBoYURlY2F5O1xuXG4gICAgICBmb3JjZXMuZWFjaChmdW5jdGlvbiAoZm9yY2UpIHtcbiAgICAgICAgZm9yY2UoYWxwaGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5meCA9PSBudWxsKSBub2RlLnggKz0gbm9kZS52eCAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICBlbHNlIG5vZGUueCA9IG5vZGUuZngsIG5vZGUudnggPSAwO1xuICAgICAgICBpZiAobm9kZS5meSA9PSBudWxsKSBub2RlLnkgKz0gbm9kZS52eSAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICBlbHNlIG5vZGUueSA9IG5vZGUuZnksIG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaW11bGF0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVzKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUuaW5kZXggPSBpO1xuICAgICAgaWYgKG5vZGUuZnggIT0gbnVsbCkgbm9kZS54ID0gbm9kZS5meDtcbiAgICAgIGlmIChub2RlLmZ5ICE9IG51bGwpIG5vZGUueSA9IG5vZGUuZnk7XG4gICAgICBpZiAoaXNOYU4obm9kZS54KSB8fCBpc05hTihub2RlLnkpKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBpbml0aWFsUmFkaXVzICogTWF0aC5zcXJ0KGkpLCBhbmdsZSA9IGkgKiBpbml0aWFsQW5nbGU7XG4gICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgbm9kZS55ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmFOKG5vZGUudngpIHx8IGlzTmFOKG5vZGUudnkpKSB7XG4gICAgICAgIG5vZGUudnggPSBub2RlLnZ5ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRm9yY2UoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UuaW5pdGlhbGl6ZSkgZm9yY2UuaW5pdGlhbGl6ZShub2Rlcyk7XG4gICAgcmV0dXJuIGZvcmNlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZU5vZGVzKCk7XG5cbiAgcmV0dXJuIHNpbXVsYXRpb24gPSB7XG4gICAgdGljazogdGljayxcblxuICAgIHJlc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIucmVzdGFydChzdGVwKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5zdG9wKCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIG5vZGVzOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlcyA9IF8sIGluaXRpYWxpemVOb2RlcygpLCBmb3JjZXMuZWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IG5vZGVzO1xuICAgIH0sXG5cbiAgICBhbHBoYTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYTtcbiAgICB9LFxuXG4gICAgYWxwaGFNaW46IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhTWluID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFNaW47XG4gICAgfSxcblxuICAgIGFscGhhRGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhRGVjYXkgPSArXywgc2ltdWxhdGlvbikgOiArYWxwaGFEZWNheTtcbiAgICB9LFxuXG4gICAgYWxwaGFUYXJnZXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhVGFyZ2V0ID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFUYXJnZXQ7XG4gICAgfSxcblxuICAgIHZlbG9jaXR5RGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZlbG9jaXR5RGVjYXkgPSAxIC0gXywgc2ltdWxhdGlvbikgOiAxIC0gdmVsb2NpdHlEZWNheTtcbiAgICB9LFxuXG4gICAgZm9yY2U6IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICgoXyA9PSBudWxsID8gZm9yY2VzLnJlbW92ZShuYW1lKSA6IGZvcmNlcy5zZXQobmFtZSwgaW5pdGlhbGl6ZUZvcmNlKF8pKSksIHNpbXVsYXRpb24pIDogZm9yY2VzLmdldChuYW1lKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeSxcbiAgICAgICAgICBkMixcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGNsb3Nlc3Q7XG5cbiAgICAgIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gICAgICBlbHNlIHJhZGl1cyAqPSByYWRpdXM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBkeCA9IHggLSBub2RlLng7XG4gICAgICAgIGR5ID0geSAtIG5vZGUueTtcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGQyIDwgcmFkaXVzKSBjbG9zZXN0ID0gbm9kZSwgcmFkaXVzID0gZDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH0sXG5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKGV2ZW50Lm9uKG5hbWUsIF8pLCBzaW11bGF0aW9uKSA6IGV2ZW50Lm9uKG5hbWUpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFueUJvZHkoKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIG5vZGUsXG4gICAgICBhbHBoYSxcbiAgICAgIHN0cmVuZ3RoID0gY29uc3RhbnQoLTMwKSxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlTWluMiA9IDEsXG4gICAgICBkaXN0YW5jZU1heDIgPSBJbmZpbml0eSxcbiAgICAgIHRoZXRhMiA9IDAuODE7XG5cbiAgZnVuY3Rpb24gZm9yY2UoXykge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCB0cmVlID0gZDNRdWFkdHJlZS5xdWFkdHJlZShub2RlcywgeCQxLCB5JDEpLnZpc2l0QWZ0ZXIoYWNjdW11bGF0ZSk7XG4gICAgZm9yIChhbHBoYSA9IF8sIGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHRyZWUudmlzaXQoYXBwbHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgc3RyZW5ndGhzW25vZGUuaW5kZXhdID0gK3N0cmVuZ3RoKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY3VtdWxhdGUocXVhZCkge1xuICAgIHZhciBzdHJlbmd0aCA9IDAsIHEsIGMsIHdlaWdodCA9IDAsIHgsIHksIGk7XG5cbiAgICAvLyBGb3IgaW50ZXJuYWwgbm9kZXMsIGFjY3VtdWxhdGUgZm9yY2VzIGZyb20gY2hpbGQgcXVhZHJhbnRzLlxuICAgIGlmIChxdWFkLmxlbmd0aCkge1xuICAgICAgZm9yICh4ID0geSA9IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIGlmICgocSA9IHF1YWRbaV0pICYmIChjID0gTWF0aC5hYnMocS52YWx1ZSkpKSB7XG4gICAgICAgICAgc3RyZW5ndGggKz0gcS52YWx1ZSwgd2VpZ2h0ICs9IGMsIHggKz0gYyAqIHEueCwgeSArPSBjICogcS55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWFkLnggPSB4IC8gd2VpZ2h0O1xuICAgICAgcXVhZC55ID0geSAvIHdlaWdodDtcbiAgICB9XG5cbiAgICAvLyBGb3IgbGVhZiBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjb2luY2lkZW50IHF1YWRyYW50cy5cbiAgICBlbHNlIHtcbiAgICAgIHEgPSBxdWFkO1xuICAgICAgcS54ID0gcS5kYXRhLng7XG4gICAgICBxLnkgPSBxLmRhdGEueTtcbiAgICAgIGRvIHN0cmVuZ3RoICs9IHN0cmVuZ3Roc1txLmRhdGEuaW5kZXhdO1xuICAgICAgd2hpbGUgKHEgPSBxLm5leHQpO1xuICAgIH1cblxuICAgIHF1YWQudmFsdWUgPSBzdHJlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgxLCBfLCB4Mikge1xuICAgIGlmICghcXVhZC52YWx1ZSkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgeCA9IHF1YWQueCAtIG5vZGUueCxcbiAgICAgICAgeSA9IHF1YWQueSAtIG5vZGUueSxcbiAgICAgICAgdyA9IHgyIC0geDEsXG4gICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgLy8gQXBwbHkgdGhlIEJhcm5lcy1IdXQgYXBwcm94aW1hdGlvbiBpZiBwb3NzaWJsZS5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAodyAqIHcgLyB0aGV0YTIgPCBsKSB7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWF4Mikge1xuICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xuICAgICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZSgpLCBsICs9IHkgKiB5O1xuICAgICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICAgICAgbm9kZS52eCArPSB4ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgICAgbm9kZS52eSArPSB5ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBwb2ludHMgZGlyZWN0bHkuXG4gICAgZWxzZSBpZiAocXVhZC5sZW5ndGggfHwgbCA+PSBkaXN0YW5jZU1heDIpIHJldHVybjtcblxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxuICAgIGlmIChxdWFkLmRhdGEgIT09IG5vZGUgfHwgcXVhZC5uZXh0KSB7XG4gICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xuICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUoKSwgbCArPSB5ICogeTtcbiAgICAgIGlmIChsIDwgZGlzdGFuY2VNaW4yKSBsID0gTWF0aC5zcXJ0KGRpc3RhbmNlTWluMiAqIGwpO1xuICAgIH1cblxuICAgIGRvIGlmIChxdWFkLmRhdGEgIT09IG5vZGUpIHtcbiAgICAgIHcgPSBzdHJlbmd0aHNbcXVhZC5kYXRhLmluZGV4XSAqIGFscGhhIC8gbDtcbiAgICAgIG5vZGUudnggKz0geCAqIHc7XG4gICAgICBub2RlLnZ5ICs9IHkgKiB3O1xuICAgIH0gd2hpbGUgKHF1YWQgPSBxdWFkLm5leHQpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNaW4yID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1pbjIpO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWF4ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWF4MiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNYXgyKTtcbiAgfTtcblxuICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuXG5mdW5jdGlvbiByYWRpYWwocmFkaXVzLCB4LCB5KSB7XG4gIHZhciBub2RlcyxcbiAgICAgIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHJhZGl1c2VzO1xuXG4gIGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHJhZGl1cyA9IGNvbnN0YW50KCtyYWRpdXMpO1xuICBpZiAoeCA9PSBudWxsKSB4ID0gMDtcbiAgaWYgKHkgPT0gbnVsbCkgeSA9IDA7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXSxcbiAgICAgICAgICBkeCA9IG5vZGUueCAtIHggfHwgMWUtNixcbiAgICAgICAgICBkeSA9IG5vZGUueSAtIHkgfHwgMWUtNixcbiAgICAgICAgICByID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSxcbiAgICAgICAgICBrID0gKHJhZGl1c2VzW2ldIC0gcikgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYSAvIHI7XG4gICAgICBub2RlLnZ4ICs9IGR4ICogaztcbiAgICAgIG5vZGUudnkgKz0gZHkgKiBrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICByYWRpdXNlcyA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICByYWRpdXNlc1tpXSA9ICtyYWRpdXMobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHJhZGl1c2VzW2ldKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXywgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArXywgZm9yY2UpIDogeDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSArXywgZm9yY2UpIDogeTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG5cbmZ1bmN0aW9uIHgkMih4KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHh6O1xuXG4gIGlmICh0eXBlb2YgeCAhPT0gXCJmdW5jdGlvblwiKSB4ID0gY29uc3RhbnQoeCA9PSBudWxsID8gMCA6ICt4KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnggKz0gKHh6W2ldIC0gbm9kZS54KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB4eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih4eltpXSA9ICt4KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuXG5mdW5jdGlvbiB5JDIoeSkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB5ejtcblxuICBpZiAodHlwZW9mIHkgIT09IFwiZnVuY3Rpb25cIikgeSA9IGNvbnN0YW50KHkgPT0gbnVsbCA/IDAgOiAreSk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ5ICs9ICh5eltpXSAtIG5vZGUueSkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeXogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeXpbaV0gPSAreShub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cblxuZXhwb3J0cy5mb3JjZUNlbnRlciA9IGNlbnRlcjtcbmV4cG9ydHMuZm9yY2VDb2xsaWRlID0gY29sbGlkZTtcbmV4cG9ydHMuZm9yY2VMaW5rID0gbGluaztcbmV4cG9ydHMuZm9yY2VNYW55Qm9keSA9IG1hbnlCb2R5O1xuZXhwb3J0cy5mb3JjZVJhZGlhbCA9IHJhZGlhbDtcbmV4cG9ydHMuZm9yY2VTaW11bGF0aW9uID0gc2ltdWxhdGlvbjtcbmV4cG9ydHMuZm9yY2VYID0geCQyO1xuZXhwb3J0cy5mb3JjZVkgPSB5JDI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWZvcm1hdC8gdjEuNC4zIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmZ1bmN0aW9uIGZvcm1hdERlY2ltYWwoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnQoeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWwoTWF0aC5hYnMoeCkpLCB4ID8geFsxXSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0R3JvdXAoZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHQgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TnVtZXJhbHMobnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG4gIHZhciBtYXRjaDtcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoe1xuICAgIGZpbGw6IG1hdGNoWzFdLFxuICAgIGFsaWduOiBtYXRjaFsyXSxcbiAgICBzaWduOiBtYXRjaFszXSxcbiAgICBzeW1ib2w6IG1hdGNoWzRdLFxuICAgIHplcm86IG1hdGNoWzVdLFxuICAgIHdpZHRoOiBtYXRjaFs2XSxcbiAgICBjb21tYTogbWF0Y2hbN10sXG4gICAgcHJlY2lzaW9uOiBtYXRjaFs4XSAmJiBtYXRjaFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiBtYXRjaFs5XSxcbiAgICB0eXBlOiBtYXRjaFsxMF1cbiAgfSk7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgdGhpcy5maWxsID0gc3BlY2lmaWVyLmZpbGwgPT09IHVuZGVmaW5lZCA/IFwiIFwiIDogc3BlY2lmaWVyLmZpbGwgKyBcIlwiO1xuICB0aGlzLmFsaWduID0gc3BlY2lmaWVyLmFsaWduID09PSB1bmRlZmluZWQgPyBcIj5cIiA6IHNwZWNpZmllci5hbGlnbiArIFwiXCI7XG4gIHRoaXMuc2lnbiA9IHNwZWNpZmllci5zaWduID09PSB1bmRlZmluZWQgPyBcIi1cIiA6IHNwZWNpZmllci5zaWduICsgXCJcIjtcbiAgdGhpcy5zeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnN5bWJvbCArIFwiXCI7XG4gIHRoaXMuemVybyA9ICEhc3BlY2lmaWVyLnplcm87XG4gIHRoaXMud2lkdGggPSBzcGVjaWZpZXIud2lkdGggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIud2lkdGg7XG4gIHRoaXMuY29tbWEgPSAhIXNwZWNpZmllci5jb21tYTtcbiAgdGhpcy5wcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLnByZWNpc2lvbjtcbiAgdGhpcy50cmltID0gISFzcGVjaWZpZXIudHJpbTtcbiAgdGhpcy50eXBlID0gc3BlY2lmaWVyLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIudHlwZSArIFwiXCI7XG59XG5cbkZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgKyB0aGlzLmFsaWduXG4gICAgICArIHRoaXMuc2lnblxuICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy53aWR0aCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICsgKHRoaXMudHJpbSA/IFwiflwiIDogXCJcIilcbiAgICAgICsgdGhpcy50eXBlO1xufTtcblxuLy8gVHJpbXMgaW5zaWduaWZpY2FudCB6ZXJvcywgZS5nLiwgcmVwbGFjZXMgMS4yMDAwayB3aXRoIDEuMmsuXG5mdW5jdGlvbiBmb3JtYXRUcmltKHMpIHtcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgIHN3aXRjaCAoc1tpXSkge1xuICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XG59XG5cbnZhciBwcmVmaXhFeHBvbmVudDtcblxuZnVuY3Rpb24gZm9ybWF0UHJlZml4QXV0byh4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufVxuXG5mdW5jdGlvbiBmb3JtYXRSb3VuZGVkKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xufVxuXG52YXIgZm9ybWF0VHlwZXMgPSB7XG4gIFwiJVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiAoeCAqIDEwMCkudG9GaXhlZChwKTsgfSxcbiAgXCJiXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMik7IH0sXG4gIFwiY1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgXCJcIjsgfSxcbiAgXCJkXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTApOyB9LFxuICBcImVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0V4cG9uZW50aWFsKHApOyB9LFxuICBcImZcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b0ZpeGVkKHApOyB9LFxuICBcImdcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4geC50b1ByZWNpc2lvbihwKTsgfSxcbiAgXCJvXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoOCk7IH0sXG4gIFwicFwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApOyB9LFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9LFxuICBcInhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNik7IH1cbn07XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbnZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLFxuICAgIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiwrVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxuZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgPT09IHVuZGVmaW5lZCB8fCBsb2NhbGUudGhvdXNhbmRzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdEdyb3VwKG1hcC5jYWxsKGxvY2FsZS5ncm91cGluZywgTnVtYmVyKSwgbG9jYWxlLnRob3VzYW5kcyArIFwiXCIpLFxuICAgICAgY3VycmVuY3lQcmVmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMF0gKyBcIlwiLFxuICAgICAgY3VycmVuY3lTdWZmaXggPSBsb2NhbGUuY3VycmVuY3kgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBsb2NhbGUuY3VycmVuY3lbMV0gKyBcIlwiLFxuICAgICAgZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsID09PSB1bmRlZmluZWQgPyBcIi5cIiA6IGxvY2FsZS5kZWNpbWFsICsgXCJcIixcbiAgICAgIG51bWVyYWxzID0gbG9jYWxlLm51bWVyYWxzID09PSB1bmRlZmluZWQgPyBpZGVudGl0eSA6IGZvcm1hdE51bWVyYWxzKG1hcC5jYWxsKGxvY2FsZS5udW1lcmFscywgU3RyaW5nKSksXG4gICAgICBwZXJjZW50ID0gbG9jYWxlLnBlcmNlbnQgPT09IHVuZGVmaW5lZCA/IFwiJVwiIDogbG9jYWxlLnBlcmNlbnQgKyBcIlwiLFxuICAgICAgbWludXMgPSBsb2NhbGUubWludXMgPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDA7XG4gICAgICAgIHZhbHVlID0gaXNOYU4odmFsdWUpID8gbmFuIDogZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gVHJpbSBpbnNpZ25pZmljYW50IHplcm9zLlxuICAgICAgICBpZiAodHJpbSkgdmFsdWUgPSBmb3JtYXRUcmltKHZhbHVlKTtcblxuICAgICAgICAvLyBJZiBhIG5lZ2F0aXZlIHZhbHVlIHJvdW5kcyB0byB6ZXJvIGR1cmluZyBmb3JtYXR0aW5nLCB0cmVhdCBhcyBwb3NpdGl2ZS5cbiAgICAgICAgaWYgKHZhbHVlTmVnYXRpdmUgJiYgK3ZhbHVlID09PSAwKSB2YWx1ZU5lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgICAgIHZhbHVlUHJlZml4ID0gKHZhbHVlTmVnYXRpdmUgPyAoc2lnbiA9PT0gXCIoXCIgPyBzaWduIDogbWludXMpIDogc2lnbiA9PT0gXCItXCIgfHwgc2lnbiA9PT0gXCIoXCIgPyBcIlwiIDogc2lnbikgKyB2YWx1ZVByZWZpeDtcblxuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG5cbnZhciBsb2NhbGU7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICBkZWNpbWFsOiBcIi5cIixcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl0sXG4gIG1pbnVzOiBcIi1cIlxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBwcmVjaXNpb25GaXhlZChzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyAtIGV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG5cbmZ1bmN0aW9uIHByZWNpc2lvblJvdW5kKHN0ZXAsIG1heCkge1xuICBzdGVwID0gTWF0aC5hYnMoc3RlcCksIG1heCA9IE1hdGguYWJzKG1heCkgLSBzdGVwO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgZXhwb25lbnQobWF4KSAtIGV4cG9uZW50KHN0ZXApKSArIDE7XG59XG5cbmV4cG9ydHMuRm9ybWF0U3BlY2lmaWVyID0gRm9ybWF0U3BlY2lmaWVyO1xuZXhwb3J0cy5mb3JtYXREZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbmV4cG9ydHMuZm9ybWF0TG9jYWxlID0gZm9ybWF0TG9jYWxlO1xuZXhwb3J0cy5mb3JtYXRTcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXI7XG5leHBvcnRzLnByZWNpc2lvbkZpeGVkID0gcHJlY2lzaW9uRml4ZWQ7XG5leHBvcnRzLnByZWNpc2lvblByZWZpeCA9IHByZWNpc2lvblByZWZpeDtcbmV4cG9ydHMucHJlY2lzaW9uUm91bmQgPSBwcmVjaXNpb25Sb3VuZDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1nZW8vIHYxLjExLjkgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1hcnJheScpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWFycmF5J10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30sIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNBcnJheSkgeyAndXNlIHN0cmljdCc7XG5cbi8vIEFkZHMgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyB3aXRoIHR3aWNlIHRoZSBub3JtYWwgcHJlY2lzaW9uLlxuLy8gUmVmZXJlbmNlOiBKLiBSLiBTaGV3Y2h1aywgQWRhcHRpdmUgUHJlY2lzaW9uIEZsb2F0aW5nLVBvaW50IEFyaXRobWV0aWMgYW5kXG4vLyBGYXN0IFJvYnVzdCBHZW9tZXRyaWMgUHJlZGljYXRlcywgRGlzY3JldGUgJiBDb21wdXRhdGlvbmFsIEdlb21ldHJ5IDE4KDMpXG4vLyAzMDXigJMzNjMgKDE5OTcpLlxuLy8gQ29kZSBhZGFwdGVkIGZyb20gR2VvZ3JhcGhpY0xpYiBieSBDaGFybGVzIEYuIEYuIEthcm5leSxcbi8vIGh0dHA6Ly9nZW9ncmFwaGljbGliLnNvdXJjZWZvcmdlLm5ldC9cblxuZnVuY3Rpb24gYWRkZXIoKSB7XG4gIHJldHVybiBuZXcgQWRkZXI7XG59XG5cbmZ1bmN0aW9uIEFkZGVyKCkge1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbkFkZGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFkZGVyLFxuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zID0gLy8gcm91bmRlZCB2YWx1ZVxuICAgIHRoaXMudCA9IDA7IC8vIGV4YWN0IGVycm9yXG4gIH0sXG4gIGFkZDogZnVuY3Rpb24oeSkge1xuICAgIGFkZCh0ZW1wLCB5LCB0aGlzLnQpO1xuICAgIGFkZCh0aGlzLCB0ZW1wLnMsIHRoaXMucyk7XG4gICAgaWYgKHRoaXMucykgdGhpcy50ICs9IHRlbXAudDtcbiAgICBlbHNlIHRoaXMucyA9IHRlbXAudDtcbiAgfSxcbiAgdmFsdWVPZjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucztcbiAgfVxufTtcblxudmFyIHRlbXAgPSBuZXcgQWRkZXI7XG5cbmZ1bmN0aW9uIGFkZChhZGRlciwgYSwgYikge1xuICB2YXIgeCA9IGFkZGVyLnMgPSBhICsgYixcbiAgICAgIGJ2ID0geCAtIGEsXG4gICAgICBhdiA9IHggLSBidjtcbiAgYWRkZXIudCA9IChhIC0gYXYpICsgKGIgLSBidik7XG59XG5cbnZhciBlcHNpbG9uID0gMWUtNjtcbnZhciBlcHNpbG9uMiA9IDFlLTEyO1xudmFyIHBpID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSAvIDI7XG52YXIgcXVhcnRlclBpID0gcGkgLyA0O1xudmFyIHRhdSA9IHBpICogMjtcblxudmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbnZhciByYWRpYW5zID0gcGkgLyAxODA7XG5cbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBhdGFuID0gTWF0aC5hdGFuO1xudmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGV4cCA9IE1hdGguZXhwO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG52YXIgc3FydCA9IE1hdGguc3FydDtcbnZhciB0YW4gPSBNYXRoLnRhbjtcblxuZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZnVuY3Rpb24gYXNpbih4KSB7XG4gIHJldHVybiB4ID4gMSA/IGhhbGZQaSA6IHggPCAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGhhdmVyc2luKHgpIHtcbiAgcmV0dXJuICh4ID0gc2luKHggLyAyKSkgKiB4O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59O1xuXG52YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgc3RyZWFtLmxpbmVFbmQoKTtcbn1cblxuZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG59XG5cbmZ1bmN0aW9uIGdlb1N0cmVhbShvYmplY3QsIHN0cmVhbSkge1xuICBpZiAob2JqZWN0ICYmIHN0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdCwgc3RyZWFtKTtcbiAgfVxufVxuXG52YXIgYXJlYVJpbmdTdW0gPSBhZGRlcigpO1xuXG52YXIgYXJlYVN1bSA9IGFkZGVyKCksXG4gICAgbGFtYmRhMDAsXG4gICAgcGhpMDAsXG4gICAgbGFtYmRhMCxcbiAgICBjb3NQaGkwLFxuICAgIHNpblBoaTA7XG5cbnZhciBhcmVhU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYVJpbmcgPSArYXJlYVJpbmdTdW07XG4gICAgYXJlYVN1bS5hZGQoYXJlYVJpbmcgPCAwID8gdGF1ICsgYXJlYVJpbmcgOiBhcmVhUmluZyk7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQgPSB0aGlzLnBvaW50ID0gbm9vcDtcbiAgfSxcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3VtLmFkZCh0YXUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kKCkge1xuICBhcmVhUG9pbnQobGFtYmRhMDAsIHBoaTAwKTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcbiAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3MocGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaSksIHNpblBoaTAgPSBzaW4ocGhpKTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgcGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaTsgLy8gaGFsZiB0aGUgYW5ndWxhciBkaXN0YW5jZSBmcm9tIHNvdXRoIHBvbGVcblxuICAvLyBTcGhlcmljYWwgZXhjZXNzIEUgZm9yIGEgc3BoZXJpY2FsIHRyaWFuZ2xlIHdpdGggdmVydGljZXM6IHNvdXRoIHBvbGUsXG4gIC8vIHByZXZpb3VzIHBvaW50LCBjdXJyZW50IHBvaW50LiAgVXNlcyBhIGZvcm11bGEgZGVyaXZlZCBmcm9tIENhZ25vbGnigJlzXG4gIC8vIHRoZW9yZW0uICBTZWUgVG9kaHVudGVyLCBTcGhlcmljYWwgVHJpZy4gKDE4NzEpLCBTZWMuIDEwMywgRXEuICgyKS5cbiAgdmFyIGRMYW1iZGEgPSBsYW1iZGEgLSBsYW1iZGEwLFxuICAgICAgc2RMYW1iZGEgPSBkTGFtYmRhID49IDAgPyAxIDogLTEsXG4gICAgICBhZExhbWJkYSA9IHNkTGFtYmRhICogZExhbWJkYSxcbiAgICAgIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBrID0gc2luUGhpMCAqIHNpblBoaSxcbiAgICAgIHUgPSBjb3NQaGkwICogY29zUGhpICsgayAqIGNvcyhhZExhbWJkYSksXG4gICAgICB2ID0gayAqIHNkTGFtYmRhICogc2luKGFkTGFtYmRhKTtcbiAgYXJlYVJpbmdTdW0uYWRkKGF0YW4yKHYsIHUpKTtcblxuICAvLyBBZHZhbmNlIHRoZSBwcmV2aW91cyBwb2ludHMuXG4gIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3NQaGksIHNpblBoaTAgPSBzaW5QaGk7XG59XG5cbmZ1bmN0aW9uIGFyZWEob2JqZWN0KSB7XG4gIGFyZWFTdW0ucmVzZXQoKTtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgYXJlYVN0cmVhbSk7XG4gIHJldHVybiBhcmVhU3VtICogMjtcbn1cblxuZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICByZXR1cm4gW2F0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgYXNpbihjYXJ0ZXNpYW5bMl0pXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuKHNwaGVyaWNhbCkge1xuICB2YXIgbGFtYmRhID0gc3BoZXJpY2FsWzBdLCBwaGkgPSBzcGhlcmljYWxbMV0sIGNvc1BoaSA9IGNvcyhwaGkpO1xuICByZXR1cm4gW2Nvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSldO1xufVxuXG5mdW5jdGlvbiBjYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuXG5mdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG59XG5cbi8vIFRPRE8gcmV0dXJuIGFcbmZ1bmN0aW9uIGNhcnRlc2lhbkFkZEluUGxhY2UoYSwgYikge1xuICBhWzBdICs9IGJbMF0sIGFbMV0gKz0gYlsxXSwgYVsyXSArPSBiWzJdO1xufVxuXG5mdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgcmV0dXJuIFt2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gZFxuZnVuY3Rpb24gY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShkKSB7XG4gIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICBkWzBdIC89IGwsIGRbMV0gLz0gbCwgZFsyXSAvPSBsO1xufVxuXG52YXIgbGFtYmRhMCQxLCBwaGkwLCBsYW1iZGExLCBwaGkxLCAvLyBib3VuZHNcbiAgICBsYW1iZGEyLCAvLyBwcmV2aW91cyBsYW1iZGEtY29vcmRpbmF0ZVxuICAgIGxhbWJkYTAwJDEsIHBoaTAwJDEsIC8vIGZpcnN0IHBvaW50XG4gICAgcDAsIC8vIHByZXZpb3VzIDNEIHBvaW50XG4gICAgZGVsdGFTdW0gPSBhZGRlcigpLFxuICAgIHJhbmdlcyxcbiAgICByYW5nZTtcblxudmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICBsaW5lU3RhcnQ6IGJvdW5kc0xpbmVTdGFydCxcbiAgbGluZUVuZDogYm91bmRzTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNSaW5nUG9pbnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc1JpbmdTdGFydDtcbiAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc1JpbmdFbmQ7XG4gICAgZGVsdGFTdW0ucmVzZXQoKTtcbiAgICBhcmVhU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzTGluZVN0YXJ0O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzTGluZUVuZDtcbiAgICBpZiAoYXJlYVJpbmdTdW0gPCAwKSBsYW1iZGEwJDEgPSAtKGxhbWJkYTEgPSAxODApLCBwaGkwID0gLShwaGkxID0gOTApO1xuICAgIGVsc2UgaWYgKGRlbHRhU3VtID4gZXBzaWxvbikgcGhpMSA9IDkwO1xuICAgIGVsc2UgaWYgKGRlbHRhU3VtIDwgLWVwc2lsb24pIHBoaTAgPSAtOTA7XG4gICAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgfSxcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICBsYW1iZGEwJDEgPSAtKGxhbWJkYTEgPSAxODApLCBwaGkwID0gLShwaGkxID0gOTApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludChsYW1iZGEsIHBoaSkge1xuICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwJDEgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xufVxuXG5mdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgdmFyIHAgPSBjYXJ0ZXNpYW4oW2xhbWJkYSAqIHJhZGlhbnMsIHBoaSAqIHJhZGlhbnNdKTtcbiAgaWYgKHAwKSB7XG4gICAgdmFyIG5vcm1hbCA9IGNhcnRlc2lhbkNyb3NzKHAwLCBwKSxcbiAgICAgICAgZXF1YXRvcmlhbCA9IFtub3JtYWxbMV0sIC1ub3JtYWxbMF0sIDBdLFxuICAgICAgICBpbmZsZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGluZmxlY3Rpb24pO1xuICAgIGluZmxlY3Rpb24gPSBzcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMixcbiAgICAgICAgc2lnbiA9IGRlbHRhID4gMCA/IDEgOiAtMSxcbiAgICAgICAgbGFtYmRhaSA9IGluZmxlY3Rpb25bMF0gKiBkZWdyZWVzICogc2lnbixcbiAgICAgICAgcGhpaSxcbiAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzKGRlbHRhKSA+IDE4MDtcbiAgICBpZiAoYW50aW1lcmlkaWFuIF4gKHNpZ24gKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiAqIGxhbWJkYSkpIHtcbiAgICAgIHBoaWkgPSBpbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgIGlmIChwaGlpID4gcGhpMSkgcGhpMSA9IHBoaWk7XG4gICAgfSBlbHNlIGlmIChsYW1iZGFpID0gKGxhbWJkYWkgKyAzNjApICUgMzYwIC0gMTgwLCBhbnRpbWVyaWRpYW4gXiAoc2lnbiAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduICogbGFtYmRhKSkge1xuICAgICAgcGhpaSA9IC1pbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgIGlmIChwaGlpIDwgcGhpMCkgcGhpMCA9IHBoaWk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xuICAgICAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG4gICAgfVxuICAgIGlmIChhbnRpbWVyaWRpYW4pIHtcbiAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEyKSB7XG4gICAgICAgIGlmIChhbmdsZShsYW1iZGEwJDEsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKSBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsYW1iZGExID49IGxhbWJkYTAkMSkge1xuICAgICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMCQxKSBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGExKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTIpIHtcbiAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCQxLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSkgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByYW5nZXMucHVzaChyYW5nZSA9IFtsYW1iZGEwJDEgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgfVxuICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG4gIHAwID0gcCwgbGFtYmRhMiA9IGxhbWJkYTtcbn1cblxuZnVuY3Rpb24gYm91bmRzTGluZVN0YXJ0KCkge1xuICBib3VuZHNTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0xpbmVFbmQoKSB7XG4gIHJhbmdlWzBdID0gbGFtYmRhMCQxLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICBwMCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICBpZiAocDApIHtcbiAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyO1xuICAgIGRlbHRhU3VtLmFkZChhYnMoZGVsdGEpID4gMTgwID8gZGVsdGEgKyAoZGVsdGEgPiAwID8gMzYwIDogLTM2MCkgOiBkZWx0YSk7XG4gIH0gZWxzZSB7XG4gICAgbGFtYmRhMDAkMSA9IGxhbWJkYSwgcGhpMDAkMSA9IHBoaTtcbiAgfVxuICBhcmVhU3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgbGluZVBvaW50KGxhbWJkYSwgcGhpKTtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ1N0YXJ0KCkge1xuICBhcmVhU3RyZWFtLmxpbmVTdGFydCgpO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nRW5kKCkge1xuICBib3VuZHNSaW5nUG9pbnQobGFtYmRhMDAkMSwgcGhpMDAkMSk7XG4gIGFyZWFTdHJlYW0ubGluZUVuZCgpO1xuICBpZiAoYWJzKGRlbHRhU3VtKSA+IGVwc2lsb24pIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCk7XG4gIHJhbmdlWzBdID0gbGFtYmRhMCQxLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gIHAwID0gbnVsbDtcbn1cblxuLy8gRmluZHMgdGhlIGxlZnQtcmlnaHQgZGlzdGFuY2UgYmV0d2VlbiB0d28gbG9uZ2l0dWRlcy5cbi8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XG4vLyB0aGUgZGlzdGFuY2UgYmV0d2VlbiDCsTE4MMKwIHRvIGJlIDM2MMKwLlxuZnVuY3Rpb24gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkge1xuICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XG59XG5cbmZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgeCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gcmFuZ2VbMV0gPyByYW5nZVswXSA8PSB4ICYmIHggPD0gcmFuZ2VbMV0gOiB4IDwgcmFuZ2VbMF0gfHwgcmFuZ2VbMV0gPCB4O1xufVxuXG5mdW5jdGlvbiBib3VuZHMoZmVhdHVyZSkge1xuICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XG5cbiAgcGhpMSA9IGxhbWJkYTEgPSAtKGxhbWJkYTAkMSA9IHBoaTAgPSBJbmZpbml0eSk7XG4gIHJhbmdlcyA9IFtdO1xuICBnZW9TdHJlYW0oZmVhdHVyZSwgYm91bmRzU3RyZWFtKTtcblxuICAvLyBGaXJzdCwgc29ydCByYW5nZXMgYnkgdGhlaXIgbWluaW11bSBsb25naXR1ZGVzLlxuICBpZiAobiA9IHJhbmdlcy5sZW5ndGgpIHtcbiAgICByYW5nZXMuc29ydChyYW5nZUNvbXBhcmUpO1xuXG4gICAgLy8gVGhlbiwgbWVyZ2UgYW55IHJhbmdlcyB0aGF0IG92ZXJsYXAuXG4gICAgZm9yIChpID0gMSwgYSA9IHJhbmdlc1swXSwgbWVyZ2VkID0gW2FdOyBpIDwgbjsgKytpKSB7XG4gICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlQ29udGFpbnMoYSwgYlswXSkgfHwgcmFuZ2VDb250YWlucyhhLCBiWzFdKSkge1xuICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVsxXSA9IGJbMV07XG4gICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBmaW5kIHRoZSBsYXJnZXN0IGdhcCBiZXR3ZWVuIHRoZSBtZXJnZWQgcmFuZ2VzLlxuICAgIC8vIFRoZSBmaW5hbCBib3VuZGluZyBib3ggd2lsbCBiZSB0aGUgaW52ZXJzZSBvZiB0aGlzIGdhcC5cbiAgICBmb3IgKGRlbHRhTWF4ID0gLUluZmluaXR5LCBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICBpZiAoKGRlbHRhID0gYW5nbGUoYVsxXSwgYlswXSkpID4gZGVsdGFNYXgpIGRlbHRhTWF4ID0gZGVsdGEsIGxhbWJkYTAkMSA9IGJbMF0sIGxhbWJkYTEgPSBhWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJhbmdlcyA9IHJhbmdlID0gbnVsbDtcblxuICByZXR1cm4gbGFtYmRhMCQxID09PSBJbmZpbml0eSB8fCBwaGkwID09PSBJbmZpbml0eVxuICAgICAgPyBbW05hTiwgTmFOXSwgW05hTiwgTmFOXV1cbiAgICAgIDogW1tsYW1iZGEwJDEsIHBoaTBdLCBbbGFtYmRhMSwgcGhpMV1dO1xufVxuXG52YXIgVzAsIFcxLFxuICAgIFgwLCBZMCwgWjAsXG4gICAgWDEsIFkxLCBaMSxcbiAgICBYMiwgWTIsIFoyLFxuICAgIGxhbWJkYTAwJDIsIHBoaTAwJDIsIC8vIGZpcnN0IHBvaW50XG4gICAgeDAsIHkwLCB6MDsgLy8gcHJldmlvdXMgcG9pbnRcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AsXG4gIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZDtcbiAgfVxufTtcblxuLy8gQXJpdGhtZXRpYyBtZWFuIG9mIENhcnRlc2lhbiB2ZWN0b3JzLlxuZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbihjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludENhcnRlc2lhbih4LCB5LCB6KSB7XG4gICsrVzA7XG4gIFgwICs9ICh4IC0gWDApIC8gVzA7XG4gIFkwICs9ICh5IC0gWTApIC8gVzA7XG4gIFowICs9ICh6IC0gWjApIC8gVzA7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gIHowID0gc2luKHBoaSk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgdyA9IGF0YW4yKHNxcnQoKHcgPSB5MCAqIHogLSB6MCAqIHkpICogdyArICh3ID0gejAgKiB4IC0geDAgKiB6KSAqIHcgKyAodyA9IHgwICogeSAtIHkwICogeCkgKiB3KSwgeDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6KTtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kKCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbi8vIFNlZSBKLiBFLiBCcm9jaywgVGhlIEluZXJ0aWEgVGVuc29yIGZvciBhIFNwaGVyaWNhbCBUcmlhbmdsZSxcbi8vIEouIEFwcGxpZWQgTWVjaGFuaWNzIDQyLCAyMzkgKDE5NzUpLlxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEwMCQyLCBwaGkwMCQyKTtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYTAwJDIgPSBsYW1iZGEsIHBoaTAwJDIgPSBwaGk7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludDtcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICB6MCA9IHNpbihwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgIGN4ID0geTAgKiB6IC0gejAgKiB5LFxuICAgICAgY3kgPSB6MCAqIHggLSB4MCAqIHosXG4gICAgICBjeiA9IHgwICogeSAtIHkwICogeCxcbiAgICAgIG0gPSBzcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksXG4gICAgICB3ID0gYXNpbihtKSwgLy8gbGluZSB3ZWlnaHQgPSBhbmdsZVxuICAgICAgdiA9IG0gJiYgLXcgLyBtOyAvLyBhcmVhIHdlaWdodCBtdWx0aXBsaWVyXG4gIFgyICs9IHYgKiBjeDtcbiAgWTIgKz0gdiAqIGN5O1xuICBaMiArPSB2ICogY3o7XG4gIFcxICs9IHc7XG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkKG9iamVjdCkge1xuICBXMCA9IFcxID1cbiAgWDAgPSBZMCA9IFowID1cbiAgWDEgPSBZMSA9IFoxID1cbiAgWDIgPSBZMiA9IFoyID0gMDtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgY2VudHJvaWRTdHJlYW0pO1xuXG4gIHZhciB4ID0gWDIsXG4gICAgICB5ID0gWTIsXG4gICAgICB6ID0gWjIsXG4gICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIC8vIElmIHRoZSBhcmVhLXdlaWdodGVkIGNjZW50cm9pZCBpcyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBsZW5ndGgtd2VpZ2h0ZWQgY2NlbnRyb2lkLlxuICBpZiAobSA8IGVwc2lsb24yKSB7XG4gICAgeCA9IFgxLCB5ID0gWTEsIHogPSBaMTtcbiAgICAvLyBJZiB0aGUgZmVhdHVyZSBoYXMgemVybyBsZW5ndGgsIGZhbGwgYmFjayB0byBhcml0aG1ldGljIG1lYW4gb2YgcG9pbnQgdmVjdG9ycy5cbiAgICBpZiAoVzEgPCBlcHNpbG9uKSB4ID0gWDAsIHkgPSBZMCwgeiA9IFowO1xuICAgIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxuICAgIGlmIChtIDwgZXBzaWxvbjIpIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG5cbiAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMsIGFzaW4oeiAvIHNxcnQobSkpICogZGVncmVlc107XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wb3NlKGEsIGIpIHtcblxuICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gIH1cblxuICBpZiAoYS5pbnZlcnQgJiYgYi5pbnZlcnQpIGNvbXBvc2UuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gIH07XG5cbiAgcmV0dXJuIGNvbXBvc2U7XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFthYnMobGFtYmRhKSA+IHBpID8gbGFtYmRhICsgTWF0aC5yb3VuZCgtbGFtYmRhIC8gdGF1KSAqIHRhdSA6IGxhbWJkYSwgcGhpXTtcbn1cblxucm90YXRpb25JZGVudGl0eS5pbnZlcnQgPSByb3RhdGlvbklkZW50aXR5O1xuXG5mdW5jdGlvbiByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICByZXR1cm4gKGRlbHRhTGFtYmRhICU9IHRhdSkgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcbiAgICA6IHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSlcbiAgICA6IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSlcbiAgICA6IHJvdGF0aW9uSWRlbnRpdHkpO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGxhbWJkYSArPSBkZWx0YUxhbWJkYSwgW2xhbWJkYSA+IHBpID8gbGFtYmRhIC0gdGF1IDogbGFtYmRhIDwgLXBpID8gbGFtYmRhICsgdGF1IDogbGFtYmRhLCBwaGldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICB2YXIgcm90YXRpb24gPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpO1xuICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHZhciBjb3NEZWx0YVBoaSA9IGNvcyhkZWx0YVBoaSksXG4gICAgICBzaW5EZWx0YVBoaSA9IHNpbihkZWx0YVBoaSksXG4gICAgICBjb3NEZWx0YUdhbW1hID0gY29zKGRlbHRhR2FtbWEpLFxuICAgICAgc2luRGVsdGFHYW1tYSA9IHNpbihkZWx0YUdhbW1hKTtcblxuICBmdW5jdGlvbiByb3RhdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YVBoaSArIHggKiBzaW5EZWx0YVBoaTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgLSBrICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpIC0geiAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhR2FtbWEgKyB5ICogc2luRGVsdGFHYW1tYSlcbiAgICBdO1xuICB9XG5cbiAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSArIHogKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgKyBrICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgXTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRpb247XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uKHJvdGF0ZSkge1xuICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9XG5cbiAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMsIGNvb3JkaW5hdGVzO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuXG4vLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxuZnVuY3Rpb24gY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCB0MCwgdDEpIHtcbiAgaWYgKCFkZWx0YSkgcmV0dXJuO1xuICB2YXIgY29zUmFkaXVzID0gY29zKHJhZGl1cyksXG4gICAgICBzaW5SYWRpdXMgPSBzaW4ocmFkaXVzKSxcbiAgICAgIHN0ZXAgPSBkaXJlY3Rpb24gKiBkZWx0YTtcbiAgaWYgKHQwID09IG51bGwpIHtcbiAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdTtcbiAgICB0MSA9IHJhZGl1cyAtIHN0ZXAgLyAyO1xuICB9IGVsc2Uge1xuICAgIHQwID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDApO1xuICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpIHQwICs9IGRpcmVjdGlvbiAqIHRhdTtcbiAgfVxuICBmb3IgKHZhciBwb2ludCwgdCA9IHQwOyBkaXJlY3Rpb24gPiAwID8gdCA+IHQxIDogdCA8IHQxOyB0IC09IHN0ZXApIHtcbiAgICBwb2ludCA9IHNwaGVyaWNhbChbY29zUmFkaXVzLCAtc2luUmFkaXVzICogY29zKHQpLCAtc2luUmFkaXVzICogc2luKHQpXSk7XG4gICAgc3RyZWFtLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgc2lnbmVkIGFuZ2xlIG9mIGEgY2FydGVzaWFuIHBvaW50IHJlbGF0aXZlIHRvIFtjb3NSYWRpdXMsIDAsIDBdLlxuZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUgLSBlcHNpbG9uKSAlIHRhdTtcbn1cblxuZnVuY3Rpb24gY2lyY2xlKCkge1xuICB2YXIgY2VudGVyID0gY29uc3RhbnQoWzAsIDBdKSxcbiAgICAgIHJhZGl1cyA9IGNvbnN0YW50KDkwKSxcbiAgICAgIHByZWNpc2lvbiA9IGNvbnN0YW50KDYpLFxuICAgICAgcmluZyxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHN0cmVhbSA9IHtwb2ludDogcG9pbnR9O1xuXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgeFswXSAqPSBkZWdyZWVzLCB4WzFdICo9IGRlZ3JlZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgdmFyIGMgPSBjZW50ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgciA9IHJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucyxcbiAgICAgICAgcCA9IHByZWNpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucztcbiAgICByaW5nID0gW107XG4gICAgcm90YXRlID0gcm90YXRlUmFkaWFucygtY1swXSAqIHJhZGlhbnMsIC1jWzFdICogcmFkaWFucywgMCkuaW52ZXJ0O1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHIsIHAsIDEpO1xuICAgIGMgPSB7dHlwZTogXCJQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBbcmluZ119O1xuICAgIHJpbmcgPSByb3RhdGUgPSBudWxsO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgY2lyY2xlLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcbiAgfTtcblxuICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcmFkaXVzO1xuICB9O1xuXG4gIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiBwcmVjaXNpb247XG4gIH07XG5cbiAgcmV0dXJuIGNpcmNsZTtcbn1cblxuZnVuY3Rpb24gY2xpcEJ1ZmZlcigpIHtcbiAgdmFyIGxpbmVzID0gW10sXG4gICAgICBsaW5lO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBsaW5lLnB1c2goW3gsIHldKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBsaW5lcy5wdXNoKGxpbmUgPSBbXSk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBub29wLFxuICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgIH0sXG4gICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsaW5lcztcbiAgICAgIGxpbmVzID0gW107XG4gICAgICBsaW5lID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb2ludEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCBlcHNpbG9uICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gIHRoaXMueCA9IHBvaW50O1xuICB0aGlzLnogPSBwb2ludHM7XG4gIHRoaXMubyA9IG90aGVyOyAvLyBhbm90aGVyIGludGVyc2VjdGlvblxuICB0aGlzLmUgPSBlbnRyeTsgLy8gaXMgYW4gZW50cnk/XG4gIHRoaXMudiA9IGZhbHNlOyAvLyB2aXNpdGVkXG4gIHRoaXMubiA9IHRoaXMucCA9IG51bGw7IC8vIG5leHQgJiBwcmV2aW91c1xufVxuXG4vLyBBIGdlbmVyYWxpemVkIHBvbHlnb24gY2xpcHBpbmcgYWxnb3JpdGhtOiBnaXZlbiBhIHBvbHlnb24gdGhhdCBoYXMgYmVlbiBjdXRcbi8vIGludG8gaXRzIHZpc2libGUgbGluZSBzZWdtZW50cywgYW5kIHJlam9pbnMgdGhlIHNlZ21lbnRzIGJ5IGludGVycG9sYXRpbmdcbi8vIGFsb25nIHRoZSBjbGlwIGVkZ2UuXG5mdW5jdGlvbiBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSkge1xuICB2YXIgc3ViamVjdCA9IFtdLFxuICAgICAgY2xpcCA9IFtdLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dLCB4O1xuXG4gICAgLy8gSWYgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBvZiBhIHNlZ21lbnQgYXJlIGNvaW5jaWRlbnQsIHRoZW4gdHJlYXQgYXMgYVxuICAgIC8vIGNsb3NlZCByaW5nLiBUT0RPIGlmIGFsbCByaW5ncyBhcmUgY2xvc2VkLCB0aGVuIHRoZSB3aW5kaW5nIG9yZGVyIG9mIHRoZVxuICAgIC8vIGV4dGVyaW9yIHJpbmcgc2hvdWxkIGJlIGNoZWNrZWQuXG4gICAgaWYgKHBvaW50RXF1YWwocDAsIHAxKSkge1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBudWxsLCB4LCBmYWxzZSkpO1xuICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMSwgc2VnbWVudCwgbnVsbCwgZmFsc2UpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMSwgbnVsbCwgeCwgdHJ1ZSkpO1xuICB9KTtcblxuICBpZiAoIXN1YmplY3QubGVuZ3RoKSByZXR1cm47XG5cbiAgY2xpcC5zb3J0KGNvbXBhcmVJbnRlcnNlY3Rpb24pO1xuICBsaW5rKHN1YmplY3QpO1xuICBsaW5rKGNsaXApO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvaW50O1xuXG4gIHdoaWxlICgxKSB7XG4gICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgIHZhciBjdXJyZW50ID0gc3RhcnQsXG4gICAgICAgIGlzU3ViamVjdCA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGluayhhcnJheSkge1xuICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgYSA9IGFycmF5WzBdLFxuICAgICAgYjtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgYi5wID0gYTtcbiAgICBhID0gYjtcbiAgfVxuICBhLm4gPSBiID0gYXJyYXlbMF07XG4gIGIucCA9IGE7XG59XG5cbnZhciBzdW0gPSBhZGRlcigpO1xuXG5mdW5jdGlvbiBsb25naXR1ZGUocG9pbnQpIHtcbiAgaWYgKGFicyhwb2ludFswXSkgPD0gcGkpXG4gICAgcmV0dXJuIHBvaW50WzBdO1xuICBlbHNlXG4gICAgcmV0dXJuIHNpZ24ocG9pbnRbMF0pICogKChhYnMocG9pbnRbMF0pICsgcGkpICUgdGF1IC0gcGkpO1xufVxuXG5mdW5jdGlvbiBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgcG9pbnQpIHtcbiAgdmFyIGxhbWJkYSA9IGxvbmdpdHVkZShwb2ludCksXG4gICAgICBwaGkgPSBwb2ludFsxXSxcbiAgICAgIHNpblBoaSA9IHNpbihwaGkpLFxuICAgICAgbm9ybWFsID0gW3NpbihsYW1iZGEpLCAtY29zKGxhbWJkYSksIDBdLFxuICAgICAgYW5nbGUgPSAwLFxuICAgICAgd2luZGluZyA9IDA7XG5cbiAgc3VtLnJlc2V0KCk7XG5cbiAgaWYgKHNpblBoaSA9PT0gMSkgcGhpID0gaGFsZlBpICsgZXBzaWxvbjtcbiAgZWxzZSBpZiAoc2luUGhpID09PSAtMSkgcGhpID0gLWhhbGZQaSAtIGVwc2lsb247XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKG0gPSAocmluZyA9IHBvbHlnb25baV0pLmxlbmd0aCkpIGNvbnRpbnVlO1xuICAgIHZhciByaW5nLFxuICAgICAgICBtLFxuICAgICAgICBwb2ludDAgPSByaW5nW20gLSAxXSxcbiAgICAgICAgbGFtYmRhMCA9IGxvbmdpdHVkZShwb2ludDApLFxuICAgICAgICBwaGkwID0gcG9pbnQwWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgc2luUGhpMCA9IHNpbihwaGkwKSxcbiAgICAgICAgY29zUGhpMCA9IGNvcyhwaGkwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcbiAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLFxuICAgICAgICAgIGxhbWJkYTEgPSBsb25naXR1ZGUocG9pbnQxKSxcbiAgICAgICAgICBwaGkxID0gcG9pbnQxWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgICBzaW5QaGkxID0gc2luKHBoaTEpLFxuICAgICAgICAgIGNvc1BoaTEgPSBjb3MocGhpMSksXG4gICAgICAgICAgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgICBzaWduID0gZGVsdGEgPj0gMCA/IDEgOiAtMSxcbiAgICAgICAgICBhYnNEZWx0YSA9IHNpZ24gKiBkZWx0YSxcbiAgICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnNEZWx0YSA+IHBpLFxuICAgICAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpMTtcblxuICAgICAgc3VtLmFkZChhdGFuMihrICogc2lnbiAqIHNpbihhYnNEZWx0YSksIGNvc1BoaTAgKiBjb3NQaGkxICsgayAqIGNvcyhhYnNEZWx0YSkpKTtcbiAgICAgIGFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGRlbHRhICsgc2lnbiAqIHRhdSA6IGRlbHRhO1xuXG4gICAgICAvLyBBcmUgdGhlIGxvbmdpdHVkZXMgZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW504oCZcyBtZXJpZGlhbiAobGFtYmRhKSxcbiAgICAgIC8vIGFuZCBhcmUgdGhlIGxhdGl0dWRlcyBzbWFsbGVyIHRoYW4gdGhlIHBhcmFsbGVsIChwaGkpP1xuICAgICAgaWYgKGFudGltZXJpZGlhbiBeIGxhbWJkYTAgPj0gbGFtYmRhIF4gbGFtYmRhMSA+PSBsYW1iZGEpIHtcbiAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoYXJjKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKG5vcm1hbCwgYXJjKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICB2YXIgcGhpQXJjID0gKGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAtMSA6IDEpICogYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICBpZiAocGhpID4gcGhpQXJjIHx8IHBoaSA9PT0gcGhpQXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcbiAgLy9cbiAgLy8gSXQgaXMgaW5zaWRlIGlmOlxuICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gIC8vICogdGhlIHBvbHlnb24gZG9lcyBub3QgKGN1bXVsYXRpdmVseSkgd2luZCBhcm91bmQgaXQsIGJ1dCBoYXMgYSBuZWdhdGl2ZVxuICAvLyAgIChjb3VudGVyLWNsb2Nrd2lzZSkgYXJlYS5cbiAgLy9cbiAgLy8gU2Vjb25kLCBjb3VudCB0aGUgKHNpZ25lZCkgbnVtYmVyIG9mIHRpbWVzIGEgc2VnbWVudCBjcm9zc2VzIGEgbGFtYmRhXG4gIC8vIGZyb20gdGhlIHBvaW50IHRvIHRoZSBTb3V0aCBwb2xlLiAgSWYgaXQgaXMgemVybywgdGhlbiB0aGUgcG9pbnQgaXMgdGhlXG4gIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cblxuICByZXR1cm4gKGFuZ2xlIDwgLWVwc2lsb24gfHwgYW5nbGUgPCBlcHNpbG9uICYmIHN1bSA8IC1lcHNpbG9uKSBeICh3aW5kaW5nICYgMSk7XG59XG5cbmZ1bmN0aW9uIGNsaXAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzaW5rKSB7XG4gICAgdmFyIGxpbmUgPSBjbGlwTGluZShzaW5rKSxcbiAgICAgICAgcmluZ0J1ZmZlciA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgcmluZ1NpbmsgPSBjbGlwTGluZShyaW5nQnVmZmVyKSxcbiAgICAgICAgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHJpbmc7XG5cbiAgICB2YXIgY2xpcCA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gZDNBcnJheS5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25Db250YWlucyhwb2x5Z29uLCBzdGFydCk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzaW5rKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydEluc2lkZSkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uRW5kKCksIHBvbHlnb25TdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICB9LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICBzaW5rLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIGlmIChwb2ludFZpc2libGUobGFtYmRhLCBwaGkpKSBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludExpbmUobGFtYmRhLCBwaGkpIHtcbiAgICAgIGxpbmUucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICBsaW5lLmxpbmVTdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICBsaW5lLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludFJpbmcobGFtYmRhLCBwaGkpIHtcbiAgICAgIHJpbmcucHVzaChbbGFtYmRhLCBwaGldKTtcbiAgICAgIHJpbmdTaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICByaW5nU2luay5saW5lU3RhcnQoKTtcbiAgICAgIHJpbmcgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgcmluZ1NpbmsubGluZUVuZCgpO1xuXG4gICAgICB2YXIgY2xlYW4gPSByaW5nU2luay5jbGVhbigpLFxuICAgICAgICAgIHJpbmdTZWdtZW50cyA9IHJpbmdCdWZmZXIucmVzdWx0KCksXG4gICAgICAgICAgaSwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGgsIG0sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBwb2ludDtcblxuICAgICAgcmluZy5wb3AoKTtcbiAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICAgIHJpbmcgPSBudWxsO1xuXG4gICAgICBpZiAoIW4pIHJldHVybjtcblxuICAgICAgLy8gTm8gaW50ZXJzZWN0aW9ucy5cbiAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcbiAgICAgICAgaWYgKChtID0gc2VnbWVudC5sZW5ndGggLSAxKSA+IDApIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzaW5rLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWpvaW4gY29ubmVjdGVkIHNlZ21lbnRzLlxuICAgICAgLy8gVE9ETyByZXVzZSByaW5nQnVmZmVyLnJlam9pbigpP1xuICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMikgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xuXG4gICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIodmFsaWRTZWdtZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG59XG5cbi8vIEludGVyc2VjdGlvbnMgYXJlIHNvcnRlZCBhbG9uZyB0aGUgY2xpcCBlZGdlLiBGb3IgYm90aCBhbnRpbWVyaWRpYW4gY3V0dGluZ1xuLy8gYW5kIGNpcmNsZSBjbGlwcGluZywgdGhlIHNhbWUgY29tcGFyaXNvbiBpcyB1c2VkLlxuZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYVsxXSlcbiAgICAgICAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBiWzFdKTtcbn1cblxudmFyIGNsaXBBbnRpbWVyaWRpYW4gPSBjbGlwKFxuICBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXG4gIGNsaXBBbnRpbWVyaWRpYW5MaW5lLFxuICBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsXG4gIFstcGksIC1oYWxmUGldXG4pO1xuXG4vLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzOiAwIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBubyBpbnRlcnNlY3Rpb25zOyAyIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBzaG91bGQgYmUgcmVqb2luZWQuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuTGluZShzdHJlYW0pIHtcbiAgdmFyIGxhbWJkYTAgPSBOYU4sXG4gICAgICBwaGkwID0gTmFOLFxuICAgICAgc2lnbjAgPSBOYU4sXG4gICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuXG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIGNsZWFuID0gMTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGExLCBwaGkxKSB7XG4gICAgICB2YXIgc2lnbjEgPSBsYW1iZGExID4gMCA/IHBpIDogLXBpLFxuICAgICAgICAgIGRlbHRhID0gYWJzKGxhbWJkYTEgLSBsYW1iZGEwKTtcbiAgICAgIGlmIChhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uKSB7IC8vIGxpbmUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAsIHBoaTAgPSAocGhpMCArIHBoaTEpIC8gMiA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpKSB7IC8vIGxpbmUgY3Jvc3NlcyBhbnRpbWVyaWRpYW5cbiAgICAgICAgaWYgKGFicyhsYW1iZGEwIC0gc2lnbjApIDwgZXBzaWxvbikgbGFtYmRhMCAtPSBzaWduMCAqIGVwc2lsb247IC8vIGhhbmRsZSBkZWdlbmVyYWNpZXNcbiAgICAgICAgaWYgKGFicyhsYW1iZGExIC0gc2lnbjEpIDwgZXBzaWxvbikgbGFtYmRhMSAtPSBzaWduMSAqIGVwc2lsb247XG4gICAgICAgIHBoaTAgPSBjbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwID0gbGFtYmRhMSwgcGhpMCA9IHBoaTEpO1xuICAgICAgc2lnbjAgPSBzaWduMTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIGxhbWJkYTAgPSBwaGkwID0gTmFOO1xuICAgIH0sXG4gICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDIgLSBjbGVhbjsgLy8gaWYgaW50ZXJzZWN0aW9ucywgcmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEpIHtcbiAgdmFyIGNvc1BoaTAsXG4gICAgICBjb3NQaGkxLFxuICAgICAgc2luTGFtYmRhMExhbWJkYTEgPSBzaW4obGFtYmRhMCAtIGxhbWJkYTEpO1xuICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb25cbiAgICAgID8gYXRhbigoc2luKHBoaTApICogKGNvc1BoaTEgPSBjb3MocGhpMSkpICogc2luKGxhbWJkYTEpXG4gICAgICAgICAgLSBzaW4ocGhpMSkgKiAoY29zUGhpMCA9IGNvcyhwaGkwKSkgKiBzaW4obGFtYmRhMCkpXG4gICAgICAgICAgLyAoY29zUGhpMCAqIGNvc1BoaTEgKiBzaW5MYW1iZGEwTGFtYmRhMSkpXG4gICAgICA6IChwaGkwICsgcGhpMSkgLyAyO1xufVxuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gIHZhciBwaGk7XG4gIGlmIChmcm9tID09IG51bGwpIHtcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBoYWxmUGk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAwKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCAwKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICB9IGVsc2UgaWYgKGFicyhmcm9tWzBdIC0gdG9bMF0pID4gZXBzaWxvbikge1xuICAgIHZhciBsYW1iZGEgPSBmcm9tWzBdIDwgdG9bMF0gPyBwaSA6IC1waTtcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBsYW1iZGEgLyAyO1xuICAgIHN0cmVhbS5wb2ludCgtbGFtYmRhLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xpcENpcmNsZShyYWRpdXMpIHtcbiAgdmFyIGNyID0gY29zKHJhZGl1cyksXG4gICAgICBkZWx0YSA9IDYgKiByYWRpYW5zLFxuICAgICAgc21hbGxSYWRpdXMgPSBjciA+IDAsXG4gICAgICBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IGVwc2lsb247IC8vIFRPRE8gb3B0aW1pc2UgZm9yIHRoaXMgY29tbW9uIGNhc2VcblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIGZyb20sIHRvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpc2libGUobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gY29zKGxhbWJkYSkgKiBjb3MocGhpKSA+IGNyO1xuICB9XG5cbiAgLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlcyB1c2VkIGZvciBwb2x5Z29uXG4gIC8vIGNsaXBwaW5nOiAwIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vXG4gIC8vIGludGVyc2VjdGlvbnMgMiAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAvLyBzaG91bGQgYmUgcmVqb2luZWQuXG4gIGZ1bmN0aW9uIGNsaXBMaW5lKHN0cmVhbSkge1xuICAgIHZhciBwb2ludDAsIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGMwLCAvLyBjb2RlIGZvciBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MCwgLy8gdmlzaWJpbGl0eSBvZiBwcmV2aW91cyBwb2ludFxuICAgICAgICB2MDAsIC8vIHZpc2liaWxpdHkgb2YgZmlyc3QgcG9pbnRcbiAgICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcG9pbnQxID0gW2xhbWJkYSwgcGhpXSxcbiAgICAgICAgICAgIHBvaW50MixcbiAgICAgICAgICAgIHYgPSB2aXNpYmxlKGxhbWJkYSwgcGhpKSxcbiAgICAgICAgICAgIGMgPSBzbWFsbFJhZGl1c1xuICAgICAgICAgICAgICA/IHYgPyAwIDogY29kZShsYW1iZGEsIHBoaSlcbiAgICAgICAgICAgICAgOiB2ID8gY29kZShsYW1iZGEgKyAobGFtYmRhIDwgMCA/IHBpIDogLXBpKSwgcGhpKSA6IDA7XG4gICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIC8vIEhhbmRsZSBkZWdlbmVyYWNpZXMuXG4gICAgICAgIC8vIFRPRE8gaWdub3JlIGlmIG5vdCBjbGlwcGluZyBwb2x5Z29ucy5cbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICBpZiAoIXBvaW50MiB8fCBwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBwb2ludEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xuICAgICAgICAgICAgcG9pbnQxWzBdICs9IGVwc2lsb247XG4gICAgICAgICAgICBwb2ludDFbMV0gKz0gZXBzaWxvbjtcbiAgICAgICAgICAgIHYgPSB2aXNpYmxlKHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAvLyBvdXRzaWRlIGdvaW5nIGluXG4gICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zaWRlIGdvaW5nIG91dFxuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XG4gICAgICAgIH0gZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvZGVzIGZvciB0d28gcG9pbnRzIGFyZSBkaWZmZXJlbnQsIG9yIGFyZSBib3RoIHplcm8sXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIHRoaXMgc2VnbWVudCBpbnRlcnNlY3RzIHdpdGggdGhlIHNtYWxsIGNpcmNsZS5cbiAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIXBvaW50RXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnQwID0gcG9pbnQxLCB2MCA9IHYsIGMwID0gYztcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHYwKSBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIC8vIFJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBpZiB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gYW5kIGxhc3QgcG9pbnRzIHdlcmUgdmlzaWJsZS5cbiAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuIHwgKCh2MDAgJiYgdjApIDw8IDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBJbnRlcnNlY3RzIHRoZSBncmVhdCBjaXJjbGUgYmV0d2VlbiBhIGFuZCBiIHdpdGggdGhlIGNsaXAgY2lyY2xlLlxuICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgdmFyIHBhID0gY2FydGVzaWFuKGEpLFxuICAgICAgICBwYiA9IGNhcnRlc2lhbihiKTtcblxuICAgIC8vIFdlIGhhdmUgdHdvIHBsYW5lcywgbjEucCA9IGQxIGFuZCBuMi5wID0gZDIuXG4gICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gbGluZSBwKHQpID0gYzEgbjEgKyBjMiBuMiArIHQgKG4xIOKoryBuMikuXG4gICAgdmFyIG4xID0gWzEsIDAsIDBdLCAvLyBub3JtYWxcbiAgICAgICAgbjIgPSBjYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLFxuICAgICAgICBuMm4yID0gY2FydGVzaWFuRG90KG4yLCBuMiksXG4gICAgICAgIG4xbjIgPSBuMlswXSwgLy8gY2FydGVzaWFuRG90KG4xLCBuMiksXG4gICAgICAgIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xuXG4gICAgLy8gVHdvIHBvbGFyIHBvaW50cy5cbiAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xuXG4gICAgdmFyIGMxID0gIGNyICogbjJuMiAvIGRldGVybWluYW50LFxuICAgICAgICBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgbjF4bjIgPSBjYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLFxuICAgICAgICBBID0gY2FydGVzaWFuU2NhbGUobjEsIGMxKSxcbiAgICAgICAgQiA9IGNhcnRlc2lhblNjYWxlKG4yLCBjMik7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShBLCBCKTtcblxuICAgIC8vIFNvbHZlIHxwKHQpfF4yID0gMS5cbiAgICB2YXIgdSA9IG4xeG4yLFxuICAgICAgICB3ID0gY2FydGVzaWFuRG90KEEsIHUpLFxuICAgICAgICB1dSA9IGNhcnRlc2lhbkRvdCh1LCB1KSxcbiAgICAgICAgdDIgPSB3ICogdyAtIHV1ICogKGNhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuXG4gICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIHQgPSBzcXJ0KHQyKSxcbiAgICAgICAgcSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocSwgQSk7XG4gICAgcSA9IHNwaGVyaWNhbChxKTtcblxuICAgIGlmICghdHdvKSByZXR1cm4gcTtcblxuICAgIC8vIFR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgIHZhciBsYW1iZGEwID0gYVswXSxcbiAgICAgICAgbGFtYmRhMSA9IGJbMF0sXG4gICAgICAgIHBoaTAgPSBhWzFdLFxuICAgICAgICBwaGkxID0gYlsxXSxcbiAgICAgICAgejtcblxuICAgIGlmIChsYW1iZGExIDwgbGFtYmRhMCkgeiA9IGxhbWJkYTAsIGxhbWJkYTAgPSBsYW1iZGExLCBsYW1iZGExID0gejtcblxuICAgIHZhciBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICBwb2xhciA9IGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24sXG4gICAgICAgIG1lcmlkaWFuID0gcG9sYXIgfHwgZGVsdGEgPCBlcHNpbG9uO1xuXG4gICAgaWYgKCFwb2xhciAmJiBwaGkxIDwgcGhpMCkgeiA9IHBoaTAsIHBoaTAgPSBwaGkxLCBwaGkxID0gejtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGZpcnN0IHBvaW50IGlzIGJldHdlZW4gYSBhbmQgYi5cbiAgICBpZiAobWVyaWRpYW5cbiAgICAgICAgPyBwb2xhclxuICAgICAgICAgID8gcGhpMCArIHBoaTEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIGxhbWJkYTApIDwgZXBzaWxvbiA/IHBoaTAgOiBwaGkxKVxuICAgICAgICAgIDogcGhpMCA8PSBxWzFdICYmIHFbMV0gPD0gcGhpMVxuICAgICAgICA6IGRlbHRhID4gcGkgXiAobGFtYmRhMCA8PSBxWzBdICYmIHFbMF0gPD0gbGFtYmRhMSkpIHtcbiAgICAgIHZhciBxMSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyArIHQpIC8gdXUpO1xuICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShxMSwgQSk7XG4gICAgICByZXR1cm4gW3EsIHNwaGVyaWNhbChxMSldO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhIDQtYml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgcmVsYXRpdmUgdG9cbiAgLy8gdGhlIHNtYWxsIGNpcmNsZSdzIGJvdW5kaW5nIGJveC5cbiAgZnVuY3Rpb24gY29kZShsYW1iZGEsIHBoaSkge1xuICAgIHZhciByID0gc21hbGxSYWRpdXMgPyByYWRpdXMgOiBwaSAtIHJhZGl1cyxcbiAgICAgICAgY29kZSA9IDA7XG4gICAgaWYgKGxhbWJkYSA8IC1yKSBjb2RlIHw9IDE7IC8vIGxlZnRcbiAgICBlbHNlIGlmIChsYW1iZGEgPiByKSBjb2RlIHw9IDI7IC8vIHJpZ2h0XG4gICAgaWYgKHBoaSA8IC1yKSBjb2RlIHw9IDQ7IC8vIGJlbG93XG4gICAgZWxzZSBpZiAocGhpID4gcikgY29kZSB8PSA4OyAvLyBhYm92ZVxuICAgIHJldHVybiBjb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFswLCAtcmFkaXVzXSA6IFstcGksIHJhZGl1cyAtIHBpXSk7XG59XG5cbmZ1bmN0aW9uIGNsaXBMaW5lKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAodDAgPiAwKSBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICBpZiAodDEgPCAxKSBiWzBdID0gYXggKyB0MSAqIGR4LCBiWzFdID0gYXkgKyB0MSAqIGR5O1xuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGNsaXBNYXggPSAxZTksIGNsaXBNaW4gPSAtY2xpcE1heDtcblxuLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG5cbmZ1bmN0aW9uIGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpIHtcblxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICA6IGFicyhwWzBdIC0geDEpIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMVxuICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLFxuICAgICAgICBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHJpbmcsXG4gICAgICAgIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGZpcnN0LFxuICAgICAgICBjbGVhbjtcblxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XG4gICAgICAgICAgZWxzZSB7IGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpIC0td2luZGluZzsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLFxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXG4gICAgICAgICAgdmlzaWJsZSA9IChzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHZfID0gZmFsc2U7XG4gICAgICB4XyA9IHlfID0gTmFOO1xuICAgIH1cblxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBpZiAodl8pIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSxcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgaWYgKCF2KSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRlbnQoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB5MCA9IDAsXG4gICAgICB4MSA9IDk2MCxcbiAgICAgIHkxID0gNTAwLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbSxcbiAgICAgIGNsaXA7XG5cbiAgcmV0dXJuIGNsaXAgPSB7XG4gICAgc3RyZWFtOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpKGNhY2hlU3RyZWFtID0gc3RyZWFtKTtcbiAgICB9LFxuICAgIGV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSwgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGwsIGNsaXApIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbGVuZ3RoU3VtID0gYWRkZXIoKSxcbiAgICBsYW1iZGEwJDIsXG4gICAgc2luUGhpMCQxLFxuICAgIGNvc1BoaTAkMTtcblxudmFyIGxlbmd0aFN0cmVhbSA9IHtcbiAgc3BoZXJlOiBub29wLFxuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBsZW5ndGhMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcFxufTtcblxuZnVuY3Rpb24gbGVuZ3RoTGluZVN0YXJ0KCkge1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICBsZW5ndGhTdHJlYW0ubGluZUVuZCA9IGxlbmd0aExpbmVFbmQ7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aExpbmVFbmQoKSB7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbm9vcDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGxhbWJkYTAkMiA9IGxhbWJkYSwgc2luUGhpMCQxID0gc2luKHBoaSksIGNvc1BoaTAkMSA9IGNvcyhwaGkpO1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIGRlbHRhID0gYWJzKGxhbWJkYSAtIGxhbWJkYTAkMiksXG4gICAgICBjb3NEZWx0YSA9IGNvcyhkZWx0YSksXG4gICAgICBzaW5EZWx0YSA9IHNpbihkZWx0YSksXG4gICAgICB4ID0gY29zUGhpICogc2luRGVsdGEsXG4gICAgICB5ID0gY29zUGhpMCQxICogc2luUGhpIC0gc2luUGhpMCQxICogY29zUGhpICogY29zRGVsdGEsXG4gICAgICB6ID0gc2luUGhpMCQxICogc2luUGhpICsgY29zUGhpMCQxICogY29zUGhpICogY29zRGVsdGE7XG4gIGxlbmd0aFN1bS5hZGQoYXRhbjIoc3FydCh4ICogeCArIHkgKiB5KSwgeikpO1xuICBsYW1iZGEwJDIgPSBsYW1iZGEsIHNpblBoaTAkMSA9IHNpblBoaSwgY29zUGhpMCQxID0gY29zUGhpO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgob2JqZWN0KSB7XG4gIGxlbmd0aFN1bS5yZXNldCgpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBsZW5ndGhTdHJlYW0pO1xuICByZXR1cm4gK2xlbmd0aFN1bTtcbn1cblxudmFyIGNvb3JkaW5hdGVzID0gW251bGwsIG51bGxdLFxuICAgIG9iamVjdCA9IHt0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBjb29yZGluYXRlc1swXSA9IGE7XG4gIGNvb3JkaW5hdGVzWzFdID0gYjtcbiAgcmV0dXJuIGxlbmd0aChvYmplY3QpO1xufVxuXG52YXIgY29udGFpbnNPYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBwb2ludCk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNvbnRhaW5zR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc1BvaW50KG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc1BvaW50KGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc0xpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc1BvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjb250YWluc0dlb21ldHJ5KGdlb21ldHJ5LCBwb2ludCkge1xuICByZXR1cm4gZ2VvbWV0cnkgJiYgY29udGFpbnNHZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSlcbiAgICAgID8gY29udGFpbnNHZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHBvaW50KVxuICAgICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNQb2ludChjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgcmV0dXJuIGRpc3RhbmNlKGNvb3JkaW5hdGVzLCBwb2ludCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zTGluZShjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgdmFyIGFvLCBibywgYWI7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgYm8gPSBkaXN0YW5jZShjb29yZGluYXRlc1tpXSwgcG9pbnQpO1xuICAgIGlmIChibyA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBhYiA9IGRpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBjb29yZGluYXRlc1tpIC0gMV0pO1xuICAgICAgaWYgKFxuICAgICAgICBhYiA+IDAgJiZcbiAgICAgICAgYW8gPD0gYWIgJiZcbiAgICAgICAgYm8gPD0gYWIgJiZcbiAgICAgICAgKGFvICsgYm8gLSBhYikgKiAoMSAtIE1hdGgucG93KChhbyAtIGJvKSAvIGFiLCAyKSkgPCBlcHNpbG9uMiAqIGFiXG4gICAgICApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhbyA9IGJvO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICByZXR1cm4gISFwb2x5Z29uQ29udGFpbnMoY29vcmRpbmF0ZXMubWFwKHJpbmdSYWRpYW5zKSwgcG9pbnRSYWRpYW5zKHBvaW50KSk7XG59XG5cbmZ1bmN0aW9uIHJpbmdSYWRpYW5zKHJpbmcpIHtcbiAgcmV0dXJuIHJpbmcgPSByaW5nLm1hcChwb2ludFJhZGlhbnMpLCByaW5nLnBvcCgpLCByaW5nO1xufVxuXG5mdW5jdGlvbiBwb2ludFJhZGlhbnMocG9pbnQpIHtcbiAgcmV0dXJuIFtwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFuc107XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKG9iamVjdCwgcG9pbnQpIHtcbiAgcmV0dXJuIChvYmplY3QgJiYgY29udGFpbnNPYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKVxuICAgICAgPyBjb250YWluc09iamVjdFR5cGVbb2JqZWN0LnR5cGVdXG4gICAgICA6IGNvbnRhaW5zR2VvbWV0cnkpKG9iamVjdCwgcG9pbnQpO1xufVxuXG5mdW5jdGlvbiBncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgdmFyIHkgPSBkM0FycmF5LnJhbmdlKHkwLCB5MSAtIGVwc2lsb24sIGR5KS5jb25jYXQoeTEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geS5tYXAoZnVuY3Rpb24oeSkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gIHZhciB4ID0gZDNBcnJheS5yYW5nZSh4MCwgeDEgLSBlcHNpbG9uLCBkeCkuY29uY2F0KHgxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHkpIHsgcmV0dXJuIHgubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgdmFyIHgxLCB4MCwgWDEsIFgwLFxuICAgICAgeTEsIHkwLCBZMSwgWTAsXG4gICAgICBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCxcbiAgICAgIHgsIHksIFgsIFksXG4gICAgICBwcmVjaXNpb24gPSAyLjU7XG5cbiAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzKCl9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgcmV0dXJuIGQzQXJyYXkucmFuZ2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSlcbiAgICAgICAgLmNvbmNhdChkM0FycmF5LnJhbmdlKGNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gYWJzKHggJSBEWCkgPiBlcHNpbG9uOyB9KS5tYXAoeCkpXG4gICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIGFicyh5ICUgRFkpID4gZXBzaWxvbjsgfSkubWFwKHkpKTtcbiAgfVxuXG4gIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykgeyByZXR1cm4ge3R5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXN9OyB9KTtcbiAgfTtcblxuICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgIFgoWDApLmNvbmNhdChcbiAgICAgICAgWShZMSkuc2xpY2UoMSksXG4gICAgICAgIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSxcbiAgICAgICAgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKVxuICAgICAgXVxuICAgIH07XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1ham9yKF8pLmV4dGVudE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW1gwLCBZMF0sIFtYMSwgWTFdXTtcbiAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgaWYgKFgwID4gWDEpIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgIGlmIChZMCA+IFkxKSBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnRNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWlub3IoKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNYWpvcihfKS5zdGVwTWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNYWpvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbRFgsIERZXTtcbiAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXBNaW5vciA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcmVjaXNpb247XG4gICAgcHJlY2lzaW9uID0gK187XG4gICAgeCA9IGdyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgeSA9IGdyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgIFggPSBncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgIFkgPSBncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIHJldHVybiBncmF0aWN1bGVcbiAgICAgIC5leHRlbnRNYWpvcihbWy0xODAsIC05MCArIGVwc2lsb25dLCBbMTgwLCA5MCAtIGVwc2lsb25dXSlcbiAgICAgIC5leHRlbnRNaW5vcihbWy0xODAsIC04MCAtIGVwc2lsb25dLCBbMTgwLCA4MCArIGVwc2lsb25dXSk7XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZTEwKCkge1xuICByZXR1cm4gZ3JhdGljdWxlKCkoKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoYSwgYikge1xuICB2YXIgeDAgPSBhWzBdICogcmFkaWFucyxcbiAgICAgIHkwID0gYVsxXSAqIHJhZGlhbnMsXG4gICAgICB4MSA9IGJbMF0gKiByYWRpYW5zLFxuICAgICAgeTEgPSBiWzFdICogcmFkaWFucyxcbiAgICAgIGN5MCA9IGNvcyh5MCksXG4gICAgICBzeTAgPSBzaW4oeTApLFxuICAgICAgY3kxID0gY29zKHkxKSxcbiAgICAgIHN5MSA9IHNpbih5MSksXG4gICAgICBreDAgPSBjeTAgKiBjb3MoeDApLFxuICAgICAga3kwID0gY3kwICogc2luKHgwKSxcbiAgICAgIGt4MSA9IGN5MSAqIGNvcyh4MSksXG4gICAgICBreTEgPSBjeTEgKiBzaW4oeDEpLFxuICAgICAgZCA9IDIgKiBhc2luKHNxcnQoaGF2ZXJzaW4oeTEgLSB5MCkgKyBjeTAgKiBjeTEgKiBoYXZlcnNpbih4MSAtIHgwKSkpLFxuICAgICAgayA9IHNpbihkKTtcblxuICB2YXIgaW50ZXJwb2xhdGUgPSBkID8gZnVuY3Rpb24odCkge1xuICAgIHZhciBCID0gc2luKHQgKj0gZCkgLyBrLFxuICAgICAgICBBID0gc2luKGQgLSB0KSAvIGssXG4gICAgICAgIHggPSBBICoga3gwICsgQiAqIGt4MSxcbiAgICAgICAgeSA9IEEgKiBreTAgKyBCICoga3kxLFxuICAgICAgICB6ID0gQSAqIHN5MCArIEIgKiBzeTE7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHksIHgpICogZGVncmVlcyxcbiAgICAgIGF0YW4yKHosIHNxcnQoeCAqIHggKyB5ICogeSkpICogZGVncmVlc1xuICAgIF07XG4gIH0gOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW3gwICogZGVncmVlcywgeTAgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBpbnRlcnBvbGF0ZS5kaXN0YW5jZSA9IGQ7XG5cbiAgcmV0dXJuIGludGVycG9sYXRlO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG52YXIgYXJlYVN1bSQxID0gYWRkZXIoKSxcbiAgICBhcmVhUmluZ1N1bSQxID0gYWRkZXIoKSxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwJDEsXG4gICAgeTAkMTtcblxudmFyIGFyZWFTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtJDEubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydCQxO1xuICAgIGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVJpbmdFbmQkMTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVN0cmVhbSQxLnBvaW50ID0gbm9vcDtcbiAgICBhcmVhU3VtJDEuYWRkKGFicyhhcmVhUmluZ1N1bSQxKSk7XG4gICAgYXJlYVJpbmdTdW0kMS5yZXNldCgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhID0gYXJlYVN1bSQxIC8gMjtcbiAgICBhcmVhU3VtJDEucmVzZXQoKTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCQxKCkge1xuICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnRGaXJzdCQxO1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgYXJlYVN0cmVhbSQxLnBvaW50ID0gYXJlYVBvaW50JDE7XG4gIHgwMCA9IHgwJDEgPSB4LCB5MDAgPSB5MCQxID0geTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50JDEoeCwgeSkge1xuICBhcmVhUmluZ1N1bSQxLmFkZCh5MCQxICogeCAtIHgwJDEgKiB5KTtcbiAgeDAkMSA9IHgsIHkwJDEgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCQxKCkge1xuICBhcmVhUG9pbnQkMSh4MDAsIHkwMCk7XG59XG5cbnZhciB4MCQyID0gSW5maW5pdHksXG4gICAgeTAkMiA9IHgwJDIsXG4gICAgeDEgPSAteDAkMixcbiAgICB5MSA9IHgxO1xuXG52YXIgYm91bmRzU3RyZWFtJDEgPSB7XG4gIHBvaW50OiBib3VuZHNQb2ludCQxLFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcCxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRzID0gW1t4MCQyLCB5MCQyXSwgW3gxLCB5MV1dO1xuICAgIHgxID0geTEgPSAtKHkwJDIgPSB4MCQyID0gSW5maW5pdHkpO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJvdW5kc1BvaW50JDEoeCwgeSkge1xuICBpZiAoeCA8IHgwJDIpIHgwJDIgPSB4O1xuICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gIGlmICh5IDwgeTAkMikgeTAkMiA9IHk7XG4gIGlmICh5ID4geTEpIHkxID0geTtcbn1cblxuLy8gVE9ETyBFbmZvcmNlIHBvc2l0aXZlIGFyZWEgZm9yIGV4dGVyaW9yLCBuZWdhdGl2ZSBhcmVhIGZvciBpbnRlcmlvcj9cblxudmFyIFgwJDEgPSAwLFxuICAgIFkwJDEgPSAwLFxuICAgIFowJDEgPSAwLFxuICAgIFgxJDEgPSAwLFxuICAgIFkxJDEgPSAwLFxuICAgIFoxJDEgPSAwLFxuICAgIFgyJDEgPSAwLFxuICAgIFkyJDEgPSAwLFxuICAgIFoyJDEgPSAwLFxuICAgIHgwMCQxLFxuICAgIHkwMCQxLFxuICAgIHgwJDMsXG4gICAgeTAkMztcblxudmFyIGNlbnRyb2lkU3RyZWFtJDEgPSB7XG4gIHBvaW50OiBjZW50cm9pZFBvaW50JDEsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQkMSxcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kJDEsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydCQxO1xuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZCQxO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQkMTtcbiAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVFbmQgPSBjZW50cm9pZExpbmVFbmQkMTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2VudHJvaWQgPSBaMiQxID8gW1gyJDEgLyBaMiQxLCBZMiQxIC8gWjIkMV1cbiAgICAgICAgOiBaMSQxID8gW1gxJDEgLyBaMSQxLCBZMSQxIC8gWjEkMV1cbiAgICAgICAgOiBaMCQxID8gW1gwJDEgLyBaMCQxLCBZMCQxIC8gWjAkMV1cbiAgICAgICAgOiBbTmFOLCBOYU5dO1xuICAgIFgwJDEgPSBZMCQxID0gWjAkMSA9XG4gICAgWDEkMSA9IFkxJDEgPSBaMSQxID1cbiAgICBYMiQxID0gWTIkMSA9IFoyJDEgPSAwO1xuICAgIHJldHVybiBjZW50cm9pZDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludCQxKHgsIHkpIHtcbiAgWDAkMSArPSB4O1xuICBZMCQxICs9IHk7XG4gICsrWjAkMTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQkMSgpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdExpbmU7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdExpbmUoeCwgeSkge1xuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XG4gIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50TGluZSh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCQzLCBkeSA9IHkgLSB5MCQzLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgWjEkMSArPSB6O1xuICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kJDEoKSB7XG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50JDE7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0JDEoKSB7XG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RSaW5nO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQkMSgpIHtcbiAgY2VudHJvaWRQb2ludFJpbmcoeDAwJDEsIHkwMCQxKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50UmluZztcbiAgY2VudHJvaWRQb2ludCQxKHgwMCQxID0geDAkMyA9IHgsIHkwMCQxID0geTAkMyA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50UmluZyh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCQzLFxuICAgICAgZHkgPSB5IC0geTAkMyxcbiAgICAgIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICBYMSQxICs9IHogKiAoeDAkMyArIHgpIC8gMjtcbiAgWTEkMSArPSB6ICogKHkwJDMgKyB5KSAvIDI7XG4gIFoxJDEgKz0gejtcblxuICB6ID0geTAkMyAqIHggLSB4MCQzICogeTtcbiAgWDIkMSArPSB6ICogKHgwJDMgKyB4KTtcbiAgWTIkMSArPSB6ICogKHkwJDMgKyB5KTtcbiAgWjIkMSArPSB6ICogMztcbiAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG59XG5cbmZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblBhdGhDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCArIHRoaXMuX3JhZGl1cywgeSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHRoaXMuX3JhZGl1cywgMCwgdGF1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXN1bHQ6IG5vb3Bcbn07XG5cbnZhciBsZW5ndGhTdW0kMSA9IGFkZGVyKCksXG4gICAgbGVuZ3RoUmluZyxcbiAgICB4MDAkMixcbiAgICB5MDAkMixcbiAgICB4MCQ0LFxuICAgIHkwJDQ7XG5cbnZhciBsZW5ndGhTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0JDE7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChsZW5ndGhSaW5nKSBsZW5ndGhQb2ludCQxKHgwMCQyLCB5MDAkMik7XG4gICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBub29wO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSB0cnVlO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhSaW5nID0gbnVsbDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gK2xlbmd0aFN1bSQxO1xuICAgIGxlbmd0aFN1bSQxLnJlc2V0KCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBsZW5ndGhQb2ludCQxO1xuICB4MDAkMiA9IHgwJDQgPSB4LCB5MDAkMiA9IHkwJDQgPSB5O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludCQxKHgsIHkpIHtcbiAgeDAkNCAtPSB4LCB5MCQ0IC09IHk7XG4gIGxlbmd0aFN1bSQxLmFkZChzcXJ0KHgwJDQgKiB4MCQ0ICsgeTAkNCAqIHkwJDQpKTtcbiAgeDAkNCA9IHgsIHkwJDQgPSB5O1xufVxuXG5mdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xuICB0aGlzLl9zdHJpbmcgPSBbXTtcbn1cblxuUGF0aFN0cmluZy5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgX2NpcmNsZTogY2lyY2xlJDEoNC41KSxcbiAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoKF8gPSArXykgIT09IHRoaXMuX3JhZGl1cykgdGhpcy5fcmFkaXVzID0gXywgdGhpcy5fY2lyY2xlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9zdHJpbmcucHVzaChcIlpcIik7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl9jaXJjbGUgPT0gbnVsbCkgdGhpcy5fY2lyY2xlID0gY2lyY2xlJDEodGhpcy5fcmFkaXVzKTtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCB0aGlzLl9jaXJjbGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3N0cmluZy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIHRoaXMuX3N0cmluZyA9IFtdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaXJjbGUkMShyYWRpdXMpIHtcbiAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcbiAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXNcbiAgICAgICsgXCJ6XCI7XG59XG5cbmZ1bmN0aW9uIGluZGV4KHByb2plY3Rpb24sIGNvbnRleHQpIHtcbiAgdmFyIHBvaW50UmFkaXVzID0gNC41LFxuICAgICAgcHJvamVjdGlvblN0cmVhbSxcbiAgICAgIGNvbnRleHRTdHJlYW07XG5cbiAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICB9XG5cbiAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShhcmVhU3RyZWFtJDEpKTtcbiAgICByZXR1cm4gYXJlYVN0cmVhbSQxLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgubWVhc3VyZSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0obGVuZ3RoU3RyZWFtJDEpKTtcbiAgICByZXR1cm4gbGVuZ3RoU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5ib3VuZHMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGJvdW5kc1N0cmVhbSQxKSk7XG4gICAgcmV0dXJuIGJvdW5kc1N0cmVhbSQxLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGguY2VudHJvaWQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNlbnRyb2lkU3RyZWFtJDEpKTtcbiAgICByZXR1cm4gY2VudHJvaWRTdHJlYW0kMS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdGlvblN0cmVhbSA9IF8gPT0gbnVsbCA/IChwcm9qZWN0aW9uID0gbnVsbCwgaWRlbnRpdHkpIDogKHByb2plY3Rpb24gPSBfKS5zdHJlYW0sIHBhdGgpIDogcHJvamVjdGlvbjtcbiAgfTtcblxuICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICBjb250ZXh0U3RyZWFtID0gXyA9PSBudWxsID8gKGNvbnRleHQgPSBudWxsLCBuZXcgUGF0aFN0cmluZykgOiBuZXcgUGF0aENvbnRleHQoY29udGV4dCA9IF8pO1xuICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihwcm9qZWN0aW9uKS5jb250ZXh0KGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0obWV0aG9kcykge1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogdHJhbnNmb3JtZXIobWV0aG9kcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHt9XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG59O1xuXG5mdW5jdGlvbiBmaXQocHJvamVjdGlvbiwgZml0Qm91bmRzLCBvYmplY3QpIHtcbiAgdmFyIGNsaXAgPSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgJiYgcHJvamVjdGlvbi5jbGlwRXh0ZW50KCk7XG4gIHByb2plY3Rpb24uc2NhbGUoMTUwKS50cmFuc2xhdGUoWzAsIDBdKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KG51bGwpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uLnN0cmVhbShib3VuZHNTdHJlYW0kMSkpO1xuICBmaXRCb3VuZHMoYm91bmRzU3RyZWFtJDEucmVzdWx0KCkpO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gIHJldHVybiBwcm9qZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sXG4gICAgICAgIGggPSBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0sXG4gICAgICAgIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLFxuICAgICAgICB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9ICt3aWR0aCxcbiAgICAgICAgayA9IHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLFxuICAgICAgICB4ID0gKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gLWsgKiBiWzBdWzFdO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgaCA9ICtoZWlnaHQsXG4gICAgICAgIGsgPSBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSxcbiAgICAgICAgeCA9IC1rICogYlswXVswXSxcbiAgICAgICAgeSA9IChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG52YXIgbWF4RGVwdGggPSAxNiwgLy8gbWF4aW11bSBkZXB0aCBvZiBzdWJkaXZpc2lvblxuICAgIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG5cbmZ1bmN0aW9uIHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikge1xuICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSA6IHJlc2FtcGxlTm9uZShwcm9qZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGVOb25lKHByb2plY3QpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZSQxKHByb2plY3QsIGRlbHRhMikge1xuXG4gIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgdmFyIGR4ID0geDEgLSB4MCxcbiAgICAgICAgZHkgPSB5MSAtIHkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xuICAgICAgdmFyIGEgPSBhMCArIGExLFxuICAgICAgICAgIGIgPSBiMCArIGIxLFxuICAgICAgICAgIGMgPSBjMCArIGMxLFxuICAgICAgICAgIG0gPSBzcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksXG4gICAgICAgICAgcGhpMiA9IGFzaW4oYyAvPSBtKSxcbiAgICAgICAgICBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiB8fCBhYnMobGFtYmRhMCAtIGxhbWJkYTEpIDwgZXBzaWxvbiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXG4gICAgICAgICAgeDIgPSBwWzBdLFxuICAgICAgICAgIHkyID0gcFsxXSxcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxuICAgICAgICAgIGR5MiA9IHkyIC0geTAsXG4gICAgICAgICAgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuXG4gICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIHgwID0gTmFOO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICBsaW5lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICB9O1xufVxuXG52YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgciA9IHJvdGF0ZSh4LCB5KTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLCByWzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHkpIHtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICByZXR1cm4gW2R4ICsgayAqIHgsIGR5IC0gayAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsoeCAtIGR4KSAvIGssIChkeSAtIHkpIC8ga107XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIGR4LCBkeSwgYWxwaGEpIHtcbiAgdmFyIGNvc0FscGhhID0gY29zKGFscGhhKSxcbiAgICAgIHNpbkFscGhhID0gc2luKGFscGhhKSxcbiAgICAgIGEgPSBjb3NBbHBoYSAqIGssXG4gICAgICBiID0gc2luQWxwaGEgKiBrLFxuICAgICAgYWkgPSBjb3NBbHBoYSAvIGssXG4gICAgICBiaSA9IHNpbkFscGhhIC8gayxcbiAgICAgIGNpID0gKHNpbkFscGhhICogZHkgLSBjb3NBbHBoYSAqIGR4KSAvIGssXG4gICAgICBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHJldHVybiBbYSAqIHggLSBiICogeSArIGR4LCBkeSAtIGIgKiB4IC0gYSAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFthaSAqIHggLSBiaSAqIHkgKyBjaSwgZmkgLSBiaSAqIHggLSBhaSAqIHldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgcmV0dXJuIHByb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvamVjdDsgfSkoKTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gIHZhciBwcm9qZWN0LFxuICAgICAgayA9IDE1MCwgLy8gc2NhbGVcbiAgICAgIHggPSA0ODAsIHkgPSAyNTAsIC8vIHRyYW5zbGF0ZVxuICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgLy8gcHJlLXJvdGF0ZVxuICAgICAgYWxwaGEgPSAwLCAvLyBwb3N0LXJvdGF0ZVxuICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gcG9zdC1jbGlwIGV4dGVudFxuICAgICAgZGVsdGEyID0gMC41LCAvLyBwcmVjaXNpb25cbiAgICAgIHByb2plY3RSZXNhbXBsZSxcbiAgICAgIHByb2plY3RUcmFuc2Zvcm0sXG4gICAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0ocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiBkZWdyZWVzLCBwb2ludFsxXSAqIGRlZ3JlZXNdO1xuICB9XG5cbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpKHByZWNsaXAocHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSkpKSk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSBfLCB0aGV0YSA9IHVuZGVmaW5lZCwgcmVzZXQoKSkgOiBwcmVjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlY2VudGVyKCkpIDogaztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWx0YUxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YVBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YUdhbW1hID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIHJhZGlhbnMgOiAwLCByZWNlbnRlcigpKSA6IFtkZWx0YUxhbWJkYSAqIGRlZ3JlZXMsIGRlbHRhUGhpICogZGVncmVlcywgZGVsdGFHYW1tYSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyID0gXyAqIF8pLCByZXNldCgpKSA6IHNxcnQoZGVsdGEyKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgdmFyIGNlbnRlciA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIDAsIDAsIGFscGhhKS5hcHBseShudWxsLCBwcm9qZWN0KGxhbWJkYSwgcGhpKSksXG4gICAgICAgIHRyYW5zZm9ybSA9IChhbHBoYSA/IHNjYWxlVHJhbnNsYXRlUm90YXRlIDogc2NhbGVUcmFuc2xhdGUpKGssIHggLSBjZW50ZXJbMF0sIHkgLSBjZW50ZXJbMV0sIGFscGhhKTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSk7XG4gICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtKTtcbiAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtID0gY29tcG9zZShyb3RhdGUsIHByb2plY3RUcmFuc2Zvcm0pO1xuICAgIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMik7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihwcm9qZWN0QXQpIHtcbiAgdmFyIHBoaTAgPSAwLFxuICAgICAgcGhpMSA9IHBpIC8gMyxcbiAgICAgIG0gPSBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLFxuICAgICAgcCA9IG0ocGhpMCwgcGhpMSk7XG5cbiAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKHBoaTAgPSBfWzBdICogcmFkaWFucywgcGhpMSA9IF9bMV0gKiByYWRpYW5zKSA6IFtwaGkwICogZGVncmVlcywgcGhpMSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyhwaGkwKSB7XG4gIHZhciBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbihwaGkpIC8gY29zUGhpMF07XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhc2luKHkgKiBjb3NQaGkwKV07XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG5cbmZ1bmN0aW9uIGNvbmljRXF1YWxBcmVhUmF3KHkwLCB5MSkge1xuICB2YXIgc3kwID0gc2luKHkwKSwgbiA9IChzeTAgKyBzaW4oeTEpKSAvIDI7XG5cbiAgLy8gQXJlIHRoZSBwYXJhbGxlbHMgc3ltbWV0cmljYWwgYXJvdW5kIHRoZSBFcXVhdG9yP1xuICBpZiAoYWJzKG4pIDwgZXBzaWxvbikgcmV0dXJuIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHkwKTtcblxuICB2YXIgYyA9IDEgKyBzeTAgKiAoMiAqIG4gLSBzeTApLCByMCA9IHNxcnQoYykgLyBuO1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIHZhciByID0gc3FydChjIC0gMiAqIG4gKiBzaW4oeSkpIC8gbjtcbiAgICByZXR1cm4gW3IgKiBzaW4oeCAqPSBuKSwgcjAgLSByICogY29zKHgpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByMHkgPSByMCAtIHk7XG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMocjB5KSkgLyBuICogc2lnbihyMHkpLCBhc2luKChjIC0gKHggKiB4ICsgcjB5ICogcjB5KSAqIG4gKiBuKSAvICgyICogbikpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZnVuY3Rpb24gY29uaWNFcXVhbEFyZWEoKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTU1LjQyNClcbiAgICAgIC5jZW50ZXIoWzAsIDMzLjY0NDJdKTtcbn1cblxuZnVuY3Rpb24gYWxiZXJzKCkge1xuICByZXR1cm4gY29uaWNFcXVhbEFyZWEoKVxuICAgICAgLnBhcmFsbGVscyhbMjkuNSwgNDUuNV0pXG4gICAgICAuc2NhbGUoMTA3MClcbiAgICAgIC50cmFuc2xhdGUoWzQ4MCwgMjUwXSlcbiAgICAgIC5yb3RhdGUoWzk2LCAwXSlcbiAgICAgIC5jZW50ZXIoWy0wLjYsIDM4LjddKTtcbn1cblxuLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4vLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbmZ1bmN0aW9uIG11bHRpcGxleChzdHJlYW1zKSB7XG4gIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7IH0sXG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0uc3BoZXJlKCk7IH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLmxpbmVFbmQoKTsgfSxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gIH07XG59XG5cbi8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4vLyA5NjDDlzUwMC4gVGhlIHByb2plY3Rpb24gYWxzbyB3b3JrcyBxdWl0ZSB3ZWxsIGF0IDk2MMOXNjAwIGlmIHlvdSBjaGFuZ2UgdGhlXG4vLyBzY2FsZSB0byAxMjg1IGFuZCBhZGp1c3QgdGhlIHRyYW5zbGF0ZSBhY2NvcmRpbmdseS4gVGhlIHNldCBvZiBzdGFuZGFyZFxuLy8gcGFyYWxsZWxzIGZvciBlYWNoIHJlZ2lvbiBjb21lcyBmcm9tIFVTR1MsIHdoaWNoIGlzIHB1Ymxpc2hlZCBoZXJlOlxuLy8gaHR0cDovL2Vnc2MudXNncy5nb3YvaXNiL3B1YnMvTWFwUHJvamVjdGlvbnMvcHJvamVjdGlvbnMuaHRtbCNhbGJlcnNcbmZ1bmN0aW9uIGFsYmVyc1VzYSgpIHtcbiAgdmFyIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW0sXG4gICAgICBsb3dlcjQ4ID0gYWxiZXJzKCksIGxvd2VyNDhQb2ludCxcbiAgICAgIGFsYXNrYSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTQsIDBdKS5jZW50ZXIoWy0yLCA1OC41XSkucGFyYWxsZWxzKFs1NSwgNjVdKSwgYWxhc2thUG9pbnQsIC8vIEVQU0c6MzMzOFxuICAgICAgaGF3YWlpID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NywgMF0pLmNlbnRlcihbLTMsIDE5LjldKS5wYXJhbGxlbHMoWzgsIDE4XSksIGhhd2FpaVBvaW50LCAvLyBFU1JJOjEwMjAwN1xuICAgICAgcG9pbnQsIHBvaW50U3RyZWFtID0ge3BvaW50OiBmdW5jdGlvbih4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9fTtcblxuICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgKGxvd2VyNDhQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgIHx8IChhbGFza2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgIHx8IChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICB9XG5cbiAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksXG4gICAgICAgIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLFxuICAgICAgICB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLFxuICAgICAgICB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgIHJldHVybiAoeSA+PSAwLjEyMCAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC40MjUgJiYgeCA8IC0wLjIxNCA/IGFsYXNrYVxuICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcbiAgICAgICAgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgoW2xvd2VyNDguc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWkuc3RyZWFtKHN0cmVhbSldKTtcbiAgfTtcblxuICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgbG93ZXI0OC5wcmVjaXNpb24oXyksIGFsYXNrYS5wcmVjaXNpb24oXyksIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICBsb3dlcjQ4LnNjYWxlKF8pLCBhbGFza2Euc2NhbGUoXyAqIDAuMzUpLCBoYXdhaWkuc2NhbGUoXyk7XG4gICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcblxuICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDhcbiAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQ1NSAqIGssIHkgLSAwLjIzOCAqIGtdLCBbeCArIDAuNDU1ICogaywgeSArIDAuMjM4ICoga11dKVxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcblxuICAgIGFsYXNrYVBvaW50ID0gYWxhc2thXG4gICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICBoYXdhaWlQb2ludCA9IGhhd2FpaVxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMTY2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuXG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKGFsYmVyc1VzYSwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKGFsYmVyc1VzYSwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChhbGJlcnNVc2EsIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gYWxiZXJzVXNhO1xuICB9XG5cbiAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbn1cblxuZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGN4ID0gY29zKHgpLFxuICAgICAgICBjeSA9IGNvcyh5KSxcbiAgICAgICAgayA9IHNjYWxlKGN4ICogY3kpO1xuICAgIHJldHVybiBbXG4gICAgICBrICogY3kgKiBzaW4oeCksXG4gICAgICBrICogc2luKHkpXG4gICAgXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhemltdXRoYWxJbnZlcnQoYW5nbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgeiA9IHNxcnQoeCAqIHggKyB5ICogeSksXG4gICAgICAgIGMgPSBhbmdsZSh6KSxcbiAgICAgICAgc2MgPSBzaW4oYyksXG4gICAgICAgIGNjID0gY29zKGMpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih4ICogc2MsIHogKiBjYyksXG4gICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICBdO1xuICB9XG59XG5cbnZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oY3hjeSkge1xuICByZXR1cm4gc3FydCgyIC8gKDEgKyBjeGN5KSk7XG59KTtcblxuYXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiAyICogYXNpbih6IC8gMik7XG59KTtcblxuZnVuY3Rpb24gYXppbXV0aGFsRXF1YWxBcmVhKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTI0Ljc1KVxuICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbn1cblxudmFyIGF6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsUmF3KGZ1bmN0aW9uKGMpIHtcbiAgcmV0dXJuIChjID0gYWNvcyhjKSkgJiYgYyAvIHNpbihjKTtcbn0pO1xuXG5hemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gejtcbn0pO1xuXG5mdW5jdGlvbiBhemltdXRoYWxFcXVpZGlzdGFudCgpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoNzkuNDE4OClcbiAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG59XG5cbmZ1bmN0aW9uIG1lcmNhdG9yUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhLCBsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpXTtcbn1cblxubWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gW3gsIDIgKiBhdGFuKGV4cCh5KSkgLSBoYWxmUGldO1xufTtcblxuZnVuY3Rpb24gbWVyY2F0b3IoKSB7XG4gIHJldHVybiBtZXJjYXRvclByb2plY3Rpb24obWVyY2F0b3JSYXcpXG4gICAgICAuc2NhbGUoOTYxIC8gdGF1KTtcbn1cblxuZnVuY3Rpb24gbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgdmFyIG0gPSBwcm9qZWN0aW9uKHByb2plY3QpLFxuICAgICAgY2VudGVyID0gbS5jZW50ZXIsXG4gICAgICBzY2FsZSA9IG0uc2NhbGUsXG4gICAgICB0cmFuc2xhdGUgPSBtLnRyYW5zbGF0ZSxcbiAgICAgIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTE7IC8vIGNsaXAgZXh0ZW50XG5cbiAgbS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZShfKSwgcmVjbGlwKCkpIDogc2NhbGUoKTtcbiAgfTtcblxuICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGUoXyksIHJlY2xpcCgpKSA6IHRyYW5zbGF0ZSgpO1xuICB9O1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlcihfKSwgcmVjbGlwKCkpIDogY2VudGVyKCk7XG4gIH07XG5cbiAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChfID09IG51bGwgPyB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwgOiAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSkpLCByZWNsaXAoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlY2xpcCgpIHtcbiAgICB2YXIgayA9IHBpICogc2NhbGUoKSxcbiAgICAgICAgdCA9IG0ocm90YXRpb24obS5yb3RhdGUoKSkuaW52ZXJ0KFswLCAwXSkpO1xuICAgIHJldHVybiBjbGlwRXh0ZW50KHgwID09IG51bGxcbiAgICAgICAgPyBbW3RbMF0gLSBrLCB0WzFdIC0ga10sIFt0WzBdICsgaywgdFsxXSArIGtdXSA6IHByb2plY3QgPT09IG1lcmNhdG9yUmF3XG4gICAgICAgID8gW1tNYXRoLm1heCh0WzBdIC0gaywgeDApLCB5MF0sIFtNYXRoLm1pbih0WzBdICsgaywgeDEpLCB5MV1dXG4gICAgICAgIDogW1t4MCwgTWF0aC5tYXgodFsxXSAtIGssIHkwKV0sIFt4MSwgTWF0aC5taW4odFsxXSArIGssIHkxKV1dKTtcbiAgfVxuXG4gIHJldHVybiByZWNsaXAoKTtcbn1cblxuZnVuY3Rpb24gdGFueSh5KSB7XG4gIHJldHVybiB0YW4oKGhhbGZQaSArIHkpIC8gMik7XG59XG5cbmZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsUmF3KHkwLCB5MSkge1xuICB2YXIgY3kwID0gY29zKHkwKSxcbiAgICAgIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogbG9nKGN5MCAvIGNvcyh5MSkpIC8gbG9nKHRhbnkoeTEpIC8gdGFueSh5MCkpLFxuICAgICAgZiA9IGN5MCAqIHBvdyh0YW55KHkwKSwgbikgLyBuO1xuXG4gIGlmICghbikgcmV0dXJuIG1lcmNhdG9yUmF3O1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIGlmIChmID4gMCkgeyBpZiAoeSA8IC1oYWxmUGkgKyBlcHNpbG9uKSB5ID0gLWhhbGZQaSArIGVwc2lsb247IH1cbiAgICBlbHNlIHsgaWYgKHkgPiBoYWxmUGkgLSBlcHNpbG9uKSB5ID0gaGFsZlBpIC0gZXBzaWxvbjsgfVxuICAgIHZhciByID0gZiAvIHBvdyh0YW55KHkpLCBuKTtcbiAgICByZXR1cm4gW3IgKiBzaW4obiAqIHgpLCBmIC0gciAqIGNvcyhuICogeCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGZ5ID0gZiAtIHksIHIgPSBzaWduKG4pICogc3FydCh4ICogeCArIGZ5ICogZnkpO1xuICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKGZ5KSkgLyBuICogc2lnbihmeSksIDIgKiBhdGFuKHBvdyhmIC8gciwgMSAvIG4pKSAtIGhhbGZQaV07XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsKCkge1xuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljQ29uZm9ybWFsUmF3KVxuICAgICAgLnNjYWxlKDEwOS41KVxuICAgICAgLnBhcmFsbGVscyhbMzAsIDMwXSk7XG59XG5cbmZ1bmN0aW9uIGVxdWlyZWN0YW5ndWxhclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xhbWJkYSwgcGhpXTtcbn1cblxuZXF1aXJlY3Rhbmd1bGFyUmF3LmludmVydCA9IGVxdWlyZWN0YW5ndWxhclJhdztcblxuZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihlcXVpcmVjdGFuZ3VsYXJSYXcpXG4gICAgICAuc2NhbGUoMTUyLjYzKTtcbn1cblxuZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudFJhdyh5MCwgeTEpIHtcbiAgdmFyIGN5MCA9IGNvcyh5MCksXG4gICAgICBuID0geTAgPT09IHkxID8gc2luKHkwKSA6IChjeTAgLSBjb3MoeTEpKSAvICh5MSAtIHkwKSxcbiAgICAgIGcgPSBjeTAgLyBuICsgeTA7XG5cbiAgaWYgKGFicyhuKSA8IGVwc2lsb24pIHJldHVybiBlcXVpcmVjdGFuZ3VsYXJSYXc7XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgdmFyIGd5ID0gZyAtIHksIG54ID0gbiAqIHg7XG4gICAgcmV0dXJuIFtneSAqIHNpbihueCksIGcgLSBneSAqIGNvcyhueCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGd5ID0gZyAtIHk7XG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZ3kpKSAvIG4gKiBzaWduKGd5KSwgZyAtIHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZ3kgKiBneSldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5mdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50KCkge1xuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoMTMxLjE1NClcbiAgICAgIC5jZW50ZXIoWzAsIDEzLjkzODldKTtcbn1cblxudmFyIEExID0gMS4zNDAyNjQsXG4gICAgQTIgPSAtMC4wODExMDYsXG4gICAgQTMgPSAwLjAwMDg5MyxcbiAgICBBNCA9IDAuMDAzNzk2LFxuICAgIE0gPSBzcXJ0KDMpIC8gMixcbiAgICBpdGVyYXRpb25zID0gMTI7XG5cbmZ1bmN0aW9uIGVxdWFsRWFydGhSYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIGwgPSBhc2luKE0gKiBzaW4ocGhpKSksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICByZXR1cm4gW1xuICAgIGxhbWJkYSAqIGNvcyhsKSAvIChNICogKEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMikpKSxcbiAgICBsICogKEExICsgQTIgKiBsMiArIGw2ICogKEEzICsgQTQgKiBsMikpXG4gIF07XG59XG5cbmVxdWFsRWFydGhSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbCA9IHksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICBmb3IgKHZhciBpID0gMCwgZGVsdGEsIGZ5LCBmcHk7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICBmeSA9IGwgKiAoQTEgKyBBMiAqIGwyICsgbDYgKiAoQTMgKyBBNCAqIGwyKSkgLSB5O1xuICAgIGZweSA9IEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMik7XG4gICAgbCAtPSBkZWx0YSA9IGZ5IC8gZnB5LCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgICBpZiAoYWJzKGRlbHRhKSA8IGVwc2lsb24yKSBicmVhaztcbiAgfVxuICByZXR1cm4gW1xuICAgIE0gKiB4ICogKEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMikpIC8gY29zKGwpLFxuICAgIGFzaW4oc2luKGwpIC8gTSlcbiAgXTtcbn07XG5cbmZ1bmN0aW9uIGVxdWFsRWFydGgoKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGVxdWFsRWFydGhSYXcpXG4gICAgICAuc2NhbGUoMTc3LjE1OCk7XG59XG5cbmZ1bmN0aW9uIGdub21vbmljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zKHkpLCBrID0gY29zKHgpICogY3k7XG4gIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbn1cblxuZ25vbW9uaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGF0YW4pO1xuXG5mdW5jdGlvbiBnbm9tb25pYygpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZ25vbW9uaWNSYXcpXG4gICAgICAuc2NhbGUoMTQ0LjA0OSlcbiAgICAgIC5jbGlwQW5nbGUoNjApO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZSQxKGt4LCBreSwgdHgsIHR5KSB7XG4gIHJldHVybiBreCA9PT0gMSAmJiBreSA9PT0gMSAmJiB0eCA9PT0gMCAmJiB0eSA9PT0gMCA/IGlkZW50aXR5IDogdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICoga3ggKyB0eCwgeSAqIGt5ICsgdHkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5JDEoKSB7XG4gIHZhciBrID0gMSwgdHggPSAwLCB0eSA9IDAsIHN4ID0gMSwgc3kgPSAxLCB0cmFuc2Zvcm0gPSBpZGVudGl0eSwgLy8gc2NhbGUsIHRyYW5zbGF0ZSBhbmQgcmVmbGVjdFxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCAvLyBjbGlwIGV4dGVudFxuICAgICAgcG9zdGNsaXAgPSBpZGVudGl0eSxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW0sXG4gICAgICBwcm9qZWN0aW9uO1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHByb2plY3Rpb24gPSB7XG4gICAgc3RyZWFtOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpO1xuICAgIH0sXG4gICAgcG9zdGNsaXA6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICAgIH0sXG4gICAgY2xpcEV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMSgoayA9ICtfKSAqIHN4LCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogaztcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiBzeSwgdHggPSArX1swXSwgdHkgPSArX1sxXSksIHJlc2V0KCkpIDogW3R4LCB0eV07XG4gICAgfSxcbiAgICByZWZsZWN0WDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMShrICogKHN4ID0gXyA/IC0xIDogMSksIGsgKiBzeSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeCA8IDA7XG4gICAgfSxcbiAgICByZWZsZWN0WTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiAoc3kgPSBfID8gLTEgOiAxKSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gICAgfSxcbiAgICBmaXRFeHRlbnQ6IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGZpdFNpemU6IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGZpdFdpZHRoOiBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gICAgfSxcbiAgICBmaXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5hdHVyYWxFYXJ0aDFSYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgcmV0dXJuIFtcbiAgICBsYW1iZGEgKiAoMC44NzA3IC0gMC4xMzE5NzkgKiBwaGkyICsgcGhpNCAqICgtMC4wMTM3OTEgKyBwaGk0ICogKDAuMDAzOTcxICogcGhpMiAtIDAuMDAxNTI5ICogcGhpNCkpKSxcbiAgICBwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSlcbiAgXTtcbn1cblxubmF0dXJhbEVhcnRoMVJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBwaGkgPSB5LCBpID0gMjUsIGRlbHRhO1xuICBkbyB7XG4gICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICBwaGkgLT0gZGVsdGEgPSAocGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpIC0geSkgL1xuICAgICAgICAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICogMyArIHBoaTQgKiAoLTAuMDQ0NDc1ICogNyArIDAuMDI4ODc0ICogOSAqIHBoaTIgLSAwLjAwNTkxNiAqIDExICogcGhpNCkpKTtcbiAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gIHJldHVybiBbXG4gICAgeCAvICgwLjg3MDcgKyAocGhpMiA9IHBoaSAqIHBoaSkgKiAoLTAuMTMxOTc5ICsgcGhpMiAqICgtMC4wMTM3OTEgKyBwaGkyICogcGhpMiAqIHBoaTIgKiAoMC4wMDM5NzEgLSAwLjAwMTUyOSAqIHBoaTIpKSkpLFxuICAgIHBoaVxuICBdO1xufTtcblxuZnVuY3Rpb24gbmF0dXJhbEVhcnRoMSgpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24obmF0dXJhbEVhcnRoMVJhdylcbiAgICAgIC5zY2FsZSgxNzUuMjk1KTtcbn1cblxuZnVuY3Rpb24gb3J0aG9ncmFwaGljUmF3KHgsIHkpIHtcbiAgcmV0dXJuIFtjb3MoeSkgKiBzaW4oeCksIHNpbih5KV07XG59XG5cbm9ydGhvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXNpbik7XG5cbmZ1bmN0aW9uIG9ydGhvZ3JhcGhpYygpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24ob3J0aG9ncmFwaGljUmF3KVxuICAgICAgLnNjYWxlKDI0OS41KVxuICAgICAgLmNsaXBBbmdsZSg5MCArIGVwc2lsb24pO1xufVxuXG5mdW5jdGlvbiBzdGVyZW9ncmFwaGljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zKHkpLCBrID0gMSArIGNvcyh4KSAqIGN5O1xuICByZXR1cm4gW2N5ICogc2luKHgpIC8gaywgc2luKHkpIC8ga107XG59XG5cbnN0ZXJlb2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIDIgKiBhdGFuKHopO1xufSk7XG5cbmZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWMoKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKHN0ZXJlb2dyYXBoaWNSYXcpXG4gICAgICAuc2NhbGUoMjUwKVxuICAgICAgLmNsaXBBbmdsZSgxNDIpO1xufVxuXG5mdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpLCAtbGFtYmRhXTtcbn1cblxudHJhbnN2ZXJzZU1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIFsteSwgMiAqIGF0YW4oZXhwKHgpKSAtIGhhbGZQaV07XG59O1xuXG5mdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3IoKSB7XG4gIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHJvdGF0ZSA9IG0ucm90YXRlO1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKFstX1sxXSwgX1swXV0pIDogKF8gPSBjZW50ZXIoKSwgW19bMV0sIC1fWzBdXSk7XG4gIH07XG5cbiAgbS5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0ZShbMCwgMCwgOTBdKVxuICAgICAgLnNjYWxlKDE1OS4xNTUpO1xufVxuXG5leHBvcnRzLmdlb0FsYmVycyA9IGFsYmVycztcbmV4cG9ydHMuZ2VvQWxiZXJzVXNhID0gYWxiZXJzVXNhO1xuZXhwb3J0cy5nZW9BcmVhID0gYXJlYTtcbmV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1YWxBcmVhID0gYXppbXV0aGFsRXF1YWxBcmVhO1xuZXhwb3J0cy5nZW9BemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxFcXVhbEFyZWFSYXc7XG5leHBvcnRzLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50ID0gYXppbXV0aGFsRXF1aWRpc3RhbnQ7XG5leHBvcnRzLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsRXF1aWRpc3RhbnRSYXc7XG5leHBvcnRzLmdlb0JvdW5kcyA9IGJvdW5kcztcbmV4cG9ydHMuZ2VvQ2VudHJvaWQgPSBjZW50cm9pZDtcbmV4cG9ydHMuZ2VvQ2lyY2xlID0gY2lyY2xlO1xuZXhwb3J0cy5nZW9DbGlwQW50aW1lcmlkaWFuID0gY2xpcEFudGltZXJpZGlhbjtcbmV4cG9ydHMuZ2VvQ2xpcENpcmNsZSA9IGNsaXBDaXJjbGU7XG5leHBvcnRzLmdlb0NsaXBFeHRlbnQgPSBleHRlbnQ7XG5leHBvcnRzLmdlb0NsaXBSZWN0YW5nbGUgPSBjbGlwUmVjdGFuZ2xlO1xuZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbCA9IGNvbmljQ29uZm9ybWFsO1xuZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbFJhdyA9IGNvbmljQ29uZm9ybWFsUmF3O1xuZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYSA9IGNvbmljRXF1YWxBcmVhO1xuZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYVJhdyA9IGNvbmljRXF1YWxBcmVhUmF3O1xuZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50ID0gY29uaWNFcXVpZGlzdGFudDtcbmV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudFJhdyA9IGNvbmljRXF1aWRpc3RhbnRSYXc7XG5leHBvcnRzLmdlb0NvbnRhaW5zID0gY29udGFpbnM7XG5leHBvcnRzLmdlb0Rpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmdlb0VxdWFsRWFydGggPSBlcXVhbEVhcnRoO1xuZXhwb3J0cy5nZW9FcXVhbEVhcnRoUmF3ID0gZXF1YWxFYXJ0aFJhdztcbmV4cG9ydHMuZ2VvRXF1aXJlY3Rhbmd1bGFyID0gZXF1aXJlY3Rhbmd1bGFyO1xuZXhwb3J0cy5nZW9FcXVpcmVjdGFuZ3VsYXJSYXcgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XG5leHBvcnRzLmdlb0dub21vbmljID0gZ25vbW9uaWM7XG5leHBvcnRzLmdlb0dub21vbmljUmF3ID0gZ25vbW9uaWNSYXc7XG5leHBvcnRzLmdlb0dyYXRpY3VsZSA9IGdyYXRpY3VsZTtcbmV4cG9ydHMuZ2VvR3JhdGljdWxlMTAgPSBncmF0aWN1bGUxMDtcbmV4cG9ydHMuZ2VvSWRlbnRpdHkgPSBpZGVudGl0eSQxO1xuZXhwb3J0cy5nZW9JbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuZXhwb3J0cy5nZW9MZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmdlb01lcmNhdG9yID0gbWVyY2F0b3I7XG5leHBvcnRzLmdlb01lcmNhdG9yUmF3ID0gbWVyY2F0b3JSYXc7XG5leHBvcnRzLmdlb05hdHVyYWxFYXJ0aDEgPSBuYXR1cmFsRWFydGgxO1xuZXhwb3J0cy5nZW9OYXR1cmFsRWFydGgxUmF3ID0gbmF0dXJhbEVhcnRoMVJhdztcbmV4cG9ydHMuZ2VvT3J0aG9ncmFwaGljID0gb3J0aG9ncmFwaGljO1xuZXhwb3J0cy5nZW9PcnRob2dyYXBoaWNSYXcgPSBvcnRob2dyYXBoaWNSYXc7XG5leHBvcnRzLmdlb1BhdGggPSBpbmRleDtcbmV4cG9ydHMuZ2VvUHJvamVjdGlvbiA9IHByb2plY3Rpb247XG5leHBvcnRzLmdlb1Byb2plY3Rpb25NdXRhdG9yID0gcHJvamVjdGlvbk11dGF0b3I7XG5leHBvcnRzLmdlb1JvdGF0aW9uID0gcm90YXRpb247XG5leHBvcnRzLmdlb1N0ZXJlb2dyYXBoaWMgPSBzdGVyZW9ncmFwaGljO1xuZXhwb3J0cy5nZW9TdGVyZW9ncmFwaGljUmF3ID0gc3RlcmVvZ3JhcGhpY1JhdztcbmV4cG9ydHMuZ2VvU3RyZWFtID0gZ2VvU3RyZWFtO1xuZXhwb3J0cy5nZW9UcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5leHBvcnRzLmdlb1RyYW5zdmVyc2VNZXJjYXRvciA9IHRyYW5zdmVyc2VNZXJjYXRvcjtcbmV4cG9ydHMuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yUmF3ID0gdHJhbnN2ZXJzZU1lcmNhdG9yUmF3O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWhpZXJhcmNoeS8gdjEuMS45IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24oYSwgYikge1xuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG59XG5cbmZ1bmN0aW9uIG1lYW5YKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UobWVhblhSZWR1Y2UsIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBtZWFuWFJlZHVjZSh4LCBjKSB7XG4gIHJldHVybiB4ICsgYy54O1xufVxuXG5mdW5jdGlvbiBtYXhZKGNoaWxkcmVuKSB7XG4gIHJldHVybiAxICsgY2hpbGRyZW4ucmVkdWNlKG1heFlSZWR1Y2UsIDApO1xufVxuXG5mdW5jdGlvbiBtYXhZUmVkdWNlKHksIGMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHksIGMueSk7XG59XG5cbmZ1bmN0aW9uIGxlYWZMZWZ0KG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuO1xuICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSBub2RlID0gY2hpbGRyZW5bMF07XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBsZWFmUmlnaHQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGNsdXN0ZXIoKSB7XG4gIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24sXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBub2RlU2l6ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsdXN0ZXIocm9vdCkge1xuICAgIHZhciBwcmV2aW91c05vZGUsXG4gICAgICAgIHggPSAwO1xuXG4gICAgLy8gRmlyc3Qgd2FsaywgY29tcHV0aW5nIHRoZSBpbml0aWFsIHggJiB5IHZhbHVlcy5cbiAgICByb290LmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIG5vZGUueCA9IG1lYW5YKGNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS55ID0gbWF4WShjaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XG4gICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGVmdCA9IGxlYWZMZWZ0KHJvb3QpLFxuICAgICAgICByaWdodCA9IGxlYWZSaWdodChyb290KSxcbiAgICAgICAgeDAgPSBsZWZ0LnggLSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsXG4gICAgICAgIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcblxuICAgIC8vIFNlY29uZCB3YWxrLCBub3JtYWxpemluZyB4ICYgeSB0byB0aGUgZGVzaXJlZCBzaXplLlxuICAgIHJldHVybiByb290LmVhY2hBZnRlcihub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogZHg7XG4gICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIGR5O1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggPSAobm9kZS54IC0geDApIC8gKHgxIC0geDApICogZHg7XG4gICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBkeTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgY2x1c3RlcikgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgY2x1c3Rlci5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gY2x1c3Rlcjtcbn1cblxuZnVuY3Rpb24gY291bnQobm9kZSkge1xuICB2YXIgc3VtID0gMCxcbiAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbixcbiAgICAgIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gIGlmICghaSkgc3VtID0gMTtcbiAgZWxzZSB3aGlsZSAoLS1pID49IDApIHN1bSArPSBjaGlsZHJlbltpXS52YWx1ZTtcbiAgbm9kZS52YWx1ZSA9IHN1bTtcbn1cblxuZnVuY3Rpb24gbm9kZV9jb3VudCgpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGNvdW50KTtcbn1cblxuZnVuY3Rpb24gbm9kZV9lYWNoKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgY3VycmVudCwgbmV4dCA9IFtub2RlXSwgY2hpbGRyZW4sIGksIG47XG4gIGRvIHtcbiAgICBjdXJyZW50ID0gbmV4dC5yZXZlcnNlKCksIG5leHQgPSBbXTtcbiAgICB3aGlsZSAobm9kZSA9IGN1cnJlbnQucG9wKCkpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbmV4dC5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5leHQubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfZWFjaEJlZm9yZShjYWxsYmFjaykge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBjaGlsZHJlbiwgaTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuKSBmb3IgKGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBub2RlX2VhY2hBZnRlcihjYWxsYmFjaykge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBuZXh0ID0gW10sIGNoaWxkcmVuLCBpLCBuO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgbmV4dC5wdXNoKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuKSBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKG5vZGUgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2sobm9kZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfc3VtKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHN1bSA9ICt2YWx1ZShub2RlLmRhdGEpIHx8IDAsXG4gICAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbixcbiAgICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoLS1pID49IDApIHN1bSArPSBjaGlsZHJlbltpXS52YWx1ZTtcbiAgICBub2RlLnZhbHVlID0gc3VtO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbm9kZV9zb3J0KGNvbXBhcmUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub2RlX3BhdGgoZW5kKSB7XG4gIHZhciBzdGFydCA9IHRoaXMsXG4gICAgICBhbmNlc3RvciA9IGxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksXG4gICAgICBub2RlcyA9IFtzdGFydF07XG4gIHdoaWxlIChzdGFydCAhPT0gYW5jZXN0b3IpIHtcbiAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcbiAgICBub2Rlcy5wdXNoKHN0YXJ0KTtcbiAgfVxuICB2YXIgayA9IG5vZGVzLmxlbmd0aDtcbiAgd2hpbGUgKGVuZCAhPT0gYW5jZXN0b3IpIHtcbiAgICBub2Rlcy5zcGxpY2UoaywgMCwgZW5kKTtcbiAgICBlbmQgPSBlbmQucGFyZW50O1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gbGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYTtcbiAgdmFyIGFOb2RlcyA9IGEuYW5jZXN0b3JzKCksXG4gICAgICBiTm9kZXMgPSBiLmFuY2VzdG9ycygpLFxuICAgICAgYyA9IG51bGw7XG4gIGEgPSBhTm9kZXMucG9wKCk7XG4gIGIgPSBiTm9kZXMucG9wKCk7XG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgYyA9IGE7XG4gICAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgICBiID0gYk5vZGVzLnBvcCgpO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBub2RlX2FuY2VzdG9ycygpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXTtcbiAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBub2RlX2Rlc2NlbmRhbnRzKCkge1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBub2RlX2xlYXZlcygpIHtcbiAgdmFyIGxlYXZlcyA9IFtdO1xuICB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgbGVhdmVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxlYXZlcztcbn1cblxuZnVuY3Rpb24gbm9kZV9saW5rcygpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLCBsaW5rcyA9IFtdO1xuICByb290LmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlICE9PSByb290KSB7IC8vIERvbuKAmXQgaW5jbHVkZSB0aGUgcm9vdOKAmXMgcGFyZW50LCBpZiBhbnkuXG4gICAgICBsaW5rcy5wdXNoKHtzb3VyY2U6IG5vZGUucGFyZW50LCB0YXJnZXQ6IG5vZGV9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGlua3M7XG59XG5cbmZ1bmN0aW9uIGhpZXJhcmNoeShkYXRhLCBjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEpLFxuICAgICAgdmFsdWVkID0gK2RhdGEudmFsdWUgJiYgKHJvb3QudmFsdWUgPSBkYXRhLnZhbHVlKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFtyb290XSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRzLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIGNoaWxkcmVuID0gZGVmYXVsdENoaWxkcmVuO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBpZiAodmFsdWVkKSBub2RlLnZhbHVlID0gK25vZGUuZGF0YS52YWx1ZTtcbiAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuKG5vZGUuZGF0YSkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV0gPSBuZXcgTm9kZShjaGlsZHNbaV0pKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdC5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBub2RlX2NvcHkoKSB7XG4gIHJldHVybiBoaWVyYXJjaHkodGhpcykuZWFjaEJlZm9yZShjb3B5RGF0YSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDaGlsZHJlbihkKSB7XG4gIHJldHVybiBkLmNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjb3B5RGF0YShub2RlKSB7XG4gIG5vZGUuZGF0YSA9IG5vZGUuZGF0YS5kYXRhO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSGVpZ2h0KG5vZGUpIHtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIGRvIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudCkgJiYgKG5vZGUuaGVpZ2h0IDwgKytoZWlnaHQpKTtcbn1cblxuZnVuY3Rpb24gTm9kZShkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuZGVwdGggPVxuICB0aGlzLmhlaWdodCA9IDA7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuTm9kZS5wcm90b3R5cGUgPSBoaWVyYXJjaHkucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTm9kZSxcbiAgY291bnQ6IG5vZGVfY291bnQsXG4gIGVhY2g6IG5vZGVfZWFjaCxcbiAgZWFjaEFmdGVyOiBub2RlX2VhY2hBZnRlcixcbiAgZWFjaEJlZm9yZTogbm9kZV9lYWNoQmVmb3JlLFxuICBzdW06IG5vZGVfc3VtLFxuICBzb3J0OiBub2RlX3NvcnQsXG4gIHBhdGg6IG5vZGVfcGF0aCxcbiAgYW5jZXN0b3JzOiBub2RlX2FuY2VzdG9ycyxcbiAgZGVzY2VuZGFudHM6IG5vZGVfZGVzY2VuZGFudHMsXG4gIGxlYXZlczogbm9kZV9sZWF2ZXMsXG4gIGxpbmtzOiBub2RlX2xpbmtzLFxuICBjb3B5OiBub2RlX2NvcHlcbn07XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICB2YXIgbSA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHQsXG4gICAgICBpO1xuXG4gIHdoaWxlIChtKSB7XG4gICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgIHQgPSBhcnJheVttXTtcbiAgICBhcnJheVttXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2ldID0gdDtcbiAgfVxuXG4gIHJldHVybiBhcnJheTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZShjaXJjbGVzKSB7XG4gIHZhciBpID0gMCwgbiA9IChjaXJjbGVzID0gc2h1ZmZsZShzbGljZS5jYWxsKGNpcmNsZXMpKSkubGVuZ3RoLCBCID0gW10sIHAsIGU7XG5cbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgcCA9IGNpcmNsZXNbaV07XG4gICAgaWYgKGUgJiYgZW5jbG9zZXNXZWFrKGUsIHApKSArK2k7XG4gICAgZWxzZSBlID0gZW5jbG9zZUJhc2lzKEIgPSBleHRlbmRCYXNpcyhCLCBwKSksIGkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZEJhc2lzKEIsIHApIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGVuY2xvc2VzV2Vha0FsbChwLCBCKSkgcmV0dXJuIFtwXTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbGVtZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgIGlmIChlbmNsb3Nlc05vdChwLCBCW2ldKVxuICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQikpIHtcbiAgICAgIHJldHVybiBbQltpXSwgcF07XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBCIG11c3QgaGF2ZSBhdCBsZWFzdCB0d28gZWxlbWVudHMuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgQi5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltpXSwgQltqXSksIHApXG4gICAgICAgICAgJiYgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQltqXSlcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbal0sIHApLCBCW2ldKVxuICAgICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMzKEJbaV0sIEJbal0sIHApLCBCKSkge1xuICAgICAgICByZXR1cm4gW0JbaV0sIEJbal0sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gc29tZXRoaW5nIGlzIHZlcnkgd3JvbmcuXG4gIHRocm93IG5ldyBFcnJvcjtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNOb3QoYSwgYikge1xuICB2YXIgZHIgPSBhLnIgLSBiLnIsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyIDwgMCB8fCBkciAqIGRyIDwgZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzV2VhayhhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciArIDFlLTYsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzV2Vha0FsbChhLCBCKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgIGlmICghZW5jbG9zZXNXZWFrKGEsIEJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMoQikge1xuICBzd2l0Y2ggKEIubGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZW5jbG9zZUJhc2lzMShCWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBlbmNsb3NlQmFzaXMyKEJbMF0sIEJbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGVuY2xvc2VCYXNpczMoQlswXSwgQlsxXSwgQlsyXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMShhKSB7XG4gIHJldHVybiB7XG4gICAgeDogYS54LFxuICAgIHk6IGEueSxcbiAgICByOiBhLnJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMihhLCBiKSB7XG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxuICAgICAgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIucixcbiAgICAgIHgyMSA9IHgyIC0geDEsIHkyMSA9IHkyIC0geTEsIHIyMSA9IHIyIC0gcjEsXG4gICAgICBsID0gTWF0aC5zcXJ0KHgyMSAqIHgyMSArIHkyMSAqIHkyMSk7XG4gIHJldHVybiB7XG4gICAgeDogKHgxICsgeDIgKyB4MjEgLyBsICogcjIxKSAvIDIsXG4gICAgeTogKHkxICsgeTIgKyB5MjEgLyBsICogcjIxKSAvIDIsXG4gICAgcjogKGwgKyByMSArIHIyKSAvIDJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzMyhhLCBiLCBjKSB7XG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxuICAgICAgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIucixcbiAgICAgIHgzID0gYy54LCB5MyA9IGMueSwgcjMgPSBjLnIsXG4gICAgICBhMiA9IHgxIC0geDIsXG4gICAgICBhMyA9IHgxIC0geDMsXG4gICAgICBiMiA9IHkxIC0geTIsXG4gICAgICBiMyA9IHkxIC0geTMsXG4gICAgICBjMiA9IHIyIC0gcjEsXG4gICAgICBjMyA9IHIzIC0gcjEsXG4gICAgICBkMSA9IHgxICogeDEgKyB5MSAqIHkxIC0gcjEgKiByMSxcbiAgICAgIGQyID0gZDEgLSB4MiAqIHgyIC0geTIgKiB5MiArIHIyICogcjIsXG4gICAgICBkMyA9IGQxIC0geDMgKiB4MyAtIHkzICogeTMgKyByMyAqIHIzLFxuICAgICAgYWIgPSBhMyAqIGIyIC0gYTIgKiBiMyxcbiAgICAgIHhhID0gKGIyICogZDMgLSBiMyAqIGQyKSAvIChhYiAqIDIpIC0geDEsXG4gICAgICB4YiA9IChiMyAqIGMyIC0gYjIgKiBjMykgLyBhYixcbiAgICAgIHlhID0gKGEzICogZDIgLSBhMiAqIGQzKSAvIChhYiAqIDIpIC0geTEsXG4gICAgICB5YiA9IChhMiAqIGMzIC0gYTMgKiBjMikgLyBhYixcbiAgICAgIEEgPSB4YiAqIHhiICsgeWIgKiB5YiAtIDEsXG4gICAgICBCID0gMiAqIChyMSArIHhhICogeGIgKyB5YSAqIHliKSxcbiAgICAgIEMgPSB4YSAqIHhhICsgeWEgKiB5YSAtIHIxICogcjEsXG4gICAgICByID0gLShBID8gKEIgKyBNYXRoLnNxcnQoQiAqIEIgLSA0ICogQSAqIEMpKSAvICgyICogQSkgOiBDIC8gQik7XG4gIHJldHVybiB7XG4gICAgeDogeDEgKyB4YSArIHhiICogcixcbiAgICB5OiB5MSArIHlhICsgeWIgKiByLFxuICAgIHI6IHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGxhY2UoYiwgYSwgYykge1xuICB2YXIgZHggPSBiLnggLSBhLngsIHgsIGEyLFxuICAgICAgZHkgPSBiLnkgLSBhLnksIHksIGIyLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgaWYgKGQyKSB7XG4gICAgYTIgPSBhLnIgKyBjLnIsIGEyICo9IGEyO1xuICAgIGIyID0gYi5yICsgYy5yLCBiMiAqPSBiMjtcbiAgICBpZiAoYTIgPiBiMikge1xuICAgICAgeCA9IChkMiArIGIyIC0gYTIpIC8gKDIgKiBkMik7XG4gICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGIyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgYy54ID0gYi54IC0geCAqIGR4IC0geSAqIGR5O1xuICAgICAgYy55ID0gYi55IC0geCAqIGR5ICsgeSAqIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKGQyICsgYTIgLSBiMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYTIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBhLnggKyB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBhLnkgKyB4ICogZHkgKyB5ICogZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGMueCA9IGEueCArIGMucjtcbiAgICBjLnkgPSBhLnk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gIHZhciBkciA9IGEuciArIGIuciAtIDFlLTYsIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyID4gMCAmJiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIHNjb3JlKG5vZGUpIHtcbiAgdmFyIGEgPSBub2RlLl8sXG4gICAgICBiID0gbm9kZS5uZXh0Ll8sXG4gICAgICBhYiA9IGEuciArIGIucixcbiAgICAgIGR4ID0gKGEueCAqIGIuciArIGIueCAqIGEucikgLyBhYixcbiAgICAgIGR5ID0gKGEueSAqIGIuciArIGIueSAqIGEucikgLyBhYjtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBOb2RlJDEoY2lyY2xlKSB7XG4gIHRoaXMuXyA9IGNpcmNsZTtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhY2tFbmNsb3NlKGNpcmNsZXMpIHtcbiAgaWYgKCEobiA9IGNpcmNsZXMubGVuZ3RoKSkgcmV0dXJuIDA7XG5cbiAgdmFyIGEsIGIsIGMsIG4sIGFhLCBjYSwgaSwgaiwgaywgc2osIHNrO1xuXG4gIC8vIFBsYWNlIHRoZSBmaXJzdCBjaXJjbGUuXG4gIGEgPSBjaXJjbGVzWzBdLCBhLnggPSAwLCBhLnkgPSAwO1xuICBpZiAoIShuID4gMSkpIHJldHVybiBhLnI7XG5cbiAgLy8gUGxhY2UgdGhlIHNlY29uZCBjaXJjbGUuXG4gIGIgPSBjaXJjbGVzWzFdLCBhLnggPSAtYi5yLCBiLnggPSBhLnIsIGIueSA9IDA7XG4gIGlmICghKG4gPiAyKSkgcmV0dXJuIGEuciArIGIucjtcblxuICAvLyBQbGFjZSB0aGUgdGhpcmQgY2lyY2xlLlxuICBwbGFjZShiLCBhLCBjID0gY2lyY2xlc1syXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgZnJvbnQtY2hhaW4gdXNpbmcgdGhlIGZpcnN0IHRocmVlIGNpcmNsZXMgYSwgYiBhbmQgYy5cbiAgYSA9IG5ldyBOb2RlJDEoYSksIGIgPSBuZXcgTm9kZSQxKGIpLCBjID0gbmV3IE5vZGUkMShjKTtcbiAgYS5uZXh0ID0gYy5wcmV2aW91cyA9IGI7XG4gIGIubmV4dCA9IGEucHJldmlvdXMgPSBjO1xuICBjLm5leHQgPSBiLnByZXZpb3VzID0gYTtcblxuICAvLyBBdHRlbXB0IHRvIHBsYWNlIGVhY2ggcmVtYWluaW5nIGNpcmNsZeKAplxuICBwYWNrOiBmb3IgKGkgPSAzOyBpIDwgbjsgKytpKSB7XG4gICAgcGxhY2UoYS5fLCBiLl8sIGMgPSBjaXJjbGVzW2ldKSwgYyA9IG5ldyBOb2RlJDEoYyk7XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGludGVyc2VjdGluZyBjaXJjbGUgb24gdGhlIGZyb250LWNoYWluLCBpZiBhbnkuXG4gICAgLy8g4oCcQ2xvc2VuZXNz4oCdIGlzIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlIGFsb25nIHRoZSBmcm9udC1jaGFpbi5cbiAgICAvLyDigJxBaGVhZOKAnSBvciDigJxiZWhpbmTigJ0gaXMgbGlrZXdpc2UgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UuXG4gICAgaiA9IGIubmV4dCwgayA9IGEucHJldmlvdXMsIHNqID0gYi5fLnIsIHNrID0gYS5fLnI7XG4gICAgZG8ge1xuICAgICAgaWYgKHNqIDw9IHNrKSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGouXywgYy5fKSkge1xuICAgICAgICAgIGIgPSBqLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2ogKz0gai5fLnIsIGogPSBqLm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW50ZXJzZWN0cyhrLl8sIGMuXykpIHtcbiAgICAgICAgICBhID0gaywgYS5uZXh0ID0gYiwgYi5wcmV2aW91cyA9IGEsIC0taTtcbiAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICB9XG4gICAgICAgIHNrICs9IGsuXy5yLCBrID0gay5wcmV2aW91cztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChqICE9PSBrLm5leHQpO1xuXG4gICAgLy8gU3VjY2VzcyEgSW5zZXJ0IHRoZSBuZXcgY2lyY2xlIGMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGMucHJldmlvdXMgPSBhLCBjLm5leHQgPSBiLCBhLm5leHQgPSBiLnByZXZpb3VzID0gYiA9IGM7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXcgY2xvc2VzdCBjaXJjbGUgcGFpciB0byB0aGUgY2VudHJvaWQuXG4gICAgYWEgPSBzY29yZShhKTtcbiAgICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XG4gICAgICBpZiAoKGNhID0gc2NvcmUoYykpIDwgYWEpIHtcbiAgICAgICAgYSA9IGMsIGFhID0gY2E7XG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBhLm5leHQ7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBlbmNsb3NpbmcgY2lyY2xlIG9mIHRoZSBmcm9udCBjaGFpbi5cbiAgYSA9IFtiLl9dLCBjID0gYjsgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikgYS5wdXNoKGMuXyk7IGMgPSBlbmNsb3NlKGEpO1xuXG4gIC8vIFRyYW5zbGF0ZSB0aGUgY2lyY2xlcyB0byBwdXQgdGhlIGVuY2xvc2luZyBjaXJjbGUgYXJvdW5kIHRoZSBvcmlnaW4uXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGEgPSBjaXJjbGVzW2ldLCBhLnggLT0gYy54LCBhLnkgLT0gYy55O1xuXG4gIHJldHVybiBjLnI7XG59XG5cbmZ1bmN0aW9uIHNpYmxpbmdzKGNpcmNsZXMpIHtcbiAgcGFja0VuY2xvc2UoY2lyY2xlcyk7XG4gIHJldHVybiBjaXJjbGVzO1xufVxuXG5mdW5jdGlvbiBvcHRpb25hbChmKSB7XG4gIHJldHVybiBmID09IG51bGwgPyBudWxsIDogcmVxdWlyZWQoZik7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkKGYpIHtcbiAgaWYgKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50WmVybygpIHtcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmFkaXVzKGQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgoKSB7XG4gIHZhciByYWRpdXMgPSBudWxsLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZyA9IGNvbnN0YW50WmVybztcblxuICBmdW5jdGlvbiBwYWNrKHJvb3QpIHtcbiAgICByb290LnggPSBkeCAvIDIsIHJvb3QueSA9IGR5IC8gMjtcbiAgICBpZiAocmFkaXVzKSB7XG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihyYWRpdXMpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIDAuNSkpXG4gICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmVhY2hCZWZvcmUocmFkaXVzTGVhZihkZWZhdWx0UmFkaXVzKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihjb25zdGFudFplcm8sIDEpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIHJvb3QuciAvIE1hdGgubWluKGR4LCBkeSkpKVxuICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKE1hdGgubWluKGR4LCBkeSkgLyAoMiAqIHJvb3QucikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBwYWNrLnJhZGl1cyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSBvcHRpb25hbCh4KSwgcGFjaykgOiByYWRpdXM7XG4gIH07XG5cbiAgcGFjay5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhY2spIDogW2R4LCBkeV07XG4gIH07XG5cbiAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgcGFjaykgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYWNrO1xufVxuXG5mdW5jdGlvbiByYWRpdXNMZWFmKHJhZGl1cykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5yID0gTWF0aC5tYXgoMCwgK3JhZGl1cyhub2RlKSB8fCAwKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhY2tDaGlsZHJlbihwYWRkaW5nLCBrKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkcmVuLFxuICAgICAgICAgIGksXG4gICAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICByID0gcGFkZGluZyhub2RlKSAqIGsgfHwgMCxcbiAgICAgICAgICBlO1xuXG4gICAgICBpZiAocikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hpbGRyZW5baV0uciArPSByO1xuICAgICAgZSA9IHBhY2tFbmNsb3NlKGNoaWxkcmVuKTtcbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yIC09IHI7XG4gICAgICBub2RlLnIgPSBlICsgcjtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUNoaWxkKGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgbm9kZS5yICo9IGs7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbm9kZS54ID0gcGFyZW50LnggKyBrICogbm9kZS54O1xuICAgICAgbm9kZS55ID0gcGFyZW50LnkgKyBrICogbm9kZS55O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcm91bmROb2RlKG5vZGUpIHtcbiAgbm9kZS54MCA9IE1hdGgucm91bmQobm9kZS54MCk7XG4gIG5vZGUueTAgPSBNYXRoLnJvdW5kKG5vZGUueTApO1xuICBub2RlLngxID0gTWF0aC5yb3VuZChub2RlLngxKTtcbiAgbm9kZS55MSA9IE1hdGgucm91bmQobm9kZS55MSk7XG59XG5cbmZ1bmN0aW9uIHRyZWVtYXBEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh4MSAtIHgwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTE7XG4gICAgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFydGl0aW9uKCkge1xuICB2YXIgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZyA9IDAsXG4gICAgICByb3VuZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihyb290KSB7XG4gICAgdmFyIG4gPSByb290LmhlaWdodCArIDE7XG4gICAgcm9vdC54MCA9XG4gICAgcm9vdC55MCA9IHBhZGRpbmc7XG4gICAgcm9vdC54MSA9IGR4O1xuICAgIHJvb3QueTEgPSBkeSAvIG47XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZShkeSwgbikpO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUoZHksIG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdHJlZW1hcERpY2Uobm9kZSwgbm9kZS54MCwgZHkgKiAobm9kZS5kZXB0aCArIDEpIC8gbiwgbm9kZS54MSwgZHkgKiAobm9kZS5kZXB0aCArIDIpIC8gbik7XG4gICAgICB9XG4gICAgICB2YXIgeDAgPSBub2RlLngwLFxuICAgICAgICAgIHkwID0gbm9kZS55MCxcbiAgICAgICAgICB4MSA9IG5vZGUueDEgLSBwYWRkaW5nLFxuICAgICAgICAgIHkxID0gbm9kZS55MSAtIHBhZGRpbmc7XG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBub2RlLngwID0geDA7XG4gICAgICBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDE7XG4gICAgICBub2RlLnkxID0geTE7XG4gICAgfTtcbiAgfVxuXG4gIHBhcnRpdGlvbi5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEheCwgcGFydGl0aW9uKSA6IHJvdW5kO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhcnRpdGlvbikgOiBbZHgsIGR5XTtcbiAgfTtcblxuICBwYXJ0aXRpb24ucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gK3gsIHBhcnRpdGlvbikgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYXJ0aXRpb247XG59XG5cbnZhciBrZXlQcmVmaXggPSBcIiRcIiwgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG4gICAgcHJlcm9vdCA9IHtkZXB0aDogLTF9LFxuICAgIGFtYmlndW91cyA9IHt9O1xuXG5mdW5jdGlvbiBkZWZhdWx0SWQoZCkge1xuICByZXR1cm4gZC5pZDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcmVudElkKGQpIHtcbiAgcmV0dXJuIGQucGFyZW50SWQ7XG59XG5cbmZ1bmN0aW9uIHN0cmF0aWZ5KCkge1xuICB2YXIgaWQgPSBkZWZhdWx0SWQsXG4gICAgICBwYXJlbnRJZCA9IGRlZmF1bHRQYXJlbnRJZDtcblxuICBmdW5jdGlvbiBzdHJhdGlmeShkYXRhKSB7XG4gICAgdmFyIGQsXG4gICAgICAgIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgbm9kZUlkLFxuICAgICAgICBub2RlS2V5LFxuICAgICAgICBub2RlQnlLZXkgPSB7fTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGQgPSBkYXRhW2ldLCBub2RlID0gbm9kZXNbaV0gPSBuZXcgTm9kZShkKTtcbiAgICAgIGlmICgobm9kZUlkID0gaWQoZCwgaSwgZGF0YSkpICE9IG51bGwgJiYgKG5vZGVJZCArPSBcIlwiKSkge1xuICAgICAgICBub2RlS2V5ID0ga2V5UHJlZml4ICsgKG5vZGUuaWQgPSBub2RlSWQpO1xuICAgICAgICBub2RlQnlLZXlbbm9kZUtleV0gPSBub2RlS2V5IGluIG5vZGVCeUtleSA/IGFtYmlndW91cyA6IG5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlSWQgPSBwYXJlbnRJZChkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICAgIGlmIChub2RlSWQgPT0gbnVsbCB8fCAhKG5vZGVJZCArPSBcIlwiKSkge1xuICAgICAgICBpZiAocm9vdCkgdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgcm9vdHNcIik7XG4gICAgICAgIHJvb3QgPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gbm9kZUJ5S2V5W2tleVByZWZpeCArIG5vZGVJZF07XG4gICAgICAgIGlmICghcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nOiBcIiArIG5vZGVJZCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGFtYmlndW91cykgdGhyb3cgbmV3IEVycm9yKFwiYW1iaWd1b3VzOiBcIiArIG5vZGVJZCk7XG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBlbHNlIHBhcmVudC5jaGlsZHJlbiA9IFtub2RlXTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJubyByb290XCIpO1xuICAgIHJvb3QucGFyZW50ID0gcHJlcm9vdDtcbiAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkgeyBub2RlLmRlcHRoID0gbm9kZS5wYXJlbnQuZGVwdGggKyAxOyAtLW47IH0pLmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG4gICAgcm9vdC5wYXJlbnQgPSBudWxsO1xuICAgIGlmIChuID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiY3ljbGVcIik7XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIHN0cmF0aWZ5LmlkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IGlkO1xuICB9O1xuXG4gIHN0cmF0aWZ5LnBhcmVudElkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhcmVudElkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IHBhcmVudElkO1xuICB9O1xuXG4gIHJldHVybiBzdHJhdGlmeTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24kMShhLCBiKSB7XG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbn1cblxuLy8gZnVuY3Rpb24gcmFkaWFsU2VwYXJhdGlvbihhLCBiKSB7XG4vLyAgIHJldHVybiAoYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDIpIC8gYS5kZXB0aDtcbi8vIH1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlIChvclxuLy8gc3ViZm9yZXN0KS4gSXQgcmV0dXJucyB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyLiBUaGlzIHN1Y2Nlc3NvciBpc1xuLy8gZWl0aGVyIGdpdmVuIGJ5IHRoZSBsZWZ0bW9zdCBjaGlsZCBvZiB2IG9yIGJ5IHRoZSB0aHJlYWQgb2Ygdi4gVGhlIGZ1bmN0aW9uXG4vLyByZXR1cm5zIG51bGwgaWYgYW5kIG9ubHkgaWYgdiBpcyBvbiB0aGUgaGlnaGVzdCBsZXZlbCBvZiBpdHMgc3VidHJlZS5cbmZ1bmN0aW9uIG5leHRMZWZ0KHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuID8gY2hpbGRyZW5bMF0gOiB2LnQ7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd29ya3MgYW5hbG9nb3VzbHkgdG8gbmV4dExlZnQuXG5mdW5jdGlvbiBuZXh0UmlnaHQodikge1xuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSA6IHYudDtcbn1cblxuLy8gU2hpZnRzIHRoZSBjdXJyZW50IHN1YnRyZWUgcm9vdGVkIGF0IHcrLiBUaGlzIGlzIGRvbmUgYnkgaW5jcmVhc2luZ1xuLy8gcHJlbGltKHcrKSBhbmQgbW9kKHcrKSBieSBzaGlmdC5cbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHdtLCB3cCwgc2hpZnQpIHtcbiAgdmFyIGNoYW5nZSA9IHNoaWZ0IC8gKHdwLmkgLSB3bS5pKTtcbiAgd3AuYyAtPSBjaGFuZ2U7XG4gIHdwLnMgKz0gc2hpZnQ7XG4gIHdtLmMgKz0gY2hhbmdlO1xuICB3cC56ICs9IHNoaWZ0O1xuICB3cC5tICs9IHNoaWZ0O1xufVxuXG4vLyBBbGwgb3RoZXIgc2hpZnRzLCBhcHBsaWVkIHRvIHRoZSBzbWFsbGVyIHN1YnRyZWVzIGJldHdlZW4gdy0gYW5kIHcrLCBhcmVcbi8vIHBlcmZvcm1lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBwcmVwYXJlIHRoZSBzaGlmdHMsIHdlIGhhdmUgdG8gYWRqdXN0XG4vLyBjaGFuZ2UodyspLCBzaGlmdCh3KyksIGFuZCBjaGFuZ2Uody0pLlxuZnVuY3Rpb24gZXhlY3V0ZVNoaWZ0cyh2KSB7XG4gIHZhciBzaGlmdCA9IDAsXG4gICAgICBjaGFuZ2UgPSAwLFxuICAgICAgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxuICAgICAgaSA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIHc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIHcgPSBjaGlsZHJlbltpXTtcbiAgICB3LnogKz0gc2hpZnQ7XG4gICAgdy5tICs9IHNoaWZ0O1xuICAgIHNoaWZ0ICs9IHcucyArIChjaGFuZ2UgKz0gdy5jKTtcbiAgfVxufVxuXG4vLyBJZiB2aS3igJlzIGFuY2VzdG9yIGlzIGEgc2libGluZyBvZiB2LCByZXR1cm5zIHZpLeKAmXMgYW5jZXN0b3IuIE90aGVyd2lzZSxcbi8vIHJldHVybnMgdGhlIHNwZWNpZmllZCAoZGVmYXVsdCkgYW5jZXN0b3IuXG5mdW5jdGlvbiBuZXh0QW5jZXN0b3IodmltLCB2LCBhbmNlc3Rvcikge1xuICByZXR1cm4gdmltLmEucGFyZW50ID09PSB2LnBhcmVudCA/IHZpbS5hIDogYW5jZXN0b3I7XG59XG5cbmZ1bmN0aW9uIFRyZWVOb2RlKG5vZGUsIGkpIHtcbiAgdGhpcy5fID0gbm9kZTtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5BID0gbnVsbDsgLy8gZGVmYXVsdCBhbmNlc3RvclxuICB0aGlzLmEgPSB0aGlzOyAvLyBhbmNlc3RvclxuICB0aGlzLnogPSAwOyAvLyBwcmVsaW1cbiAgdGhpcy5tID0gMDsgLy8gbW9kXG4gIHRoaXMuYyA9IDA7IC8vIGNoYW5nZVxuICB0aGlzLnMgPSAwOyAvLyBzaGlmdFxuICB0aGlzLnQgPSBudWxsOyAvLyB0aHJlYWRcbiAgdGhpcy5pID0gaTsgLy8gbnVtYmVyXG59XG5cblRyZWVOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiB0cmVlUm9vdChyb290KSB7XG4gIHZhciB0cmVlID0gbmV3IFRyZWVOb2RlKHJvb3QsIDApLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVzID0gW3RyZWVdLFxuICAgICAgY2hpbGQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLl8uY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobiA9IGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV0gPSBuZXcgVHJlZU5vZGUoY2hpbGRyZW5baV0sIGkpKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAodHJlZS5wYXJlbnQgPSBuZXcgVHJlZU5vZGUobnVsbCwgMCkpLmNoaWxkcmVuID0gW3RyZWVdO1xuICByZXR1cm4gdHJlZTtcbn1cblxuLy8gTm9kZS1saW5rIHRyZWUgZGlhZ3JhbSB1c2luZyB0aGUgUmVpbmdvbGQtVGlsZm9yZCBcInRpZHlcIiBhbGdvcml0aG1cbmZ1bmN0aW9uIHRyZWUoKSB7XG4gIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24kMSxcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIG5vZGVTaXplID0gbnVsbDtcblxuICBmdW5jdGlvbiB0cmVlKHJvb3QpIHtcbiAgICB2YXIgdCA9IHRyZWVSb290KHJvb3QpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGF5b3V0IHVzaW5nIEJ1Y2hoZWltIGV0IGFsLuKAmXMgYWxnb3JpdGhtLlxuICAgIHQuZWFjaEFmdGVyKGZpcnN0V2FsayksIHQucGFyZW50Lm0gPSAtdC56O1xuICAgIHQuZWFjaEJlZm9yZShzZWNvbmRXYWxrKTtcblxuICAgIC8vIElmIGEgZml4ZWQgbm9kZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeS5cbiAgICBpZiAobm9kZVNpemUpIHJvb3QuZWFjaEJlZm9yZShzaXplTm9kZSk7XG5cbiAgICAvLyBJZiBhIGZpeGVkIHRyZWUgc2l6ZSBpcyBzcGVjaWZpZWQsIHNjYWxlIHggYW5kIHkgYmFzZWQgb24gdGhlIGV4dGVudC5cbiAgICAvLyBDb21wdXRlIHRoZSBsZWZ0LW1vc3QsIHJpZ2h0LW1vc3QsIGFuZCBkZXB0aC1tb3N0IG5vZGVzIGZvciBleHRlbnRzLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGxlZnQgPSByb290LFxuICAgICAgICAgIHJpZ2h0ID0gcm9vdCxcbiAgICAgICAgICBib3R0b20gPSByb290O1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueCkgbGVmdCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLnggPiByaWdodC54KSByaWdodCA9IG5vZGU7XG4gICAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tLmRlcHRoKSBib3R0b20gPSBub2RlO1xuICAgICAgfSk7XG4gICAgICB2YXIgcyA9IGxlZnQgPT09IHJpZ2h0ID8gMSA6IHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcbiAgICAgICAgICB0eCA9IHMgLSBsZWZ0LngsXG4gICAgICAgICAga3ggPSBkeCAvIChyaWdodC54ICsgcyArIHR4KSxcbiAgICAgICAgICBreSA9IGR5IC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggKyB0eCkgKiBreDtcbiAgICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGt5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICAvLyBDb21wdXRlcyBhIHByZWxpbWluYXJ5IHgtY29vcmRpbmF0ZSBmb3Igdi4gQmVmb3JlIHRoYXQsIEZJUlNUIFdBTEsgaXNcbiAgLy8gYXBwbGllZCByZWN1cnNpdmVseSB0byB0aGUgY2hpbGRyZW4gb2YgdiwgYXMgd2VsbCBhcyB0aGUgZnVuY3Rpb25cbiAgLy8gQVBQT1JUSU9OLiBBZnRlciBzcGFjaW5nIG91dCB0aGUgY2hpbGRyZW4gYnkgY2FsbGluZyBFWEVDVVRFIFNISUZUUywgdGhlXG4gIC8vIG5vZGUgdiBpcyBwbGFjZWQgdG8gdGhlIG1pZHBvaW50IG9mIGl0cyBvdXRlcm1vc3QgY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIGZpcnN0V2Fsayh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcbiAgICAgICAgc2libGluZ3MgPSB2LnBhcmVudC5jaGlsZHJlbixcbiAgICAgICAgdyA9IHYuaSA/IHNpYmxpbmdzW3YuaSAtIDFdIDogbnVsbDtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGV4ZWN1dGVTaGlmdHModik7XG4gICAgICB2YXIgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ueiArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnopIC8gMjtcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgICB2Lm0gPSB2LnogLSBtaWRwb2ludDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYueiA9IG1pZHBvaW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodykge1xuICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgfVxuICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gIH1cblxuICAvLyBDb21wdXRlcyBhbGwgcmVhbCB4LWNvb3JkaW5hdGVzIGJ5IHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyByZWN1cnNpdmVseS5cbiAgZnVuY3Rpb24gc2Vjb25kV2Fsayh2KSB7XG4gICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgIHYubSArPSB2LnBhcmVudC5tO1xuICB9XG5cbiAgLy8gVGhlIGNvcmUgb2YgdGhlIGFsZ29yaXRobS4gSGVyZSwgYSBuZXcgc3VidHJlZSBpcyBjb21iaW5lZCB3aXRoIHRoZVxuICAvLyBwcmV2aW91cyBzdWJ0cmVlcy4gVGhyZWFkcyBhcmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgaW5zaWRlIGFuZCBvdXRzaWRlXG4gIC8vIGNvbnRvdXJzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlIHVwIHRvIHRoZSBoaWdoZXN0IGNvbW1vbiBsZXZlbC4gVGhlXG4gIC8vIHZlcnRpY2VzIHVzZWQgZm9yIHRoZSB0cmF2ZXJzYWxzIGFyZSB2aSssIHZpLSwgdm8tLCBhbmQgdm8rLCB3aGVyZSB0aGVcbiAgLy8gc3VwZXJzY3JpcHQgbyBtZWFucyBvdXRzaWRlIGFuZCBpIG1lYW5zIGluc2lkZSwgdGhlIHN1YnNjcmlwdCAtIG1lYW5zIGxlZnRcbiAgLy8gc3VidHJlZSBhbmQgKyBtZWFucyByaWdodCBzdWJ0cmVlLiBGb3Igc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIGFsb25nIHRoZVxuICAvLyBjb250b3VyLCB3ZSB1c2UgcmVzcGVjdGl2ZSB2YXJpYWJsZXMgc2krLCBzaS0sIHNvLSwgYW5kIHNvKy4gV2hlbmV2ZXIgdHdvXG4gIC8vIG5vZGVzIG9mIHRoZSBpbnNpZGUgY29udG91cnMgY29uZmxpY3QsIHdlIGNvbXB1dGUgdGhlIGxlZnQgb25lIG9mIHRoZVxuICAvLyBncmVhdGVzdCB1bmNvbW1vbiBhbmNlc3RvcnMgdXNpbmcgdGhlIGZ1bmN0aW9uIEFOQ0VTVE9SIGFuZCBjYWxsIE1PVkVcbiAgLy8gU1VCVFJFRSB0byBzaGlmdCB0aGUgc3VidHJlZSBhbmQgcHJlcGFyZSB0aGUgc2hpZnRzIG9mIHNtYWxsZXIgc3VidHJlZXMuXG4gIC8vIEZpbmFsbHksIHdlIGFkZCBhIG5ldyB0aHJlYWQgKGlmIG5lY2Vzc2FyeSkuXG4gIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgIGlmICh3KSB7XG4gICAgICB2YXIgdmlwID0gdixcbiAgICAgICAgICB2b3AgPSB2LFxuICAgICAgICAgIHZpbSA9IHcsXG4gICAgICAgICAgdm9tID0gdmlwLnBhcmVudC5jaGlsZHJlblswXSxcbiAgICAgICAgICBzaXAgPSB2aXAubSxcbiAgICAgICAgICBzb3AgPSB2b3AubSxcbiAgICAgICAgICBzaW0gPSB2aW0ubSxcbiAgICAgICAgICBzb20gPSB2b20ubSxcbiAgICAgICAgICBzaGlmdDtcbiAgICAgIHdoaWxlICh2aW0gPSBuZXh0UmlnaHQodmltKSwgdmlwID0gbmV4dExlZnQodmlwKSwgdmltICYmIHZpcCkge1xuICAgICAgICB2b20gPSBuZXh0TGVmdCh2b20pO1xuICAgICAgICB2b3AgPSBuZXh0UmlnaHQodm9wKTtcbiAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICBzaGlmdCA9IHZpbS56ICsgc2ltIC0gdmlwLnogLSBzaXAgKyBzZXBhcmF0aW9uKHZpbS5fLCB2aXAuXyk7XG4gICAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgICBtb3ZlU3VidHJlZShuZXh0QW5jZXN0b3IodmltLCB2LCBhbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICB9XG4gICAgICAgIHNpbSArPSB2aW0ubTtcbiAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICBzb20gKz0gdm9tLm07XG4gICAgICAgIHNvcCArPSB2b3AubTtcbiAgICAgIH1cbiAgICAgIGlmICh2aW0gJiYgIW5leHRSaWdodCh2b3ApKSB7XG4gICAgICAgIHZvcC50ID0gdmltO1xuICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XG4gICAgICB9XG4gICAgICBpZiAodmlwICYmICFuZXh0TGVmdCh2b20pKSB7XG4gICAgICAgIHZvbS50ID0gdmlwO1xuICAgICAgICB2b20ubSArPSBzaXAgLSBzb207XG4gICAgICAgIGFuY2VzdG9yID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gc2l6ZU5vZGUobm9kZSkge1xuICAgIG5vZGUueCAqPSBkeDtcbiAgICBub2RlLnkgPSBub2RlLmRlcHRoICogZHk7XG4gIH1cblxuICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2VwYXJhdGlvbiA9IHgsIHRyZWUpIDogc2VwYXJhdGlvbjtcbiAgfTtcblxuICB0cmVlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZSkgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xuICB9O1xuXG4gIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIHRyZWU7XG59XG5cbmZ1bmN0aW9uIHRyZWVtYXBTbGljZShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIG5vZGUsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeTEgLSB5MCkgLyBwYXJlbnQudmFsdWU7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkwICs9IG5vZGUudmFsdWUgKiBrO1xuICB9XG59XG5cbnZhciBwaGkgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyO1xuXG5mdW5jdGlvbiBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciByb3dzID0gW10sXG4gICAgICBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIHJvdyxcbiAgICAgIG5vZGVWYWx1ZSxcbiAgICAgIGkwID0gMCxcbiAgICAgIGkxID0gMCxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBkeCwgZHksXG4gICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZSxcbiAgICAgIHN1bVZhbHVlLFxuICAgICAgbWluVmFsdWUsXG4gICAgICBtYXhWYWx1ZSxcbiAgICAgIG5ld1JhdGlvLFxuICAgICAgbWluUmF0aW8sXG4gICAgICBhbHBoYSxcbiAgICAgIGJldGE7XG5cbiAgd2hpbGUgKGkwIDwgbikge1xuICAgIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwO1xuXG4gICAgLy8gRmluZCB0aGUgbmV4dCBub24tZW1wdHkgbm9kZS5cbiAgICBkbyBzdW1WYWx1ZSA9IG5vZGVzW2kxKytdLnZhbHVlOyB3aGlsZSAoIXN1bVZhbHVlICYmIGkxIDwgbik7XG4gICAgbWluVmFsdWUgPSBtYXhWYWx1ZSA9IHN1bVZhbHVlO1xuICAgIGFscGhhID0gTWF0aC5tYXgoZHkgLyBkeCwgZHggLyBkeSkgLyAodmFsdWUgKiByYXRpbyk7XG4gICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICBtaW5SYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcblxuICAgIC8vIEtlZXAgYWRkaW5nIG5vZGVzIHdoaWxlIHRoZSBhc3BlY3QgcmF0aW8gbWFpbnRhaW5zIG9yIGltcHJvdmVzLlxuICAgIGZvciAoOyBpMSA8IG47ICsraTEpIHtcbiAgICAgIHN1bVZhbHVlICs9IG5vZGVWYWx1ZSA9IG5vZGVzW2kxXS52YWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPCBtaW5WYWx1ZSkgbWluVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBpZiAobm9kZVZhbHVlID4gbWF4VmFsdWUpIG1heFZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuICAgICAgaWYgKG5ld1JhdGlvID4gbWluUmF0aW8pIHsgc3VtVmFsdWUgLT0gbm9kZVZhbHVlOyBicmVhazsgfVxuICAgICAgbWluUmF0aW8gPSBuZXdSYXRpbztcbiAgICB9XG5cbiAgICAvLyBQb3NpdGlvbiBhbmQgcmVjb3JkIHRoZSByb3cgb3JpZW50YXRpb24uXG4gICAgcm93cy5wdXNoKHJvdyA9IHt2YWx1ZTogc3VtVmFsdWUsIGRpY2U6IGR4IDwgZHksIGNoaWxkcmVuOiBub2Rlcy5zbGljZShpMCwgaTEpfSk7XG4gICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHZhbHVlID8geTAgKz0gZHkgKiBzdW1WYWx1ZSAvIHZhbHVlIDogeTEpO1xuICAgIGVsc2UgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB2YWx1ZSA/IHgwICs9IGR4ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHgxLCB5MSk7XG4gICAgdmFsdWUgLT0gc3VtVmFsdWUsIGkwID0gaTE7XG4gIH1cblxuICByZXR1cm4gcm93cztcbn1cblxudmFyIHNxdWFyaWZ5ID0gKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuXG4gIGZ1bmN0aW9uIHNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuXG4gIHNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICB9O1xuXG4gIHJldHVybiBzcXVhcmlmeTtcbn0pKHBoaSk7XG5cbmZ1bmN0aW9uIGluZGV4JDEoKSB7XG4gIHZhciB0aWxlID0gc3F1YXJpZnksXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZ1N0YWNrID0gWzBdLFxuICAgICAgcGFkZGluZ0lubmVyID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1RvcCA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdSaWdodCA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdCb3R0b20gPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nTGVmdCA9IGNvbnN0YW50WmVybztcblxuICBmdW5jdGlvbiB0cmVlbWFwKHJvb3QpIHtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gMDtcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5O1xuICAgIHJvb3QuZWFjaEJlZm9yZShwb3NpdGlvbk5vZGUpO1xuICAgIHBhZGRpbmdTdGFjayA9IFswXTtcbiAgICBpZiAocm91bmQpIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Ob2RlKG5vZGUpIHtcbiAgICB2YXIgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoXSxcbiAgICAgICAgeDAgPSBub2RlLngwICsgcCxcbiAgICAgICAgeTAgPSBub2RlLnkwICsgcCxcbiAgICAgICAgeDEgPSBub2RlLngxIC0gcCxcbiAgICAgICAgeTEgPSBub2RlLnkxIC0gcDtcbiAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgIG5vZGUueDAgPSB4MDtcbiAgICBub2RlLnkwID0geTA7XG4gICAgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTEgPSB5MTtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoICsgMV0gPSBwYWRkaW5nSW5uZXIobm9kZSkgLyAyO1xuICAgICAgeDAgKz0gcGFkZGluZ0xlZnQobm9kZSkgLSBwO1xuICAgICAgeTAgKz0gcGFkZGluZ1RvcChub2RlKSAtIHA7XG4gICAgICB4MSAtPSBwYWRkaW5nUmlnaHQobm9kZSkgLSBwO1xuICAgICAgeTEgLT0gcGFkZGluZ0JvdHRvbShub2RlKSAtIHA7XG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICB0aWxlKG5vZGUsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICB9XG4gIH1cblxuICB0cmVlbWFwLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCB0cmVlbWFwKSA6IHJvdW5kO1xuICB9O1xuXG4gIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlbWFwKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHRyZWVtYXAudGlsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWxlID0gcmVxdWlyZWQoeCksIHRyZWVtYXApIDogdGlsZTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdJbm5lcih4KS5wYWRkaW5nT3V0ZXIoeCkgOiB0cmVlbWFwLnBhZGRpbmdJbm5lcigpO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ1RvcCh4KS5wYWRkaW5nUmlnaHQoeCkucGFkZGluZ0JvdHRvbSh4KS5wYWRkaW5nTGVmdCh4KSA6IHRyZWVtYXAucGFkZGluZ1RvcCgpO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ1RvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nVG9wID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1RvcDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdSaWdodCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nUmlnaHQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nUmlnaHQ7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nQm90dG9tID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdCb3R0b20gPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nQm90dG9tO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0xlZnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0xlZnQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nTGVmdDtcbiAgfTtcblxuICByZXR1cm4gdHJlZW1hcDtcbn1cblxuZnVuY3Rpb24gYmluYXJ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIHN1bSwgc3VtcyA9IG5ldyBBcnJheShuICsgMSk7XG5cbiAgZm9yIChzdW1zWzBdID0gc3VtID0gaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzdW1zW2kgKyAxXSA9IHN1bSArPSBub2Rlc1tpXS52YWx1ZTtcbiAgfVxuXG4gIHBhcnRpdGlvbigwLCBuLCBwYXJlbnQudmFsdWUsIHgwLCB5MCwgeDEsIHkxKTtcblxuICBmdW5jdGlvbiBwYXJ0aXRpb24oaSwgaiwgdmFsdWUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgaWYgKGkgPj0gaiAtIDEpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBub2RlLngwID0geDAsIG5vZGUueTAgPSB5MDtcbiAgICAgIG5vZGUueDEgPSB4MSwgbm9kZS55MSA9IHkxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZU9mZnNldCA9IHN1bXNbaV0sXG4gICAgICAgIHZhbHVlVGFyZ2V0ID0gKHZhbHVlIC8gMikgKyB2YWx1ZU9mZnNldCxcbiAgICAgICAgayA9IGkgKyAxLFxuICAgICAgICBoaSA9IGogLSAxO1xuXG4gICAgd2hpbGUgKGsgPCBoaSkge1xuICAgICAgdmFyIG1pZCA9IGsgKyBoaSA+Pj4gMTtcbiAgICAgIGlmIChzdW1zW21pZF0gPCB2YWx1ZVRhcmdldCkgayA9IG1pZCArIDE7XG4gICAgICBlbHNlIGhpID0gbWlkO1xuICAgIH1cblxuICAgIGlmICgodmFsdWVUYXJnZXQgLSBzdW1zW2sgLSAxXSkgPCAoc3Vtc1trXSAtIHZhbHVlVGFyZ2V0KSAmJiBpICsgMSA8IGspIC0taztcblxuICAgIHZhciB2YWx1ZUxlZnQgPSBzdW1zW2tdIC0gdmFsdWVPZmZzZXQsXG4gICAgICAgIHZhbHVlUmlnaHQgPSB2YWx1ZSAtIHZhbHVlTGVmdDtcblxuICAgIGlmICgoeDEgLSB4MCkgPiAoeTEgLSB5MCkpIHtcbiAgICAgIHZhciB4ayA9ICh4MCAqIHZhbHVlUmlnaHQgKyB4MSAqIHZhbHVlTGVmdCkgLyB2YWx1ZTtcbiAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeGssIHkxKTtcbiAgICAgIHBhcnRpdGlvbihrLCBqLCB2YWx1ZVJpZ2h0LCB4aywgeTAsIHgxLCB5MSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5ayA9ICh5MCAqIHZhbHVlUmlnaHQgKyB5MSAqIHZhbHVlTGVmdCkgLyB2YWx1ZTtcbiAgICAgIHBhcnRpdGlvbihpLCBrLCB2YWx1ZUxlZnQsIHgwLCB5MCwgeDEsIHlrKTtcbiAgICAgIHBhcnRpdGlvbihrLCBqLCB2YWx1ZVJpZ2h0LCB4MCwgeWssIHgxLCB5MSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNsaWNlRGljZShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIChwYXJlbnQuZGVwdGggJiAxID8gdHJlZW1hcFNsaWNlIDogdHJlZW1hcERpY2UpKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xufVxuXG52YXIgcmVzcXVhcmlmeSA9IChmdW5jdGlvbiBjdXN0b20ocmF0aW8pIHtcblxuICBmdW5jdGlvbiByZXNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBpZiAoKHJvd3MgPSBwYXJlbnQuX3NxdWFyaWZ5KSAmJiAocm93cy5yYXRpbyA9PT0gcmF0aW8pKSB7XG4gICAgICB2YXIgcm93cyxcbiAgICAgICAgICByb3csXG4gICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBqID0gLTEsXG4gICAgICAgICAgbixcbiAgICAgICAgICBtID0gcm93cy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBwYXJlbnQudmFsdWU7XG5cbiAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgIHJvdyA9IHJvd3Nbal0sIG5vZGVzID0gcm93LmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGkgPSByb3cudmFsdWUgPSAwLCBuID0gbm9kZXMubGVuZ3RoOyBpIDwgbjsgKytpKSByb3cudmFsdWUgKz0gbm9kZXNbaV0udmFsdWU7XG4gICAgICAgIGlmIChyb3cuZGljZSkgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB5MCArPSAoeTEgLSB5MCkgKiByb3cudmFsdWUgLyB2YWx1ZSk7XG4gICAgICAgIGVsc2UgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB4MCArPSAoeDEgLSB4MCkgKiByb3cudmFsdWUgLyB2YWx1ZSwgeTEpO1xuICAgICAgICB2YWx1ZSAtPSByb3cudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5fc3F1YXJpZnkgPSByb3dzID0gc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgICByb3dzLnJhdGlvID0gcmF0aW87XG4gICAgfVxuICB9XG5cbiAgcmVzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY3VzdG9tKCh4ID0gK3gpID4gMSA/IHggOiAxKTtcbiAgfTtcblxuICByZXR1cm4gcmVzcXVhcmlmeTtcbn0pKHBoaSk7XG5cbmV4cG9ydHMuY2x1c3RlciA9IGNsdXN0ZXI7XG5leHBvcnRzLmhpZXJhcmNoeSA9IGhpZXJhcmNoeTtcbmV4cG9ydHMucGFjayA9IGluZGV4O1xuZXhwb3J0cy5wYWNrRW5jbG9zZSA9IGVuY2xvc2U7XG5leHBvcnRzLnBhY2tTaWJsaW5ncyA9IHNpYmxpbmdzO1xuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG5leHBvcnRzLnN0cmF0aWZ5ID0gc3RyYXRpZnk7XG5leHBvcnRzLnRyZWUgPSB0cmVlO1xuZXhwb3J0cy50cmVlbWFwID0gaW5kZXgkMTtcbmV4cG9ydHMudHJlZW1hcEJpbmFyeSA9IGJpbmFyeTtcbmV4cG9ydHMudHJlZW1hcERpY2UgPSB0cmVlbWFwRGljZTtcbmV4cG9ydHMudHJlZW1hcFJlc3F1YXJpZnkgPSByZXNxdWFyaWZ5O1xuZXhwb3J0cy50cmVlbWFwU2xpY2UgPSB0cmVlbWFwU2xpY2U7XG5leHBvcnRzLnRyZWVtYXBTbGljZURpY2UgPSBzbGljZURpY2U7XG5leHBvcnRzLnRyZWVtYXBTcXVhcmlmeSA9IHNxdWFyaWZ5O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWludGVycG9sYXRlLyB2MS40LjAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1jb2xvcicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30sIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNDb2xvcikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmZ1bmN0aW9uIGJhc2lzJDEodmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpc0Nsb3NlZCh2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5mbG9vcigoKHQgJT0gMSkgPCAwID8gKyt0IDogdCkgKiBuKSxcbiAgICAgICAgdjAgPSB2YWx1ZXNbKGkgKyBuIC0gMSkgJSBuXSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaSAlIG5dLFxuICAgICAgICB2MiA9IHZhbHVlc1soaSArIDEpICUgbl0sXG4gICAgICAgIHYzID0gdmFsdWVzWyhpICsgMikgJSBuXTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxudmFyIHJnYiA9IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBkM0NvbG9yLnJnYihzdGFydCkpLnIsIChlbmQgPSBkM0NvbG9yLnJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGQzQ29sb3IucmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbnZhciByZ2JCYXNpcyA9IHJnYlNwbGluZShiYXNpcyQxKTtcbnZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG5cbmZ1bmN0aW9uIG51bWJlckFycmF5KGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoeCkge1xuICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHgpICYmICEoeCBpbnN0YW5jZW9mIERhdGFWaWV3KTtcbn1cblxuZnVuY3Rpb24gYXJyYXkoYSwgYikge1xuICByZXR1cm4gKGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheSA6IGdlbmVyaWNBcnJheSkoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGdlbmVyaWNBcnJheShhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRhdGUoYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKiAoMSAtIHQpICsgYiAqIHQpLCBkO1xuICB9O1xufVxuXG5mdW5jdGlvbiBudW1iZXIoYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0KGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSB2YWx1ZShhW2tdLCBiW2tdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY1trXSA9IGJba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csXG4gICAgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHJpbmcoYSwgYikge1xuICB2YXIgYmkgPSByZUEubGFzdEluZGV4ID0gcmVCLmxhc3RJbmRleCA9IDAsIC8vIHNjYW4gaW5kZXggZm9yIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGFtLCAvLyBjdXJyZW50IG1hdGNoIGluIGFcbiAgICAgIGJtLCAvLyBjdXJyZW50IG1hdGNoIGluIGJcbiAgICAgIGJzLCAvLyBzdHJpbmcgcHJlY2VkaW5nIGN1cnJlbnQgbnVtYmVyIGluIGIsIGlmIGFueVxuICAgICAgaSA9IC0xLCAvLyBpbmRleCBpbiBzXG4gICAgICBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuXG4gIC8vIENvZXJjZSBpbnB1dHMgdG8gc3RyaW5ncy5cbiAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG5cbiAgLy8gSW50ZXJwb2xhdGUgcGFpcnMgb2YgbnVtYmVycyBpbiBhICYgYi5cbiAgd2hpbGUgKChhbSA9IHJlQS5leGVjKGEpKVxuICAgICAgJiYgKGJtID0gcmVCLmV4ZWMoYikpKSB7XG4gICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7IC8vIGEgc3RyaW5nIHByZWNlZGVzIHRoZSBuZXh0IG51bWJlciBpbiBiXG4gICAgICBicyA9IGIuc2xpY2UoYmksIGJzKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7IC8vIG51bWJlcnMgaW4gYSAmIGIgbWF0Y2hcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgICAgZWxzZSBzWysraV0gPSBibTtcbiAgICB9IGVsc2UgeyAvLyBpbnRlcnBvbGF0ZSBub24tbWF0Y2hpbmcgbnVtYmVyc1xuICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgIHEucHVzaCh7aTogaSwgeDogbnVtYmVyKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufVxuXG5mdW5jdGlvbiB2YWx1ZShhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gZDNDb2xvci5jb2xvcihiKSkgPyAoYiA9IGMsIHJnYikgOiBzdHJpbmcpXG4gICAgICA6IGIgaW5zdGFuY2VvZiBkM0NvbG9yLmNvbG9yID8gcmdiXG4gICAgICA6IGIgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZVxuICAgICAgOiBpc051bWJlckFycmF5KGIpID8gbnVtYmVyQXJyYXlcbiAgICAgIDogQXJyYXkuaXNBcnJheShiKSA/IGdlbmVyaWNBcnJheVxuICAgICAgOiB0eXBlb2YgYi52YWx1ZU9mICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGIudG9TdHJpbmcgIT09IFwiZnVuY3Rpb25cIiB8fCBpc05hTihiKSA/IG9iamVjdFxuICAgICAgOiBudW1iZXIpKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBkaXNjcmV0ZShyYW5nZSkge1xuICB2YXIgbiA9IHJhbmdlLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqIG4pKSldO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodWUkMShhLCBiKSB7XG4gIHZhciBpID0gaHVlKCthLCArYik7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIHggPSBpKHQpO1xuICAgIHJldHVybiB4IC0gMzYwICogTWF0aC5mbG9vcih4IC8gMzYwKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcm91bmQoYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChhICogKDEgLSB0KSArIGIgKiB0KTtcbiAgfTtcbn1cblxudmFyIGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuXG52YXIgaWRlbnRpdHkgPSB7XG4gIHRyYW5zbGF0ZVg6IDAsXG4gIHRyYW5zbGF0ZVk6IDAsXG4gIHJvdGF0ZTogMCxcbiAgc2tld1g6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuXG5mdW5jdGlvbiBkZWNvbXBvc2UoYSwgYiwgYywgZCwgZSwgZikge1xuICB2YXIgc2NhbGVYLCBzY2FsZVksIHNrZXdYO1xuICBpZiAoc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpKSBhIC89IHNjYWxlWCwgYiAvPSBzY2FsZVg7XG4gIGlmIChza2V3WCA9IGEgKiBjICsgYiAqIGQpIGMgLT0gYSAqIHNrZXdYLCBkIC09IGIgKiBza2V3WDtcbiAgaWYgKHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKSkgYyAvPSBzY2FsZVksIGQgLz0gc2NhbGVZLCBza2V3WCAvPSBzY2FsZVk7XG4gIGlmIChhICogZCA8IGIgKiBjKSBhID0gLWEsIGIgPSAtYiwgc2tld1ggPSAtc2tld1gsIHNjYWxlWCA9IC1zY2FsZVg7XG4gIHJldHVybiB7XG4gICAgdHJhbnNsYXRlWDogZSxcbiAgICB0cmFuc2xhdGVZOiBmLFxuICAgIHJvdGF0ZTogTWF0aC5hdGFuMihiLCBhKSAqIGRlZ3JlZXMsXG4gICAgc2tld1g6IE1hdGguYXRhbihza2V3WCkgKiBkZWdyZWVzLFxuICAgIHNjYWxlWDogc2NhbGVYLFxuICAgIHNjYWxlWTogc2NhbGVZXG4gIH07XG59XG5cbnZhciBjc3NOb2RlLFxuICAgIGNzc1Jvb3QsXG4gICAgY3NzVmlldyxcbiAgICBzdmdOb2RlO1xuXG5mdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IFwibm9uZVwiKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghY3NzTm9kZSkgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIGNzc1Jvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNzc1ZpZXcgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY3NzTm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgdmFsdWUgPSBjc3NWaWV3LmdldENvbXB1dGVkU3R5bGUoY3NzUm9vdC5hcHBlbmRDaGlsZChjc3NOb2RlKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKTtcbiAgY3NzUm9vdC5yZW1vdmVDaGlsZChjc3NOb2RlKTtcbiAgdmFsdWUgPSB2YWx1ZS5zbGljZSg3LCAtMSkuc3BsaXQoXCIsXCIpO1xuICByZXR1cm4gZGVjb21wb3NlKCt2YWx1ZVswXSwgK3ZhbHVlWzFdLCArdmFsdWVbMl0sICt2YWx1ZVszXSwgK3ZhbHVlWzRdLCArdmFsdWVbNV0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xudmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcblxudmFyIHJobyA9IE1hdGguU1FSVDIsXG4gICAgcmhvMiA9IDIsXG4gICAgcmhvNCA9IDQsXG4gICAgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxuZnVuY3Rpb24gem9vbShwMCwgcDEpIHtcbiAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgaSxcbiAgICAgIFM7XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgIF07XG4gICAgfTtcbiAgfVxuXG4gIC8vIEdlbmVyYWwgY2FzZS5cbiAgZWxzZSB7XG4gICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgXTtcbiAgICB9O1xuICB9XG5cbiAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBoc2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gZDNDb2xvci5oc2woc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5oc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBub2dhbW1hKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoc2wkMSA9IGhzbChodWUpO1xudmFyIGhzbExvbmcgPSBoc2wobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIGxhYihzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gbm9nYW1tYSgoc3RhcnQgPSBkM0NvbG9yLmxhYihzdGFydCkpLmwsIChlbmQgPSBkM0NvbG9yLmxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBub2dhbW1hKHN0YXJ0LmEsIGVuZC5hKSxcbiAgICAgIGIgPSBub2dhbW1hKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBoY2woaHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gZDNDb2xvci5oY2woc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5oY2woZW5kKSkuaCksXG4gICAgICAgIGMgPSBub2dhbW1hKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQuYyA9IGModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoY2wkMSA9IGhjbChodWUpO1xudmFyIGhjbExvbmcgPSBoY2wobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeChodWUpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiBjdWJlaGVsaXhHYW1tYSh5KSB7XG4gICAgeSA9ICt5O1xuXG4gICAgZnVuY3Rpb24gY3ViZWhlbGl4KHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBoID0gaHVlKChzdGFydCA9IGQzQ29sb3IuY3ViZWhlbGl4KHN0YXJ0KSkuaCwgKGVuZCA9IGQzQ29sb3IuY3ViZWhlbGl4KGVuZCkpLmgpLFxuICAgICAgICAgIHMgPSBub2dhbW1hKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgICBsID0gbm9nYW1tYShzdGFydC5sLCBlbmQubCksXG4gICAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICAgIHN0YXJ0LnMgPSBzKHQpO1xuICAgICAgICBzdGFydC5sID0gbChNYXRoLnBvdyh0LCB5KSk7XG4gICAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjdWJlaGVsaXguZ2FtbWEgPSBjdWJlaGVsaXhHYW1tYTtcblxuICAgIHJldHVybiBjdWJlaGVsaXg7XG4gIH0pKDEpO1xufVxuXG52YXIgY3ViZWhlbGl4JDEgPSBjdWJlaGVsaXgoaHVlKTtcbnZhciBjdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4KG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn1cblxuZXhwb3J0cy5pbnRlcnBvbGF0ZSA9IHZhbHVlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUFycmF5ID0gYXJyYXk7XG5leHBvcnRzLmludGVycG9sYXRlQmFzaXMgPSBiYXNpcyQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkID0gYmFzaXNDbG9zZWQ7XG5leHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4ID0gY3ViZWhlbGl4JDE7XG5leHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeExvbmc7XG5leHBvcnRzLmludGVycG9sYXRlRGF0ZSA9IGRhdGU7XG5leHBvcnRzLmludGVycG9sYXRlRGlzY3JldGUgPSBkaXNjcmV0ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIY2wgPSBoY2wkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIY2xMb25nID0gaGNsTG9uZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVIc2wgPSBoc2wkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIc2xMb25nID0gaHNsTG9uZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVIdWUgPSBodWUkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVMYWIgPSBsYWI7XG5leHBvcnRzLmludGVycG9sYXRlTnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlckFycmF5ID0gbnVtYmVyQXJyYXk7XG5leHBvcnRzLmludGVycG9sYXRlT2JqZWN0ID0gb2JqZWN0O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYiA9IHJnYjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2JCYXNpcyA9IHJnYkJhc2lzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYkJhc2lzQ2xvc2VkID0gcmdiQmFzaXNDbG9zZWQ7XG5leHBvcnRzLmludGVycG9sYXRlUm91bmQgPSByb3VuZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVTdHJpbmcgPSBzdHJpbmc7XG5leHBvcnRzLmludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3M7XG5leHBvcnRzLmludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Tdmc7XG5leHBvcnRzLmludGVycG9sYXRlWm9vbSA9IHpvb207XG5leHBvcnRzLnBpZWNld2lzZSA9IHBpZWNld2lzZTtcbmV4cG9ydHMucXVhbnRpemUgPSBxdWFudGl6ZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1wYXRoLyB2MS4wLjkgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnRzLnBhdGggPSBwYXRoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXBvbHlnb24vIHYxLjAuNiBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGFyZWEocG9seWdvbikge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgYSxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIGFyZWEgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYSA9IGI7XG4gICAgYiA9IHBvbHlnb25baV07XG4gICAgYXJlYSArPSBhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdO1xuICB9XG5cbiAgcmV0dXJuIGFyZWEgLyAyO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZChwb2x5Z29uKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgYSxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIGMsXG4gICAgICBrID0gMDtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEgPSBiO1xuICAgIGIgPSBwb2x5Z29uW2ldO1xuICAgIGsgKz0gYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgeCArPSAoYVswXSArIGJbMF0pICogYztcbiAgICB5ICs9IChhWzFdICsgYlsxXSkgKiBjO1xuICB9XG5cbiAgcmV0dXJuIGsgKj0gMywgW3ggLyBrLCB5IC8ga107XG59XG5cbi8vIFJldHVybnMgdGhlIDJEIGNyb3NzIHByb2R1Y3Qgb2YgQUIgYW5kIEFDIHZlY3RvcnMsIGkuZS4sIHRoZSB6LWNvbXBvbmVudCBvZlxuLy8gdGhlIDNEIGNyb3NzIHByb2R1Y3QgaW4gYSBxdWFkcmFudCBJIENhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbSAoK3ggaXNcbi8vIHJpZ2h0LCAreSBpcyB1cCkuIFJldHVybnMgYSBwb3NpdGl2ZSB2YWx1ZSBpZiBBQkMgaXMgY291bnRlci1jbG9ja3dpc2UsXG4vLyBuZWdhdGl2ZSBpZiBjbG9ja3dpc2UsIGFuZCB6ZXJvIGlmIHRoZSBwb2ludHMgYXJlIGNvbGxpbmVhci5cbmZ1bmN0aW9uIGNyb3NzKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pIC0gKGJbMV0gLSBhWzFdKSAqIChjWzBdIC0gYVswXSk7XG59XG5cbmZ1bmN0aW9uIGxleGljb2dyYXBoaWNPcmRlcihhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXTtcbn1cblxuLy8gQ29tcHV0ZXMgdGhlIHVwcGVyIGNvbnZleCBodWxsIHBlciB0aGUgbW9ub3RvbmUgY2hhaW4gYWxnb3JpdGhtLlxuLy8gQXNzdW1lcyBwb2ludHMubGVuZ3RoID49IDMsIGlzIHNvcnRlZCBieSB4LCB1bmlxdWUgaW4geS5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgaW5kaWNlcyBpbnRvIHBvaW50cyBpbiBsZWZ0LXRvLXJpZ2h0IG9yZGVyLlxuZnVuY3Rpb24gY29tcHV0ZVVwcGVySHVsbEluZGV4ZXMocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgIGluZGV4ZXMgPSBbMCwgMV0sXG4gICAgICBzaXplID0gMjtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IG47ICsraSkge1xuICAgIHdoaWxlIChzaXplID4gMSAmJiBjcm9zcyhwb2ludHNbaW5kZXhlc1tzaXplIC0gMl1dLCBwb2ludHNbaW5kZXhlc1tzaXplIC0gMV1dLCBwb2ludHNbaV0pIDw9IDApIC0tc2l6ZTtcbiAgICBpbmRleGVzW3NpemUrK10gPSBpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4ZXMuc2xpY2UoMCwgc2l6ZSk7IC8vIHJlbW92ZSBwb3BwZWQgcG9pbnRzXG59XG5cbmZ1bmN0aW9uIGh1bGwocG9pbnRzKSB7XG4gIGlmICgobiA9IHBvaW50cy5sZW5ndGgpIDwgMykgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGksXG4gICAgICBuLFxuICAgICAgc29ydGVkUG9pbnRzID0gbmV3IEFycmF5KG4pLFxuICAgICAgZmxpcHBlZFBvaW50cyA9IG5ldyBBcnJheShuKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzb3J0ZWRQb2ludHNbaV0gPSBbK3BvaW50c1tpXVswXSwgK3BvaW50c1tpXVsxXSwgaV07XG4gIHNvcnRlZFBvaW50cy5zb3J0KGxleGljb2dyYXBoaWNPcmRlcik7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGZsaXBwZWRQb2ludHNbaV0gPSBbc29ydGVkUG9pbnRzW2ldWzBdLCAtc29ydGVkUG9pbnRzW2ldWzFdXTtcblxuICB2YXIgdXBwZXJJbmRleGVzID0gY29tcHV0ZVVwcGVySHVsbEluZGV4ZXMoc29ydGVkUG9pbnRzKSxcbiAgICAgIGxvd2VySW5kZXhlcyA9IGNvbXB1dGVVcHBlckh1bGxJbmRleGVzKGZsaXBwZWRQb2ludHMpO1xuXG4gIC8vIENvbnN0cnVjdCB0aGUgaHVsbCBwb2x5Z29uLCByZW1vdmluZyBwb3NzaWJsZSBkdXBsaWNhdGUgZW5kcG9pbnRzLlxuICB2YXIgc2tpcExlZnQgPSBsb3dlckluZGV4ZXNbMF0gPT09IHVwcGVySW5kZXhlc1swXSxcbiAgICAgIHNraXBSaWdodCA9IGxvd2VySW5kZXhlc1tsb3dlckluZGV4ZXMubGVuZ3RoIC0gMV0gPT09IHVwcGVySW5kZXhlc1t1cHBlckluZGV4ZXMubGVuZ3RoIC0gMV0sXG4gICAgICBodWxsID0gW107XG5cbiAgLy8gQWRkIHVwcGVyIGh1bGwgaW4gcmlnaHQtdG8tbCBvcmRlci5cbiAgLy8gVGhlbiBhZGQgbG93ZXIgaHVsbCBpbiBsZWZ0LXRvLXJpZ2h0IG9yZGVyLlxuICBmb3IgKGkgPSB1cHBlckluZGV4ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGh1bGwucHVzaChwb2ludHNbc29ydGVkUG9pbnRzW3VwcGVySW5kZXhlc1tpXV1bMl1dKTtcbiAgZm9yIChpID0gK3NraXBMZWZ0OyBpIDwgbG93ZXJJbmRleGVzLmxlbmd0aCAtIHNraXBSaWdodDsgKytpKSBodWxsLnB1c2gocG9pbnRzW3NvcnRlZFBvaW50c1tsb3dlckluZGV4ZXNbaV1dWzJdXSk7XG5cbiAgcmV0dXJuIGh1bGw7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBvbHlnb24sIHBvaW50KSB7XG4gIHZhciBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICBwID0gcG9seWdvbltuIC0gMV0sXG4gICAgICB4ID0gcG9pbnRbMF0sIHkgPSBwb2ludFsxXSxcbiAgICAgIHgwID0gcFswXSwgeTAgPSBwWzFdLFxuICAgICAgeDEsIHkxLFxuICAgICAgaW5zaWRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBwID0gcG9seWdvbltpXSwgeDEgPSBwWzBdLCB5MSA9IHBbMV07XG4gICAgaWYgKCgoeTEgPiB5KSAhPT0gKHkwID4geSkpICYmICh4IDwgKHgwIC0geDEpICogKHkgLSB5MSkgLyAoeTAgLSB5MSkgKyB4MSkpIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgeDAgPSB4MSwgeTAgPSB5MTtcbiAgfVxuXG4gIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChwb2x5Z29uKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICBiID0gcG9seWdvbltuIC0gMV0sXG4gICAgICB4YSxcbiAgICAgIHlhLFxuICAgICAgeGIgPSBiWzBdLFxuICAgICAgeWIgPSBiWzFdLFxuICAgICAgcGVyaW1ldGVyID0gMDtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIHhhID0geGI7XG4gICAgeWEgPSB5YjtcbiAgICBiID0gcG9seWdvbltpXTtcbiAgICB4YiA9IGJbMF07XG4gICAgeWIgPSBiWzFdO1xuICAgIHhhIC09IHhiO1xuICAgIHlhIC09IHliO1xuICAgIHBlcmltZXRlciArPSBNYXRoLnNxcnQoeGEgKiB4YSArIHlhICogeWEpO1xuICB9XG5cbiAgcmV0dXJuIHBlcmltZXRlcjtcbn1cblxuZXhwb3J0cy5wb2x5Z29uQXJlYSA9IGFyZWE7XG5leHBvcnRzLnBvbHlnb25DZW50cm9pZCA9IGNlbnRyb2lkO1xuZXhwb3J0cy5wb2x5Z29uQ29udGFpbnMgPSBjb250YWlucztcbmV4cG9ydHMucG9seWdvbkh1bGwgPSBodWxsO1xuZXhwb3J0cy5wb2x5Z29uTGVuZ3RoID0gbGVuZ3RoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXF1YWR0cmVlLyB2MS4wLjcgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiB0cmVlX2FkZChkKSB7XG4gIHZhciB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufVxuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5mdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xuICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHl6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB4MSA9IC1JbmZpbml0eSxcbiAgICAgIHkxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQgPSBkYXRhW2ldKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSBjb250aW51ZTtcbiAgICB4eltpXSA9IHg7XG4gICAgeXpbaV0gPSB5O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmUgbm8gKHZhbGlkKSBwb2ludHMsIGFib3J0LlxuICBpZiAoeDAgPiB4MSB8fCB5MCA+IHkxKSByZXR1cm4gdGhpcztcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDAsIHkwKS5jb3Zlcih4MSwgeTEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGFkZCh0aGlzLCB4eltpXSwgeXpbaV0sIGRhdGFbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfY292ZXIoeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlICh4MCA+IHggfHwgeCA+PSB4MSB8fCB5MCA+IHkgfHwgeSA+PSB5MSkge1xuICAgICAgaSA9ICh5IDwgeTApIDw8IDEgfCAoeCA8IHgwKTtcbiAgICAgIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudCwgeiAqPSAyO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMDogeDEgPSB4MCArIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAxOiB4MCA9IHgxIC0geiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHgxID0geDAgKyB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogeDAgPSB4MSAtIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lmxlbmd0aCkgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV9kYXRhKCkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyBkYXRhLnB1c2gobm9kZS5kYXRhKTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gdHJlZV9leHRlbnQoXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn1cblxuZnVuY3Rpb24gUXVhZChub2RlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLngwID0geDA7XG4gIHRoaXMueTAgPSB5MDtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG59XG5cbmZ1bmN0aW9uIHRyZWVfZmluZCh4LCB5LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeDMgPSB0aGlzLl94MSxcbiAgICAgIHkzID0gdGhpcy5feTEsXG4gICAgICBxdWFkcyA9IFtdLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBxLFxuICAgICAgaTtcblxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcbiAgICB4MyA9IHggKyByYWRpdXMsIHkzID0geSArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuXG4gICAgLy8gU3RvcCBzZWFyY2hpbmcgaWYgdGhpcyBxdWFkcmFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHgyID0gcS54MSkgPCB4MFxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcblxuICAgIC8vIEJpc2VjdCB0aGUgY3VycmVudCBxdWFkcmFudC5cbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgeW0gPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICBxdWFkcy5wdXNoKFxuICAgICAgICBuZXcgUXVhZChub2RlWzNdLCB4bSwgeW0sIHgyLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsxXSwgeG0sIHkxLCB4MiwgeW0pLFxuICAgICAgICBuZXcgUXVhZChub2RlWzBdLCB4MSwgeTEsIHhtLCB5bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IHF1YWRyYW50IGZpcnN0LlxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZpc2l0IHRoaXMgcG9pbnQuIChWaXNpdGluZyBjb2luY2lkZW50IHBvaW50cyBpc27igJl0IG5lY2Vzc2FyeSEpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGR5ID0geSAtICt0aGlzLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gdHJlZV9yZW1vdmUoZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAzXSB8fCBwYXJlbnRbKGkgKyAyKSAmIDNdIHx8IHBhcmVudFsoaSArIDMpICYgM10pIHJldGFpbmVyID0gcGFyZW50LCBqID0gaTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHBvaW50IHRvIHJlbW92ZS5cbiAgd2hpbGUgKG5vZGUuZGF0YSAhPT0gZCkgaWYgKCEocHJldmlvdXMgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0KSkgcmV0dXJuIHRoaXM7XG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb2luY2lkZW50IHBvaW50cywgcmVtb3ZlIGp1c3QgdGhlIHBvaW50LlxuICBpZiAocHJldmlvdXMpIHJldHVybiAobmV4dCA/IHByZXZpb3VzLm5leHQgPSBuZXh0IDogZGVsZXRlIHByZXZpb3VzLm5leHQpLCB0aGlzO1xuXG4gIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgcG9pbnQsIHJlbW92ZSBpdC5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiB0aGlzLl9yb290ID0gbmV4dCwgdGhpcztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWFmLlxuICBuZXh0ID8gcGFyZW50W2ldID0gbmV4dCA6IGRlbGV0ZSBwYXJlbnRbaV07XG5cbiAgLy8gSWYgdGhlIHBhcmVudCBub3cgY29udGFpbnMgZXhhY3RseSBvbmUgbGVhZiwgY29sbGFwc2Ugc3VwZXJmbHVvdXMgcGFyZW50cy5cbiAgaWYgKChub2RlID0gcGFyZW50WzBdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzNdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcbiAgICAgICYmICFub2RlLmxlbmd0aCkge1xuICAgIGlmIChyZXRhaW5lcikgcmV0YWluZXJbal0gPSBub2RlO1xuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkgdGhpcy5yZW1vdmUoZGF0YVtpXSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX3Jvb3QoKSB7XG4gIHJldHVybiB0aGlzLl9yb290O1xufVxuXG5mdW5jdGlvbiB0cmVlX3NpemUoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiB0cmVlX3Zpc2l0KGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV92aXNpdEFmdGVyKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBuZXh0ID0gW10sIHE7XG4gIGlmICh0aGlzLl9yb290KSBxdWFkcy5wdXNoKG5ldyBRdWFkKHRoaXMuX3Jvb3QsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxLCB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgfVxuICAgIG5leHQucHVzaChxKTtcbiAgfVxuICB3aGlsZSAocSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhxLm5vZGUsIHEueDAsIHEueTAsIHEueDEsIHEueTEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5mdW5jdGlvbiB0cmVlX3goXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5mdW5jdGlvbiB0cmVlX3koXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufVxuXG5mdW5jdGlvbiBxdWFkdHJlZShub2RlcywgeCwgeSkge1xuICB2YXIgdHJlZSA9IG5ldyBRdWFkdHJlZSh4ID09IG51bGwgPyBkZWZhdWx0WCA6IHgsIHkgPT0gbnVsbCA/IGRlZmF1bHRZIDogeSwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbiAgcmV0dXJuIG5vZGVzID09IG51bGwgPyB0cmVlIDogdHJlZS5hZGRBbGwobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBRdWFkdHJlZSh4LCB5LCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLl94ID0geDtcbiAgdGhpcy5feSA9IHk7XG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XG4gIHZhciBjb3B5ID0ge2RhdGE6IGxlYWYuZGF0YX0sIG5leHQgPSBjb3B5O1xuICB3aGlsZSAobGVhZiA9IGxlYWYubmV4dCkgbmV4dCA9IG5leHQubmV4dCA9IHtkYXRhOiBsZWFmLmRhdGF9O1xuICByZXR1cm4gY29weTtcbn1cblxudmFyIHRyZWVQcm90byA9IHF1YWR0cmVlLnByb3RvdHlwZSA9IFF1YWR0cmVlLnByb3RvdHlwZTtcblxudHJlZVByb3RvLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvcHkgPSBuZXcgUXVhZHRyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkO1xuXG4gIGlmICghbm9kZSkgcmV0dXJuIGNvcHk7XG5cbiAgaWYgKCFub2RlLmxlbmd0aCkgcmV0dXJuIGNvcHkuX3Jvb3QgPSBsZWFmX2NvcHkobm9kZSksIGNvcHk7XG5cbiAgbm9kZXMgPSBbe3NvdXJjZTogbm9kZSwgdGFyZ2V0OiBjb3B5Ll9yb290ID0gbmV3IEFycmF5KDQpfV07XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKGNoaWxkID0gbm9kZS5zb3VyY2VbaV0pIHtcbiAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCkgbm9kZXMucHVzaCh7c291cmNlOiBjaGlsZCwgdGFyZ2V0OiBub2RlLnRhcmdldFtpXSA9IG5ldyBBcnJheSg0KX0pO1xuICAgICAgICBlbHNlIG5vZGUudGFyZ2V0W2ldID0gbGVhZl9jb3B5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbnRyZWVQcm90by5hZGQgPSB0cmVlX2FkZDtcbnRyZWVQcm90by5hZGRBbGwgPSBhZGRBbGw7XG50cmVlUHJvdG8uY292ZXIgPSB0cmVlX2NvdmVyO1xudHJlZVByb3RvLmRhdGEgPSB0cmVlX2RhdGE7XG50cmVlUHJvdG8uZXh0ZW50ID0gdHJlZV9leHRlbnQ7XG50cmVlUHJvdG8uZmluZCA9IHRyZWVfZmluZDtcbnRyZWVQcm90by5yZW1vdmUgPSB0cmVlX3JlbW92ZTtcbnRyZWVQcm90by5yZW1vdmVBbGwgPSByZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7XG50cmVlUHJvdG8ueSA9IHRyZWVfeTtcblxuZXhwb3J0cy5xdWFkdHJlZSA9IHF1YWR0cmVlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXJhbmRvbS8gdjEuMS4yIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U291cmNlKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbn1cblxudmFyIHVuaWZvcm0gPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tVW5pZm9ybShzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tVW5pZm9ybShtaW4sIG1heCkge1xuICAgIG1pbiA9IG1pbiA9PSBudWxsID8gMCA6ICttaW47XG4gICAgbWF4ID0gbWF4ID09IG51bGwgPyAxIDogK21heDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgbWF4ID0gbWluLCBtaW4gPSAwO1xuICAgIGVsc2UgbWF4IC09IG1pbjtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc291cmNlKCkgKiBtYXggKyBtaW47XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbVVuaWZvcm0uc291cmNlID0gc291cmNlUmFuZG9tVW5pZm9ybTtcblxuICByZXR1cm4gcmFuZG9tVW5pZm9ybTtcbn0pKGRlZmF1bHRTb3VyY2UpO1xuXG52YXIgbm9ybWFsID0gKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbU5vcm1hbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tTm9ybWFsKG11LCBzaWdtYSkge1xuICAgIHZhciB4LCByO1xuICAgIG11ID0gbXUgPT0gbnVsbCA/IDAgOiArbXU7XG4gICAgc2lnbWEgPSBzaWdtYSA9PSBudWxsID8gMSA6ICtzaWdtYTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeTtcblxuICAgICAgLy8gSWYgYXZhaWxhYmxlLCB1c2UgdGhlIHNlY29uZCBwcmV2aW91c2x5LWdlbmVyYXRlZCB1bmlmb3JtIHJhbmRvbS5cbiAgICAgIGlmICh4ICE9IG51bGwpIHkgPSB4LCB4ID0gbnVsbDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhIG5ldyB4IGFuZCB5LlxuICAgICAgZWxzZSBkbyB7XG4gICAgICAgIHggPSBzb3VyY2UoKSAqIDIgLSAxO1xuICAgICAgICB5ID0gc291cmNlKCkgKiAyIC0gMTtcbiAgICAgICAgciA9IHggKiB4ICsgeSAqIHk7XG4gICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG5cbiAgICAgIHJldHVybiBtdSArIHNpZ21hICogeSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbU5vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Ob3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbU5vcm1hbDtcbn0pKGRlZmF1bHRTb3VyY2UpO1xuXG52YXIgbG9nTm9ybWFsID0gKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbUxvZ05vcm1hbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tTG9nTm9ybWFsKCkge1xuICAgIHZhciByYW5kb21Ob3JtYWwgPSBub3JtYWwuc291cmNlKHNvdXJjZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5leHAocmFuZG9tTm9ybWFsKCkpO1xuICAgIH07XG4gIH1cblxuICByYW5kb21Mb2dOb3JtYWwuc291cmNlID0gc291cmNlUmFuZG9tTG9nTm9ybWFsO1xuXG4gIHJldHVybiByYW5kb21Mb2dOb3JtYWw7XG59KShkZWZhdWx0U291cmNlKTtcblxudmFyIGlyd2luSGFsbCA9IChmdW5jdGlvbiBzb3VyY2VSYW5kb21JcndpbkhhbGwoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbUlyd2luSGFsbChuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgc3VtID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHN1bSArPSBzb3VyY2UoKTtcbiAgICAgIHJldHVybiBzdW07XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUlyd2luSGFsbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21JcndpbkhhbGw7XG5cbiAgcmV0dXJuIHJhbmRvbUlyd2luSGFsbDtcbn0pKGRlZmF1bHRTb3VyY2UpO1xuXG52YXIgYmF0ZXMgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tQmF0ZXMoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbUJhdGVzKG4pIHtcbiAgICB2YXIgcmFuZG9tSXJ3aW5IYWxsID0gaXJ3aW5IYWxsLnNvdXJjZShzb3VyY2UpKG4pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb21JcndpbkhhbGwoKSAvIG47XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUJhdGVzLnNvdXJjZSA9IHNvdXJjZVJhbmRvbUJhdGVzO1xuXG4gIHJldHVybiByYW5kb21CYXRlcztcbn0pKGRlZmF1bHRTb3VyY2UpO1xuXG52YXIgZXhwb25lbnRpYWwgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tRXhwb25lbnRpYWwoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbUV4cG9uZW50aWFsKGxhbWJkYSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtTWF0aC5sb2coMSAtIHNvdXJjZSgpKSAvIGxhbWJkYTtcbiAgICB9O1xuICB9XG5cbiAgcmFuZG9tRXhwb25lbnRpYWwuc291cmNlID0gc291cmNlUmFuZG9tRXhwb25lbnRpYWw7XG5cbiAgcmV0dXJuIHJhbmRvbUV4cG9uZW50aWFsO1xufSkoZGVmYXVsdFNvdXJjZSk7XG5cbmV4cG9ydHMucmFuZG9tVW5pZm9ybSA9IHVuaWZvcm07XG5leHBvcnRzLnJhbmRvbU5vcm1hbCA9IG5vcm1hbDtcbmV4cG9ydHMucmFuZG9tTG9nTm9ybWFsID0gbG9nTm9ybWFsO1xuZXhwb3J0cy5yYW5kb21CYXRlcyA9IGJhdGVzO1xuZXhwb3J0cy5yYW5kb21JcndpbkhhbGwgPSBpcndpbkhhbGw7XG5leHBvcnRzLnJhbmRvbUV4cG9uZW50aWFsID0gZXhwb25lbnRpYWw7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNjYWxlLWNocm9tYXRpYy8gdjEuNS4wIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtY29sb3InKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1pbnRlcnBvbGF0ZScsICdkMy1jb2xvciddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNJbnRlcnBvbGF0ZSwgZDNDb2xvcikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbG9ycyhzcGVjaWZpZXIpIHtcbiAgdmFyIG4gPSBzcGVjaWZpZXIubGVuZ3RoIC8gNiB8IDAsIGNvbG9ycyA9IG5ldyBBcnJheShuKSwgaSA9IDA7XG4gIHdoaWxlIChpIDwgbikgY29sb3JzW2ldID0gXCIjXCIgKyBzcGVjaWZpZXIuc2xpY2UoaSAqIDYsICsraSAqIDYpO1xuICByZXR1cm4gY29sb3JzO1xufVxuXG52YXIgY2F0ZWdvcnkxMCA9IGNvbG9ycyhcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKTtcblxudmFyIEFjY2VudCA9IGNvbG9ycyhcIjdmYzk3ZmJlYWVkNGZkYzA4NmZmZmY5OTM4NmNiMGYwMDI3ZmJmNWIxNzY2NjY2NlwiKTtcblxudmFyIERhcmsyID0gY29sb3JzKFwiMWI5ZTc3ZDk1ZjAyNzU3MGIzZTcyOThhNjZhNjFlZTZhYjAyYTY3NjFkNjY2NjY2XCIpO1xuXG52YXIgUGFpcmVkID0gY29sb3JzKFwiYTZjZWUzMWY3OGI0YjJkZjhhMzNhMDJjZmI5YTk5ZTMxYTFjZmRiZjZmZmY3ZjAwY2FiMmQ2NmEzZDlhZmZmZjk5YjE1OTI4XCIpO1xuXG52YXIgUGFzdGVsMSA9IGNvbG9ycyhcImZiYjRhZWIzY2RlM2NjZWJjNWRlY2JlNGZlZDlhNmZmZmZjY2U1ZDhiZGZkZGFlY2YyZjJmMlwiKTtcblxudmFyIFBhc3RlbDIgPSBjb2xvcnMoXCJiM2UyY2RmZGNkYWNjYmQ1ZThmNGNhZTRlNmY1YzlmZmYyYWVmMWUyY2NjY2NjY2NcIik7XG5cbnZhciBTZXQxID0gY29sb3JzKFwiZTQxYTFjMzc3ZWI4NGRhZjRhOTg0ZWEzZmY3ZjAwZmZmZjMzYTY1NjI4Zjc4MWJmOTk5OTk5XCIpO1xuXG52YXIgU2V0MiA9IGNvbG9ycyhcIjY2YzJhNWZjOGQ2MjhkYTBjYmU3OGFjM2E2ZDg1NGZmZDkyZmU1YzQ5NGIzYjNiM1wiKTtcblxudmFyIFNldDMgPSBjb2xvcnMoXCI4ZGQzYzdmZmZmYjNiZWJhZGFmYjgwNzI4MGIxZDNmZGI0NjJiM2RlNjlmY2NkZTVkOWQ5ZDliYzgwYmRjY2ViYzVmZmVkNmZcIik7XG5cbnZhciBUYWJsZWF1MTAgPSBjb2xvcnMoXCI0ZTc5YTdmMjhlMmNlMTU3NTk3NmI3YjI1OWExNGZlZGM5NDlhZjdhYTFmZjlkYTc5Yzc1NWZiYWIwYWJcIik7XG5cbmZ1bmN0aW9uIHJhbXAoc2NoZW1lKSB7XG4gIHJldHVybiBkM0ludGVycG9sYXRlLmludGVycG9sYXRlUmdiQmFzaXMoc2NoZW1lW3NjaGVtZS5sZW5ndGggLSAxXSk7XG59XG5cbnZhciBzY2hlbWUgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImQ4YjM2NWY1ZjVmNTVhYjRhY1wiLFxuICBcImE2NjExYWRmYzI3ZDgwY2RjMTAxODU3MVwiLFxuICBcImE2NjExYWRmYzI3ZGY1ZjVmNTgwY2RjMTAxODU3MVwiLFxuICBcIjhjNTEwYWQ4YjM2NWY2ZThjM2M3ZWFlNTVhYjRhYzAxNjY1ZVwiLFxuICBcIjhjNTEwYWQ4YjM2NWY2ZThjM2Y1ZjVmNWM3ZWFlNTVhYjRhYzAxNjY1ZVwiLFxuICBcIjhjNTEwYWJmODEyZGRmYzI3ZGY2ZThjM2M3ZWFlNTgwY2RjMTM1OTc4ZjAxNjY1ZVwiLFxuICBcIjhjNTEwYWJmODEyZGRmYzI3ZGY2ZThjM2Y1ZjVmNWM3ZWFlNTgwY2RjMTM1OTc4ZjAxNjY1ZVwiLFxuICBcIjU0MzAwNThjNTEwYWJmODEyZGRmYzI3ZGY2ZThjM2M3ZWFlNTgwY2RjMTM1OTc4ZjAxNjY1ZTAwM2MzMFwiLFxuICBcIjU0MzAwNThjNTEwYWJmODEyZGRmYzI3ZGY2ZThjM2Y1ZjVmNWM3ZWFlNTgwY2RjMTM1OTc4ZjAxNjY1ZTAwM2MzMFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgQnJCRyA9IHJhbXAoc2NoZW1lKTtcblxudmFyIHNjaGVtZSQxID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJhZjhkYzNmN2Y3Zjc3ZmJmN2JcIixcbiAgXCI3YjMyOTRjMmE1Y2ZhNmRiYTAwMDg4MzdcIixcbiAgXCI3YjMyOTRjMmE1Y2ZmN2Y3ZjdhNmRiYTAwMDg4MzdcIixcbiAgXCI3NjJhODNhZjhkYzNlN2Q0ZThkOWYwZDM3ZmJmN2IxYjc4MzdcIixcbiAgXCI3NjJhODNhZjhkYzNlN2Q0ZThmN2Y3ZjdkOWYwZDM3ZmJmN2IxYjc4MzdcIixcbiAgXCI3NjJhODM5OTcwYWJjMmE1Y2ZlN2Q0ZThkOWYwZDNhNmRiYTA1YWFlNjExYjc4MzdcIixcbiAgXCI3NjJhODM5OTcwYWJjMmE1Y2ZlN2Q0ZThmN2Y3ZjdkOWYwZDNhNmRiYTA1YWFlNjExYjc4MzdcIixcbiAgXCI0MDAwNGI3NjJhODM5OTcwYWJjMmE1Y2ZlN2Q0ZThkOWYwZDNhNmRiYTA1YWFlNjExYjc4MzcwMDQ0MWJcIixcbiAgXCI0MDAwNGI3NjJhODM5OTcwYWJjMmE1Y2ZlN2Q0ZThmN2Y3ZjdkOWYwZDNhNmRiYTA1YWFlNjExYjc4MzcwMDQ0MWJcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFBSR24gPSByYW1wKHNjaGVtZSQxKTtcblxudmFyIHNjaGVtZSQyID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlOWEzYzlmN2Y3ZjdhMWQ3NmFcIixcbiAgXCJkMDFjOGJmMWI2ZGFiOGUxODY0ZGFjMjZcIixcbiAgXCJkMDFjOGJmMWI2ZGFmN2Y3ZjdiOGUxODY0ZGFjMjZcIixcbiAgXCJjNTFiN2RlOWEzYzlmZGUwZWZlNmY1ZDBhMWQ3NmE0ZDkyMjFcIixcbiAgXCJjNTFiN2RlOWEzYzlmZGUwZWZmN2Y3ZjdlNmY1ZDBhMWQ3NmE0ZDkyMjFcIixcbiAgXCJjNTFiN2RkZTc3YWVmMWI2ZGFmZGUwZWZlNmY1ZDBiOGUxODY3ZmJjNDE0ZDkyMjFcIixcbiAgXCJjNTFiN2RkZTc3YWVmMWI2ZGFmZGUwZWZmN2Y3ZjdlNmY1ZDBiOGUxODY3ZmJjNDE0ZDkyMjFcIixcbiAgXCI4ZTAxNTJjNTFiN2RkZTc3YWVmMWI2ZGFmZGUwZWZlNmY1ZDBiOGUxODY3ZmJjNDE0ZDkyMjEyNzY0MTlcIixcbiAgXCI4ZTAxNTJjNTFiN2RkZTc3YWVmMWI2ZGFmZGUwZWZmN2Y3ZjdlNmY1ZDBiOGUxODY3ZmJjNDE0ZDkyMjEyNzY0MTlcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFBpWUcgPSByYW1wKHNjaGVtZSQyKTtcblxudmFyIHNjaGVtZSQzID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCI5OThlYzNmN2Y3ZjdmMWEzNDBcIixcbiAgXCI1ZTNjOTliMmFiZDJmZGI4NjNlNjYxMDFcIixcbiAgXCI1ZTNjOTliMmFiZDJmN2Y3ZjdmZGI4NjNlNjYxMDFcIixcbiAgXCI1NDI3ODg5OThlYzNkOGRhZWJmZWUwYjZmMWEzNDBiMzU4MDZcIixcbiAgXCI1NDI3ODg5OThlYzNkOGRhZWJmN2Y3ZjdmZWUwYjZmMWEzNDBiMzU4MDZcIixcbiAgXCI1NDI3ODg4MDczYWNiMmFiZDJkOGRhZWJmZWUwYjZmZGI4NjNlMDgyMTRiMzU4MDZcIixcbiAgXCI1NDI3ODg4MDczYWNiMmFiZDJkOGRhZWJmN2Y3ZjdmZWUwYjZmZGI4NjNlMDgyMTRiMzU4MDZcIixcbiAgXCIyZDAwNGI1NDI3ODg4MDczYWNiMmFiZDJkOGRhZWJmZWUwYjZmZGI4NjNlMDgyMTRiMzU4MDY3ZjNiMDhcIixcbiAgXCIyZDAwNGI1NDI3ODg4MDczYWNiMmFiZDJkOGRhZWJmN2Y3ZjdmZWUwYjZmZGI4NjNlMDgyMTRiMzU4MDY3ZjNiMDhcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFB1T3IgPSByYW1wKHNjaGVtZSQzKTtcblxudmFyIHNjaGVtZSQ0ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlZjhhNjJmN2Y3Zjc2N2E5Y2ZcIixcbiAgXCJjYTAwMjBmNGE1ODI5MmM1ZGUwNTcxYjBcIixcbiAgXCJjYTAwMjBmNGE1ODJmN2Y3Zjc5MmM1ZGUwNTcxYjBcIixcbiAgXCJiMjE4MmJlZjhhNjJmZGRiYzdkMWU1ZjA2N2E5Y2YyMTY2YWNcIixcbiAgXCJiMjE4MmJlZjhhNjJmZGRiYzdmN2Y3ZjdkMWU1ZjA2N2E5Y2YyMTY2YWNcIixcbiAgXCJiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdkMWU1ZjA5MmM1ZGU0MzkzYzMyMTY2YWNcIixcbiAgXCJiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdmN2Y3ZjdkMWU1ZjA5MmM1ZGU0MzkzYzMyMTY2YWNcIixcbiAgXCI2NzAwMWZiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdkMWU1ZjA5MmM1ZGU0MzkzYzMyMTY2YWMwNTMwNjFcIixcbiAgXCI2NzAwMWZiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdmN2Y3ZjdkMWU1ZjA5MmM1ZGU0MzkzYzMyMTY2YWMwNTMwNjFcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFJkQnUgPSByYW1wKHNjaGVtZSQ0KTtcblxudmFyIHNjaGVtZSQ1ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlZjhhNjJmZmZmZmY5OTk5OTlcIixcbiAgXCJjYTAwMjBmNGE1ODJiYWJhYmE0MDQwNDBcIixcbiAgXCJjYTAwMjBmNGE1ODJmZmZmZmZiYWJhYmE0MDQwNDBcIixcbiAgXCJiMjE4MmJlZjhhNjJmZGRiYzdlMGUwZTA5OTk5OTk0ZDRkNGRcIixcbiAgXCJiMjE4MmJlZjhhNjJmZGRiYzdmZmZmZmZlMGUwZTA5OTk5OTk0ZDRkNGRcIixcbiAgXCJiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdlMGUwZTBiYWJhYmE4Nzg3ODc0ZDRkNGRcIixcbiAgXCJiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdmZmZmZmZlMGUwZTBiYWJhYmE4Nzg3ODc0ZDRkNGRcIixcbiAgXCI2NzAwMWZiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdlMGUwZTBiYWJhYmE4Nzg3ODc0ZDRkNGQxYTFhMWFcIixcbiAgXCI2NzAwMWZiMjE4MmJkNjYwNGRmNGE1ODJmZGRiYzdmZmZmZmZlMGUwZTBiYWJhYmE4Nzg3ODc0ZDRkNGQxYTFhMWFcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFJkR3kgPSByYW1wKHNjaGVtZSQ1KTtcblxudmFyIHNjaGVtZSQ2ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmYzhkNTlmZmZmYmY5MWJmZGJcIixcbiAgXCJkNzE5MWNmZGFlNjFhYmQ5ZTkyYzdiYjZcIixcbiAgXCJkNzE5MWNmZGFlNjFmZmZmYmZhYmQ5ZTkyYzdiYjZcIixcbiAgXCJkNzMwMjdmYzhkNTlmZWUwOTBlMGYzZjg5MWJmZGI0NTc1YjRcIixcbiAgXCJkNzMwMjdmYzhkNTlmZWUwOTBmZmZmYmZlMGYzZjg5MWJmZGI0NTc1YjRcIixcbiAgXCJkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOTBlMGYzZjhhYmQ5ZTk3NGFkZDE0NTc1YjRcIixcbiAgXCJkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOTBmZmZmYmZlMGYzZjhhYmQ5ZTk3NGFkZDE0NTc1YjRcIixcbiAgXCJhNTAwMjZkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOTBlMGYzZjhhYmQ5ZTk3NGFkZDE0NTc1YjQzMTM2OTVcIixcbiAgXCJhNTAwMjZkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOTBmZmZmYmZlMGYzZjhhYmQ5ZTk3NGFkZDE0NTc1YjQzMTM2OTVcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFJkWWxCdSA9IHJhbXAoc2NoZW1lJDYpO1xuXG52YXIgc2NoZW1lJDcgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZjOGQ1OWZmZmZiZjkxY2Y2MFwiLFxuICBcImQ3MTkxY2ZkYWU2MWE2ZDk2YTFhOTY0MVwiLFxuICBcImQ3MTkxY2ZkYWU2MWZmZmZiZmE2ZDk2YTFhOTY0MVwiLFxuICBcImQ3MzAyN2ZjOGQ1OWZlZTA4YmQ5ZWY4YjkxY2Y2MDFhOTg1MFwiLFxuICBcImQ3MzAyN2ZjOGQ1OWZlZTA4YmZmZmZiZmQ5ZWY4YjkxY2Y2MDFhOTg1MFwiLFxuICBcImQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA4YmQ5ZWY4YmE2ZDk2YTY2YmQ2MzFhOTg1MFwiLFxuICBcImQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA4YmZmZmZiZmQ5ZWY4YmE2ZDk2YTY2YmQ2MzFhOTg1MFwiLFxuICBcImE1MDAyNmQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA4YmQ5ZWY4YmE2ZDk2YTY2YmQ2MzFhOTg1MDAwNjgzN1wiLFxuICBcImE1MDAyNmQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA4YmZmZmZiZmQ5ZWY4YmE2ZDk2YTY2YmQ2MzFhOTg1MDAwNjgzN1wiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUmRZbEduID0gcmFtcChzY2hlbWUkNyk7XG5cbnZhciBzY2hlbWUkOCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmM4ZDU5ZmZmZmJmOTlkNTk0XCIsXG4gIFwiZDcxOTFjZmRhZTYxYWJkZGE0MmI4M2JhXCIsXG4gIFwiZDcxOTFjZmRhZTYxZmZmZmJmYWJkZGE0MmI4M2JhXCIsXG4gIFwiZDUzZTRmZmM4ZDU5ZmVlMDhiZTZmNTk4OTlkNTk0MzI4OGJkXCIsXG4gIFwiZDUzZTRmZmM4ZDU5ZmVlMDhiZmZmZmJmZTZmNTk4OTlkNTk0MzI4OGJkXCIsXG4gIFwiZDUzZTRmZjQ2ZDQzZmRhZTYxZmVlMDhiZTZmNTk4YWJkZGE0NjZjMmE1MzI4OGJkXCIsXG4gIFwiZDUzZTRmZjQ2ZDQzZmRhZTYxZmVlMDhiZmZmZmJmZTZmNTk4YWJkZGE0NjZjMmE1MzI4OGJkXCIsXG4gIFwiOWUwMTQyZDUzZTRmZjQ2ZDQzZmRhZTYxZmVlMDhiZTZmNTk4YWJkZGE0NjZjMmE1MzI4OGJkNWU0ZmEyXCIsXG4gIFwiOWUwMTQyZDUzZTRmZjQ2ZDQzZmRhZTYxZmVlMDhiZmZmZmJmZTZmNTk4YWJkZGE0NjZjMmE1MzI4OGJkNWU0ZmEyXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBTcGVjdHJhbCA9IHJhbXAoc2NoZW1lJDgpO1xuXG52YXIgc2NoZW1lJDkgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImU1ZjVmOTk5ZDhjOTJjYTI1ZlwiLFxuICBcImVkZjhmYmIyZTJlMjY2YzJhNDIzOGI0NVwiLFxuICBcImVkZjhmYmIyZTJlMjY2YzJhNDJjYTI1ZjAwNmQyY1wiLFxuICBcImVkZjhmYmNjZWNlNjk5ZDhjOTY2YzJhNDJjYTI1ZjAwNmQyY1wiLFxuICBcImVkZjhmYmNjZWNlNjk5ZDhjOTY2YzJhNDQxYWU3NjIzOGI0NTAwNTgyNFwiLFxuICBcImY3ZmNmZGU1ZjVmOWNjZWNlNjk5ZDhjOTY2YzJhNDQxYWU3NjIzOGI0NTAwNTgyNFwiLFxuICBcImY3ZmNmZGU1ZjVmOWNjZWNlNjk5ZDhjOTY2YzJhNDQxYWU3NjIzOGI0NTAwNmQyYzAwNDQxYlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgQnVHbiA9IHJhbXAoc2NoZW1lJDkpO1xuXG52YXIgc2NoZW1lJGEgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImUwZWNmNDllYmNkYTg4NTZhN1wiLFxuICBcImVkZjhmYmIzY2RlMzhjOTZjNjg4NDE5ZFwiLFxuICBcImVkZjhmYmIzY2RlMzhjOTZjNjg4NTZhNzgxMGY3Y1wiLFxuICBcImVkZjhmYmJmZDNlNjllYmNkYThjOTZjNjg4NTZhNzgxMGY3Y1wiLFxuICBcImVkZjhmYmJmZDNlNjllYmNkYThjOTZjNjhjNmJiMTg4NDE5ZDZlMDE2YlwiLFxuICBcImY3ZmNmZGUwZWNmNGJmZDNlNjllYmNkYThjOTZjNjhjNmJiMTg4NDE5ZDZlMDE2YlwiLFxuICBcImY3ZmNmZGUwZWNmNGJmZDNlNjllYmNkYThjOTZjNjhjNmJiMTg4NDE5ZDgxMGY3YzRkMDA0YlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgQnVQdSA9IHJhbXAoc2NoZW1lJGEpO1xuXG52YXIgc2NoZW1lJGIgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImUwZjNkYmE4ZGRiNTQzYTJjYVwiLFxuICBcImYwZjllOGJhZTRiYzdiY2NjNDJiOGNiZVwiLFxuICBcImYwZjllOGJhZTRiYzdiY2NjNDQzYTJjYTA4NjhhY1wiLFxuICBcImYwZjllOGNjZWJjNWE4ZGRiNTdiY2NjNDQzYTJjYTA4NjhhY1wiLFxuICBcImYwZjllOGNjZWJjNWE4ZGRiNTdiY2NjNDRlYjNkMzJiOGNiZTA4NTg5ZVwiLFxuICBcImY3ZmNmMGUwZjNkYmNjZWJjNWE4ZGRiNTdiY2NjNDRlYjNkMzJiOGNiZTA4NTg5ZVwiLFxuICBcImY3ZmNmMGUwZjNkYmNjZWJjNWE4ZGRiNTdiY2NjNDRlYjNkMzJiOGNiZTA4NjhhYzA4NDA4MVwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgR25CdSA9IHJhbXAoc2NoZW1lJGIpO1xuXG52YXIgc2NoZW1lJGMgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZlZThjOGZkYmI4NGUzNGEzM1wiLFxuICBcImZlZjBkOWZkY2M4YWZjOGQ1OWQ3MzAxZlwiLFxuICBcImZlZjBkOWZkY2M4YWZjOGQ1OWUzNGEzM2IzMDAwMFwiLFxuICBcImZlZjBkOWZkZDQ5ZWZkYmI4NGZjOGQ1OWUzNGEzM2IzMDAwMFwiLFxuICBcImZlZjBkOWZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZjk5MDAwMFwiLFxuICBcImZmZjdlY2ZlZThjOGZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZjk5MDAwMFwiLFxuICBcImZmZjdlY2ZlZThjOGZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZmIzMDAwMDdmMDAwMFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgT3JSZCA9IHJhbXAoc2NoZW1lJGMpO1xuXG52YXIgc2NoZW1lJGQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVjZTJmMGE2YmRkYjFjOTA5OVwiLFxuICBcImY2ZWZmN2JkYzllMTY3YTljZjAyODE4YVwiLFxuICBcImY2ZWZmN2JkYzllMTY3YTljZjFjOTA5OTAxNmM1OVwiLFxuICBcImY2ZWZmN2QwZDFlNmE2YmRkYjY3YTljZjFjOTA5OTAxNmM1OVwiLFxuICBcImY2ZWZmN2QwZDFlNmE2YmRkYjY3YTljZjM2OTBjMDAyODE4YTAxNjQ1MFwiLFxuICBcImZmZjdmYmVjZTJmMGQwZDFlNmE2YmRkYjY3YTljZjM2OTBjMDAyODE4YTAxNjQ1MFwiLFxuICBcImZmZjdmYmVjZTJmMGQwZDFlNmE2YmRkYjY3YTljZjM2OTBjMDAyODE4YTAxNmM1OTAxNDYzNlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUHVCdUduID0gcmFtcChzY2hlbWUkZCk7XG5cbnZhciBzY2hlbWUkZSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWNlN2YyYTZiZGRiMmI4Y2JlXCIsXG4gIFwiZjFlZWY2YmRjOWUxNzRhOWNmMDU3MGIwXCIsXG4gIFwiZjFlZWY2YmRjOWUxNzRhOWNmMmI4Y2JlMDQ1YThkXCIsXG4gIFwiZjFlZWY2ZDBkMWU2YTZiZGRiNzRhOWNmMmI4Y2JlMDQ1YThkXCIsXG4gIFwiZjFlZWY2ZDBkMWU2YTZiZGRiNzRhOWNmMzY5MGMwMDU3MGIwMDM0ZTdiXCIsXG4gIFwiZmZmN2ZiZWNlN2YyZDBkMWU2YTZiZGRiNzRhOWNmMzY5MGMwMDU3MGIwMDM0ZTdiXCIsXG4gIFwiZmZmN2ZiZWNlN2YyZDBkMWU2YTZiZGRiNzRhOWNmMzY5MGMwMDU3MGIwMDQ1YThkMDIzODU4XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdUJ1ID0gcmFtcChzY2hlbWUkZSk7XG5cbnZhciBzY2hlbWUkZiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTdlMWVmYzk5NGM3ZGQxYzc3XCIsXG4gIFwiZjFlZWY2ZDdiNWQ4ZGY2NWIwY2UxMjU2XCIsXG4gIFwiZjFlZWY2ZDdiNWQ4ZGY2NWIwZGQxYzc3OTgwMDQzXCIsXG4gIFwiZjFlZWY2ZDRiOWRhYzk5NGM3ZGY2NWIwZGQxYzc3OTgwMDQzXCIsXG4gIFwiZjFlZWY2ZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTEwMDNmXCIsXG4gIFwiZjdmNGY5ZTdlMWVmZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTEwMDNmXCIsXG4gIFwiZjdmNGY5ZTdlMWVmZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTgwMDQzNjcwMDFmXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdVJkID0gcmFtcChzY2hlbWUkZik7XG5cbnZhciBzY2hlbWUkZyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmRlMGRkZmE5ZmI1YzUxYjhhXCIsXG4gIFwiZmVlYmUyZmJiNGI5Zjc2OGExYWUwMTdlXCIsXG4gIFwiZmVlYmUyZmJiNGI5Zjc2OGExYzUxYjhhN2EwMTc3XCIsXG4gIFwiZmVlYmUyZmNjNWMwZmE5ZmI1Zjc2OGExYzUxYjhhN2EwMTc3XCIsXG4gIFwiZmVlYmUyZmNjNWMwZmE5ZmI1Zjc2OGExZGQzNDk3YWUwMTdlN2EwMTc3XCIsXG4gIFwiZmZmN2YzZmRlMGRkZmNjNWMwZmE5ZmI1Zjc2OGExZGQzNDk3YWUwMTdlN2EwMTc3XCIsXG4gIFwiZmZmN2YzZmRlMGRkZmNjNWMwZmE5ZmI1Zjc2OGExZGQzNDk3YWUwMTdlN2EwMTc3NDkwMDZhXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZFB1ID0gcmFtcChzY2hlbWUkZyk7XG5cbnZhciBzY2hlbWUkaCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWRmOGIxN2ZjZGJiMmM3ZmI4XCIsXG4gIFwiZmZmZmNjYTFkYWI0NDFiNmM0MjI1ZWE4XCIsXG4gIFwiZmZmZmNjYTFkYWI0NDFiNmM0MmM3ZmI4MjUzNDk0XCIsXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MmM3ZmI4MjUzNDk0XCIsXG4gIFwiZmZmZmNjYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MGMyYzg0XCIsXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MGMyYzg0XCIsXG4gIFwiZmZmZmQ5ZWRmOGIxYzdlOWI0N2ZjZGJiNDFiNmM0MWQ5MWMwMjI1ZWE4MjUzNDk0MDgxZDU4XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBZbEduQnUgPSByYW1wKHNjaGVtZSRoKTtcblxudmFyIHNjaGVtZSRpID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmN2ZjYjlhZGRkOGUzMWEzNTRcIixcbiAgXCJmZmZmY2NjMmU2OTk3OGM2NzkyMzg0NDNcIixcbiAgXCJmZmZmY2NjMmU2OTk3OGM2NzkzMWEzNTQwMDY4MzdcIixcbiAgXCJmZmZmY2NkOWYwYTNhZGRkOGU3OGM2NzkzMWEzNTQwMDY4MzdcIixcbiAgXCJmZmZmY2NkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDVhMzJcIixcbiAgXCJmZmZmZTVmN2ZjYjlkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDVhMzJcIixcbiAgXCJmZmZmZTVmN2ZjYjlkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDY4MzcwMDQ1MjlcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFlsR24gPSByYW1wKHNjaGVtZSRpKTtcblxudmFyIHNjaGVtZSRqID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZmY3YmNmZWM0NGZkOTVmMGVcIixcbiAgXCJmZmZmZDRmZWQ5OGVmZTk5MjljYzRjMDJcIixcbiAgXCJmZmZmZDRmZWQ5OGVmZTk5MjlkOTVmMGU5OTM0MDRcIixcbiAgXCJmZmZmZDRmZWUzOTFmZWM0NGZmZTk5MjlkOTVmMGU5OTM0MDRcIixcbiAgXCJmZmZmZDRmZWUzOTFmZWM0NGZmZTk5MjllYzcwMTRjYzRjMDI4YzJkMDRcIixcbiAgXCJmZmZmZTVmZmY3YmNmZWUzOTFmZWM0NGZmZTk5MjllYzcwMTRjYzRjMDI4YzJkMDRcIixcbiAgXCJmZmZmZTVmZmY3YmNmZWUzOTFmZWM0NGZmZTk5MjllYzcwMTRjYzRjMDI5OTM0MDQ2NjI1MDZcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFlsT3JCciA9IHJhbXAoc2NoZW1lJGopO1xuXG52YXIgc2NoZW1lJGsgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZmZWRhMGZlYjI0Y2YwM2IyMFwiLFxuICBcImZmZmZiMmZlY2M1Y2ZkOGQzY2UzMWExY1wiLFxuICBcImZmZmZiMmZlY2M1Y2ZkOGQzY2YwM2IyMGJkMDAyNlwiLFxuICBcImZmZmZiMmZlZDk3NmZlYjI0Y2ZkOGQzY2YwM2IyMGJkMDAyNlwiLFxuICBcImZmZmZiMmZlZDk3NmZlYjI0Y2ZkOGQzY2ZjNGUyYWUzMWExY2IxMDAyNlwiLFxuICBcImZmZmZjY2ZmZWRhMGZlZDk3NmZlYjI0Y2ZkOGQzY2ZjNGUyYWUzMWExY2IxMDAyNlwiLFxuICBcImZmZmZjY2ZmZWRhMGZlZDk3NmZlYjI0Y2ZkOGQzY2ZjNGUyYWUzMWExY2JkMDAyNjgwMDAyNlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgWWxPclJkID0gcmFtcChzY2hlbWUkayk7XG5cbnZhciBzY2hlbWUkbCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZGVlYmY3OWVjYWUxMzE4MmJkXCIsXG4gIFwiZWZmM2ZmYmRkN2U3NmJhZWQ2MjE3MWI1XCIsXG4gIFwiZWZmM2ZmYmRkN2U3NmJhZWQ2MzE4MmJkMDg1MTljXCIsXG4gIFwiZWZmM2ZmYzZkYmVmOWVjYWUxNmJhZWQ2MzE4MmJkMDg1MTljXCIsXG4gIFwiZWZmM2ZmYzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg0NTk0XCIsXG4gIFwiZjdmYmZmZGVlYmY3YzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg0NTk0XCIsXG4gIFwiZjdmYmZmZGVlYmY3YzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg1MTljMDgzMDZiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBCbHVlcyA9IHJhbXAoc2NoZW1lJGwpO1xuXG52YXIgc2NoZW1lJG0gPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImU1ZjVlMGExZDk5YjMxYTM1NFwiLFxuICBcImVkZjhlOWJhZTRiMzc0YzQ3NjIzOGI0NVwiLFxuICBcImVkZjhlOWJhZTRiMzc0YzQ3NjMxYTM1NDAwNmQyY1wiLFxuICBcImVkZjhlOWM3ZTljMGExZDk5Yjc0YzQ3NjMxYTM1NDAwNmQyY1wiLFxuICBcImVkZjhlOWM3ZTljMGExZDk5Yjc0YzQ3NjQxYWI1ZDIzOGI0NTAwNWEzMlwiLFxuICBcImY3ZmNmNWU1ZjVlMGM3ZTljMGExZDk5Yjc0YzQ3NjQxYWI1ZDIzOGI0NTAwNWEzMlwiLFxuICBcImY3ZmNmNWU1ZjVlMGM3ZTljMGExZDk5Yjc0YzQ3NjQxYWI1ZDIzOGI0NTAwNmQyYzAwNDQxYlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgR3JlZW5zID0gcmFtcChzY2hlbWUkbSk7XG5cbnZhciBzY2hlbWUkbiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZjBmMGYwYmRiZGJkNjM2MzYzXCIsXG4gIFwiZjdmN2Y3Y2NjY2NjOTY5Njk2NTI1MjUyXCIsXG4gIFwiZjdmN2Y3Y2NjY2NjOTY5Njk2NjM2MzYzMjUyNTI1XCIsXG4gIFwiZjdmN2Y3ZDlkOWQ5YmRiZGJkOTY5Njk2NjM2MzYzMjUyNTI1XCIsXG4gIFwiZjdmN2Y3ZDlkOWQ5YmRiZGJkOTY5Njk2NzM3MzczNTI1MjUyMjUyNTI1XCIsXG4gIFwiZmZmZmZmZjBmMGYwZDlkOWQ5YmRiZGJkOTY5Njk2NzM3MzczNTI1MjUyMjUyNTI1XCIsXG4gIFwiZmZmZmZmZjBmMGYwZDlkOWQ5YmRiZGJkOTY5Njk2NzM3MzczNTI1MjUyMjUyNTI1MDAwMDAwXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBHcmV5cyA9IHJhbXAoc2NoZW1lJG4pO1xuXG52YXIgc2NoZW1lJG8gPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVmZWRmNWJjYmRkYzc1NmJiMVwiLFxuICBcImYyZjBmN2NiYzllMjllOWFjODZhNTFhM1wiLFxuICBcImYyZjBmN2NiYzllMjllOWFjODc1NmJiMTU0Mjc4ZlwiLFxuICBcImYyZjBmN2RhZGFlYmJjYmRkYzllOWFjODc1NmJiMTU0Mjc4ZlwiLFxuICBcImYyZjBmN2RhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzRhMTQ4NlwiLFxuICBcImZjZmJmZGVmZWRmNWRhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzRhMTQ4NlwiLFxuICBcImZjZmJmZGVmZWRmNWRhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzU0Mjc4ZjNmMDA3ZFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUHVycGxlcyA9IHJhbXAoc2NoZW1lJG8pO1xuXG52YXIgc2NoZW1lJHAgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZlZTBkMmZjOTI3MmRlMmQyNlwiLFxuICBcImZlZTVkOWZjYWU5MWZiNmE0YWNiMTgxZFwiLFxuICBcImZlZTVkOWZjYWU5MWZiNmE0YWRlMmQyNmE1MGYxNVwiLFxuICBcImZlZTVkOWZjYmJhMWZjOTI3MmZiNmE0YWRlMmQyNmE1MGYxNVwiLFxuICBcImZlZTVkOWZjYmJhMWZjOTI3MmZiNmE0YWVmM2IyY2NiMTgxZDk5MDAwZFwiLFxuICBcImZmZjVmMGZlZTBkMmZjYmJhMWZjOTI3MmZiNmE0YWVmM2IyY2NiMTgxZDk5MDAwZFwiLFxuICBcImZmZjVmMGZlZTBkMmZjYmJhMWZjOTI3MmZiNmE0YWVmM2IyY2NiMTgxZGE1MGYxNTY3MDAwZFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUmVkcyA9IHJhbXAoc2NoZW1lJHApO1xuXG52YXIgc2NoZW1lJHEgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZlZTZjZWZkYWU2YmU2NTUwZFwiLFxuICBcImZlZWRkZWZkYmU4NWZkOGQzY2Q5NDcwMVwiLFxuICBcImZlZWRkZWZkYmU4NWZkOGQzY2U2NTUwZGE2MzYwM1wiLFxuICBcImZlZWRkZWZkZDBhMmZkYWU2YmZkOGQzY2U2NTUwZGE2MzYwM1wiLFxuICBcImZlZWRkZWZkZDBhMmZkYWU2YmZkOGQzY2YxNjkxM2Q5NDgwMThjMmQwNFwiLFxuICBcImZmZjVlYmZlZTZjZWZkZDBhMmZkYWU2YmZkOGQzY2YxNjkxM2Q5NDgwMThjMmQwNFwiLFxuICBcImZmZjVlYmZlZTZjZWZkZDBhMmZkYWU2YmZkOGQzY2YxNjkxM2Q5NDgwMWE2MzYwMzdmMjcwNFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgT3JhbmdlcyA9IHJhbXAoc2NoZW1lJHEpO1xuXG5mdW5jdGlvbiBjaXZpZGlzKHQpIHtcbiAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcbiAgcmV0dXJuIFwicmdiKFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCgtNC41NCAtIHQgKiAoMzUuMzQgLSB0ICogKDIzODEuNzMgLSB0ICogKDY0MDIuNyAtIHQgKiAoNzAyNC43MiAtIHQgKiAyNzEwLjU3KSkpKSkpKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoMzIuNDkgKyB0ICogKDE3MC43MyArIHQgKiAoNTIuODIgLSB0ICogKDEzMS40NiAtIHQgKiAoMTc2LjU4IC0gdCAqIDY3LjM3KSkpKSkpKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoODEuMjQgKyB0ICogKDQ0Mi4zNiAtIHQgKiAoMjQ4Mi40MyAtIHQgKiAoNjE2Ny4yNCAtIHQgKiAoNjYxNC45NCAtIHQgKiAyNDc1LjY3KSkpKSkpKVxuICAgICAgKyBcIilcIjtcbn1cblxudmFyIGN1YmVoZWxpeCA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDMwMCwgMC41LCAwLjApLCBkM0NvbG9yLmN1YmVoZWxpeCgtMjQwLCAwLjUsIDEuMCkpO1xuXG52YXIgd2FybSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KC0xMDAsIDAuNzUsIDAuMzUpLCBkM0NvbG9yLmN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XG5cbnZhciBjb29sID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoMjYwLCAwLjc1LCAwLjM1KSwgZDNDb2xvci5jdWJlaGVsaXgoODAsIDEuNTAsIDAuOCkpO1xuXG52YXIgYyA9IGQzQ29sb3IuY3ViZWhlbGl4KCk7XG5cbmZ1bmN0aW9uIHJhaW5ib3codCkge1xuICBpZiAodCA8IDAgfHwgdCA+IDEpIHQgLT0gTWF0aC5mbG9vcih0KTtcbiAgdmFyIHRzID0gTWF0aC5hYnModCAtIDAuNSk7XG4gIGMuaCA9IDM2MCAqIHQgLSAxMDA7XG4gIGMucyA9IDEuNSAtIDEuNSAqIHRzO1xuICBjLmwgPSAwLjggLSAwLjkgKiB0cztcbiAgcmV0dXJuIGMgKyBcIlwiO1xufVxuXG52YXIgYyQxID0gZDNDb2xvci5yZ2IoKSxcbiAgICBwaV8xXzMgPSBNYXRoLlBJIC8gMyxcbiAgICBwaV8yXzMgPSBNYXRoLlBJICogMiAvIDM7XG5cbmZ1bmN0aW9uIHNpbmVib3codCkge1xuICB2YXIgeDtcbiAgdCA9ICgwLjUgLSB0KSAqIE1hdGguUEk7XG4gIGMkMS5yID0gMjU1ICogKHggPSBNYXRoLnNpbih0KSkgKiB4O1xuICBjJDEuZyA9IDI1NSAqICh4ID0gTWF0aC5zaW4odCArIHBpXzFfMykpICogeDtcbiAgYyQxLmIgPSAyNTUgKiAoeCA9IE1hdGguc2luKHQgKyBwaV8yXzMpKSAqIHg7XG4gIHJldHVybiBjJDEgKyBcIlwiO1xufVxuXG5mdW5jdGlvbiB0dXJibyh0KSB7XG4gIHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0KSk7XG4gIHJldHVybiBcInJnYihcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoMzQuNjEgKyB0ICogKDExNzIuMzMgLSB0ICogKDEwNzkzLjU2IC0gdCAqICgzMzMwMC4xMiAtIHQgKiAoMzgzOTQuNDkgLSB0ICogMTQ4MjUuMDUpKSkpKSkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCgyMy4zMSArIHQgKiAoNTU3LjMzICsgdCAqICgxMjI1LjMzIC0gdCAqICgzNTc0Ljk2IC0gdCAqICgxMDczLjc3ICsgdCAqIDcwNy41NikpKSkpKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKDI3LjIgKyB0ICogKDMyMTEuMSAtIHQgKiAoMTUzMjcuOTcgLSB0ICogKDI3ODE0IC0gdCAqICgyMjU2OS4xOCAtIHQgKiA2ODM4LjY2KSkpKSkpKVxuICAgICAgKyBcIilcIjtcbn1cblxuZnVuY3Rpb24gcmFtcCQxKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG5cbnZhciB2aXJpZGlzID0gcmFtcCQxKGNvbG9ycyhcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSk7XG5cbnZhciBtYWdtYSA9IHJhbXAkMShjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMDkwMjAyMGIwMjAyMGQwMzAzMGYwMzAzMTIwNDA0MTQwNTA0MTYwNjA1MTgwNjA1MWEwNzA2MWMwODA3MWUwOTA3MjAwYTA4MjIwYjA5MjQwYzA5MjYwZDBhMjkwZTBiMmIxMDBiMmQxMTBjMmYxMjBkMzExMzBkMzQxNDBlMzYxNTBlMzgxNjBmM2IxODBmM2QxOTEwM2YxYTEwNDIxYzEwNDQxZDExNDcxZTExNDkyMDExNGIyMTExNGUyMjExNTAyNDEyNTMyNTEyNTUyNzEyNTgyOTExNWEyYTExNWMyYzExNWYyZDExNjEyZjExNjMzMTExNjUzMzEwNjczNDEwNjkzNjEwNmIzODEwNmMzOTBmNmUzYjBmNzAzZDBmNzEzZjBmNzI0MDBmNzQ0MjBmNzU0NDBmNzY0NTEwNzc0NzEwNzg0OTEwNzg0YTEwNzk0YzExN2E0ZTExN2I0ZjEyN2I1MTEyN2M1MjEzN2M1NDEzN2Q1NjE0N2Q1NzE1N2U1OTE1N2U1YTE2N2U1YzE2N2Y1ZDE3N2Y1ZjE4N2Y2MDE4ODA2MjE5ODA2NDFhODA2NTFhODA2NzFiODA2ODFjODE2YTFjODE2YjFkODE2ZDFkODE2ZTFlODE3MDFmODE3MjFmODE3MzIwODE3NTIxODE3NjIxODE3ODIyODE3OTIyODI3YjIzODI3YzIzODI3ZTI0ODI4MDI1ODI4MTI1ODE4MzI2ODE4NDI2ODE4NjI3ODE4ODI3ODE4OTI4ODE4YjI5ODE4YzI5ODE4ZTJhODE5MDJhODE5MTJiODE5MzJiODA5NDJjODA5NjJjODA5ODJkODA5OTJkODA5YjJlN2Y5YzJlN2Y5ZTJmN2ZhMDJmN2ZhMTMwN2VhMzMwN2VhNTMxN2VhNjMxN2RhODMyN2RhYTMzN2RhYjMzN2NhZDM0N2NhZTM0N2JiMDM1N2JiMjM1N2JiMzM2N2FiNTM2N2FiNzM3NzliODM3NzliYTM4NzhiYzM5NzhiZDM5NzdiZjNhNzdjMDNhNzZjMjNiNzVjNDNjNzVjNTNjNzRjNzNkNzNjODNlNzNjYTNlNzJjYzNmNzFjZDQwNzFjZjQwNzBkMDQxNmZkMjQyNmZkMzQzNmVkNTQ0NmRkNjQ1NmNkODQ1NmNkOTQ2NmJkYjQ3NmFkYzQ4NjlkZTQ5NjhkZjRhNjhlMDRjNjdlMjRkNjZlMzRlNjVlNDRmNjRlNTUwNjRlNzUyNjNlODUzNjJlOTU0NjJlYTU2NjFlYjU3NjBlYzU4NjBlZDVhNWZlZTViNWVlZjVkNWVmMDVmNWVmMTYwNWRmMjYyNWRmMjY0NWNmMzY1NWNmNDY3NWNmNDY5NWNmNTZiNWNmNjZjNWNmNjZlNWNmNzcwNWNmNzcyNWNmODc0NWNmODc2NWNmOTc4NWRmOTc5NWRmOTdiNWRmYTdkNWVmYTdmNWVmYTgxNWZmYjgzNWZmYjg1NjBmYjg3NjFmYzg5NjFmYzhhNjJmYzhjNjNmYzhlNjRmYzkwNjVmZDkyNjZmZDk0NjdmZDk2NjhmZDk4NjlmZDlhNmFmZDliNmJmZTlkNmNmZTlmNmRmZWExNmVmZWEzNmZmZWE1NzFmZWE3NzJmZWE5NzNmZWFhNzRmZWFjNzZmZWFlNzdmZWIwNzhmZWIyN2FmZWI0N2JmZWI2N2NmZWI3N2VmZWI5N2ZmZWJiODFmZWJkODJmZWJmODRmZWMxODVmZWMyODdmZWM0ODhmZWM2OGFmZWM4OGNmZWNhOGRmZWNjOGZmZWNkOTBmZWNmOTJmZWQxOTRmZWQzOTVmZWQ1OTdmZWQ3OTlmZWQ4OWFmZGRhOWNmZGRjOWVmZGRlYTBmZGUwYTFmZGUyYTNmZGUzYTVmZGU1YTdmZGU3YTlmZGU5YWFmZGViYWNmY2VjYWVmY2VlYjBmY2YwYjJmY2YyYjRmY2Y0YjZmY2Y2YjhmY2Y3YjlmY2Y5YmJmY2ZiYmRmY2ZkYmZcIikpO1xuXG52YXIgaW5mZXJubyA9IHJhbXAkMShjb2xvcnMoXCIwMDAwMDQwMTAwMDUwMTAxMDYwMTAxMDgwMjAxMGEwMjAyMGMwMjAyMGUwMzAyMTAwNDAzMTIwNDAzMTQwNTA0MTcwNjA0MTkwNzA1MWIwODA1MWQwOTA2MWYwYTA3MjIwYjA3MjQwYzA4MjYwZDA4MjkwZTA5MmIxMDA5MmQxMTBhMzAxMjBhMzIxNDBiMzQxNTBiMzcxNjBiMzkxODBjM2MxOTBjM2UxYjBjNDExYzBjNDMxZTBjNDUxZjBjNDgyMTBjNGEyMzBjNGMyNDBjNGYyNjBjNTEyODBiNTMyOTBiNTUyYjBiNTcyZDBiNTkyZjBhNWIzMTBhNWMzMjBhNWUzNDBhNWYzNjA5NjEzODA5NjIzOTA5NjMzYjA5NjQzZDA5NjUzZTA5NjY0MDBhNjc0MjBhNjg0NDBhNjg0NTBhNjk0NzBiNmE0OTBiNmE0YTBjNmI0YzBjNmI0ZDBkNmM0ZjBkNmM1MTBlNmM1MjBlNmQ1NDBmNmQ1NTBmNmQ1NzEwNmU1OTEwNmU1YTExNmU1YzEyNmU1ZDEyNmU1ZjEzNmU2MTEzNmU2MjE0NmU2NDE1NmU2NTE1NmU2NzE2NmU2OTE2NmU2YTE3NmU2YzE4NmU2ZDE4NmU2ZjE5NmU3MTE5NmU3MjFhNmU3NDFhNmU3NTFiNmU3NzFjNmQ3ODFjNmQ3YTFkNmQ3YzFkNmQ3ZDFlNmQ3ZjFlNmM4MDFmNmM4MjIwNmM4NDIwNmI4NTIxNmI4NzIxNmI4ODIyNmE4YTIyNmE4YzIzNjk4ZDIzNjk4ZjI0Njk5MDI1Njg5MjI1Njg5MzI2Njc5NTI2Njc5NzI3NjY5ODI3NjY5YTI4NjU5YjI5NjQ5ZDI5NjQ5ZjJhNjNhMDJhNjNhMjJiNjJhMzJjNjFhNTJjNjBhNjJkNjBhODJlNWZhOTJlNWVhYjJmNWVhZDMwNWRhZTMwNWNiMDMxNWJiMTMyNWFiMzMyNWFiNDMzNTliNjM0NThiNzM1NTdiOTM1NTZiYTM2NTViYzM3NTRiZDM4NTNiZjM5NTJjMDNhNTFjMTNhNTBjMzNiNGZjNDNjNGVjNjNkNGRjNzNlNGNjODNmNGJjYTQwNGFjYjQxNDljYzQyNDhjZTQzNDdjZjQ0NDZkMDQ1NDVkMjQ2NDRkMzQ3NDNkNDQ4NDJkNTRhNDFkNzRiM2ZkODRjM2VkOTRkM2RkYTRlM2NkYjUwM2JkZDUxM2FkZTUyMzhkZjUzMzdlMDU1MzZlMTU2MzVlMjU3MzRlMzU5MzNlNDVhMzFlNTVjMzBlNjVkMmZlNzVlMmVlODYwMmRlOTYxMmJlYTYzMmFlYjY0MjllYjY2MjhlYzY3MjZlZDY5MjVlZTZhMjRlZjZjMjNlZjZlMjFmMDZmMjBmMTcxMWZmMTczMWRmMjc0MWNmMzc2MWJmMzc4MTlmNDc5MThmNTdiMTdmNTdkMTVmNjdlMTRmNjgwMTNmNzgyMTJmNzg0MTBmODg1MGZmODg3MGVmODg5MGNmOThiMGJmOThjMGFmOThlMDlmYTkwMDhmYTkyMDdmYTk0MDdmYjk2MDZmYjk3MDZmYjk5MDZmYjliMDZmYjlkMDdmYzlmMDdmY2ExMDhmY2EzMDlmY2E1MGFmY2E2MGNmY2E4MGRmY2FhMGZmY2FjMTFmY2FlMTJmY2IwMTRmY2IyMTZmY2I0MThmYmI2MWFmYmI4MWRmYmJhMWZmYmJjMjFmYmJlMjNmYWMwMjZmYWMyMjhmYWM0MmFmYWM2MmRmOWM3MmZmOWM5MzJmOWNiMzVmOGNkMzdmOGNmM2FmN2QxM2RmN2QzNDBmNmQ1NDNmNmQ3NDZmNWQ5NDlmNWRiNGNmNGRkNGZmNGRmNTNmNGUxNTZmM2UzNWFmM2U1NWRmMmU2NjFmMmU4NjVmMmVhNjlmMWVjNmRmMWVkNzFmMWVmNzVmMWYxNzlmMmYyN2RmMmY0ODJmM2Y1ODZmM2Y2OGFmNGY4OGVmNWY5OTJmNmZhOTZmOGZiOWFmOWZjOWRmYWZkYTFmY2ZmYTRcIikpO1xuXG52YXIgcGxhc21hID0gcmFtcCQxKGNvbG9ycyhcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSk7XG5cbmV4cG9ydHMuaW50ZXJwb2xhdGVCbHVlcyA9IEJsdWVzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJyQkcgPSBCckJHO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJ1R24gPSBCdUduO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJ1UHUgPSBCdVB1O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUNpdmlkaXMgPSBjaXZpZGlzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUNvb2wgPSBjb29sO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeERlZmF1bHQgPSBjdWJlaGVsaXg7XG5leHBvcnRzLmludGVycG9sYXRlR25CdSA9IEduQnU7XG5leHBvcnRzLmludGVycG9sYXRlR3JlZW5zID0gR3JlZW5zO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUdyZXlzID0gR3JleXM7XG5leHBvcnRzLmludGVycG9sYXRlSW5mZXJubyA9IGluZmVybm87XG5leHBvcnRzLmludGVycG9sYXRlTWFnbWEgPSBtYWdtYTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPclJkID0gT3JSZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPcmFuZ2VzID0gT3JhbmdlcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVQUkduID0gUFJHbjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVQaVlHID0gUGlZRztcbmV4cG9ydHMuaW50ZXJwb2xhdGVQbGFzbWEgPSBwbGFzbWE7XG5leHBvcnRzLmludGVycG9sYXRlUHVCdSA9IFB1QnU7XG5leHBvcnRzLmludGVycG9sYXRlUHVCdUduID0gUHVCdUduO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVB1T3IgPSBQdU9yO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVB1UmQgPSBQdVJkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVB1cnBsZXMgPSBQdXJwbGVzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJhaW5ib3cgPSByYWluYm93O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJkQnUgPSBSZEJ1O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJkR3kgPSBSZEd5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJkUHUgPSBSZFB1O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJkWWxCdSA9IFJkWWxCdTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZFlsR24gPSBSZFlsR247XG5leHBvcnRzLmludGVycG9sYXRlUmVkcyA9IFJlZHM7XG5leHBvcnRzLmludGVycG9sYXRlU2luZWJvdyA9IHNpbmVib3c7XG5leHBvcnRzLmludGVycG9sYXRlU3BlY3RyYWwgPSBTcGVjdHJhbDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVUdXJibyA9IHR1cmJvO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVZpcmlkaXMgPSB2aXJpZGlzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVdhcm0gPSB3YXJtO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVlsR24gPSBZbEduO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVlsR25CdSA9IFlsR25CdTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVZbE9yQnIgPSBZbE9yQnI7XG5leHBvcnRzLmludGVycG9sYXRlWWxPclJkID0gWWxPclJkO1xuZXhwb3J0cy5zY2hlbWVBY2NlbnQgPSBBY2NlbnQ7XG5leHBvcnRzLnNjaGVtZUJsdWVzID0gc2NoZW1lJGw7XG5leHBvcnRzLnNjaGVtZUJyQkcgPSBzY2hlbWU7XG5leHBvcnRzLnNjaGVtZUJ1R24gPSBzY2hlbWUkOTtcbmV4cG9ydHMuc2NoZW1lQnVQdSA9IHNjaGVtZSRhO1xuZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTEwID0gY2F0ZWdvcnkxMDtcbmV4cG9ydHMuc2NoZW1lRGFyazIgPSBEYXJrMjtcbmV4cG9ydHMuc2NoZW1lR25CdSA9IHNjaGVtZSRiO1xuZXhwb3J0cy5zY2hlbWVHcmVlbnMgPSBzY2hlbWUkbTtcbmV4cG9ydHMuc2NoZW1lR3JleXMgPSBzY2hlbWUkbjtcbmV4cG9ydHMuc2NoZW1lT3JSZCA9IHNjaGVtZSRjO1xuZXhwb3J0cy5zY2hlbWVPcmFuZ2VzID0gc2NoZW1lJHE7XG5leHBvcnRzLnNjaGVtZVBSR24gPSBzY2hlbWUkMTtcbmV4cG9ydHMuc2NoZW1lUGFpcmVkID0gUGFpcmVkO1xuZXhwb3J0cy5zY2hlbWVQYXN0ZWwxID0gUGFzdGVsMTtcbmV4cG9ydHMuc2NoZW1lUGFzdGVsMiA9IFBhc3RlbDI7XG5leHBvcnRzLnNjaGVtZVBpWUcgPSBzY2hlbWUkMjtcbmV4cG9ydHMuc2NoZW1lUHVCdSA9IHNjaGVtZSRlO1xuZXhwb3J0cy5zY2hlbWVQdUJ1R24gPSBzY2hlbWUkZDtcbmV4cG9ydHMuc2NoZW1lUHVPciA9IHNjaGVtZSQzO1xuZXhwb3J0cy5zY2hlbWVQdVJkID0gc2NoZW1lJGY7XG5leHBvcnRzLnNjaGVtZVB1cnBsZXMgPSBzY2hlbWUkbztcbmV4cG9ydHMuc2NoZW1lUmRCdSA9IHNjaGVtZSQ0O1xuZXhwb3J0cy5zY2hlbWVSZEd5ID0gc2NoZW1lJDU7XG5leHBvcnRzLnNjaGVtZVJkUHUgPSBzY2hlbWUkZztcbmV4cG9ydHMuc2NoZW1lUmRZbEJ1ID0gc2NoZW1lJDY7XG5leHBvcnRzLnNjaGVtZVJkWWxHbiA9IHNjaGVtZSQ3O1xuZXhwb3J0cy5zY2hlbWVSZWRzID0gc2NoZW1lJHA7XG5leHBvcnRzLnNjaGVtZVNldDEgPSBTZXQxO1xuZXhwb3J0cy5zY2hlbWVTZXQyID0gU2V0MjtcbmV4cG9ydHMuc2NoZW1lU2V0MyA9IFNldDM7XG5leHBvcnRzLnNjaGVtZVNwZWN0cmFsID0gc2NoZW1lJDg7XG5leHBvcnRzLnNjaGVtZVRhYmxlYXUxMCA9IFRhYmxlYXUxMDtcbmV4cG9ydHMuc2NoZW1lWWxHbiA9IHNjaGVtZSRpO1xuZXhwb3J0cy5zY2hlbWVZbEduQnUgPSBzY2hlbWUkaDtcbmV4cG9ydHMuc2NoZW1lWWxPckJyID0gc2NoZW1lJGo7XG5leHBvcnRzLnNjaGVtZVlsT3JSZCA9IHNjaGVtZSRrO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNjYWxlLyB2Mi4yLjIgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWFycmF5JyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLWZvcm1hdCcpLCByZXF1aXJlKCdkMy10aW1lJyksIHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0JykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtY29sbGVjdGlvbicsICdkMy1hcnJheScsICdkMy1pbnRlcnBvbGF0ZScsICdkMy1mb3JtYXQnLCAnZDMtdGltZScsICdkMy10aW1lLWZvcm1hdCddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNDb2xsZWN0aW9uLGQzQXJyYXksZDNJbnRlcnBvbGF0ZSxkM0Zvcm1hdCxkM1RpbWUsZDNUaW1lRm9ybWF0KSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaW5pdFJhbmdlKGRvbWFpbiwgcmFuZ2UpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMucmFuZ2UoZG9tYWluKTsgYnJlYWs7XG4gICAgZGVmYXVsdDogdGhpcy5yYW5nZShyYW5nZSkuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJwb2xhdG9yKGRvbWFpbiwgaW50ZXJwb2xhdG9yKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLmludGVycG9sYXRvcihkb21haW4pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLmludGVycG9sYXRvcihpbnRlcnBvbGF0b3IpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgbWFwID0gYXJyYXkubWFwO1xudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG5cbnZhciBpbXBsaWNpdCA9IHtuYW1lOiBcImltcGxpY2l0XCJ9O1xuXG5mdW5jdGlvbiBvcmRpbmFsKCkge1xuICB2YXIgaW5kZXggPSBkM0NvbGxlY3Rpb24ubWFwKCksXG4gICAgICBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgZnVuY3Rpb24gc2NhbGUoZCkge1xuICAgIHZhciBrZXkgPSBkICsgXCJcIiwgaSA9IGluZGV4LmdldChrZXkpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKHVua25vd24gIT09IGltcGxpY2l0KSByZXR1cm4gdW5rbm93bjtcbiAgICAgIGluZGV4LnNldChrZXksIGkgPSBkb21haW4ucHVzaChkKSk7XG4gICAgfVxuICAgIHJldHVybiByYW5nZVsoaSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXSwgaW5kZXggPSBkM0NvbGxlY3Rpb24ubWFwKCk7XG4gICAgdmFyIGkgPSAtMSwgbiA9IF8ubGVuZ3RoLCBkLCBrZXk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKGtleSA9IChkID0gX1tpXSkgKyBcIlwiKSkgaW5kZXguc2V0KGtleSwgZG9tYWluLnB1c2goZCkpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9yZGluYWwoZG9tYWluLCByYW5nZSkudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBiYW5kKCkge1xuICB2YXIgc2NhbGUgPSBvcmRpbmFsKCkudW5rbm93bih1bmRlZmluZWQpLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgb3JkaW5hbFJhbmdlID0gc2NhbGUucmFuZ2UsXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHN0ZXAsXG4gICAgICBiYW5kd2lkdGgsXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgcGFkZGluZ0lubmVyID0gMCxcbiAgICAgIHBhZGRpbmdPdXRlciA9IDAsXG4gICAgICBhbGlnbiA9IDAuNTtcblxuICBkZWxldGUgc2NhbGUudW5rbm93bjtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICByZXZlcnNlID0gcmFuZ2VbMV0gPCByYW5nZVswXSxcbiAgICAgICAgc3RhcnQgPSByYW5nZVtyZXZlcnNlIC0gMF0sXG4gICAgICAgIHN0b3AgPSByYW5nZVsxIC0gcmV2ZXJzZV07XG4gICAgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMSwgbiAtIHBhZGRpbmdJbm5lciArIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgIGlmIChyb3VuZCkgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgc3RhcnQgKz0gKHN0b3AgLSBzdGFydCAtIHN0ZXAgKiAobiAtIHBhZGRpbmdJbm5lcikpICogYWxpZ247XG4gICAgYmFuZHdpZHRoID0gc3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICBpZiAocm91bmQpIHN0YXJ0ID0gTWF0aC5yb3VuZChzdGFydCksIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB2YXIgdmFsdWVzID0gZDNBcnJheS5yYW5nZShuKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gc3RhcnQgKyBzdGVwICogaTsgfSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBbK19bMF0sICtfWzFdXSwgcm91bmQgPSB0cnVlLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcblxuICBzY2FsZS5zdGVwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH07XG5cbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIV8sIHJlc2NhbGUoKSkgOiByb3VuZDtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWluKDEsIHBhZGRpbmdPdXRlciA9ICtfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgXyksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9ICtfLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKGRvbWFpbigpLCByYW5nZSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShyZXNjYWxlKCksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIHZhciBjb3B5ID0gc2NhbGUuY29weTtcblxuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ091dGVyO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcG9pbnRpc2goY29weSgpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHBvaW50KCkge1xuICByZXR1cm4gcG9pbnRpc2goYmFuZC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhZGRpbmdJbm5lcigxKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBudW1iZXIoeCkge1xuICByZXR1cm4gK3g7XG59XG5cbnZhciB1bml0ID0gWzAsIDFdO1xuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUoYSwgYikge1xuICByZXR1cm4gKGIgLT0gKGEgPSArYSkpXG4gICAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICh4IC0gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50KGlzTmFOKGIpID8gTmFOIDogMC41KTtcbn1cblxuZnVuY3Rpb24gY2xhbXBlcihkb21haW4pIHtcbiAgdmFyIGEgPSBkb21haW5bMF0sIGIgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdLCB0O1xuICBpZiAoYSA+IGIpIHQgPSBhLCBhID0gYiwgYiA9IHQ7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLm1heChhLCBNYXRoLm1pbihiLCB4KSk7IH07XG59XG5cbi8vIG5vcm1hbGl6ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gaW50ZXJwb2xhdGUoYSwgYikodCkgdGFrZXMgYSBwYXJhbWV0ZXIgdCBpbiBbMCwxXSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByYW5nZSB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGQwID0gZG9tYWluWzBdLCBkMSA9IGRvbWFpblsxXSwgcjAgPSByYW5nZVswXSwgcjEgPSByYW5nZVsxXTtcbiAgaWYgKGQxIDwgZDApIGQwID0gbm9ybWFsaXplKGQxLCBkMCksIHIwID0gaW50ZXJwb2xhdGUocjEsIHIwKTtcbiAgZWxzZSBkMCA9IG5vcm1hbGl6ZShkMCwgZDEpLCByMCA9IGludGVycG9sYXRlKHIwLCByMSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiByMChkMCh4KSk7IH07XG59XG5cbmZ1bmN0aW9uIHBvbHltYXAoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpIC0gMSxcbiAgICAgIGQgPSBuZXcgQXJyYXkoaiksXG4gICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgaSA9IC0xO1xuXG4gIC8vIFJldmVyc2UgZGVzY2VuZGluZyBkb21haW5zLlxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoKytpIDwgaikge1xuICAgIGRbaV0gPSBub3JtYWxpemUoZG9tYWluW2ldLCBkb21haW5baSArIDFdKTtcbiAgICByW2ldID0gaW50ZXJwb2xhdGUocmFuZ2VbaV0sIHJhbmdlW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpID0gZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdW50cmFuc2Zvcm0sXG4gICAgICB1bmtub3duLFxuICAgICAgY2xhbXAgPSBpZGVudGl0eSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcGllY2V3aXNlID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSA+IDIgPyBwb2x5bWFwIDogYmltYXA7XG4gICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCByYW5nZSwgaW50ZXJwb2xhdGUpKSkodHJhbnNmb3JtKGNsYW1wKHgpKSk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIGNsYW1wKHVudHJhbnNmb3JtKChpbnB1dCB8fCAoaW5wdXQgPSBwaWVjZXdpc2UocmFuZ2UsIGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZU51bWJlcikpKSh5KSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBjbGFtcCA9PT0gaWRlbnRpdHkgfHwgKGNsYW1wID0gY2xhbXBlcihkb21haW4pKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gXyA/IGNsYW1wZXIoZG9tYWluKSA6IGlkZW50aXR5LCBzY2FsZSkgOiBjbGFtcCAhPT0gaWRlbnRpdHk7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCwgdSkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHVudHJhbnNmb3JtID0gdTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb250aW51b3VzKHRyYW5zZm9ybSwgdW50cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKCkodHJhbnNmb3JtLCB1bnRyYW5zZm9ybSk7XG59XG5cbmZ1bmN0aW9uIHRpY2tGb3JtYXQoc3RhcnQsIHN0b3AsIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCksXG4gICAgICBwcmVjaXNpb247XG4gIHNwZWNpZmllciA9IGQzRm9ybWF0LmZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIgPT0gbnVsbCA/IFwiLGZcIiA6IHNwZWNpZmllcik7XG4gIHN3aXRjaCAoc3BlY2lmaWVyLnR5cGUpIHtcbiAgICBjYXNlIFwic1wiOiB7XG4gICAgICB2YXIgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IGQzRm9ybWF0LnByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICAgICAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgY2FzZSBcIlwiOlxuICAgIGNhc2UgXCJlXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJyXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IGQzRm9ybWF0LnByZWNpc2lvblJvdW5kKHN0ZXAsIE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiZVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZlwiOlxuICAgIGNhc2UgXCIlXCI6IHtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwgJiYgIWlzTmFOKHByZWNpc2lvbiA9IGQzRm9ybWF0LnByZWNpc2lvbkZpeGVkKHN0ZXApKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCIlXCIpICogMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZDNGb3JtYXQuZm9ybWF0KHNwZWNpZmllcik7XG59XG5cbmZ1bmN0aW9uIGxpbmVhcmlzaChzY2FsZSkge1xuICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiBkM0FycmF5LnRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuXG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgaTAgPSAwLFxuICAgICAgICBpMSA9IGQubGVuZ3RoIC0gMSxcbiAgICAgICAgc3RhcnQgPSBkW2kwXSxcbiAgICAgICAgc3RvcCA9IGRbaTFdLFxuICAgICAgICBzdGVwO1xuXG4gICAgaWYgKHN0b3AgPCBzdGFydCkge1xuICAgICAgc3RlcCA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBzdGVwO1xuICAgICAgc3RlcCA9IGkwLCBpMCA9IGkxLCBpMSA9IHN0ZXA7XG4gICAgfVxuXG4gICAgc3RlcCA9IGQzQXJyYXkudGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RlcCA9IGQzQXJyYXkudGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5mbG9vcihzdG9wICogc3RlcCkgLyBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGxpbmVhcigpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbGluZWFyKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkkMShkb21haW4pIHtcbiAgdmFyIHVua25vd247XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHg7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBzY2FsZTtcblxuICBzY2FsZS5kb21haW4gPSBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAuY2FsbChfLCBudW1iZXIpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkkMShkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgZG9tYWluID0gYXJndW1lbnRzLmxlbmd0aCA/IG1hcC5jYWxsKGRvbWFpbiwgbnVtYmVyKSA6IFswLCAxXTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gbmljZShkb21haW4sIGludGVydmFsKSB7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuXG4gIHZhciBpMCA9IDAsXG4gICAgICBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLFxuICAgICAgeDAgPSBkb21haW5baTBdLFxuICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgdDtcblxuICBpZiAoeDEgPCB4MCkge1xuICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICB9XG5cbiAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgZG9tYWluW2kxXSA9IGludGVydmFsLmNlaWwoeDEpO1xuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2coeCkge1xuICByZXR1cm4gTWF0aC5sb2coeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cCh4KSB7XG4gIHJldHVybiBNYXRoLmV4cCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nbih4KSB7XG4gIHJldHVybiAtTWF0aC5sb2coLXgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHBuKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmV4cCgteCk7XG59XG5cbmZ1bmN0aW9uIHBvdzEwKHgpIHtcbiAgcmV0dXJuIGlzRmluaXRlKHgpID8gKyhcIjFlXCIgKyB4KSA6IHggPCAwID8gMCA6IHg7XG59XG5cbmZ1bmN0aW9uIHBvd3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gMTAgPyBwb3cxMFxuICAgICAgOiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmV4cFxuICAgICAgOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnBvdyhiYXNlLCB4KTsgfTtcbn1cblxuZnVuY3Rpb24gbG9ncChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSBNYXRoLkUgPyBNYXRoLmxvZ1xuICAgICAgOiBiYXNlID09PSAxMCAmJiBNYXRoLmxvZzEwXG4gICAgICB8fCBiYXNlID09PSAyICYmIE1hdGgubG9nMlxuICAgICAgfHwgKGJhc2UgPSBNYXRoLmxvZyhiYXNlKSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5sb2coeCkgLyBiYXNlOyB9KTtcbn1cblxuZnVuY3Rpb24gcmVmbGVjdChmKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIC1mKC14KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbG9nZ2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MsXG4gICAgICBwb3dzO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgbG9ncyA9IGxvZ3AoYmFzZSksIHBvd3MgPSBwb3dwKGJhc2UpO1xuICAgIGlmIChkb21haW4oKVswXSA8IDApIHtcbiAgICAgIGxvZ3MgPSByZWZsZWN0KGxvZ3MpLCBwb3dzID0gcmVmbGVjdChwb3dzKTtcbiAgICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1Mb2duLCB0cmFuc2Zvcm1FeHBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZywgdHJhbnNmb3JtRXhwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGgucm91bmQoaSkgLSAxLCBqID0gTWF0aC5yb3VuZChqKSArIDE7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IGQzQXJyYXkudGlja3MoaSwgaiwgTWF0aC5taW4oaiAtIGksIG4pKS5tYXAocG93cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgIGlmICh0eXBlb2Ygc3BlY2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHNwZWNpZmllciA9IGQzRm9ybWF0LmZvcm1hdChzcGVjaWZpZXIpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7IC8vIFRPRE8gZmFzdCBlc3RpbWF0ZT9cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSk7IH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIoKSkuZG9tYWluKFsxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TeW1sb2coYykge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWV4cChjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGguZXhwbTEoTWF0aC5hYnMoeCkpICogYztcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3ltbG9naXNoKHRyYW5zZm9ybSkge1xuICB2YXIgYyA9IDEsIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjKSwgdHJhbnNmb3JtU3ltZXhwKGMpKTtcblxuICBzY2FsZS5jb25zdGFudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyA9ICtfKSwgdHJhbnNmb3JtU3ltZXhwKGMpKSA6IGM7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIHN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvdyhleHBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXJ0KHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLU1hdGguc3FydCgteCkgOiBNYXRoLnNxcnQoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxdWFyZSh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC14ICogeCA6IHggKiB4O1xufVxuXG5mdW5jdGlvbiBwb3dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBzY2FsZSA9IHRyYW5zZm9ybShpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgZXhwb25lbnQgPSAxO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcmV0dXJuIGV4cG9uZW50ID09PSAxID8gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSlcbiAgICAgICAgOiBleHBvbmVudCA9PT0gMC41ID8gdHJhbnNmb3JtKHRyYW5zZm9ybVNxcnQsIHRyYW5zZm9ybVNxdWFyZSlcbiAgICAgICAgOiB0cmFuc2Zvcm0odHJhbnNmb3JtUG93KGV4cG9uZW50KSwgdHJhbnNmb3JtUG93KDEgLyBleHBvbmVudCkpO1xuICB9XG5cbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgcmVzY2FsZSgpKSA6IGV4cG9uZW50O1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBwb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdygpKS5leHBvbmVudChzY2FsZS5leHBvbmVudCgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBzcXJ0KCkge1xuICByZXR1cm4gcG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpbGUoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlID0gW10sXG4gICAgICB0aHJlc2hvbGRzID0gW10sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gTWF0aC5tYXgoMSwgcmFuZ2UubGVuZ3RoKTtcbiAgICB0aHJlc2hvbGRzID0gbmV3IEFycmF5KG4gLSAxKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGhyZXNob2xkc1tpIC0gMV0gPSBkM0FycmF5LnF1YW50aWxlKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiByYW5nZVtkM0FycmF5LmJpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gIH1cblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBpID4gMCA/IHRocmVzaG9sZHNbaSAtIDFdIDogZG9tYWluWzBdLFxuICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IF8ubGVuZ3RoLCBkOyBpIDwgbjsgKytpKSBpZiAoZCA9IF9baV0sIGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoZDNBcnJheS5hc2NlbmRpbmcpO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgbiA9IDEsXG4gICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPD0geCA/IHJhbmdlW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBzbGljZS5jYWxsKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdGhyZXNob2xkKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSA9IFswLCAxXSxcbiAgICAgIHVua25vd24sXG4gICAgICBuID0gMTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPD0geCA/IHJhbmdlW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildIDogdW5rbm93bjtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlKVxuICAgICAgICAudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG52YXIgZHVyYXRpb25TZWNvbmQgPSAxMDAwLFxuICAgIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MCxcbiAgICBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwLFxuICAgIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQsXG4gICAgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3LFxuICAgIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwLFxuICAgIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG5mdW5jdGlvbiBkYXRlKHQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHQpO1xufVxuXG5mdW5jdGlvbiBudW1iZXIkMSh0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhpZGVudGl0eSwgaWRlbnRpdHkpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91cihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhcihkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGQzQXJyYXkuYmlzZWN0b3IoZnVuY3Rpb24oaSkgeyByZXR1cm4gaVsyXTsgfSkucmlnaHQodGlja0ludGVydmFscywgdGFyZ2V0KTtcbiAgICAgIGlmIChpID09PSB0aWNrSW50ZXJ2YWxzLmxlbmd0aCkge1xuICAgICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgaW50ZXJ2YWwpO1xuICAgICAgICBpbnRlcnZhbCA9IHllYXI7XG4gICAgICB9IGVsc2UgaWYgKGkpIHtcbiAgICAgICAgaSA9IHRpY2tJbnRlcnZhbHNbdGFyZ2V0IC8gdGlja0ludGVydmFsc1tpIC0gMV1bMl0gPCB0aWNrSW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICAgICAgc3RlcCA9IGlbMV07XG4gICAgICAgIGludGVydmFsID0gaVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXAgPSBNYXRoLm1heChkM0FycmF5LnRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCksIDEpO1xuICAgICAgICBpbnRlcnZhbCA9IG1pbGxpc2Vjb25kO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGVwID09IG51bGwgPyBpbnRlcnZhbCA6IGludGVydmFsLmV2ZXJ5KHN0ZXApO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShpbnZlcnQoeSkpO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRvbWFpbihtYXAuY2FsbChfLCBudW1iZXIkMSkpIDogZG9tYWluKCkubWFwKGRhdGUpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB0MCA9IGRbMF0sXG4gICAgICAgIHQxID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByID0gdDEgPCB0MCxcbiAgICAgICAgdDtcbiAgICBpZiAocikgdCA9IHQwLCB0MCA9IHQxLCB0MSA9IHQ7XG4gICAgdCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgdDAsIHQxLCBzdGVwKTtcbiAgICB0ID0gdCA/IHQucmFuZ2UodDAsIHQxICsgMSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcbiAgICByZXR1cm4gciA/IHQucmV2ZXJzZSgpIDogdDtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiAoaW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgc3RlcCkpXG4gICAgICAgID8gZG9tYWluKG5pY2UoZCwgaW50ZXJ2YWwpKVxuICAgICAgICA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHRpbWUoKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIoZDNUaW1lLnRpbWVZZWFyLCBkM1RpbWUudGltZU1vbnRoLCBkM1RpbWUudGltZVdlZWssIGQzVGltZS50aW1lRGF5LCBkM1RpbWUudGltZUhvdXIsIGQzVGltZS50aW1lTWludXRlLCBkM1RpbWUudGltZVNlY29uZCwgZDNUaW1lLnRpbWVNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnRpbWVGb3JtYXQpLmRvbWFpbihbbmV3IERhdGUoMjAwMCwgMCwgMSksIG5ldyBEYXRlKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHV0Y1RpbWUoKSB7XG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoY2FsZW5kYXIoZDNUaW1lLnV0Y1llYXIsIGQzVGltZS51dGNNb250aCwgZDNUaW1lLnV0Y1dlZWssIGQzVGltZS51dGNEYXksIGQzVGltZS51dGNIb3VyLCBkM1RpbWUudXRjTWludXRlLCBkM1RpbWUudXRjU2Vjb25kLCBkM1RpbWUudXRjTWlsbGlzZWNvbmQsIGQzVGltZUZvcm1hdC51dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMjAwMCwgMCwgMSksIERhdGUuVVRDKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyJDEoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICB0MCxcbiAgICAgIHQxLFxuICAgICAgazEwLFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogaW50ZXJwb2xhdG9yKGsxMCA9PT0gMCA/IDAuNSA6ICh4ID0gKHRyYW5zZm9ybSh4KSAtIHQwKSAqIGsxMCwgY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSkgOiB4KSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodDAgPSB0cmFuc2Zvcm0oeDAgPSArX1swXSksIHQxID0gdHJhbnNmb3JtKHgxID0gK19bMV0pLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMSAvICh0MSAtIHQwKSwgc2NhbGUpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHQwID0gdCh4MCksIHQxID0gdCh4MSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29weSQxKHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLmludGVycG9sYXRvcihzb3VyY2UuaW50ZXJwb2xhdG9yKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpXG4gICAgICAudW5rbm93bihzb3VyY2UudW5rbm93bigpKTtcbn1cblxuZnVuY3Rpb24gc2VxdWVudGlhbCgpIHtcbiAgdmFyIHNjYWxlID0gbGluZWFyaXNoKHRyYW5zZm9ybWVyJDEoKShpZGVudGl0eSkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBzZXF1ZW50aWFsKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyJDEoKSkuZG9tYWluKFsxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBzZXF1ZW50aWFsTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VxdWVudGlhbFN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyJDEoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWxTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lciQxKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBzZXF1ZW50aWFsUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsU3FydCgpIHtcbiAgcmV0dXJuIHNlcXVlbnRpYWxQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsUXVhbnRpbGUoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIGludGVycG9sYXRvciA9IGlkZW50aXR5O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICBpZiAoIWlzTmFOKHggPSAreCkpIHJldHVybiBpbnRlcnBvbGF0b3IoKGQzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCkgLSAxKSAvIChkb21haW4ubGVuZ3RoIC0gMSkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChkM0FycmF5LmFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXF1ZW50aWFsUXVhbnRpbGUoaW50ZXJwb2xhdG9yKS5kb21haW4oZG9tYWluKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIkMigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMC41LFxuICAgICAgeDIgPSAxLFxuICAgICAgdDAsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgazEwLFxuICAgICAgazIxLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKHggPSAwLjUgKyAoKHggPSArdHJhbnNmb3JtKHgpKSAtIHQxKSAqICh4IDwgdDEgPyBrMTAgOiBrMjEpLCBpbnRlcnBvbGF0b3IoY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSkgOiB4KSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodDAgPSB0cmFuc2Zvcm0oeDAgPSArX1swXSksIHQxID0gdHJhbnNmb3JtKHgxID0gK19bMV0pLCB0MiA9IHRyYW5zZm9ybSh4MiA9ICtfWzJdKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDAuNSAvICh0MSAtIHQwKSwgazIxID0gdDEgPT09IHQyID8gMCA6IDAuNSAvICh0MiAtIHQxKSwgc2NhbGUpIDogW3gwLCB4MSwgeDJdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0cmFuc2Zvcm0gPSB0LCB0MCA9IHQoeDApLCB0MSA9IHQoeDEpLCB0MiA9IHQoeDIpLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGl2ZXJnaW5nKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIkMigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIGRpdmVyZ2luZygpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGl2ZXJnaW5nTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyJDIoKSkuZG9tYWluKFswLjEsIDEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIGRpdmVyZ2luZ0xvZygpKS5iYXNlKHNjYWxlLmJhc2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRpdmVyZ2luZ1N5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyJDIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIGRpdmVyZ2luZ1N5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGl2ZXJnaW5nUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIkMigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkkMShzY2FsZSwgZGl2ZXJnaW5nUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkaXZlcmdpbmdTcXJ0KCkge1xuICByZXR1cm4gZGl2ZXJnaW5nUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cblxuZXhwb3J0cy5zY2FsZUJhbmQgPSBiYW5kO1xuZXhwb3J0cy5zY2FsZVBvaW50ID0gcG9pbnQ7XG5leHBvcnRzLnNjYWxlSWRlbnRpdHkgPSBpZGVudGl0eSQxO1xuZXhwb3J0cy5zY2FsZUxpbmVhciA9IGxpbmVhcjtcbmV4cG9ydHMuc2NhbGVMb2cgPSBsb2c7XG5leHBvcnRzLnNjYWxlU3ltbG9nID0gc3ltbG9nO1xuZXhwb3J0cy5zY2FsZU9yZGluYWwgPSBvcmRpbmFsO1xuZXhwb3J0cy5zY2FsZUltcGxpY2l0ID0gaW1wbGljaXQ7XG5leHBvcnRzLnNjYWxlUG93ID0gcG93O1xuZXhwb3J0cy5zY2FsZVNxcnQgPSBzcXJ0O1xuZXhwb3J0cy5zY2FsZVF1YW50aWxlID0gcXVhbnRpbGU7XG5leHBvcnRzLnNjYWxlUXVhbnRpemUgPSBxdWFudGl6ZTtcbmV4cG9ydHMuc2NhbGVUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG5leHBvcnRzLnNjYWxlVGltZSA9IHRpbWU7XG5leHBvcnRzLnNjYWxlVXRjID0gdXRjVGltZTtcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsID0gc2VxdWVudGlhbDtcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsTG9nID0gc2VxdWVudGlhbExvZztcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsUG93ID0gc2VxdWVudGlhbFBvdztcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsU3FydCA9IHNlcXVlbnRpYWxTcXJ0O1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxTeW1sb2cgPSBzZXF1ZW50aWFsU3ltbG9nO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxRdWFudGlsZSA9IHNlcXVlbnRpYWxRdWFudGlsZTtcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmcgPSBkaXZlcmdpbmc7XG5leHBvcnRzLnNjYWxlRGl2ZXJnaW5nTG9nID0gZGl2ZXJnaW5nTG9nO1xuZXhwb3J0cy5zY2FsZURpdmVyZ2luZ1BvdyA9IGRpdmVyZ2luZ1BvdztcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmdTcXJ0ID0gZGl2ZXJnaW5nU3FydDtcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmdTeW1sb2cgPSBkaXZlcmdpbmdTeW1sb2c7XG5leHBvcnRzLnRpY2tGb3JtYXQgPSB0aWNrRm9ybWF0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zZWxlY3Rpb24vIHYxLjQuMSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG52YXIgbmFtZXNwYWNlcyA9IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG5cbmZ1bmN0aW9uIG5hbWVzcGFjZShuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3IobmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG5cbmZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5mdW5jdGlvbiBzZWxlY3RvcihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdChzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0QWxsKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2ZpbHRlcihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gbWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc3BhcnNlKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZW50ZXIoKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbn1cblxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZCwgbmV4dCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbn07XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG52YXIga2V5UHJlZml4ID0gXCIkXCI7IC8vIFByb3RlY3QgYWdhaW5zdCBrZXlzIGxpa2Ug4oCcX19wcm90b19f4oCdLlxuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IHt9LFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICAgIGlmIChrZXlWYWx1ZSBpbiBub2RlQnlLZXlWYWx1ZSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0pIHtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVzW2ldXSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZGF0YSh2YWx1ZSwga2V5KSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBkYXRhID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaiA9IC0xO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihkKSB7IGRhdGFbKytqXSA9IGQ7IH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gdmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2V4aXQoKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2pvaW4ob25lbnRlciwgb251cGRhdGUsIG9uZXhpdCkge1xuICB2YXIgZW50ZXIgPSB0aGlzLmVudGVyKCksIHVwZGF0ZSA9IHRoaXMsIGV4aXQgPSB0aGlzLmV4aXQoKTtcbiAgZW50ZXIgPSB0eXBlb2Ygb25lbnRlciA9PT0gXCJmdW5jdGlvblwiID8gb25lbnRlcihlbnRlcikgOiBlbnRlci5hcHBlbmQob25lbnRlciArIFwiXCIpO1xuICBpZiAob251cGRhdGUgIT0gbnVsbCkgdXBkYXRlID0gb251cGRhdGUodXBkYXRlKTtcbiAgaWYgKG9uZXhpdCA9PSBudWxsKSBleGl0LnJlbW92ZSgpOyBlbHNlIG9uZXhpdChleGl0KTtcbiAgcmV0dXJuIGVudGVyICYmIHVwZGF0ZSA/IGVudGVyLm1lcmdlKHVwZGF0ZSkub3JkZXIoKSA6IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX21lcmdlKHNlbGVjdGlvbikge1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX29yZGVyKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obmV4dCkgXiA0KSBuZXh0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIG5leHQpO1xuICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NvcnQoY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG5cbiAgZnVuY3Rpb24gY29tcGFyZU5vZGUoYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJlKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHNvcnRncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHNvcnRncm91cCA9IHNvcnRncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNvcnRncm91cFtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHNvcnRncm91cC5zb3J0KGNvbXBhcmVOb2RlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHNvcnRncm91cHMsIHRoaXMuX3BhcmVudHMpLm9yZGVyKCk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2NhbGwoKSB7XG4gIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1swXTtcbiAgYXJndW1lbnRzWzBdID0gdGhpcztcbiAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9ub2RlcygpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbm9kZSgpIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NpemUoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkgeyArK3NpemU7IH0pO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2VtcHR5KCkge1xuICByZXR1cm4gIXRoaXMubm9kZSgpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZWFjaChjYWxsYmFjaykge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgdik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgcmV0dXJuIGZ1bGxuYW1lLmxvY2FsXG4gICAgICAgID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpXG4gICAgICAgIDogbm9kZS5nZXRBdHRyaWJ1dGUoZnVsbG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKSkoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRWaWV3KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdiwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyB0aGlzLmVhY2goKHZhbHVlID09IG51bGxcbiAgICAgICAgICAgID8gc3R5bGVSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uXG4gICAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQpKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSlcbiAgICAgIDogc3R5bGVWYWx1ZSh0aGlzLm5vZGUoKSwgbmFtZSk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlVmFsdWUobm9kZSwgbmFtZSkge1xuICByZXR1cm4gbm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpXG4gICAgICB8fCBkZWZhdWx0Vmlldyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5UmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzW25hbWVdID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICBlbHNlIHRoaXNbbmFtZV0gPSB2O1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gcHJvcGVydHlSZW1vdmUgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gcHJvcGVydHlGdW5jdGlvblxuICAgICAgICAgIDogcHJvcGVydHlDb25zdGFudCkobmFtZSwgdmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKVtuYW1lXTtcbn1cblxuZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIHRleHRSZW1vdmUoKSB7XG4gIHRoaXMudGV4dENvbnRlbnQgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiB0ZXh0Q29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fdGV4dCh2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gdGV4dFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gdGV4dEZ1bmN0aW9uXG4gICAgICAgICAgOiB0ZXh0Q29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGh0bWxSZW1vdmUoKSB7XG4gIHRoaXMuaW5uZXJIVE1MID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gaHRtbENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlubmVySFRNTCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBodG1sRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmlubmVySFRNTCA9IHYgPT0gbnVsbCA/IFwiXCIgOiB2O1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25faHRtbCh2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2godmFsdWUgPT0gbnVsbFxuICAgICAgICAgID8gaHRtbFJlbW92ZSA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gaHRtbEZ1bmN0aW9uXG4gICAgICAgICAgOiBodG1sQ29uc3RhbnQpKHZhbHVlKSlcbiAgICAgIDogdGhpcy5ub2RlKCkuaW5uZXJIVE1MO1xufVxuXG5mdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3JhaXNlKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn1cblxuZnVuY3Rpb24gbG93ZXIoKSB7XG4gIGlmICh0aGlzLnByZXZpb3VzU2libGluZykgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLCB0aGlzLnBhcmVudE5vZGUuZmlyc3RDaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9sb3dlcigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChsb3dlcik7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9hcHBlbmQobmFtZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kQ2hpbGQoY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2luc2VydChuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3JlbW92ZSgpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChyZW1vdmUpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KCkge1xuICB2YXIgY2xvbmUgPSB0aGlzLmNsb25lTm9kZShmYWxzZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKHRydWUpLCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCB0aGlzLm5leHRTaWJsaW5nKSA6IGNsb25lO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xvbmUoZGVlcCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZGVlcCA/IHNlbGVjdGlvbl9jbG9uZURlZXAgOiBzZWxlY3Rpb25fY2xvbmVTaGFsbG93KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2RhdHVtKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiLCB2YWx1ZSlcbiAgICAgIDogdGhpcy5ub2RlKCkuX19kYXRhX187XG59XG5cbnZhciBmaWx0ZXJFdmVudHMgPSB7fTtcblxuZXhwb3J0cy5ldmVudCA9IG51bGw7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICghKFwib25tb3VzZWVudGVyXCIgaW4gZWxlbWVudCkpIHtcbiAgICBmaWx0ZXJFdmVudHMgPSB7bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIiwgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwifTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJDb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcykgJiA4KSkpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50MSkge1xuICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDE7XG4gICAgdHJ5IHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgaW5kZXgsIGdyb3VwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uUmVtb3ZlKHR5cGVuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb24gPSB0aGlzLl9fb247XG4gICAgaWYgKCFvbikgcmV0dXJuO1xuICAgIGZvciAodmFyIGogPSAwLCBpID0gLTEsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGlmIChvID0gb25bal0sICghdHlwZW5hbWUudHlwZSB8fCBvLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUpICYmIG8ubmFtZSA9PT0gdHlwZW5hbWUubmFtZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoby50eXBlLCBvLmxpc3RlbmVyLCBvLmNhcHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25bKytpXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgrK2kpIG9uLmxlbmd0aCA9IGk7XG4gICAgZWxzZSBkZWxldGUgdGhpcy5fX29uO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFkZCh0eXBlbmFtZSwgdmFsdWUsIGNhcHR1cmUpIHtcbiAgdmFyIHdyYXAgPSBmaWx0ZXJFdmVudHMuaGFzT3duUHJvcGVydHkodHlwZW5hbWUudHlwZSkgPyBmaWx0ZXJDb250ZXh0TGlzdGVuZXIgOiBjb250ZXh0TGlzdGVuZXI7XG4gIHJldHVybiBmdW5jdGlvbihkLCBpLCBncm91cCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbiwgbywgbGlzdGVuZXIgPSB3cmFwKHZhbHVlLCBpLCBncm91cCk7XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgICAgaWYgKChvID0gb25bal0pLnR5cGUgPT09IHR5cGVuYW1lLnR5cGUgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIgPSBsaXN0ZW5lciwgby5jYXB0dXJlID0gY2FwdHVyZSk7XG4gICAgICAgIG8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodHlwZW5hbWUudHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgIG8gPSB7dHlwZTogdHlwZW5hbWUudHlwZSwgbmFtZTogdHlwZW5hbWUubmFtZSwgdmFsdWU6IHZhbHVlLCBsaXN0ZW5lcjogbGlzdGVuZXIsIGNhcHR1cmU6IGNhcHR1cmV9O1xuICAgIGlmICghb24pIHRoaXMuX19vbiA9IFtvXTtcbiAgICBlbHNlIG9uLnB1c2gobyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9vbih0eXBlbmFtZSwgdmFsdWUsIGNhcHR1cmUpIHtcbiAgdmFyIHR5cGVuYW1lcyA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiksIGksIG4gPSB0eXBlbmFtZXMubGVuZ3RoLCB0O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBvbiA9IHRoaXMubm9kZSgpLl9fb247XG4gICAgaWYgKG9uKSBmb3IgKHZhciBqID0gMCwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgZm9yIChpID0gMCwgbyA9IG9uW2pdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICgodCA9IHR5cGVuYW1lc1tpXSkudHlwZSA9PT0gby50eXBlICYmIHQubmFtZSA9PT0gby5uYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIG8udmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb24gPSB2YWx1ZSA/IG9uQWRkIDogb25SZW1vdmU7XG4gIGlmIChjYXB0dXJlID09IG51bGwpIGNhcHR1cmUgPSBmYWxzZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgdGhpcy5lYWNoKG9uKHR5cGVuYW1lc1tpXSwgdmFsdWUsIGNhcHR1cmUpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUV2ZW50KGV2ZW50MSwgbGlzdGVuZXIsIHRoYXQsIGFyZ3MpIHtcbiAgdmFyIGV2ZW50MCA9IGV4cG9ydHMuZXZlbnQ7XG4gIGV2ZW50MS5zb3VyY2VFdmVudCA9IGV4cG9ydHMuZXZlbnQ7XG4gIGV4cG9ydHMuZXZlbnQgPSBldmVudDE7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Rpc3BhdGNoKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn1cblxudmFyIHJvb3QgPSBbbnVsbF07XG5cbmZ1bmN0aW9uIFNlbGVjdGlvbihncm91cHMsIHBhcmVudHMpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF1dLCByb290KTtcbn1cblxuU2VsZWN0aW9uLnByb3RvdHlwZSA9IHNlbGVjdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZWxlY3Rpb24sXG4gIHNlbGVjdDogc2VsZWN0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiBzZWxlY3Rpb25fc2VsZWN0QWxsLFxuICBmaWx0ZXI6IHNlbGVjdGlvbl9maWx0ZXIsXG4gIGRhdGE6IHNlbGVjdGlvbl9kYXRhLFxuICBlbnRlcjogc2VsZWN0aW9uX2VudGVyLFxuICBleGl0OiBzZWxlY3Rpb25fZXhpdCxcbiAgam9pbjogc2VsZWN0aW9uX2pvaW4sXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGNsb25lOiBzZWxlY3Rpb25fY2xvbmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2hcbn07XG5cbmZ1bmN0aW9uIHNlbGVjdChzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobmFtZSkge1xuICByZXR1cm4gc2VsZWN0KGNyZWF0b3IobmFtZSkuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKTtcbn1cblxudmFyIG5leHRJZCA9IDA7XG5cbmZ1bmN0aW9uIGxvY2FsKCkge1xuICByZXR1cm4gbmV3IExvY2FsO1xufVxuXG5mdW5jdGlvbiBMb2NhbCgpIHtcbiAgdGhpcy5fID0gXCJAXCIgKyAoKytuZXh0SWQpLnRvU3RyaW5nKDM2KTtcbn1cblxuTG9jYWwucHJvdG90eXBlID0gbG9jYWwucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTG9jYWwsXG4gIGdldDogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBpZCA9IHRoaXMuXztcbiAgICB3aGlsZSAoIShpZCBpbiBub2RlKSkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gbm9kZVtpZF07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZVt0aGlzLl9dID0gdmFsdWU7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLl8gaW4gbm9kZSAmJiBkZWxldGUgbm9kZVt0aGlzLl9dO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcblxuZnVuY3Rpb24gc291cmNlRXZlbnQoKSB7XG4gIHZhciBjdXJyZW50ID0gZXhwb3J0cy5ldmVudCwgc291cmNlO1xuICB3aGlsZSAoc291cmNlID0gY3VycmVudC5zb3VyY2VFdmVudCkgY3VycmVudCA9IHNvdXJjZTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvaW50KG5vZGUsIGV2ZW50KSB7XG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH1cblxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xufVxuXG5mdW5jdGlvbiBtb3VzZShub2RlKSB7XG4gIHZhciBldmVudCA9IHNvdXJjZUV2ZW50KCk7XG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcykgZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgcmV0dXJuIHBvaW50KG5vZGUsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0QWxsKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn1cblxuZnVuY3Rpb24gdG91Y2gobm9kZSwgdG91Y2hlcywgaWRlbnRpZmllcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gc291cmNlRXZlbnQoKS5jaGFuZ2VkVG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCh0b3VjaCA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJldHVybiBwb2ludChub2RlLCB0b3VjaCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHRvdWNoZXMobm9kZSwgdG91Y2hlcykge1xuICBpZiAodG91Y2hlcyA9PSBudWxsKSB0b3VjaGVzID0gc291cmNlRXZlbnQoKS50b3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgcG9pbnRzID0gbmV3IEFycmF5KG4pOyBpIDwgbjsgKytpKSB7XG4gICAgcG9pbnRzW2ldID0gcG9pbnQobm9kZSwgdG91Y2hlc1tpXSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuXG5leHBvcnRzLmNsaWVudFBvaW50ID0gcG9pbnQ7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuY3JlYXRvciA9IGNyZWF0b3I7XG5leHBvcnRzLmN1c3RvbUV2ZW50ID0gY3VzdG9tRXZlbnQ7XG5leHBvcnRzLmxvY2FsID0gbG9jYWw7XG5leHBvcnRzLm1hdGNoZXIgPSBtYXRjaGVyO1xuZXhwb3J0cy5tb3VzZSA9IG1vdXNlO1xuZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5leHBvcnRzLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuZXhwb3J0cy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuZXhwb3J0cy5zZWxlY3RvckFsbCA9IHNlbGVjdG9yQWxsO1xuZXhwb3J0cy5zdHlsZSA9IHN0eWxlVmFsdWU7XG5leHBvcnRzLnRvdWNoID0gdG91Y2g7XG5leHBvcnRzLnRvdWNoZXMgPSB0b3VjaGVzO1xuZXhwb3J0cy53aW5kb3cgPSBkZWZhdWx0VmlldztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1zaGFwZS8gdjEuMy43IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtcGF0aCcpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXBhdGgnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM1BhdGgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG52YXIgZXBzaWxvbiA9IDFlLTEyO1xudmFyIHBpID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSAvIDI7XG52YXIgdGF1ID0gMiAqIHBpO1xuXG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5mdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPj0gMSA/IGhhbGZQaSA6IHggPD0gLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5mdW5jdGlvbiBhcmNJbm5lclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLmlubmVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNPdXRlclJhZGl1cyhkKSB7XG4gIHJldHVybiBkLm91dGVyUmFkaXVzO1xufVxuXG5mdW5jdGlvbiBhcmNTdGFydEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjRW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxuZnVuY3Rpb24gYXJjUGFkQW5nbGUoZCkge1xuICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlOyAvLyBOb3RlOiBvcHRpb25hbCFcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgeDEwID0geDEgLSB4MCwgeTEwID0geTEgLSB5MCxcbiAgICAgIHgzMiA9IHgzIC0geDIsIHkzMiA9IHkzIC0geTIsXG4gICAgICB0ID0geTMyICogeDEwIC0geDMyICogeTEwO1xuICBpZiAodCAqIHQgPCBlcHNpbG9uKSByZXR1cm47XG4gIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvIHQ7XG4gIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xufVxuXG4vLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuLy8gaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9DaXJjbGUtTGluZUludGVyc2VjdGlvbi5odG1sXG5mdW5jdGlvbiBjb3JuZXJUYW5nZW50cyh4MCwgeTAsIHgxLCB5MSwgcjEsIHJjLCBjdykge1xuICB2YXIgeDAxID0geDAgLSB4MSxcbiAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICBsbyA9IChjdyA/IHJjIDogLXJjKSAvIHNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSxcbiAgICAgIG94ID0gbG8gKiB5MDEsXG4gICAgICBveSA9IC1sbyAqIHgwMSxcbiAgICAgIHgxMSA9IHgwICsgb3gsXG4gICAgICB5MTEgPSB5MCArIG95LFxuICAgICAgeDEwID0geDEgKyBveCxcbiAgICAgIHkxMCA9IHkxICsgb3ksXG4gICAgICB4MDAgPSAoeDExICsgeDEwKSAvIDIsXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXG4gICAgICBkeCA9IHgxMCAtIHgxMSxcbiAgICAgIGR5ID0geTEwIC0geTExLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIHIgPSByMSAtIHJjLFxuICAgICAgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSxcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIHNxcnQobWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLFxuICAgICAgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLFxuICAgICAgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMixcbiAgICAgIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLFxuICAgICAgZHgwID0gY3gwIC0geDAwLFxuICAgICAgZHkwID0gY3kwIC0geTAwLFxuICAgICAgZHgxID0gY3gxIC0geDAwLFxuICAgICAgZHkxID0gY3kxIC0geTAwO1xuXG4gIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKSBjeDAgPSBjeDEsIGN5MCA9IGN5MTtcblxuICByZXR1cm4ge1xuICAgIGN4OiBjeDAsXG4gICAgY3k6IGN5MCxcbiAgICB4MDE6IC1veCxcbiAgICB5MDE6IC1veSxcbiAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICB5MTE6IGN5MCAqIChyMSAvIHIgLSAxKVxuICB9O1xufVxuXG5mdW5jdGlvbiBhcmMoKSB7XG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBhcmNPdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLFxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBhcmNTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgcixcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgcjEgPSArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgZGEgPSBhYnMoYTEgLSBhMCksXG4gICAgICAgIGN3ID0gYTEgPiBhMDtcblxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oMCwgMCk7XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmNsZSBvciBhbm51bHVzP1xuICAgIGVsc2UgaWYgKGRhID4gdGF1IC0gZXBzaWxvbikge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MoYTApLCByMSAqIHNpbihhMCkpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcbiAgICAgIGlmIChyMCA+IGVwc2lsb24pIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocjAgKiBjb3MoYTEpLCByMCAqIHNpbihhMSkpO1xuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEsIGEwLCBjdyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjdWxhciBvciBhbm51bGFyIHNlY3Rvcj9cbiAgICBlbHNlIHtcbiAgICAgIHZhciBhMDEgPSBhMCxcbiAgICAgICAgICBhMTEgPSBhMSxcbiAgICAgICAgICBhMDAgPSBhMCxcbiAgICAgICAgICBhMTAgPSBhMSxcbiAgICAgICAgICBkYTAgPSBkYSxcbiAgICAgICAgICBkYTEgPSBkYSxcbiAgICAgICAgICBhcCA9IHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLyAyLFxuICAgICAgICAgIHJwID0gKGFwID4gZXBzaWxvbikgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNxcnQocjAgKiByMCArIHIxICogcjEpKSxcbiAgICAgICAgICByYyA9IG1pbihhYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICAgIHJjMCA9IHJjLFxuICAgICAgICAgIHJjMSA9IHJjLFxuICAgICAgICAgIHQwLFxuICAgICAgICAgIHQxO1xuXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgIGlmIChycCA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHAwID0gYXNpbihycCAvIHIwICogc2luKGFwKSksXG4gICAgICAgICAgICBwMSA9IGFzaW4ocnAgLyByMSAqIHNpbihhcCkpO1xuICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbikgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24pIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICBlbHNlIGRhMSA9IDAsIGEwMSA9IGExMSA9IChhMCArIGExKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHZhciB4MDEgPSByMSAqIGNvcyhhMDEpLFxuICAgICAgICAgIHkwMSA9IHIxICogc2luKGEwMSksXG4gICAgICAgICAgeDEwID0gcjAgKiBjb3MoYTEwKSxcbiAgICAgICAgICB5MTAgPSByMCAqIHNpbihhMTApO1xuXG4gICAgICAvLyBBcHBseSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBpZiAocmMgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciB4MTEgPSByMSAqIGNvcyhhMTEpLFxuICAgICAgICAgICAgeTExID0gcjEgKiBzaW4oYTExKSxcbiAgICAgICAgICAgIHgwMCA9IHIwICogY29zKGEwMCksXG4gICAgICAgICAgICB5MDAgPSByMCAqIHNpbihhMDApLFxuICAgICAgICAgICAgb2M7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIGNvcm5lciByYWRpdXMgYWNjb3JkaW5nIHRvIHRoZSBzZWN0b3IgYW5nbGUuXG4gICAgICAgIGlmIChkYSA8IHBpICYmIChvYyA9IGludGVyc2VjdCh4MDEsIHkwMSwgeDAwLCB5MDAsIHgxMSwgeTExLCB4MTAsIHkxMCkpKSB7XG4gICAgICAgICAgdmFyIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGtjID0gMSAvIHNpbihhY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksXG4gICAgICAgICAgICAgIGxjID0gc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgcmMwID0gbWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gbWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXMgdGhlIHNlY3RvciBjb2xsYXBzZWQgdG8gYSBsaW5lP1xuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEwLCBhMDAsIGN3KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsXG4gICAgICAgIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSAvIDI7XG4gICAgcmV0dXJuIFtjb3MoYSkgKiByLCBzaW4oYSkgKiByXTtcbiAgfTtcblxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvdXRlclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogb3V0ZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgfTtcblxuICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBhcmMuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn1cblxuZnVuY3Rpb24gTGluZWFyKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhci5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY3VydmVMaW5lYXIoY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhcihjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24geChwKSB7XG4gIHJldHVybiBwWzBdO1xufVxuXG5mdW5jdGlvbiB5KHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG5cbmZ1bmN0aW9uIGxpbmUoKSB7XG4gIHZhciB4JDEgPSB4LFxuICAgICAgeSQxID0geSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gZDNQYXRoLnBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3gkMShkLCBpLCBkYXRhKSwgK3kkMShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB4JDE7XG4gIH07XG5cbiAgbGluZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHkkMTtcbiAgfTtcblxuICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluZTtcbn1cblxuZnVuY3Rpb24gYXJlYSgpIHtcbiAgdmFyIHgwID0geCxcbiAgICAgIHgxID0gbnVsbCxcbiAgICAgIHkwID0gY29uc3RhbnQoMCksXG4gICAgICB5MSA9IHksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyZWEoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgeDB6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICB5MHogPSBuZXcgQXJyYXkobik7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBkM1BhdGgucGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eShkKSB7XG4gIHJldHVybiBkO1xufVxuXG5mdW5jdGlvbiBwaWUoKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmcsXG4gICAgICBzb3J0ID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSxcbiAgICAgIGVuZEFuZ2xlID0gY29uc3RhbnQodGF1KSxcbiAgICAgIHBhZEFuZ2xlID0gY29uc3RhbnQoMCk7XG5cbiAgZnVuY3Rpb24gcGllKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBqLFxuICAgICAgICBrLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBpbmRleCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYXJjcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYTAgPSArc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBkYSA9IE1hdGgubWluKHRhdSwgTWF0aC5tYXgoLXRhdSwgZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGEwKSksXG4gICAgICAgIGExLFxuICAgICAgICBwID0gTWF0aC5taW4oTWF0aC5hYnMoZGEpIC8gbiwgcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLFxuICAgICAgICB2O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh2ID0gYXJjc1tpbmRleFtpXSA9IGldID0gK3ZhbHVlKGRhdGFbaV0sIGksIGRhdGEpKSA+IDApIHtcbiAgICAgICAgc3VtICs9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3B0aW9uYWxseSBzb3J0IHRoZSBhcmNzIGJ5IHByZXZpb3VzbHktY29tcHV0ZWQgdmFsdWVzIG9yIGJ5IGRhdGEuXG4gICAgaWYgKHNvcnRWYWx1ZXMgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0VmFsdWVzKGFyY3NbaV0sIGFyY3Nbal0pOyB9KTtcbiAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICBmb3IgKGkgPSAwLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDA7IGkgPCBuOyArK2ksIGEwID0gYTEpIHtcbiAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyY3M7XG4gIH1cblxuICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHZhbHVlO1xuICB9O1xuXG4gIHBpZS5zb3J0VmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRWYWx1ZXMgPSBfLCBzb3J0ID0gbnVsbCwgcGllKSA6IHNvcnRWYWx1ZXM7XG4gIH07XG5cbiAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgfTtcblxuICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIHBpZS5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgfTtcblxuICByZXR1cm4gcGllO1xufVxuXG52YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG5cbmZ1bmN0aW9uIGxpbmVSYWRpYWwobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxuZnVuY3Rpb24gbGluZVJhZGlhbCQxKCkge1xuICByZXR1cm4gbGluZVJhZGlhbChsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbn1cblxuZnVuY3Rpb24gYXJlYVJhZGlhbCgpIHtcbiAgdmFyIGEgPSBhcmVhKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpLFxuICAgICAgYyA9IGEuY3VydmUsXG4gICAgICB4MCA9IGEubGluZVgwLFxuICAgICAgeDEgPSBhLmxpbmVYMSxcbiAgICAgIHkwID0gYS5saW5lWTAsXG4gICAgICB5MSA9IGEubGluZVkxO1xuXG4gIGEuYW5nbGUgPSBhLngsIGRlbGV0ZSBhLng7XG4gIGEuc3RhcnRBbmdsZSA9IGEueDAsIGRlbGV0ZSBhLngwO1xuICBhLmVuZEFuZ2xlID0gYS54MSwgZGVsZXRlIGEueDE7XG4gIGEucmFkaXVzID0gYS55LCBkZWxldGUgYS55O1xuICBhLmlubmVyUmFkaXVzID0gYS55MCwgZGVsZXRlIGEueTA7XG4gIGEub3V0ZXJSYWRpdXMgPSBhLnkxLCBkZWxldGUgYS55MTtcbiAgYS5saW5lU3RhcnRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xuICBhLmxpbmVFbmRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MSgpKTsgfSwgZGVsZXRlIGEubGluZVgxO1xuICBhLmxpbmVJbm5lclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MCgpKTsgfSwgZGVsZXRlIGEubGluZVkwO1xuICBhLmxpbmVPdXRlclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZVJhZGlhbCh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xuXG4gIGEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIHBvaW50UmFkaWFsKHgsIHkpIHtcbiAgcmV0dXJuIFsoeSA9ICt5KSAqIE1hdGguY29zKHggLT0gTWF0aC5QSSAvIDIpLCB5ICogTWF0aC5zaW4oeCldO1xufVxuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGxpbmtTb3VyY2UoZCkge1xuICByZXR1cm4gZC5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGxpbmtUYXJnZXQoZCkge1xuICByZXR1cm4gZC50YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGxpbmsoY3VydmUpIHtcbiAgdmFyIHNvdXJjZSA9IGxpbmtTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxuICAgICAgeCQxID0geCxcbiAgICAgIHkkMSA9IHksXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBsaW5rKCkge1xuICAgIHZhciBidWZmZXIsIGFyZ3YgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIHMgPSBzb3VyY2UuYXBwbHkodGhpcywgYXJndiksIHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndik7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcbiAgICBjdXJ2ZShjb250ZXh0LCAreCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLCAreSQxLmFwcGx5KHRoaXMsIGFyZ3YpLCAreCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gdCwgYXJndikpLCAreSQxLmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmsuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIGxpbmspIDogc291cmNlO1xuICB9O1xuXG4gIGxpbmsudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xuICB9O1xuXG4gIGxpbmsueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB4JDE7XG4gIH07XG5cbiAgbGluay55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHkkMTtcbiAgfTtcblxuICBsaW5rLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGxpbmspIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gY3VydmVIb3Jpem9udGFsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCA9ICh4MCArIHgxKSAvIDIsIHkwLCB4MCwgeTEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlVmVydGljYWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIsIHgxLCB5MCwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gY3VydmVSYWRpYWwkMShjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgcDAgPSBwb2ludFJhZGlhbCh4MCwgeTApLFxuICAgICAgcDEgPSBwb2ludFJhZGlhbCh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyKSxcbiAgICAgIHAyID0gcG9pbnRSYWRpYWwoeDEsIHkwKSxcbiAgICAgIHAzID0gcG9pbnRSYWRpYWwoeDEsIHkxKTtcbiAgY29udGV4dC5tb3ZlVG8ocDBbMF0sIHAwWzFdKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHAxWzBdLCBwMVsxXSwgcDJbMF0sIHAyWzFdLCBwM1swXSwgcDNbMV0pO1xufVxuXG5mdW5jdGlvbiBsaW5rSG9yaXpvbnRhbCgpIHtcbiAgcmV0dXJuIGxpbmsoY3VydmVIb3Jpem9udGFsKTtcbn1cblxuZnVuY3Rpb24gbGlua1ZlcnRpY2FsKCkge1xuICByZXR1cm4gbGluayhjdXJ2ZVZlcnRpY2FsKTtcbn1cblxuZnVuY3Rpb24gbGlua1JhZGlhbCgpIHtcbiAgdmFyIGwgPSBsaW5rKGN1cnZlUmFkaWFsJDEpO1xuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xuICBsLnJhZGl1cyA9IGwueSwgZGVsZXRlIGwueTtcbiAgcmV0dXJuIGw7XG59XG5cbnZhciBjaXJjbGUgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHIsIDAsIHRhdSk7XG4gIH1cbn07XG5cbnZhciBjcm9zcyA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgY29udGV4dC5tb3ZlVG8oLTMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgcik7XG4gICAgY29udGV4dC5saW5lVG8oLTMgKiByLCByKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgdGFuMzAgPSBNYXRoLnNxcnQoMSAvIDMpLFxuICAgIHRhbjMwXzIgPSB0YW4zMCAqIDI7XG5cbnZhciBkaWFtb25kID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLFxuICAgICAgICB4ID0geSAqIHRhbjMwO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCAwKTtcbiAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICBjb250ZXh0LmxpbmVUbygteCwgMCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIGthID0gMC44OTA4MTMwOTE1MjkyODUyMjgxMCxcbiAgICBrciA9IE1hdGguc2luKHBpIC8gMTApIC8gTWF0aC5zaW4oNyAqIHBpIC8gMTApLFxuICAgIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsXG4gICAga3kgPSAtTWF0aC5jb3ModGF1IC8gMTApICoga3I7XG5cbnZhciBzdGFyID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAqIGthKSxcbiAgICAgICAgeCA9IGt4ICogcixcbiAgICAgICAgeSA9IGt5ICogcjtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCA1OyArK2kpIHtcbiAgICAgIHZhciBhID0gdGF1ICogaSAvIDUsXG4gICAgICAgICAgYyA9IE1hdGguY29zKGEpLFxuICAgICAgICAgIHMgPSBNYXRoLnNpbihhKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMgKiByLCAtYyAqIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBzcXVhcmUgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG5cbnZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcblxudmFyIHRyaWFuZ2xlID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSAtTWF0aC5zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgYyA9IC0wLjUsXG4gICAgcyA9IE1hdGguc3FydCgzKSAvIDIsXG4gICAgayA9IDEgLyBNYXRoLnNxcnQoMTIpLFxuICAgIGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbnZhciB3eWUgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgc3ltYm9scyA9IFtcbiAgY2lyY2xlLFxuICBjcm9zcyxcbiAgZGlhbW9uZCxcbiAgc3F1YXJlLFxuICBzdGFyLFxuICB0cmlhbmdsZSxcbiAgd3llXG5dO1xuXG5mdW5jdGlvbiBzeW1ib2woKSB7XG4gIHZhciB0eXBlID0gY29uc3RhbnQoY2lyY2xlKSxcbiAgICAgIHNpemUgPSBjb25zdGFudCg2NCksXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuICAgIHR5cGUuYXBwbHkodGhpcywgYXJndW1lbnRzKS5kcmF3KGNvbnRleHQsICtzaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHlwZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIHN5bWJvbCkgOiB0eXBlO1xuICB9O1xuXG4gIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNpemUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3ltYm9sKSA6IHNpemU7XG4gIH07XG5cbiAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gc3ltYm9sO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgKDIgKiB0aGF0Ll94MCArIHRoYXQuX3gxKSAvIDMsXG4gICAgKDIgKiB0aGF0Ll95MCArIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgMiAqIHRoYXQuX3gxKSAvIDMsXG4gICAgKHRoYXQuX3kwICsgMiAqIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgNCAqIHRoYXQuX3gxICsgeCkgLyA2LFxuICAgICh0aGF0Ll95MCArIDQgKiB0aGF0Ll95MSArIHkpIC8gNlxuICApO1xufVxuXG5mdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmFzaXMoY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBCYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MiArIDIgKiB0aGlzLl94MykgLyAzLCAodGhpcy5feTIgKyAyICogdGhpcy5feTMpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKCh0aGlzLl94MyArIDIgKiB0aGlzLl94MikgLyAzLCAodGhpcy5feTMgKyAyICogdGhpcy5feTIpIC8gMyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDIgPSB4LCB0aGlzLl95MiA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geTsgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCAodGhpcy5feTAgKyA0ICogdGhpcy5feTEgKyB5KSAvIDYpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmFzaXNDbG9zZWQoY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzQ2xvc2VkKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2lzT3Blbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNPcGVuKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG52YXIgYnVuZGxlID0gKGZ1bmN0aW9uIGN1c3RvbShiZXRhKSB7XG5cbiAgZnVuY3Rpb24gYnVuZGxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYmV0YSA9PT0gMSA/IG5ldyBCYXNpcyhjb250ZXh0KSA6IG5ldyBCdW5kbGUoY29udGV4dCwgYmV0YSk7XG4gIH1cblxuICBidW5kbGUuYmV0YSA9IGZ1bmN0aW9uKGJldGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCtiZXRhKTtcbiAgfTtcblxuICByZXR1cm4gYnVuZGxlO1xufSkoMC44NSk7XG5cbmZ1bmN0aW9uIHBvaW50JDEodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgdGhhdC5feDEgKyB0aGF0Ll9rICogKHRoYXQuX3gyIC0gdGhhdC5feDApLFxuICAgIHRoYXQuX3kxICsgdGhhdC5fayAqICh0aGF0Ll95MiAtIHRoYXQuX3kwKSxcbiAgICB0aGF0Ll94MiArIHRoYXQuX2sgKiAodGhhdC5feDEgLSB4KSxcbiAgICB0aGF0Ll95MiArIHRoYXQuX2sgKiAodGhhdC5feTEgLSB5KSxcbiAgICB0aGF0Ll94MixcbiAgICB0aGF0Ll95MlxuICApO1xufVxuXG5mdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50JDEodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MSA9IHgsIHRoaXMuX3kxID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQkMSh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXJkaW5hbCA9IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcblxuZnVuY3Rpb24gQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbENsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDEodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2FyZGluYWxDbG9zZWQgPSAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG5cbmZ1bmN0aW9uIENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDEodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2FyZGluYWxPcGVuID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcblxuZnVuY3Rpb24gcG9pbnQkMih0aGF0LCB4LCB5KSB7XG4gIHZhciB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIHgyID0gdGhhdC5feDIsXG4gICAgICB5MiA9IHRoYXQuX3kyO1xuXG4gIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24pIHtcbiAgICB2YXIgYSA9IDIgKiB0aGF0Ll9sMDFfMmEgKyAzICogdGhhdC5fbDAxX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbiA9IDMgKiB0aGF0Ll9sMDFfYSAqICh0aGF0Ll9sMDFfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MSA9ICh4MSAqIGEgLSB0aGF0Ll94MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3gyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gICAgeTEgPSAoeTEgKiBhIC0gdGhhdC5feTAgKiB0aGF0Ll9sMTJfMmEgKyB0aGF0Ll95MiAqIHRoYXQuX2wwMV8yYSkgLyBuO1xuICB9XG5cbiAgaWYgKHRoYXQuX2wyM19hID4gZXBzaWxvbikge1xuICAgIHZhciBiID0gMiAqIHRoYXQuX2wyM18yYSArIDMgKiB0aGF0Ll9sMjNfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBtID0gMyAqIHRoYXQuX2wyM19hICogKHRoYXQuX2wyM19hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgyID0gKHgyICogYiArIHRoYXQuX3gxICogdGhhdC5fbDIzXzJhIC0geCAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICAgIHkyID0gKHkyICogYiArIHRoYXQuX3kxICogdGhhdC5fbDIzXzJhIC0geSAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICB9XG5cbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB0aGF0Ll94MiwgdGhhdC5feTIpO1xufVxuXG5mdW5jdGlvbiBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDIodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb20gPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2F0bXVsbFJvbUNsb3NlZCA9IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxDbG9zZWQoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDIodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb21PcGVuID0gKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcblxuZnVuY3Rpb24gTGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkxpbmVhckNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGVsc2UgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXJDbG9zZWQoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXG4vLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxuZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLFxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxuICAgICAgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSxcbiAgICAgIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcbiAgcmV0dXJuIChzaWduKHMwKSArIHNpZ24oczEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMwKSwgTWF0aC5hYnMoczEpLCAwLjUgKiBNYXRoLmFicyhwKSkgfHwgMDtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgb25lLXNpZGVkIHNsb3BlLlxuZnVuY3Rpb24gc2xvcGUyKHRoYXQsIHQpIHtcbiAgdmFyIGggPSB0aGF0Ll94MSAtIHRoYXQuX3gwO1xuICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XG59XG5cbi8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcbi8vIFwieW91IGNhbiBleHByZXNzIGN1YmljIEhlcm1pdGUgaW50ZXJwb2xhdGlvbiBpbiB0ZXJtcyBvZiBjdWJpYyBCw6l6aWVyIGN1cnZlc1xuLy8gd2l0aCByZXNwZWN0IHRvIHRoZSBmb3VyIHZhbHVlcyBwMCwgcDAgKyBtMCAvIDMsIHAxIC0gbTEgLyAzLCBwMVwiLlxuZnVuY3Rpb24gcG9pbnQkMyh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCQzKHRoaXMsIHRoaXMuX3QwLCBzbG9wZTIodGhpcywgdGhpcy5fdDApKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHQxID0gTmFOO1xuXG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHggPT09IHRoaXMuX3gxICYmIHkgPT09IHRoaXMuX3kxKSByZXR1cm47IC8vIElnbm9yZSBjb2luY2lkZW50IHBvaW50cy5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHBvaW50JDModGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDModGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNb25vdG9uZVkoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IFJlZmxlY3RDb250ZXh0KGNvbnRleHQpO1xufVxuXG4oTW9ub3RvbmVZLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9ub3RvbmVYLnByb3RvdHlwZSkpLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICBNb25vdG9uZVgucHJvdG90eXBlLnBvaW50LmNhbGwodGhpcywgeSwgeCk7XG59O1xuXG5mdW5jdGlvbiBSZWZsZWN0Q29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZsZWN0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh5LCB4KTsgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubGluZVRvKHksIHgpOyB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkgeyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oeTEsIHgxLCB5MiwgeDIsIHksIHgpOyB9XG59O1xuXG5mdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVkoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIE5hdHVyYWwoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTmF0dXJhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4pIHtcbiAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzBdLCB5WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHhbMF0sIHlbMF0pO1xuICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHggPSBjb250cm9sUG9pbnRzKHgpLFxuICAgICAgICAgICAgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xuICAgICAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMTsgaTEgPCBuOyArK2kwLCArK2kxKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHB4WzBdW2kwXSwgcHlbMF1baTBdLCBweFsxXVtpMF0sIHB5WzFdW2kwXSwgeFtpMV0sIHlbaTFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG4vLyBTZWUgaHR0cHM6Ly93d3cucGFydGljbGVpbmNlbGwuY29tLzIwMTIvYmV6aWVyLXNwbGluZXMvIGZvciBkZXJpdmF0aW9uLlxuZnVuY3Rpb24gY29udHJvbFBvaW50cyh4KSB7XG4gIHZhciBpLFxuICAgICAgbiA9IHgubGVuZ3RoIC0gMSxcbiAgICAgIG0sXG4gICAgICBhID0gbmV3IEFycmF5KG4pLFxuICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkobik7XG4gIGFbMF0gPSAwLCBiWzBdID0gMiwgclswXSA9IHhbMF0gKyAyICogeFsxXTtcbiAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIGFbaV0gPSAxLCBiW2ldID0gNCwgcltpXSA9IDQgKiB4W2ldICsgMiAqIHhbaSArIDFdO1xuICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xuICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSBtID0gYVtpXSAvIGJbaSAtIDFdLCBiW2ldIC09IG0sIHJbaV0gLT0gbSAqIHJbaSAtIDFdO1xuICBhW24gLSAxXSA9IHJbbiAtIDFdIC8gYltuIC0gMV07XG4gIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcbiAgYltuIC0gMV0gPSAoeFtuXSArIGFbbiAtIDFdKSAvIDI7XG4gIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgKytpKSBiW2ldID0gMiAqIHhbaSArIDFdIC0gYVtpICsgMV07XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmZ1bmN0aW9uIG5hdHVyYWwoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIFN0ZXAoY29udGV4dCwgdCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fdCA9IHQ7XG59XG5cblN0ZXAucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKDAgPCB0aGlzLl90ICYmIHRoaXMuX3QgPCAxICYmIHRoaXMuX3BvaW50ID09PSAyKSB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB0aGlzLl95KTtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgaWYgKHRoaXMuX2xpbmUgPj0gMCkgdGhpcy5fdCA9IDEgLSB0aGlzLl90LCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl90IDw9IDApIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5KTtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgeDEgPSB0aGlzLl94ICogKDEgLSB0aGlzLl90KSArIHggKiB0aGlzLl90O1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB0aGlzLl95KTtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3ggPSB4LCB0aGlzLl95ID0geTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAwLjUpO1xufVxuXG5mdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xufVxuXG5mdW5jdGlvbiBzdGVwQWZ0ZXIoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMSk7XG59XG5cbmZ1bmN0aW9uIG5vbmUoc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMSkpIHJldHVybjtcbiAgZm9yICh2YXIgaSA9IDEsIGosIHMwLCBzMSA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzMCA9IHMxLCBzMSA9IHNlcmllc1tvcmRlcltpXV07XG4gICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgczFbal1bMV0gKz0gczFbal1bMF0gPSBpc05hTihzMFtqXVsxXSkgPyBzMFtqXVswXSA6IHMwW2pdWzFdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub25lJDEoc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShuKTtcbiAgd2hpbGUgKC0tbiA+PSAwKSBvW25dID0gbjtcbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIHN0YWNrVmFsdWUoZCwga2V5KSB7XG4gIHJldHVybiBkW2tleV07XG59XG5cbmZ1bmN0aW9uIHN0YWNrKCkge1xuICB2YXIga2V5cyA9IGNvbnN0YW50KFtdKSxcbiAgICAgIG9yZGVyID0gbm9uZSQxLFxuICAgICAgb2Zmc2V0ID0gbm9uZSxcbiAgICAgIHZhbHVlID0gc3RhY2tWYWx1ZTtcblxuICBmdW5jdGlvbiBzdGFjayhkYXRhKSB7XG4gICAgdmFyIGt6ID0ga2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBpLFxuICAgICAgICBtID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIG4gPSBrei5sZW5ndGgsXG4gICAgICAgIHN6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBvejtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGtpID0ga3pbaV0sIHNpID0gc3pbaV0gPSBuZXcgQXJyYXkobSksIGogPSAwLCBzaWo7IGogPCBtOyArK2opIHtcbiAgICAgICAgc2lbal0gPSBzaWogPSBbMCwgK3ZhbHVlKGRhdGFbal0sIGtpLCBqLCBkYXRhKV07XG4gICAgICAgIHNpai5kYXRhID0gZGF0YVtqXTtcbiAgICAgIH1cbiAgICAgIHNpLmtleSA9IGtpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG96ID0gb3JkZXIoc3opOyBpIDwgbjsgKytpKSB7XG4gICAgICBzeltveltpXV0uaW5kZXggPSBpO1xuICAgIH1cblxuICAgIG9mZnNldChzeiwgb3opO1xuICAgIHJldHVybiBzejtcbiAgfVxuXG4gIHN0YWNrLmtleXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoa2V5cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoc2xpY2UuY2FsbChfKSksIHN0YWNrKSA6IGtleXM7XG4gIH07XG5cbiAgc3RhY2sudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgc3RhY2spIDogdmFsdWU7XG4gIH07XG5cbiAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3JkZXIgPSBfID09IG51bGwgPyBub25lJDEgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBvcmRlcjtcbiAgfTtcblxuICBzdGFjay5vZmZzZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob2Zmc2V0ID0gXyA9PSBudWxsID8gbm9uZSA6IF8sIHN0YWNrKSA6IG9mZnNldDtcbiAgfTtcblxuICByZXR1cm4gc3RhY2s7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZChzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpLCBuLCBqID0gMCwgbSA9IHNlcmllc1swXS5sZW5ndGgsIHk7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHkgPSBpID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICBpZiAoeSkgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc2VyaWVzW2ldW2pdWzFdIC89IHk7XG4gIH1cbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cblxuZnVuY3Rpb24gZGl2ZXJnaW5nKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIGogPSAwLCBkLCBkeSwgeXAsIHluLCBuLCBtID0gc2VyaWVzW29yZGVyWzBdXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHlwID0geW4gPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChkeSA9IChkID0gc2VyaWVzW29yZGVyW2ldXVtqXSlbMV0gLSBkWzBdKSA+IDApIHtcbiAgICAgICAgZFswXSA9IHlwLCBkWzFdID0geXAgKz0gZHk7XG4gICAgICB9IGVsc2UgaWYgKGR5IDwgMCkge1xuICAgICAgICBkWzFdID0geW4sIGRbMF0gPSB5biArPSBkeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRbMF0gPSAwLCBkWzFdID0gZHk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNpbGhvdWV0dGUoc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaiA9IDAsIHMwID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMwLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGkgPSAwLCB5ID0gMDsgaSA8IG47ICsraSkgeSArPSBzZXJpZXNbaV1bal1bMV0gfHwgMDtcbiAgICBzMFtqXVsxXSArPSBzMFtqXVswXSA9IC15IC8gMjtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuXG5mdW5jdGlvbiB3aWdnbGUoc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkgfHwgISgobSA9IChzMCA9IHNlcmllc1tvcmRlclswXV0pLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciB5ID0gMCwgaiA9IDEsIHMwLCBtLCBuOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHMxID0gMCwgczIgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgc2kgPSBzZXJpZXNbb3JkZXJbaV1dLFxuICAgICAgICAgIHNpajAgPSBzaVtqXVsxXSB8fCAwLFxuICAgICAgICAgIHNpajEgPSBzaVtqIC0gMV1bMV0gfHwgMCxcbiAgICAgICAgICBzMyA9IChzaWowIC0gc2lqMSkgLyAyO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpOyArK2spIHtcbiAgICAgICAgdmFyIHNrID0gc2VyaWVzW29yZGVyW2tdXSxcbiAgICAgICAgICAgIHNrajAgPSBza1tqXVsxXSB8fCAwLFxuICAgICAgICAgICAgc2tqMSA9IHNrW2ogLSAxXVsxXSB8fCAwO1xuICAgICAgICBzMyArPSBza2owIC0gc2tqMTtcbiAgICAgIH1cbiAgICAgIHMxICs9IHNpajAsIHMyICs9IHMzICogc2lqMDtcbiAgICB9XG4gICAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XG4gICAgaWYgKHMxKSB5IC09IHMyIC8gczE7XG4gIH1cbiAgczBbaiAtIDFdWzFdICs9IHMwW2ogLSAxXVswXSA9IHk7XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG5cbmZ1bmN0aW9uIGFwcGVhcmFuY2Uoc2VyaWVzKSB7XG4gIHZhciBwZWFrcyA9IHNlcmllcy5tYXAocGVhayk7XG4gIHJldHVybiBub25lJDEoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHBlYWtzW2FdIC0gcGVha3NbYl07IH0pO1xufVxuXG5mdW5jdGlvbiBwZWFrKHNlcmllcykge1xuICB2YXIgaSA9IC0xLCBqID0gMCwgbiA9IHNlcmllcy5sZW5ndGgsIHZpLCB2aiA9IC1JbmZpbml0eTtcbiAgd2hpbGUgKCsraSA8IG4pIGlmICgodmkgPSArc2VyaWVzW2ldWzFdKSA+IHZqKSB2aiA9IHZpLCBqID0gaTtcbiAgcmV0dXJuIGo7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyhzZXJpZXMpIHtcbiAgdmFyIHN1bXMgPSBzZXJpZXMubWFwKHN1bSk7XG4gIHJldHVybiBub25lJDEoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYV0gLSBzdW1zW2JdOyB9KTtcbn1cblxuZnVuY3Rpb24gc3VtKHNlcmllcykge1xuICB2YXIgcyA9IDAsIGkgPSAtMSwgbiA9IHNlcmllcy5sZW5ndGgsIHY7XG4gIHdoaWxlICgrK2kgPCBuKSBpZiAodiA9ICtzZXJpZXNbaV1bMV0pIHMgKz0gdjtcbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGRlc2NlbmRpbmckMShzZXJpZXMpIHtcbiAgcmV0dXJuIGFzY2VuZGluZyhzZXJpZXMpLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gaW5zaWRlT3V0KHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHN1bXMgPSBzZXJpZXMubWFwKHN1bSksXG4gICAgICBvcmRlciA9IGFwcGVhcmFuY2Uoc2VyaWVzKSxcbiAgICAgIHRvcCA9IDAsXG4gICAgICBib3R0b20gPSAwLFxuICAgICAgdG9wcyA9IFtdLFxuICAgICAgYm90dG9tcyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBqID0gb3JkZXJbaV07XG4gICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICB0b3BzLnB1c2goaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdHRvbSArPSBzdW1zW2pdO1xuICAgICAgYm90dG9tcy5wdXNoKGopO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2Uoc2VyaWVzKSB7XG4gIHJldHVybiBub25lJDEoc2VyaWVzKS5yZXZlcnNlKCk7XG59XG5cbmV4cG9ydHMuYXJjID0gYXJjO1xuZXhwb3J0cy5hcmVhID0gYXJlYTtcbmV4cG9ydHMuYXJlYVJhZGlhbCA9IGFyZWFSYWRpYWw7XG5leHBvcnRzLmN1cnZlQmFzaXMgPSBiYXNpcztcbmV4cG9ydHMuY3VydmVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5jdXJ2ZUJhc2lzT3BlbiA9IGJhc2lzT3BlbjtcbmV4cG9ydHMuY3VydmVCdW5kbGUgPSBidW5kbGU7XG5leHBvcnRzLmN1cnZlQ2FyZGluYWwgPSBjYXJkaW5hbDtcbmV4cG9ydHMuY3VydmVDYXJkaW5hbENsb3NlZCA9IGNhcmRpbmFsQ2xvc2VkO1xuZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsT3BlbiA9IGNhcmRpbmFsT3BlbjtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tID0gY2F0bXVsbFJvbTtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkID0gY2F0bXVsbFJvbUNsb3NlZDtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tT3BlbiA9IGNhdG11bGxSb21PcGVuO1xuZXhwb3J0cy5jdXJ2ZUxpbmVhciA9IGN1cnZlTGluZWFyO1xuZXhwb3J0cy5jdXJ2ZUxpbmVhckNsb3NlZCA9IGxpbmVhckNsb3NlZDtcbmV4cG9ydHMuY3VydmVNb25vdG9uZVggPSBtb25vdG9uZVg7XG5leHBvcnRzLmN1cnZlTW9ub3RvbmVZID0gbW9ub3RvbmVZO1xuZXhwb3J0cy5jdXJ2ZU5hdHVyYWwgPSBuYXR1cmFsO1xuZXhwb3J0cy5jdXJ2ZVN0ZXAgPSBzdGVwO1xuZXhwb3J0cy5jdXJ2ZVN0ZXBBZnRlciA9IHN0ZXBBZnRlcjtcbmV4cG9ydHMuY3VydmVTdGVwQmVmb3JlID0gc3RlcEJlZm9yZTtcbmV4cG9ydHMubGluZSA9IGxpbmU7XG5leHBvcnRzLmxpbmVSYWRpYWwgPSBsaW5lUmFkaWFsJDE7XG5leHBvcnRzLmxpbmtIb3Jpem9udGFsID0gbGlua0hvcml6b250YWw7XG5leHBvcnRzLmxpbmtSYWRpYWwgPSBsaW5rUmFkaWFsO1xuZXhwb3J0cy5saW5rVmVydGljYWwgPSBsaW5rVmVydGljYWw7XG5leHBvcnRzLnBpZSA9IHBpZTtcbmV4cG9ydHMucG9pbnRSYWRpYWwgPSBwb2ludFJhZGlhbDtcbmV4cG9ydHMucmFkaWFsQXJlYSA9IGFyZWFSYWRpYWw7XG5leHBvcnRzLnJhZGlhbExpbmUgPSBsaW5lUmFkaWFsJDE7XG5leHBvcnRzLnN0YWNrID0gc3RhY2s7XG5leHBvcnRzLnN0YWNrT2Zmc2V0RGl2ZXJnaW5nID0gZGl2ZXJnaW5nO1xuZXhwb3J0cy5zdGFja09mZnNldEV4cGFuZCA9IGV4cGFuZDtcbmV4cG9ydHMuc3RhY2tPZmZzZXROb25lID0gbm9uZTtcbmV4cG9ydHMuc3RhY2tPZmZzZXRTaWxob3VldHRlID0gc2lsaG91ZXR0ZTtcbmV4cG9ydHMuc3RhY2tPZmZzZXRXaWdnbGUgPSB3aWdnbGU7XG5leHBvcnRzLnN0YWNrT3JkZXJBcHBlYXJhbmNlID0gYXBwZWFyYW5jZTtcbmV4cG9ydHMuc3RhY2tPcmRlckFzY2VuZGluZyA9IGFzY2VuZGluZztcbmV4cG9ydHMuc3RhY2tPcmRlckRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nJDE7XG5leHBvcnRzLnN0YWNrT3JkZXJJbnNpZGVPdXQgPSBpbnNpZGVPdXQ7XG5leHBvcnRzLnN0YWNrT3JkZXJOb25lID0gbm9uZSQxO1xuZXhwb3J0cy5zdGFja09yZGVyUmV2ZXJzZSA9IHJldmVyc2U7XG5leHBvcnRzLnN5bWJvbCA9IHN5bWJvbDtcbmV4cG9ydHMuc3ltYm9sQ2lyY2xlID0gY2lyY2xlO1xuZXhwb3J0cy5zeW1ib2xDcm9zcyA9IGNyb3NzO1xuZXhwb3J0cy5zeW1ib2xEaWFtb25kID0gZGlhbW9uZDtcbmV4cG9ydHMuc3ltYm9sU3F1YXJlID0gc3F1YXJlO1xuZXhwb3J0cy5zeW1ib2xTdGFyID0gc3RhcjtcbmV4cG9ydHMuc3ltYm9sVHJpYW5nbGUgPSB0cmlhbmdsZTtcbmV4cG9ydHMuc3ltYm9sV3llID0gd3llO1xuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9scztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10aW1lLWZvcm1hdC8gdjIuMi4zIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtdGltZScpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXRpbWUnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM1RpbWUpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBsb2NhbERhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xufVxuXG5mdW5jdGlvbiB1dGNEYXRlKGQpIHtcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xufVxuXG5mdW5jdGlvbiBuZXdEYXRlKHksIG0sIGQpIHtcbiAgcmV0dXJuIHt5OiB5LCBtOiBtLCBkOiBkLCBIOiAwLCBNOiAwLCBTOiAwLCBMOiAwfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9jYWxlKGxvY2FsZSkge1xuICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICB2YXIgcGVyaW9kUmUgPSBmb3JtYXRSZShsb2NhbGVfcGVyaW9kcyksXG4gICAgICBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICB2YXIgZm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0TWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgXCJxXCI6IGZvcm1hdFF1YXJ0ZXIsXG4gICAgXCJRXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBmb3JtYXRTZWNvbmRzLFxuICAgIFwidVwiOiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBmb3JtYXRXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0VVRDU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRVVENNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0VVRDTWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBmb3JtYXRVVENIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdFVUQ0hvdXIxMixcbiAgICBcImpcIjogZm9ybWF0VVRDRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRVVENNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdFVUQ01vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRVVENNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRVVENQZXJpb2QsXG4gICAgXCJxXCI6IGZvcm1hdFVUQ1F1YXJ0ZXIsXG4gICAgXCJRXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgIFwidVwiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBmb3JtYXRVVENXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRVVENGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0VVRDWm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgcGFyc2VzID0ge1xuICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICBcIkFcIjogcGFyc2VXZWVrZGF5LFxuICAgIFwiYlwiOiBwYXJzZVNob3J0TW9udGgsXG4gICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgXCJjXCI6IHBhcnNlTG9jYWxlRGF0ZVRpbWUsXG4gICAgXCJkXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBwYXJzZU1pY3Jvc2Vjb25kcyxcbiAgICBcIkhcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgIFwialwiOiBwYXJzZURheU9mWWVhcixcbiAgICBcIkxcIjogcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IHBhcnNlTWludXRlcyxcbiAgICBcInBcIjogcGFyc2VQZXJpb2QsXG4gICAgXCJxXCI6IHBhcnNlUXVhcnRlcixcbiAgICBcIlFcIjogcGFyc2VVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgXCJ1XCI6IHBhcnNlV2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBwYXJzZVdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYWQsXG4gICAgICAgICAgZm9ybWF0O1xuXG4gICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICBlbHNlIHBhZCA9IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIjtcbiAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQpO1xuICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIFopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgZCA9IG5ld0RhdGUoMTkwMCwgdW5kZWZpbmVkLCAxKSxcbiAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcgKz0gXCJcIiwgMCksXG4gICAgICAgICAgd2VlaywgZGF5O1xuICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIElmIGEgVU5JWCB0aW1lc3RhbXAgaXMgc3BlY2lmaWVkLCByZXR1cm4gaXQuXG4gICAgICBpZiAoXCJRXCIgaW4gZCkgcmV0dXJuIG5ldyBEYXRlKGQuUSk7XG4gICAgICBpZiAoXCJzXCIgaW4gZCkgcmV0dXJuIG5ldyBEYXRlKGQucyAqIDEwMDAgKyAoXCJMXCIgaW4gZCA/IGQuTCA6IDApKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyB1dGNQYXJzZSwgbmV2ZXIgdXNlIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAgICAgIGlmIChaICYmICEoXCJaXCIgaW4gZCkpIGQuWiA9IDA7XG5cbiAgICAgIC8vIFRoZSBhbS1wbSBmbGFnIGlzIDAgZm9yIEFNLCBhbmQgMSBmb3IgUE0uXG4gICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgLy8gSWYgdGhlIG1vbnRoIHdhcyBub3Qgc3BlY2lmaWVkLCBpbmhlcml0IGZyb20gdGhlIHF1YXJ0ZXIuXG4gICAgICBpZiAoZC5tID09PSB1bmRlZmluZWQpIGQubSA9IFwicVwiIGluIGQgPyBkLnEgOiAwO1xuXG4gICAgICAvLyBDb252ZXJ0IGRheS1vZi13ZWVrIGFuZCB3ZWVrLW9mLXllYXIgdG8gZGF5LW9mLXllYXIuXG4gICAgICBpZiAoXCJWXCIgaW4gZCkge1xuICAgICAgICBpZiAoZC5WIDwgMSB8fCBkLlYgPiA1MykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSAxO1xuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIHdlZWsgPSB1dGNEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSksIGRheSA9IHdlZWsuZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgd2VlayA9IGRheSA+IDQgfHwgZGF5ID09PSAwID8gZDNUaW1lLnV0Y01vbmRheS5jZWlsKHdlZWspIDogZDNUaW1lLnV0Y01vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gZDNUaW1lLnV0Y0RheS5vZmZzZXQod2VlaywgKGQuViAtIDEpICogNyk7XG4gICAgICAgICAgZC55ID0gd2Vlay5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgIGQubSA9IHdlZWsuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICBkLmQgPSB3ZWVrLmdldFVUQ0RhdGUoKSArIChkLncgKyA2KSAlIDc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2VlayA9IGxvY2FsRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLCBkYXkgPSB3ZWVrLmdldERheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IGQzVGltZS50aW1lTW9uZGF5LmNlaWwod2VlaykgOiBkM1RpbWUudGltZU1vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gZDNUaW1lLnRpbWVEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldE1vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXREYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJ1XCIgaW4gZCA/IGQudSAlIDcgOiBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgIGRheSA9IFwiWlwiIGluIGQgPyB1dGNEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSkuZ2V0VVRDRGF5KCkgOiBsb2NhbERhdGUobmV3RGF0ZShkLnksIDAsIDEpKS5nZXREYXkoKTtcbiAgICAgICAgZC5tID0gMDtcbiAgICAgICAgZC5kID0gXCJXXCIgaW4gZCA/IChkLncgKyA2KSAlIDcgKyBkLlcgKiA3IC0gKGRheSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cbiAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xuICAgICAgICByZXR1cm4gdXRjRGF0ZShkKTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgZmllbGRzIGFyZSBpbiBsb2NhbCB0aW1lLlxuICAgICAgcmV0dXJuIGxvY2FsRGF0ZShkKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgYyxcbiAgICAgICAgcGFyc2U7XG5cbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyaW9kUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQucCA9IHBlcmlvZExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0V2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0V2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSBzaG9ydFdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gd2Vla2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLncgPSB3ZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gbW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gbW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGVUaW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVEYXRlKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlVGltZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX3RpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFBlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRRdWFydGVyKGQpIHtcbiAgICByZXR1cm4gMSArIH5+KGQuZ2V0TW9udGgoKSAvIDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENQZXJpb2QoZCkge1xuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDUXVhcnRlcihkKSB7XG4gICAgcmV0dXJuIDEgKyB+fihkLmdldFVUQ01vbnRoKCkgLyAzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIgKz0gXCJcIiwgZmFsc2UpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICB1dGNGb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICB1dGNQYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCB0cnVlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHBhZHMgPSB7XCItXCI6IFwiXCIsIFwiX1wiOiBcIiBcIiwgXCIwXCI6IFwiMFwifSxcbiAgICBudW1iZXJSZSA9IC9eXFxzKlxcZCsvLCAvLyBub3RlOiBpZ25vcmVzIG5leHQgZGlyZWN0aXZlXG4gICAgcGVyY2VudFJlID0gL14lLyxcbiAgICByZXF1b3RlUmUgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICB2YXIgbWFwID0ge30sIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIG1hcFtuYW1lc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGk7XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC51ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlcklTTyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlYgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/Ly5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLlogPSBuWzFdID8gMCA6IC0oblsyXSArIChuWzNdIHx8IFwiMDBcIikpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVhcnRlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnEgPSBuWzBdICogMyAtIDMsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb250aE51bWJlcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLm0gPSBuWzBdIC0gMSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZlllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gMCwgZC5kID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIb3VyMjQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaW51dGVzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuTSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pY3Jvc2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLkwgPSBNYXRoLmZsb29yKG5bMF0gLyAxMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxpdGVyYWxQZXJjZW50KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IHBlcmNlbnRSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IGkgKyBuWzBdLmxlbmd0aCA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXAoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLlEgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5zID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudGltZURheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgcmV0dXJuIGRheSA9PT0gMCA/IDcgOiBkYXk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lU3VuZGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyBkM1RpbWUudGltZVRodXJzZGF5KGQpIDogZDNUaW1lLnRpbWVUaHVyc2RheS5jZWlsKGQpO1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lVGh1cnNkYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpLCBkKSArIChkM1RpbWUudGltZVllYXIoZCkuZ2V0RGF5KCkgPT09IDQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlclN1bmRheShkKSB7XG4gIHJldHVybiBkLmdldERheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZU1vbmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgZDNUaW1lLnV0Y0RheS5jb3VudChkM1RpbWUudXRjWWVhcihkKSwgZCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaWNyb3NlY29uZHMoZCwgcCkge1xuICByZXR1cm4gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApICsgXCIwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaW51dGVzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbnV0ZXMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlck1vbmRheShkKSB7XG4gIHZhciBkb3cgPSBkLmdldFVUQ0RheSgpO1xuICByZXR1cm4gZG93ID09PSAwID8gNyA6IGRvdztcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQoZDNUaW1lLnV0Y1N1bmRheS5jb3VudChkM1RpbWUudXRjWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldFVUQ0RheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyBkM1RpbWUudXRjVGh1cnNkYXkoZCkgOiBkM1RpbWUudXRjVGh1cnNkYXkuY2VpbChkKTtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjVGh1cnNkYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpICsgKGQzVGltZS51dGNZZWFyKGQpLmdldFVUQ0RheSgpID09PSA0KSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXkoZCkge1xuICByZXR1cm4gZC5nZXRVVENEYXkoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQoZDNUaW1lLnV0Y01vbmRheS5jb3VudChkM1RpbWUudXRjWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgcmV0dXJuIFwiKzAwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gIHJldHVybiBcIiVcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcChkKSB7XG4gIHJldHVybiArZDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMoZCkge1xuICByZXR1cm4gTWF0aC5mbG9vcigrZCAvIDEwMDApO1xufVxuXG52YXIgbG9jYWxlO1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICBleHBvcnRzLnRpbWVGb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLnRpbWVQYXJzZSA9IGxvY2FsZS5wYXJzZTtcbiAgZXhwb3J0cy51dGNGb3JtYXQgPSBsb2NhbGUudXRjRm9ybWF0O1xuICBleHBvcnRzLnV0Y1BhcnNlID0gbG9jYWxlLnV0Y1BhcnNlO1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG52YXIgaXNvU3BlY2lmaWVyID0gXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIjtcblxuZnVuY3Rpb24gZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTtcbn1cblxudmFyIGZvcm1hdElzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nXG4gICAgPyBmb3JtYXRJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjRm9ybWF0KGlzb1NwZWNpZmllcik7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvTmF0aXZlKHN0cmluZykge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xufVxuXG52YXIgcGFyc2VJc28gPSArbmV3IERhdGUoXCIyMDAwLTAxLTAxVDAwOjAwOjAwLjAwMFpcIilcbiAgICA/IHBhcnNlSXNvTmF0aXZlXG4gICAgOiBleHBvcnRzLnV0Y1BhcnNlKGlzb1NwZWNpZmllcik7XG5cbmV4cG9ydHMuaXNvRm9ybWF0ID0gZm9ybWF0SXNvO1xuZXhwb3J0cy5pc29QYXJzZSA9IHBhcnNlSXNvO1xuZXhwb3J0cy50aW1lRm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG5leHBvcnRzLnRpbWVGb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdGltZS8gdjEuMS4wIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHQwID0gbmV3IERhdGUsXG4gICAgdDEgPSBuZXcgRGF0ZTtcblxuZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCwgZmllbGQpIHtcblxuICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IG5ldyBEYXRlIDogbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfVxuXG4gIGludGVydmFsLmZsb29yID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBmbG9vcmkoZGF0ZSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGQwID0gaW50ZXJ2YWwoZGF0ZSksXG4gICAgICAgIGQxID0gaW50ZXJ2YWwuY2VpbChkYXRlKTtcbiAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgfTtcblxuICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICB2YXIgcmFuZ2UgPSBbXSwgcHJldmlvdXM7XG4gICAgc3RhcnQgPSBpbnRlcnZhbC5jZWlsKHN0YXJ0KTtcbiAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgZG8gcmFuZ2UucHVzaChwcmV2aW91cyA9IG5ldyBEYXRlKCtzdGFydCkpLCBvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICB3aGlsZSAocHJldmlvdXMgPCBzdGFydCAmJiBzdGFydCA8IHN0b3ApO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKytzdGVwIDw9IDApIHtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCAtMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gZWxzZSB3aGlsZSAoLS1zdGVwID49IDApIHtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCArMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoY291bnQpIHtcbiAgICBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHQwLnNldFRpbWUoK3N0YXJ0KSwgdDEuc2V0VGltZSgrZW5kKTtcbiAgICAgIGZsb29yaSh0MCksIGZsb29yaSh0MSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjb3VudCh0MCwgdDEpKTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZXZlcnkgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUoc3RlcCkgfHwgIShzdGVwID4gMCkgPyBudWxsXG4gICAgICAgICAgOiAhKHN0ZXAgPiAxKSA/IGludGVydmFsXG4gICAgICAgICAgOiBpbnRlcnZhbC5maWx0ZXIoZmllbGRcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbihkKSB7IHJldHVybiBmaWVsZChkKSAlIHN0ZXAgPT09IDA7IH1cbiAgICAgICAgICAgICAgOiBmdW5jdGlvbihkKSB7IHJldHVybiBpbnRlcnZhbC5jb3VudCgwLCBkKSAlIHN0ZXAgPT09IDA7IH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaW50ZXJ2YWw7XG59XG5cbnZhciBtaWxsaXNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKCkge1xuICAvLyBub29wXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxubWlsbGlzZWNvbmQuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBpZiAoIWlzRmluaXRlKGspIHx8ICEoayA+IDApKSByZXR1cm4gbnVsbDtcbiAgaWYgKCEoayA+IDEpKSByZXR1cm4gbWlsbGlzZWNvbmQ7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGspICogayk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGs7XG4gIH0pO1xufTtcbnZhciBtaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZC5yYW5nZTtcblxudmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xudmFyIGR1cmF0aW9uTWludXRlID0gNmU0O1xudmFyIGR1cmF0aW9uSG91ciA9IDM2ZTU7XG52YXIgZHVyYXRpb25EYXkgPSA4NjRlNTtcbnZhciBkdXJhdGlvbldlZWsgPSA2MDQ4ZTU7XG5cbnZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQ7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ1NlY29uZHMoKTtcbn0pO1xudmFyIHNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbnZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShkYXRlIC0gZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAtIGRhdGUuZ2V0U2Vjb25kcygpICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNaW51dGVzKCk7XG59KTtcbnZhciBtaW51dGVzID0gbWludXRlLnJhbmdlO1xuXG52YXIgaG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gZGF0ZS5nZXRTZWNvbmRzKCkgKiBkdXJhdGlvblNlY29uZCAtIGRhdGUuZ2V0TWludXRlcygpICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcbnZhciBob3VycyA9IGhvdXIucmFuZ2U7XG5cbnZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbn0pO1xudmFyIGRheXMgPSBkYXkucmFuZ2U7XG5cbmZ1bmN0aW9uIHdlZWtkYXkoaSkge1xuICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIChkYXRlLmdldERheSgpICsgNyAtIGkpICUgNyk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXAgKiA3KTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbnZhciBzdW5kYXkgPSB3ZWVrZGF5KDApO1xudmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG52YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG52YXIgd2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcbnZhciB0aHVyc2RheSA9IHdlZWtkYXkoNCk7XG52YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbnZhciBzYXR1cmRheSA9IHdlZWtkYXkoNik7XG5cbnZhciBzdW5kYXlzID0gc3VuZGF5LnJhbmdlO1xudmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG52YXIgdHVlc2RheXMgPSB0dWVzZGF5LnJhbmdlO1xudmFyIHdlZG5lc2RheXMgPSB3ZWRuZXNkYXkucmFuZ2U7XG52YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG52YXIgZnJpZGF5cyA9IGZyaWRheS5yYW5nZTtcbnZhciBzYXR1cmRheXMgPSBzYXR1cmRheS5yYW5nZTtcblxudmFyIG1vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldERhdGUoMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xufSk7XG52YXIgbW9udGhzID0gbW9udGgucmFuZ2U7XG5cbnZhciB5ZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnllYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xudmFyIHllYXJzID0geWVhci5yYW5nZTtcblxudmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG59KTtcbnZhciB1dGNNaW51dGVzID0gdXRjTWludXRlLnJhbmdlO1xuXG52YXIgdXRjSG91ciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNaW51dGVzKDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0hvdXJzKCk7XG59KTtcbnZhciB1dGNIb3VycyA9IHV0Y0hvdXIucmFuZ2U7XG5cbnZhciB1dGNEYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG52YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG52YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbnZhciB1dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xudmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xudmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG52YXIgdXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xudmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG52YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG52YXIgdXRjU3VuZGF5cyA9IHV0Y1N1bmRheS5yYW5nZTtcbnZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xudmFyIHV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheS5yYW5nZTtcbnZhciB1dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5LnJhbmdlO1xudmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xudmFyIHV0Y0ZyaWRheXMgPSB1dGNGcmlkYXkucmFuZ2U7XG52YXIgdXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXkucmFuZ2U7XG5cbnZhciB1dGNNb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn0pO1xudmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuXG52YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG51dGNZZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcbnZhciB1dGNZZWFycyA9IHV0Y1llYXIucmFuZ2U7XG5cbmV4cG9ydHMudGltZURheSA9IGRheTtcbmV4cG9ydHMudGltZURheXMgPSBkYXlzO1xuZXhwb3J0cy50aW1lRnJpZGF5ID0gZnJpZGF5O1xuZXhwb3J0cy50aW1lRnJpZGF5cyA9IGZyaWRheXM7XG5leHBvcnRzLnRpbWVIb3VyID0gaG91cjtcbmV4cG9ydHMudGltZUhvdXJzID0gaG91cnM7XG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IG5ld0ludGVydmFsO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbmV4cG9ydHMudGltZU1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbmV4cG9ydHMudGltZU1pbnV0ZSA9IG1pbnV0ZTtcbmV4cG9ydHMudGltZU1pbnV0ZXMgPSBtaW51dGVzO1xuZXhwb3J0cy50aW1lTW9uZGF5ID0gbW9uZGF5O1xuZXhwb3J0cy50aW1lTW9uZGF5cyA9IG1vbmRheXM7XG5leHBvcnRzLnRpbWVNb250aCA9IG1vbnRoO1xuZXhwb3J0cy50aW1lTW9udGhzID0gbW9udGhzO1xuZXhwb3J0cy50aW1lU2F0dXJkYXkgPSBzYXR1cmRheTtcbmV4cG9ydHMudGltZVNhdHVyZGF5cyA9IHNhdHVyZGF5cztcbmV4cG9ydHMudGltZVNlY29uZCA9IHNlY29uZDtcbmV4cG9ydHMudGltZVNlY29uZHMgPSBzZWNvbmRzO1xuZXhwb3J0cy50aW1lU3VuZGF5ID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lU3VuZGF5cyA9IHN1bmRheXM7XG5leHBvcnRzLnRpbWVUaHVyc2RheSA9IHRodXJzZGF5O1xuZXhwb3J0cy50aW1lVGh1cnNkYXlzID0gdGh1cnNkYXlzO1xuZXhwb3J0cy50aW1lVHVlc2RheSA9IHR1ZXNkYXk7XG5leHBvcnRzLnRpbWVUdWVzZGF5cyA9IHR1ZXNkYXlzO1xuZXhwb3J0cy50aW1lV2VkbmVzZGF5ID0gd2VkbmVzZGF5O1xuZXhwb3J0cy50aW1lV2VkbmVzZGF5cyA9IHdlZG5lc2RheXM7XG5leHBvcnRzLnRpbWVXZWVrID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lV2Vla3MgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lWWVhciA9IHllYXI7XG5leHBvcnRzLnRpbWVZZWFycyA9IHllYXJzO1xuZXhwb3J0cy51dGNEYXkgPSB1dGNEYXk7XG5leHBvcnRzLnV0Y0RheXMgPSB1dGNEYXlzO1xuZXhwb3J0cy51dGNGcmlkYXkgPSB1dGNGcmlkYXk7XG5leHBvcnRzLnV0Y0ZyaWRheXMgPSB1dGNGcmlkYXlzO1xuZXhwb3J0cy51dGNIb3VyID0gdXRjSG91cjtcbmV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VycztcbmV4cG9ydHMudXRjTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbmV4cG9ydHMudXRjTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG5leHBvcnRzLnV0Y01pbnV0ZXMgPSB1dGNNaW51dGVzO1xuZXhwb3J0cy51dGNNb25kYXkgPSB1dGNNb25kYXk7XG5leHBvcnRzLnV0Y01vbmRheXMgPSB1dGNNb25kYXlzO1xuZXhwb3J0cy51dGNNb250aCA9IHV0Y01vbnRoO1xuZXhwb3J0cy51dGNNb250aHMgPSB1dGNNb250aHM7XG5leHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjU2F0dXJkYXk7XG5leHBvcnRzLnV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5cztcbmV4cG9ydHMudXRjU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy51dGNTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudXRjU3VuZGF5ID0gdXRjU3VuZGF5O1xuZXhwb3J0cy51dGNTdW5kYXlzID0gdXRjU3VuZGF5cztcbmV4cG9ydHMudXRjVGh1cnNkYXkgPSB1dGNUaHVyc2RheTtcbmV4cG9ydHMudXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXlzO1xuZXhwb3J0cy51dGNUdWVzZGF5ID0gdXRjVHVlc2RheTtcbmV4cG9ydHMudXRjVHVlc2RheXMgPSB1dGNUdWVzZGF5cztcbmV4cG9ydHMudXRjV2VkbmVzZGF5ID0gdXRjV2VkbmVzZGF5O1xuZXhwb3J0cy51dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5cztcbmV4cG9ydHMudXRjV2VlayA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjV2Vla3MgPSB1dGNTdW5kYXlzO1xuZXhwb3J0cy51dGNZZWFyID0gdXRjWWVhcjtcbmV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFycztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10aW1lci8gdjEuMC4xMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBmcmFtZSA9IDAsIC8vIGlzIGFuIGFuaW1hdGlvbiBmcmFtZSBwZW5kaW5nP1xuICAgIHRpbWVvdXQgPSAwLCAvLyBpcyBhIHRpbWVvdXQgcGVuZGluZz9cbiAgICBpbnRlcnZhbCA9IDAsIC8vIGFyZSBhbnkgdGltZXJzIGFjdGl2ZT9cbiAgICBwb2tlRGVsYXkgPSAxMDAwLCAvLyBob3cgZnJlcXVlbnRseSB3ZSBjaGVjayBmb3IgY2xvY2sgc2tld1xuICAgIHRhc2tIZWFkLFxuICAgIHRhc2tUYWlsLFxuICAgIGNsb2NrTGFzdCA9IDAsXG4gICAgY2xvY2tOb3cgPSAwLFxuICAgIGNsb2NrU2tldyA9IDAsXG4gICAgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlLFxuICAgIHNldEZyYW1lID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdykgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMTcpOyB9O1xuXG5mdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiBjbG9ja05vdyB8fCAoc2V0RnJhbWUoY2xlYXJOb3cpLCBjbG9ja05vdyA9IGNsb2NrLm5vdygpICsgY2xvY2tTa2V3KTtcbn1cblxuZnVuY3Rpb24gY2xlYXJOb3coKSB7XG4gIGNsb2NrTm93ID0gMDtcbn1cblxuZnVuY3Rpb24gVGltZXIoKSB7XG4gIHRoaXMuX2NhbGwgPVxuICB0aGlzLl90aW1lID1cbiAgdGhpcy5fbmV4dCA9IG51bGw7XG59XG5cblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRpbWVyLFxuICByZXN0YXJ0OiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcbiAgICBpZiAoIXRoaXMuX25leHQgJiYgdGFza1RhaWwgIT09IHRoaXMpIHtcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xuICAgICAgZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBzbGVlcCgpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyO1xuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIHRpbWVyRmx1c2goKSB7XG4gIG5vdygpOyAvLyBHZXQgdGhlIGN1cnJlbnQgdGltZSwgaWYgbm90IGFscmVhZHkgc2V0LlxuICArK2ZyYW1lOyAvLyBQcmV0ZW5kIHdl4oCZdmUgc2V0IGFuIGFsYXJtLCBpZiB3ZSBoYXZlbuKAmXQgYWxyZWFkeS5cbiAgdmFyIHQgPSB0YXNrSGVhZCwgZTtcbiAgd2hpbGUgKHQpIHtcbiAgICBpZiAoKGUgPSBjbG9ja05vdyAtIHQuX3RpbWUpID49IDApIHQuX2NhbGwuY2FsbChudWxsLCBlKTtcbiAgICB0ID0gdC5fbmV4dDtcbiAgfVxuICAtLWZyYW1lO1xufVxuXG5mdW5jdGlvbiB3YWtlKCkge1xuICBjbG9ja05vdyA9IChjbG9ja0xhc3QgPSBjbG9jay5ub3coKSkgKyBjbG9ja1NrZXc7XG4gIGZyYW1lID0gdGltZW91dCA9IDA7XG4gIHRyeSB7XG4gICAgdGltZXJGbHVzaCgpO1xuICB9IGZpbmFsbHkge1xuICAgIGZyYW1lID0gMDtcbiAgICBuYXAoKTtcbiAgICBjbG9ja05vdyA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9rZSgpIHtcbiAgdmFyIG5vdyA9IGNsb2NrLm5vdygpLCBkZWxheSA9IG5vdyAtIGNsb2NrTGFzdDtcbiAgaWYgKGRlbGF5ID4gcG9rZURlbGF5KSBjbG9ja1NrZXcgLT0gZGVsYXksIGNsb2NrTGFzdCA9IG5vdztcbn1cblxuZnVuY3Rpb24gbmFwKCkge1xuICB2YXIgdDAsIHQxID0gdGFza0hlYWQsIHQyLCB0aW1lID0gSW5maW5pdHk7XG4gIHdoaWxlICh0MSkge1xuICAgIGlmICh0MS5fY2FsbCkge1xuICAgICAgaWYgKHRpbWUgPiB0MS5fdGltZSkgdGltZSA9IHQxLl90aW1lO1xuICAgICAgdDAgPSB0MSwgdDEgPSB0MS5fbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgPSB0MS5fbmV4dCwgdDEuX25leHQgPSBudWxsO1xuICAgICAgdDEgPSB0MCA/IHQwLl9uZXh0ID0gdDIgOiB0YXNrSGVhZCA9IHQyO1xuICAgIH1cbiAgfVxuICB0YXNrVGFpbCA9IHQwO1xuICBzbGVlcCh0aW1lKTtcbn1cblxuZnVuY3Rpb24gc2xlZXAodGltZSkge1xuICBpZiAoZnJhbWUpIHJldHVybjsgLy8gU29vbmVzdCBhbGFybSBhbHJlYWR5IHNldCwgb3Igd2lsbCBiZS5cbiAgaWYgKHRpbWVvdXQpIHRpbWVvdXQgPSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIHZhciBkZWxheSA9IHRpbWUgLSBjbG9ja05vdzsgLy8gU3RyaWN0bHkgbGVzcyB0aGFuIGlmIHdlIHJlY29tcHV0ZWQgY2xvY2tOb3cuXG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgdGltZSAtIGNsb2NrLm5vdygpIC0gY2xvY2tTa2V3KTtcbiAgICBpZiAoaW50ZXJ2YWwpIGludGVydmFsID0gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFpbnRlcnZhbCkgY2xvY2tMYXN0ID0gY2xvY2subm93KCksIGludGVydmFsID0gc2V0SW50ZXJ2YWwocG9rZSwgcG9rZURlbGF5KTtcbiAgICBmcmFtZSA9IDEsIHNldEZyYW1lKHdha2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpbWVvdXQkMShjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIGRlbGF5ID0gZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXk7XG4gIHQucmVzdGFydChmdW5jdGlvbihlbGFwc2VkKSB7XG4gICAgdC5zdG9wKCk7XG4gICAgY2FsbGJhY2soZWxhcHNlZCArIGRlbGF5KTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW50ZXJ2YWwkMShjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXIsIHRvdGFsID0gZGVsYXk7XG4gIGlmIChkZWxheSA9PSBudWxsKSByZXR1cm4gdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSksIHQ7XG4gIGRlbGF5ID0gK2RlbGF5LCB0aW1lID0gdGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgdC5yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5pbnRlcnZhbCA9IGludGVydmFsJDE7XG5leHBvcnRzLm5vdyA9IG5vdztcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQkMTtcbmV4cG9ydHMudGltZXIgPSB0aW1lcjtcbmV4cG9ydHMudGltZXJGbHVzaCA9IHRpbWVyRmx1c2g7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdHJhbnNpdGlvbi8gdjEuMy4yIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtc2VsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXRpbWVyJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLWNvbG9yJyksIHJlcXVpcmUoJ2QzLWVhc2UnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1zZWxlY3Rpb24nLCAnZDMtZGlzcGF0Y2gnLCAnZDMtdGltZXInLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtY29sb3InLCAnZDMtZWFzZSddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM1NlbGVjdGlvbiwgZDNEaXNwYXRjaCwgZDNUaW1lciwgZDNJbnRlcnBvbGF0ZSwgZDNDb2xvciwgZDNFYXNlKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T24gPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJjYW5jZWxcIiwgXCJpbnRlcnJ1cHRcIik7XG52YXIgZW1wdHlUd2VlbiA9IFtdO1xuXG52YXIgQ1JFQVRFRCA9IDA7XG52YXIgU0NIRURVTEVEID0gMTtcbnZhciBTVEFSVElORyA9IDI7XG52YXIgU1RBUlRFRCA9IDM7XG52YXIgUlVOTklORyA9IDQ7XG52YXIgRU5ESU5HID0gNTtcbnZhciBFTkRFRCA9IDY7XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpbmRleCwgZ3JvdXAsIHRpbWluZykge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGVzKSBub2RlLl9fdHJhbnNpdGlvbiA9IHt9O1xuICBlbHNlIGlmIChpZCBpbiBzY2hlZHVsZXMpIHJldHVybjtcbiAgY3JlYXRlKG5vZGUsIGlkLCB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBpbmRleDogaW5kZXgsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBncm91cDogZ3JvdXAsIC8vIEZvciBjb250ZXh0IGR1cmluZyBjYWxsYmFjay5cbiAgICBvbjogZW1wdHlPbixcbiAgICB0d2VlbjogZW1wdHlUd2VlbixcbiAgICB0aW1lOiB0aW1pbmcudGltZSxcbiAgICBkZWxheTogdGltaW5nLmRlbGF5LFxuICAgIGR1cmF0aW9uOiB0aW1pbmcuZHVyYXRpb24sXG4gICAgZWFzZTogdGltaW5nLmVhc2UsXG4gICAgdGltZXI6IG51bGwsXG4gICAgc3RhdGU6IENSRUFURURcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gZ2V0KG5vZGUsIGlkKTtcbiAgaWYgKHNjaGVkdWxlLnN0YXRlID4gQ1JFQVRFRCkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGU7IGFscmVhZHkgc2NoZWR1bGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIHNldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBTVEFSVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBydW5uaW5nXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSBkM1RpbWVyLnRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIGQzVGltZXIudGltZW91dChzdGFydCk7XG5cbiAgICAgIC8vIEludGVycnVwdCB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGlmIGFueS5cbiAgICAgIGlmIChvLnN0YXRlID09PSBSVU5OSU5HKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIGFueSBwcmUtZW1wdGVkIHRyYW5zaXRpb25zLlxuICAgICAgZWxzZSBpZiAoK2kgPCBpZCkge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJjYW5jZWxcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG4gICAgZDNUaW1lci50aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobm9kZSwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnJ1cHQobm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcbiAgICAgIGk7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcblxuICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5uYW1lICE9PSBuYW1lKSB7IGVtcHR5ID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgYWN0aXZlID0gc2NoZWR1bGUuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZS5zdGF0ZSA8IEVORElORztcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IEVOREVEO1xuICAgIHNjaGVkdWxlLnRpbWVyLnN0b3AoKTtcbiAgICBzY2hlZHVsZS5vbi5jYWxsKGFjdGl2ZSA/IFwiaW50ZXJydXB0XCIgOiBcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2ludGVycnVwdChuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdHdlZW5SZW1vdmUoaWQsIG5hbWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9IHR3ZWVuMCA9IHR3ZWVuO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMSA9IHR3ZWVuMS5zbGljZSgpO1xuICAgICAgICAgIHR3ZWVuMS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHdlZW5GdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHR3ZWVuMCwgdHdlZW4xO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fdHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCh0aGlzLm5vZGUoKSwgaWQpLnR3ZWVuO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4ubGVuZ3RoLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHQgPSB0d2VlbltpXSkubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsID8gdHdlZW5SZW1vdmUgOiB0d2VlbkZ1bmN0aW9uKShpZCwgbmFtZSwgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gdHdlZW5WYWx1ZSh0cmFuc2l0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0cmFuc2l0aW9uLl9pZDtcblxuICB0cmFuc2l0aW9uLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKTtcbiAgICAoc2NoZWR1bGUudmFsdWUgfHwgKHNjaGVkdWxlLnZhbHVlID0ge30pKVtuYW1lXSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGdldChub2RlLCBpZCkudmFsdWVbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIpIHtcbiAgdmFyIGM7XG4gIHJldHVybiAodHlwZW9mIGIgPT09IFwibnVtYmVyXCIgPyBkM0ludGVycG9sYXRlLmludGVycG9sYXRlTnVtYmVyXG4gICAgICA6IGIgaW5zdGFuY2VvZiBkM0NvbG9yLmNvbG9yID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGQzQ29sb3IuY29sb3IoYikpID8gKGIgPSBjLCBkM0ludGVycG9sYXRlLmludGVycG9sYXRlUmdiKVxuICAgICAgOiBkM0ludGVycG9sYXRlLmludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUxKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TKGZ1bGxuYW1lLCBpbnRlcnBvbGF0ZSwgdmFsdWUpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCwgdmFsdWUxID0gdmFsdWUodGhpcyksIHN0cmluZzE7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nMCA9PT0gc3RyaW5nMSA/IG51bGxcbiAgICAgICAgOiBzdHJpbmcwID09PSBzdHJpbmcwMCAmJiBzdHJpbmcxID09PSBzdHJpbmcxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IChzdHJpbmcxMCA9IHN0cmluZzEsIGludGVycG9sYXRlMCA9IGludGVycG9sYXRlKHN0cmluZzAwID0gc3RyaW5nMCwgdmFsdWUxKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBkM1NlbGVjdGlvbi5uYW1lc3BhY2UobmFtZSksIGkgPSBmdWxsbmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKShmdWxsbmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcImF0dHIuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHZhbHVlID09IG51bGwgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyUmVtb3ZlTlMgOiBhdHRyUmVtb3ZlKShmdWxsbmFtZSlcbiAgICAgIDogKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQpKGZ1bGxuYW1lLCBpLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIGkuY2FsbCh0aGlzLCB0KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIGF0dHJJbnRlcnBvbGF0ZU5TKGZ1bGxuYW1lLCBpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlKG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2F0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJhdHRyLlwiICsgbmFtZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICB2YXIgZnVsbG5hbWUgPSBkM1NlbGVjdGlvbi5uYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgKGZ1bGxuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pKGZ1bGxuYW1lLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2RlbGF5KHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9kdXJhdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXG4gICAgICAgICAgOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5kdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZWFzZSA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2Vhc2UodmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKGVhc2VDb25zdGFudChpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQodGhpcy5ub2RlKCksIGlkKS5lYXNlO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2ZpbHRlcihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gZDNTZWxlY3Rpb24ubWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX21lcmdlKHRyYW5zaXRpb24pIHtcbiAgaWYgKHRyYW5zaXRpb24uX2lkICE9PSB0aGlzLl9pZCkgdGhyb3cgbmV3IEVycm9yO1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSB0cmFuc2l0aW9uLl9ncm91cHMsIG0wID0gZ3JvdXBzMC5sZW5ndGgsIG0xID0gZ3JvdXBzMS5sZW5ndGgsIG0gPSBNYXRoLm1pbihtMCwgbTEpLCBtZXJnZXMgPSBuZXcgQXJyYXkobTApLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwMCA9IGdyb3VwczBbal0sIGdyb3VwMSA9IGdyb3VwczFbal0sIG4gPSBncm91cDAubGVuZ3RoLCBtZXJnZSA9IG1lcmdlc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXAwW2ldIHx8IGdyb3VwMVtpXSkge1xuICAgICAgICBtZXJnZVtpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGogPCBtMDsgKytqKSB7XG4gICAgbWVyZ2VzW2pdID0gZ3JvdXBzMFtqXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn1cblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2l0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCkgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihuYW1lLCBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9vbihuYW1lLCBsaXN0ZW5lcikge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDJcbiAgICAgID8gZ2V0KHRoaXMubm9kZSgpLCBpZCkub24ub24obmFtZSlcbiAgICAgIDogdGhpcy5lYWNoKG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fcmVtb3ZlKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zZWxlY3Qoc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gZDNTZWxlY3Rpb24uc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIHNjaGVkdWxlKHN1Ymdyb3VwW2ldLCBuYW1lLCBpZCwgaSwgc3ViZ3JvdXAsIGdldChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zZWxlY3RBbGwoc2VsZWN0KSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gZDNTZWxlY3Rpb24uc2VsZWN0b3JBbGwoc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSwgY2hpbGQsIGluaGVyaXQgPSBnZXQobm9kZSwgaWQpLCBrID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgayA8IGw7ICsraykge1xuICAgICAgICAgIGlmIChjaGlsZCA9IGNoaWxkcmVuW2tdKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShjaGlsZCwgbmFtZSwgaWQsIGssIGNoaWxkcmVuLCBpbmhlcml0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goY2hpbGRyZW4pO1xuICAgICAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpO1xufVxuXG52YXIgU2VsZWN0aW9uID0gZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlTnVsbChuYW1lLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHN0cmluZzEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCBzdHJpbmcxMCA9IHN0cmluZzEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpLFxuICAgICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIjtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHN0cmluZzEgPSB2YWx1ZTEgPSAodGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKSwgZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVNYXliZVJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgb24wLCBvbjEsIGxpc3RlbmVyMCwga2V5ID0gXCJzdHlsZS5cIiArIG5hbWUsIGV2ZW50ID0gXCJlbmQuXCIgKyBrZXksIHJlbW92ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIG9uID0gc2NoZWR1bGUub24sXG4gICAgICAgIGxpc3RlbmVyID0gc2NoZWR1bGUudmFsdWVba2V5XSA9PSBudWxsID8gcmVtb3ZlIHx8IChyZW1vdmUgPSBzdHlsZVJlbW92ZShuYW1lKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIGEgZGlzcGF0Y2ggd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKG9uICE9PSBvbjAgfHwgbGlzdGVuZXIwICE9PSBsaXN0ZW5lcikgKG9uMSA9IChvbjAgPSBvbikuY29weSgpKS5vbihldmVudCwgbGlzdGVuZXIwID0gbGlzdGVuZXIpO1xuXG4gICAgc2NoZWR1bGUub24gPSBvbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fc3R5bGUobmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBkM0ludGVycG9sYXRlLmludGVycG9sYXRlVHJhbnNmb3JtQ3NzIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVOdWxsKG5hbWUsIGkpKVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgc3R5bGVSZW1vdmUobmFtZSkpXG4gICAgOiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXNcbiAgICAgIC5zdHlsZVR3ZWVuKG5hbWUsIHN0eWxlRnVuY3Rpb24obmFtZSwgaSwgdHdlZW5WYWx1ZSh0aGlzLCBcInN0eWxlLlwiICsgbmFtZSwgdmFsdWUpKSlcbiAgICAgIC5lYWNoKHN0eWxlTWF5YmVSZW1vdmUodGhpcy5faWQsIG5hbWUpKVxuICAgIDogdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVDb25zdGFudChuYW1lLCBpLCB2YWx1ZSksIHByaW9yaXR5KVxuICAgICAgLm9uKFwiZW5kLnN0eWxlLlwiICsgbmFtZSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkuY2FsbCh0aGlzLCB0KSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgdCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQgPSAoaTAgPSBpKSAmJiBzdHlsZUludGVycG9sYXRlKG5hbWUsIGksIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBrZXkgPSBcInN0eWxlLlwiICsgKG5hbWUgKz0gXCJcIik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBzdHlsZVR3ZWVuKG5hbWUsIHZhbHVlLCBwcmlvcml0eSA9PSBudWxsID8gXCJcIiA6IHByaW9yaXR5KSk7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWUxID09IG51bGwgPyBcIlwiIDogdmFsdWUxO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3RleHQodmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufVxuXG5mdW5jdGlvbiB0ZXh0SW50ZXJwb2xhdGUoaSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSBpLmNhbGwodGhpcywgdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRUd2Vlbih2YWx1ZSkge1xuICB2YXIgdDAsIGkwO1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGkgIT09IGkwKSB0MCA9IChpMCA9IGkpICYmIHRleHRJbnRlcnBvbGF0ZShpKTtcbiAgICByZXR1cm4gdDA7XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl90ZXh0VHdlZW4odmFsdWUpIHtcbiAgdmFyIGtleSA9IFwidGV4dFwiO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgdGV4dFR3ZWVuKHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fdHJhbnNpdGlvbigpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQwID0gdGhpcy5faWQsXG4gICAgICBpZDEgPSBuZXdJZCgpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHZhciBpbmhlcml0ID0gZ2V0KG5vZGUsIGlkMCk7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkMSwgaSwgZ3JvdXAsIHtcbiAgICAgICAgICB0aW1lOiBpbmhlcml0LnRpbWUgKyBpbmhlcml0LmRlbGF5ICsgaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQxKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9lbmQoKSB7XG4gIHZhciBvbjAsIG9uMSwgdGhhdCA9IHRoaXMsIGlkID0gdGhhdC5faWQsIHNpemUgPSB0aGF0LnNpemUoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBjYW5jZWwgPSB7dmFsdWU6IHJlamVjdH0sXG4gICAgICAgIGVuZCA9IHt2YWx1ZTogZnVuY3Rpb24oKSB7IGlmICgtLXNpemUgPT09IDApIHJlc29sdmUoKTsgfX07XG5cbiAgICB0aGF0LmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICAgIG9uID0gc2NoZWR1bGUub247XG5cbiAgICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgICBpZiAob24gIT09IG9uMCkge1xuICAgICAgICBvbjEgPSAob24wID0gb24pLmNvcHkoKTtcbiAgICAgICAgb24xLl8uY2FuY2VsLnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uaW50ZXJydXB0LnB1c2goY2FuY2VsKTtcbiAgICAgICAgb24xLl8uZW5kLnB1c2goZW5kKTtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGUub24gPSBvbjE7XG4gICAgfSk7XG4gIH0pO1xufVxuXG52YXIgaWQgPSAwO1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGdyb3VwcywgcGFyZW50cywgbmFtZSwgaWQpIHtcbiAgdGhpcy5fZ3JvdXBzID0gZ3JvdXBzO1xuICB0aGlzLl9wYXJlbnRzID0gcGFyZW50cztcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2lkID0gaWQ7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb24obmFtZSkge1xuICByZXR1cm4gZDNTZWxlY3Rpb24uc2VsZWN0aW9uKCkudHJhbnNpdGlvbihuYW1lKTtcbn1cblxuZnVuY3Rpb24gbmV3SWQoKSB7XG4gIHJldHVybiArK2lkO1xufVxuXG52YXIgc2VsZWN0aW9uX3Byb3RvdHlwZSA9IGQzU2VsZWN0aW9uLnNlbGVjdGlvbi5wcm90b3R5cGU7XG5cblRyYW5zaXRpb24ucHJvdG90eXBlID0gdHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2l0aW9uLFxuICBzZWxlY3Q6IHRyYW5zaXRpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHRyYW5zaXRpb25fc2VsZWN0QWxsLFxuICBmaWx0ZXI6IHRyYW5zaXRpb25fZmlsdGVyLFxuICBtZXJnZTogdHJhbnNpdGlvbl9tZXJnZSxcbiAgc2VsZWN0aW9uOiB0cmFuc2l0aW9uX3NlbGVjdGlvbixcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbl90cmFuc2l0aW9uLFxuICBjYWxsOiBzZWxlY3Rpb25fcHJvdG90eXBlLmNhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fcHJvdG90eXBlLm5vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9wcm90b3R5cGUuc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9wcm90b3R5cGUuZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9wcm90b3R5cGUuZWFjaCxcbiAgb246IHRyYW5zaXRpb25fb24sXG4gIGF0dHI6IHRyYW5zaXRpb25fYXR0cixcbiAgYXR0clR3ZWVuOiB0cmFuc2l0aW9uX2F0dHJUd2VlbixcbiAgc3R5bGU6IHRyYW5zaXRpb25fc3R5bGUsXG4gIHN0eWxlVHdlZW46IHRyYW5zaXRpb25fc3R5bGVUd2VlbixcbiAgdGV4dDogdHJhbnNpdGlvbl90ZXh0LFxuICB0ZXh0VHdlZW46IHRyYW5zaXRpb25fdGV4dFR3ZWVuLFxuICByZW1vdmU6IHRyYW5zaXRpb25fcmVtb3ZlLFxuICB0d2VlbjogdHJhbnNpdGlvbl90d2VlbixcbiAgZGVsYXk6IHRyYW5zaXRpb25fZGVsYXksXG4gIGR1cmF0aW9uOiB0cmFuc2l0aW9uX2R1cmF0aW9uLFxuICBlYXNlOiB0cmFuc2l0aW9uX2Vhc2UsXG4gIGVuZDogdHJhbnNpdGlvbl9lbmRcbn07XG5cbnZhciBkZWZhdWx0VGltaW5nID0ge1xuICB0aW1lOiBudWxsLCAvLyBTZXQgb24gdXNlLlxuICBkZWxheTogMCxcbiAgZHVyYXRpb246IDI1MCxcbiAgZWFzZTogZDNFYXNlLmVhc2VDdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VGltaW5nLnRpbWUgPSBkM1RpbWVyLm5vdygpLCBkZWZhdWx0VGltaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGltaW5nO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fdHJhbnNpdGlvbihuYW1lKSB7XG4gIHZhciBpZCxcbiAgICAgIHRpbWluZztcblxuICBpZiAobmFtZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICBpZCA9IG5hbWUuX2lkLCBuYW1lID0gbmFtZS5fbmFtZTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IG5ld0lkKCksICh0aW1pbmcgPSBkZWZhdWx0VGltaW5nKS50aW1lID0gZDNUaW1lci5ub3coKSwgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcbiAgfVxuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkLCBpLCBncm91cCwgdGltaW5nIHx8IGluaGVyaXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59XG5cbmQzU2VsZWN0aW9uLnNlbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gc2VsZWN0aW9uX2ludGVycnVwdDtcbmQzU2VsZWN0aW9uLnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZnVuY3Rpb24gYWN0aXZlKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBpO1xuXG4gIGlmIChzY2hlZHVsZXMpIHtcbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLnN0YXRlID4gU0NIRURVTEVEICYmIHNjaGVkdWxlLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKFtbbm9kZV1dLCByb290LCBuYW1lLCAraSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuYWN0aXZlID0gYWN0aXZlO1xuZXhwb3J0cy5pbnRlcnJ1cHQgPSBpbnRlcnJ1cHQ7XG5leHBvcnRzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXZvcm9ub2kvIHYxLjEuNCBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5mdW5jdGlvbiBSZWRCbGFja1RyZWUoKSB7XG4gIHRoaXMuXyA9IG51bGw7IC8vIHJvb3Qgbm9kZVxufVxuXG5mdW5jdGlvbiBSZWRCbGFja05vZGUobm9kZSkge1xuICBub2RlLlUgPSAvLyBwYXJlbnQgbm9kZVxuICBub2RlLkMgPSAvLyBjb2xvciAtIHRydWUgZm9yIHJlZCwgZmFsc2UgZm9yIGJsYWNrXG4gIG5vZGUuTCA9IC8vIGxlZnQgbm9kZVxuICBub2RlLlIgPSAvLyByaWdodCBub2RlXG4gIG5vZGUuUCA9IC8vIHByZXZpb3VzIG5vZGVcbiAgbm9kZS5OID0gbnVsbDsgLy8gbmV4dCBub2RlXG59XG5cblJlZEJsYWNrVHJlZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSZWRCbGFja1RyZWUsXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbihhZnRlciwgbm9kZSkge1xuICAgIHZhciBwYXJlbnQsIGdyYW5kcGEsIHVuY2xlO1xuXG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBub2RlLlAgPSBhZnRlcjtcbiAgICAgIG5vZGUuTiA9IGFmdGVyLk47XG4gICAgICBpZiAoYWZ0ZXIuTikgYWZ0ZXIuTi5QID0gbm9kZTtcbiAgICAgIGFmdGVyLk4gPSBub2RlO1xuICAgICAgaWYgKGFmdGVyLlIpIHtcbiAgICAgICAgYWZ0ZXIgPSBhZnRlci5SO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIuTCkgYWZ0ZXIgPSBhZnRlci5MO1xuICAgICAgICBhZnRlci5MID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyLlIgPSBub2RlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl8pIHtcbiAgICAgIGFmdGVyID0gUmVkQmxhY2tGaXJzdCh0aGlzLl8pO1xuICAgICAgbm9kZS5QID0gbnVsbDtcbiAgICAgIG5vZGUuTiA9IGFmdGVyO1xuICAgICAgYWZ0ZXIuUCA9IGFmdGVyLkwgPSBub2RlO1xuICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gICAgICB0aGlzLl8gPSBub2RlO1xuICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5MID0gbm9kZS5SID0gbnVsbDtcbiAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgbm9kZS5DID0gdHJ1ZTtcblxuICAgIGFmdGVyID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5DKSB7XG4gICAgICBncmFuZHBhID0gcGFyZW50LlU7XG4gICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcbiAgICAgICAgdW5jbGUgPSBncmFuZHBhLlI7XG4gICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuUikge1xuICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmNsZSA9IGdyYW5kcGEuTDtcbiAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgfVxuICAgIHRoaXMuXy5DID0gZmFsc2U7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuTikgbm9kZS5OLlAgPSBub2RlLlA7XG4gICAgaWYgKG5vZGUuUCkgbm9kZS5QLk4gPSBub2RlLk47XG4gICAgbm9kZS5OID0gbm9kZS5QID0gbnVsbDtcblxuICAgIHZhciBwYXJlbnQgPSBub2RlLlUsXG4gICAgICAgIHNpYmxpbmcsXG4gICAgICAgIGxlZnQgPSBub2RlLkwsXG4gICAgICAgIHJpZ2h0ID0gbm9kZS5SLFxuICAgICAgICBuZXh0LFxuICAgICAgICByZWQ7XG5cbiAgICBpZiAoIWxlZnQpIG5leHQgPSByaWdodDtcbiAgICBlbHNlIGlmICghcmlnaHQpIG5leHQgPSBsZWZ0O1xuICAgIGVsc2UgbmV4dCA9IFJlZEJsYWNrRmlyc3QocmlnaHQpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBub2RlKSBwYXJlbnQuTCA9IG5leHQ7XG4gICAgICBlbHNlIHBhcmVudC5SID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgcmVkID0gbmV4dC5DO1xuICAgICAgbmV4dC5DID0gbm9kZS5DO1xuICAgICAgbmV4dC5MID0gbGVmdDtcbiAgICAgIGxlZnQuVSA9IG5leHQ7XG4gICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcbiAgICAgICAgcGFyZW50ID0gbmV4dC5VO1xuICAgICAgICBuZXh0LlUgPSBub2RlLlU7XG4gICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgIHBhcmVudC5MID0gbm9kZTtcbiAgICAgICAgbmV4dC5SID0gcmlnaHQ7XG4gICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dC5VID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWQgPSBub2RlLkM7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSkgbm9kZS5VID0gcGFyZW50O1xuICAgIGlmIChyZWQpIHJldHVybjtcbiAgICBpZiAobm9kZSAmJiBub2RlLkMpIHsgbm9kZS5DID0gZmFsc2U7IHJldHVybjsgfVxuXG4gICAgZG8ge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMuXykgYnJlYWs7XG4gICAgICBpZiAobm9kZSA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQylcbiAgICAgICAgICAgIHx8IChzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpKSB7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nLlIgfHwgIXNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQylcbiAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xuICAgICAgICAgIGlmICghc2libGluZy5MIHx8ICFzaWJsaW5nLkwuQykge1xuICAgICAgICAgICAgc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuVTtcbiAgICB9IHdoaWxlICghbm9kZS5DKTtcblxuICAgIGlmIChub2RlKSBub2RlLkMgPSBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVkQmxhY2tSb3RhdGVMZWZ0KHRyZWUsIG5vZGUpIHtcbiAgdmFyIHAgPSBub2RlLFxuICAgICAgcSA9IG5vZGUuUixcbiAgICAgIHBhcmVudCA9IHAuVTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7XG4gICAgZWxzZSBwYXJlbnQuUiA9IHE7XG4gIH0gZWxzZSB7XG4gICAgdHJlZS5fID0gcTtcbiAgfVxuXG4gIHEuVSA9IHBhcmVudDtcbiAgcC5VID0gcTtcbiAgcC5SID0gcS5MO1xuICBpZiAocC5SKSBwLlIuVSA9IHA7XG4gIHEuTCA9IHA7XG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xuICB2YXIgcCA9IG5vZGUsXG4gICAgICBxID0gbm9kZS5MLFxuICAgICAgcGFyZW50ID0gcC5VO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTtcbiAgICBlbHNlIHBhcmVudC5SID0gcTtcbiAgfSBlbHNlIHtcbiAgICB0cmVlLl8gPSBxO1xuICB9XG5cbiAgcS5VID0gcGFyZW50O1xuICBwLlUgPSBxO1xuICBwLkwgPSBxLlI7XG4gIGlmIChwLkwpIHAuTC5VID0gcDtcbiAgcS5SID0gcDtcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tGaXJzdChub2RlKSB7XG4gIHdoaWxlIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGxlZnQsIHJpZ2h0LCB2MCwgdjEpIHtcbiAgdmFyIGVkZ2UgPSBbbnVsbCwgbnVsbF0sXG4gICAgICBpbmRleCA9IGVkZ2VzLnB1c2goZWRnZSkgLSAxO1xuICBlZGdlLmxlZnQgPSBsZWZ0O1xuICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XG4gIGlmICh2MCkgc2V0RWRnZUVuZChlZGdlLCBsZWZ0LCByaWdodCwgdjApO1xuICBpZiAodjEpIHNldEVkZ2VFbmQoZWRnZSwgcmlnaHQsIGxlZnQsIHYxKTtcbiAgY2VsbHNbbGVmdC5pbmRleF0uaGFsZmVkZ2VzLnB1c2goaW5kZXgpO1xuICBjZWxsc1tyaWdodC5pbmRleF0uaGFsZmVkZ2VzLnB1c2goaW5kZXgpO1xuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQm9yZGVyRWRnZShsZWZ0LCB2MCwgdjEpIHtcbiAgdmFyIGVkZ2UgPSBbdjAsIHYxXTtcbiAgZWRnZS5sZWZ0ID0gbGVmdDtcbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHNldEVkZ2VFbmQoZWRnZSwgbGVmdCwgcmlnaHQsIHZlcnRleCkge1xuICBpZiAoIWVkZ2VbMF0gJiYgIWVkZ2VbMV0pIHtcbiAgICBlZGdlWzBdID0gdmVydGV4O1xuICAgIGVkZ2UubGVmdCA9IGxlZnQ7XG4gICAgZWRnZS5yaWdodCA9IHJpZ2h0O1xuICB9IGVsc2UgaWYgKGVkZ2UubGVmdCA9PT0gcmlnaHQpIHtcbiAgICBlZGdlWzFdID0gdmVydGV4O1xuICB9IGVsc2Uge1xuICAgIGVkZ2VbMF0gPSB2ZXJ0ZXg7XG4gIH1cbn1cblxuLy8gTGlhbmfigJNCYXJza3kgbGluZSBjbGlwcGluZy5cbmZ1bmN0aW9uIGNsaXBFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBhID0gZWRnZVswXSxcbiAgICAgIGIgPSBlZGdlWzFdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgZHggPSBieCAtIGF4LFxuICAgICAgZHkgPSBieSAtIGF5LFxuICAgICAgcjtcblxuICByID0geDAgLSBheDtcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHgxIC0gYXg7XG4gIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIHIgPSB5MCAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geTEgLSBheTtcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgaWYgKCEodDAgPiAwKSAmJiAhKHQxIDwgMSkpIHJldHVybiB0cnVlOyAvLyBUT0RPIEJldHRlciBjaGVjaz9cblxuICBpZiAodDAgPiAwKSBlZGdlWzBdID0gW2F4ICsgdDAgKiBkeCwgYXkgKyB0MCAqIGR5XTtcbiAgaWYgKHQxIDwgMSkgZWRnZVsxXSA9IFtheCArIHQxICogZHgsIGF5ICsgdDEgKiBkeV07XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0RWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgdjEgPSBlZGdlWzFdO1xuICBpZiAodjEpIHJldHVybiB0cnVlO1xuXG4gIHZhciB2MCA9IGVkZ2VbMF0sXG4gICAgICBsZWZ0ID0gZWRnZS5sZWZ0LFxuICAgICAgcmlnaHQgPSBlZGdlLnJpZ2h0LFxuICAgICAgbHggPSBsZWZ0WzBdLFxuICAgICAgbHkgPSBsZWZ0WzFdLFxuICAgICAgcnggPSByaWdodFswXSxcbiAgICAgIHJ5ID0gcmlnaHRbMV0sXG4gICAgICBmeCA9IChseCArIHJ4KSAvIDIsXG4gICAgICBmeSA9IChseSArIHJ5KSAvIDIsXG4gICAgICBmbSxcbiAgICAgIGZiO1xuXG4gIGlmIChyeSA9PT0gbHkpIHtcbiAgICBpZiAoZnggPCB4MCB8fCBmeCA+PSB4MSkgcmV0dXJuO1xuICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICBpZiAoIXYwKSB2MCA9IFtmeCwgeTBdO1xuICAgICAgZWxzZSBpZiAodjBbMV0gPj0geTEpIHJldHVybjtcbiAgICAgIHYxID0gW2Z4LCB5MV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdjApIHYwID0gW2Z4LCB5MV07XG4gICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKSByZXR1cm47XG4gICAgICB2MSA9IFtmeCwgeTBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmbSA9IChseCAtIHJ4KSAvIChyeSAtIGx5KTtcbiAgICBmYiA9IGZ5IC0gZm0gKiBmeDtcbiAgICBpZiAoZm0gPCAtMSB8fCBmbSA+IDEpIHtcbiAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgIGlmICghdjApIHYwID0gWyh5MCAtIGZiKSAvIGZtLCB5MF07XG4gICAgICAgIGVsc2UgaWYgKHYwWzFdID49IHkxKSByZXR1cm47XG4gICAgICAgIHYxID0gWyh5MSAtIGZiKSAvIGZtLCB5MV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXYwKSB2MCA9IFsoeTEgLSBmYikgLyBmbSwgeTFdO1xuICAgICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKSByZXR1cm47XG4gICAgICAgIHYxID0gWyh5MCAtIGZiKSAvIGZtLCB5MF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChseSA8IHJ5KSB7XG4gICAgICAgIGlmICghdjApIHYwID0gW3gwLCBmbSAqIHgwICsgZmJdO1xuICAgICAgICBlbHNlIGlmICh2MFswXSA+PSB4MSkgcmV0dXJuO1xuICAgICAgICB2MSA9IFt4MSwgZm0gKiB4MSArIGZiXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdjApIHYwID0gW3gxLCBmbSAqIHgxICsgZmJdO1xuICAgICAgICBlbHNlIGlmICh2MFswXSA8IHgwKSByZXR1cm47XG4gICAgICAgIHYxID0gW3gwLCBmbSAqIHgwICsgZmJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVkZ2VbMF0gPSB2MDtcbiAgZWRnZVsxXSA9IHYxO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBpID0gZWRnZXMubGVuZ3RoLFxuICAgICAgZWRnZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKCFjb25uZWN0RWRnZShlZGdlID0gZWRnZXNbaV0sIHgwLCB5MCwgeDEsIHkxKVxuICAgICAgICB8fCAhY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgIHx8ICEoTWF0aC5hYnMoZWRnZVswXVswXSAtIGVkZ2VbMV1bMF0pID4gZXBzaWxvblxuICAgICAgICAgICAgfHwgTWF0aC5hYnMoZWRnZVswXVsxXSAtIGVkZ2VbMV1bMV0pID4gZXBzaWxvbikpIHtcbiAgICAgIGRlbGV0ZSBlZGdlc1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2VsbChzaXRlKSB7XG4gIHJldHVybiBjZWxsc1tzaXRlLmluZGV4XSA9IHtcbiAgICBzaXRlOiBzaXRlLFxuICAgIGhhbGZlZGdlczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlQW5nbGUoY2VsbCwgZWRnZSkge1xuICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZSxcbiAgICAgIHZhID0gZWRnZS5sZWZ0LFxuICAgICAgdmIgPSBlZGdlLnJpZ2h0O1xuICBpZiAoc2l0ZSA9PT0gdmIpIHZiID0gdmEsIHZhID0gc2l0ZTtcbiAgaWYgKHZiKSByZXR1cm4gTWF0aC5hdGFuMih2YlsxXSAtIHZhWzFdLCB2YlswXSAtIHZhWzBdKTtcbiAgaWYgKHNpdGUgPT09IHZhKSB2YSA9IGVkZ2VbMV0sIHZiID0gZWRnZVswXTtcbiAgZWxzZSB2YSA9IGVkZ2VbMF0sIHZiID0gZWRnZVsxXTtcbiAgcmV0dXJuIE1hdGguYXRhbjIodmFbMF0gLSB2YlswXSwgdmJbMV0gLSB2YVsxXSk7XG59XG5cbmZ1bmN0aW9uIGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2UpIHtcbiAgcmV0dXJuIGVkZ2VbKyhlZGdlLmxlZnQgIT09IGNlbGwuc2l0ZSldO1xufVxuXG5mdW5jdGlvbiBjZWxsSGFsZmVkZ2VFbmQoY2VsbCwgZWRnZSkge1xuICByZXR1cm4gZWRnZVsrKGVkZ2UubGVmdCA9PT0gY2VsbC5zaXRlKV07XG59XG5cbmZ1bmN0aW9uIHNvcnRDZWxsSGFsZmVkZ2VzKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGNlbGxzLmxlbmd0aCwgY2VsbCwgaGFsZmVkZ2VzLCBqLCBtOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKChjZWxsID0gY2VsbHNbaV0pICYmIChtID0gKGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzKS5sZW5ndGgpKSB7XG4gICAgICB2YXIgaW5kZXggPSBuZXcgQXJyYXkobSksXG4gICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkobSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBpbmRleFtqXSA9IGosIGFycmF5W2pdID0gY2VsbEhhbGZlZGdlQW5nbGUoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzW2pdXSk7XG4gICAgICBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIGFycmF5W2pdIC0gYXJyYXlbaV07IH0pO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgYXJyYXlbal0gPSBoYWxmZWRnZXNbaW5kZXhbal1dO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgaGFsZmVkZ2VzW2pdID0gYXJyYXlbal07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBDZWxscyh4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbkNlbGxzID0gY2VsbHMubGVuZ3RoLFxuICAgICAgaUNlbGwsXG4gICAgICBjZWxsLFxuICAgICAgc2l0ZSxcbiAgICAgIGlIYWxmZWRnZSxcbiAgICAgIGhhbGZlZGdlcyxcbiAgICAgIG5IYWxmZWRnZXMsXG4gICAgICBzdGFydCxcbiAgICAgIHN0YXJ0WCxcbiAgICAgIHN0YXJ0WSxcbiAgICAgIGVuZCxcbiAgICAgIGVuZFgsXG4gICAgICBlbmRZLFxuICAgICAgY292ZXIgPSB0cnVlO1xuXG4gIGZvciAoaUNlbGwgPSAwOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgaGFsZmVkZ2VzID0gY2VsbC5oYWxmZWRnZXM7XG4gICAgICBpSGFsZmVkZ2UgPSBoYWxmZWRnZXMubGVuZ3RoO1xuXG4gICAgICAvLyBSZW1vdmUgYW55IGRhbmdsaW5nIGNsaXBwZWQgZWRnZXMuXG4gICAgICB3aGlsZSAoaUhhbGZlZGdlLS0pIHtcbiAgICAgICAgaWYgKCFlZGdlc1toYWxmZWRnZXNbaUhhbGZlZGdlXV0pIHtcbiAgICAgICAgICBoYWxmZWRnZXMuc3BsaWNlKGlIYWxmZWRnZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5zZXJ0IGFueSBib3JkZXIgZWRnZXMgYXMgbmVjZXNzYXJ5LlxuICAgICAgaUhhbGZlZGdlID0gMCwgbkhhbGZlZGdlcyA9IGhhbGZlZGdlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaUhhbGZlZGdlIDwgbkhhbGZlZGdlcykge1xuICAgICAgICBlbmQgPSBjZWxsSGFsZmVkZ2VFbmQoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzW2lIYWxmZWRnZV1dKSwgZW5kWCA9IGVuZFswXSwgZW5kWSA9IGVuZFsxXTtcbiAgICAgICAgc3RhcnQgPSBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlc1toYWxmZWRnZXNbKytpSGFsZmVkZ2UgJSBuSGFsZmVkZ2VzXV0pLCBzdGFydFggPSBzdGFydFswXSwgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgICAgIGlmIChNYXRoLmFicyhlbmRYIC0gc3RhcnRYKSA+IGVwc2lsb24gfHwgTWF0aC5hYnMoZW5kWSAtIHN0YXJ0WSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgaGFsZmVkZ2VzLnNwbGljZShpSGFsZmVkZ2UsIDAsIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCBlbmQsXG4gICAgICAgICAgICAgIE1hdGguYWJzKGVuZFggLSB4MCkgPCBlcHNpbG9uICYmIHkxIC0gZW5kWSA+IGVwc2lsb24gPyBbeDAsIE1hdGguYWJzKHN0YXJ0WCAtIHgwKSA8IGVwc2lsb24gPyBzdGFydFkgOiB5MV1cbiAgICAgICAgICAgICAgOiBNYXRoLmFicyhlbmRZIC0geTEpIDwgZXBzaWxvbiAmJiB4MSAtIGVuZFggPiBlcHNpbG9uID8gW01hdGguYWJzKHN0YXJ0WSAtIHkxKSA8IGVwc2lsb24gPyBzdGFydFggOiB4MSwgeTFdXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWCAtIHgxKSA8IGVwc2lsb24gJiYgZW5kWSAtIHkwID4gZXBzaWxvbiA/IFt4MSwgTWF0aC5hYnMoc3RhcnRYIC0geDEpIDwgZXBzaWxvbiA/IHN0YXJ0WSA6IHkwXVxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MCkgPCBlcHNpbG9uICYmIGVuZFggLSB4MCA+IGVwc2lsb24gPyBbTWF0aC5hYnMoc3RhcnRZIC0geTApIDwgZXBzaWxvbiA/IHN0YXJ0WCA6IHgwLCB5MF1cbiAgICAgICAgICAgICAgOiBudWxsKSkgLSAxKTtcbiAgICAgICAgICArK25IYWxmZWRnZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5IYWxmZWRnZXMpIGNvdmVyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZW7igJl0IGFueSBlZGdlcywgaGF2ZSB0aGUgY2xvc2VzdCBzaXRlIGNvdmVyIHRoZSBleHRlbnQuXG4gIC8vIEl0IGRvZXNu4oCZdCBtYXR0ZXIgd2hpY2ggY29ybmVyIG9mIHRoZSBleHRlbnQgd2UgbWVhc3VyZSFcbiAgaWYgKGNvdmVyKSB7XG4gICAgdmFyIGR4LCBkeSwgZDIsIGRjID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKGlDZWxsID0gMCwgY292ZXIgPSBudWxsOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcbiAgICAgICAgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgICAgZHggPSBzaXRlWzBdIC0geDA7XG4gICAgICAgIGR5ID0gc2l0ZVsxXSAtIHkwO1xuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZDIgPCBkYykgZGMgPSBkMiwgY292ZXIgPSBjZWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3Zlcikge1xuICAgICAgdmFyIHYwMCA9IFt4MCwgeTBdLCB2MDEgPSBbeDAsIHkxXSwgdjExID0gW3gxLCB5MV0sIHYxMCA9IFt4MSwgeTBdO1xuICAgICAgY292ZXIuaGFsZmVkZ2VzLnB1c2goXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlID0gY292ZXIuc2l0ZSwgdjAwLCB2MDEpKSAtIDEsXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MDEsIHYxMSkpIC0gMSxcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYxMSwgdjEwKSkgLSAxLFxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjEwLCB2MDApKSAtIDFcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gTGFzdGx5IGRlbGV0ZSBhbnkgY2VsbHMgd2l0aCBubyBlZGdlczsgdGhlc2Ugd2VyZSBlbnRpcmVseSBjbGlwcGVkLlxuICBmb3IgKGlDZWxsID0gMDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcbiAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgaWYgKCFjZWxsLmhhbGZlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGNlbGxzW2lDZWxsXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGNpcmNsZVBvb2wgPSBbXTtcblxudmFyIGZpcnN0Q2lyY2xlO1xuXG5mdW5jdGlvbiBDaXJjbGUoKSB7XG4gIFJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgdGhpcy54ID1cbiAgdGhpcy55ID1cbiAgdGhpcy5hcmMgPVxuICB0aGlzLnNpdGUgPVxuICB0aGlzLmN5ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXR0YWNoQ2lyY2xlKGFyYykge1xuICB2YXIgbEFyYyA9IGFyYy5QLFxuICAgICAgckFyYyA9IGFyYy5OO1xuXG4gIGlmICghbEFyYyB8fCAhckFyYykgcmV0dXJuO1xuXG4gIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSxcbiAgICAgIGNTaXRlID0gYXJjLnNpdGUsXG4gICAgICByU2l0ZSA9IHJBcmMuc2l0ZTtcblxuICBpZiAobFNpdGUgPT09IHJTaXRlKSByZXR1cm47XG5cbiAgdmFyIGJ4ID0gY1NpdGVbMF0sXG4gICAgICBieSA9IGNTaXRlWzFdLFxuICAgICAgYXggPSBsU2l0ZVswXSAtIGJ4LFxuICAgICAgYXkgPSBsU2l0ZVsxXSAtIGJ5LFxuICAgICAgY3ggPSByU2l0ZVswXSAtIGJ4LFxuICAgICAgY3kgPSByU2l0ZVsxXSAtIGJ5O1xuXG4gIHZhciBkID0gMiAqIChheCAqIGN5IC0gYXkgKiBjeCk7XG4gIGlmIChkID49IC1lcHNpbG9uMikgcmV0dXJuO1xuXG4gIHZhciBoYSA9IGF4ICogYXggKyBheSAqIGF5LFxuICAgICAgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSxcbiAgICAgIHggPSAoY3kgKiBoYSAtIGF5ICogaGMpIC8gZCxcbiAgICAgIHkgPSAoYXggKiBoYyAtIGN4ICogaGEpIC8gZDtcblxuICB2YXIgY2lyY2xlID0gY2lyY2xlUG9vbC5wb3AoKSB8fCBuZXcgQ2lyY2xlO1xuICBjaXJjbGUuYXJjID0gYXJjO1xuICBjaXJjbGUuc2l0ZSA9IGNTaXRlO1xuICBjaXJjbGUueCA9IHggKyBieDtcbiAgY2lyY2xlLnkgPSAoY2lyY2xlLmN5ID0geSArIGJ5KSArIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTsgLy8geSBib3R0b21cblxuICBhcmMuY2lyY2xlID0gY2lyY2xlO1xuXG4gIHZhciBiZWZvcmUgPSBudWxsLFxuICAgICAgbm9kZSA9IGNpcmNsZXMuXztcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChjaXJjbGUueSA8IG5vZGUueSB8fCAoY2lyY2xlLnkgPT09IG5vZGUueSAmJiBjaXJjbGUueCA8PSBub2RlLngpKSB7XG4gICAgICBpZiAobm9kZS5MKSBub2RlID0gbm9kZS5MO1xuICAgICAgZWxzZSB7IGJlZm9yZSA9IG5vZGUuUDsgYnJlYWs7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5vZGUuUikgbm9kZSA9IG5vZGUuUjtcbiAgICAgIGVsc2UgeyBiZWZvcmUgPSBub2RlOyBicmVhazsgfVxuICAgIH1cbiAgfVxuXG4gIGNpcmNsZXMuaW5zZXJ0KGJlZm9yZSwgY2lyY2xlKTtcbiAgaWYgKCFiZWZvcmUpIGZpcnN0Q2lyY2xlID0gY2lyY2xlO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hDaXJjbGUoYXJjKSB7XG4gIHZhciBjaXJjbGUgPSBhcmMuY2lyY2xlO1xuICBpZiAoY2lyY2xlKSB7XG4gICAgaWYgKCFjaXJjbGUuUCkgZmlyc3RDaXJjbGUgPSBjaXJjbGUuTjtcbiAgICBjaXJjbGVzLnJlbW92ZShjaXJjbGUpO1xuICAgIGNpcmNsZVBvb2wucHVzaChjaXJjbGUpO1xuICAgIFJlZEJsYWNrTm9kZShjaXJjbGUpO1xuICAgIGFyYy5jaXJjbGUgPSBudWxsO1xuICB9XG59XG5cbnZhciBiZWFjaFBvb2wgPSBbXTtcblxuZnVuY3Rpb24gQmVhY2goKSB7XG4gIFJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgdGhpcy5lZGdlID1cbiAgdGhpcy5zaXRlID1cbiAgdGhpcy5jaXJjbGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCZWFjaChzaXRlKSB7XG4gIHZhciBiZWFjaCA9IGJlYWNoUG9vbC5wb3AoKSB8fCBuZXcgQmVhY2g7XG4gIGJlYWNoLnNpdGUgPSBzaXRlO1xuICByZXR1cm4gYmVhY2g7XG59XG5cbmZ1bmN0aW9uIGRldGFjaEJlYWNoKGJlYWNoKSB7XG4gIGRldGFjaENpcmNsZShiZWFjaCk7XG4gIGJlYWNoZXMucmVtb3ZlKGJlYWNoKTtcbiAgYmVhY2hQb29sLnB1c2goYmVhY2gpO1xuICBSZWRCbGFja05vZGUoYmVhY2gpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVCZWFjaChiZWFjaCkge1xuICB2YXIgY2lyY2xlID0gYmVhY2guY2lyY2xlLFxuICAgICAgeCA9IGNpcmNsZS54LFxuICAgICAgeSA9IGNpcmNsZS5jeSxcbiAgICAgIHZlcnRleCA9IFt4LCB5XSxcbiAgICAgIHByZXZpb3VzID0gYmVhY2guUCxcbiAgICAgIG5leHQgPSBiZWFjaC5OLFxuICAgICAgZGlzYXBwZWFyaW5nID0gW2JlYWNoXTtcblxuICBkZXRhY2hCZWFjaChiZWFjaCk7XG5cbiAgdmFyIGxBcmMgPSBwcmV2aW91cztcbiAgd2hpbGUgKGxBcmMuY2lyY2xlXG4gICAgICAmJiBNYXRoLmFicyh4IC0gbEFyYy5jaXJjbGUueCkgPCBlcHNpbG9uXG4gICAgICAmJiBNYXRoLmFicyh5IC0gbEFyYy5jaXJjbGUuY3kpIDwgZXBzaWxvbikge1xuICAgIHByZXZpb3VzID0gbEFyYy5QO1xuICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgIGRldGFjaEJlYWNoKGxBcmMpO1xuICAgIGxBcmMgPSBwcmV2aW91cztcbiAgfVxuXG4gIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICBkZXRhY2hDaXJjbGUobEFyYyk7XG5cbiAgdmFyIHJBcmMgPSBuZXh0O1xuICB3aGlsZSAockFyYy5jaXJjbGVcbiAgICAgICYmIE1hdGguYWJzKHggLSByQXJjLmNpcmNsZS54KSA8IGVwc2lsb25cbiAgICAgICYmIE1hdGguYWJzKHkgLSByQXJjLmNpcmNsZS5jeSkgPCBlcHNpbG9uKSB7XG4gICAgbmV4dCA9IHJBcmMuTjtcbiAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICBkZXRhY2hCZWFjaChyQXJjKTtcbiAgICByQXJjID0gbmV4dDtcbiAgfVxuXG4gIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICBkZXRhY2hDaXJjbGUockFyYyk7XG5cbiAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCxcbiAgICAgIGlBcmM7XG4gIGZvciAoaUFyYyA9IDE7IGlBcmMgPCBuQXJjczsgKytpQXJjKSB7XG4gICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcbiAgICBsQXJjID0gZGlzYXBwZWFyaW5nW2lBcmMgLSAxXTtcbiAgICBzZXRFZGdlRW5kKHJBcmMuZWRnZSwgbEFyYy5zaXRlLCByQXJjLnNpdGUsIHZlcnRleCk7XG4gIH1cblxuICBsQXJjID0gZGlzYXBwZWFyaW5nWzBdO1xuICByQXJjID0gZGlzYXBwZWFyaW5nW25BcmNzIC0gMV07XG4gIHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCByQXJjLnNpdGUsIG51bGwsIHZlcnRleCk7XG5cbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICBhdHRhY2hDaXJjbGUockFyYyk7XG59XG5cbmZ1bmN0aW9uIGFkZEJlYWNoKHNpdGUpIHtcbiAgdmFyIHggPSBzaXRlWzBdLFxuICAgICAgZGlyZWN0cml4ID0gc2l0ZVsxXSxcbiAgICAgIGxBcmMsXG4gICAgICByQXJjLFxuICAgICAgZHhsLFxuICAgICAgZHhyLFxuICAgICAgbm9kZSA9IGJlYWNoZXMuXztcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGR4bCA9IGxlZnRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCkgLSB4O1xuICAgIGlmIChkeGwgPiBlcHNpbG9uKSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgIGR4ciA9IHggLSByaWdodEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KTtcbiAgICAgIGlmIChkeHIgPiBlcHNpbG9uKSB7XG4gICAgICAgIGlmICghbm9kZS5SKSB7XG4gICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUuUjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkeGwgPiAtZXBzaWxvbikge1xuICAgICAgICAgIGxBcmMgPSBub2RlLlA7XG4gICAgICAgICAgckFyYyA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZHhyID4gLWVwc2lsb24pIHtcbiAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICByQXJjID0gbm9kZS5OO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxBcmMgPSByQXJjID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjcmVhdGVDZWxsKHNpdGUpO1xuICB2YXIgbmV3QXJjID0gY3JlYXRlQmVhY2goc2l0ZSk7XG4gIGJlYWNoZXMuaW5zZXJ0KGxBcmMsIG5ld0FyYyk7XG5cbiAgaWYgKCFsQXJjICYmICFyQXJjKSByZXR1cm47XG5cbiAgaWYgKGxBcmMgPT09IHJBcmMpIHtcbiAgICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgckFyYyA9IGNyZWF0ZUJlYWNoKGxBcmMuc2l0ZSk7XG4gICAgYmVhY2hlcy5pbnNlcnQobmV3QXJjLCByQXJjKTtcbiAgICBuZXdBcmMuZWRnZSA9IHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGF0dGFjaENpcmNsZShyQXJjKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXJBcmMpIHsgLy8gJiYgbEFyY1xuICAgIG5ld0FyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlbHNlIGxBcmMgIT09IHJBcmNcbiAgZGV0YWNoQ2lyY2xlKGxBcmMpO1xuICBkZXRhY2hDaXJjbGUockFyYyk7XG5cbiAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLFxuICAgICAgYXggPSBsU2l0ZVswXSxcbiAgICAgIGF5ID0gbFNpdGVbMV0sXG4gICAgICBieCA9IHNpdGVbMF0gLSBheCxcbiAgICAgIGJ5ID0gc2l0ZVsxXSAtIGF5LFxuICAgICAgclNpdGUgPSByQXJjLnNpdGUsXG4gICAgICBjeCA9IHJTaXRlWzBdIC0gYXgsXG4gICAgICBjeSA9IHJTaXRlWzFdIC0gYXksXG4gICAgICBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksXG4gICAgICBoYiA9IGJ4ICogYnggKyBieSAqIGJ5LFxuICAgICAgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSxcbiAgICAgIHZlcnRleCA9IFsoY3kgKiBoYiAtIGJ5ICogaGMpIC8gZCArIGF4LCAoYnggKiBoYyAtIGN4ICogaGIpIC8gZCArIGF5XTtcblxuICBzZXRFZGdlRW5kKHJBcmMuZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpO1xuICBuZXdBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobFNpdGUsIHNpdGUsIG51bGwsIHZlcnRleCk7XG4gIHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2Uoc2l0ZSwgclNpdGUsIG51bGwsIHZlcnRleCk7XG4gIGF0dGFjaENpcmNsZShsQXJjKTtcbiAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xufVxuXG5mdW5jdGlvbiBsZWZ0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICB2YXIgc2l0ZSA9IGFyYy5zaXRlLFxuICAgICAgcmZvY3ggPSBzaXRlWzBdLFxuICAgICAgcmZvY3kgPSBzaXRlWzFdLFxuICAgICAgcGJ5MiA9IHJmb2N5IC0gZGlyZWN0cml4O1xuXG4gIGlmICghcGJ5MikgcmV0dXJuIHJmb2N4O1xuXG4gIHZhciBsQXJjID0gYXJjLlA7XG4gIGlmICghbEFyYykgcmV0dXJuIC1JbmZpbml0eTtcblxuICBzaXRlID0gbEFyYy5zaXRlO1xuICB2YXIgbGZvY3ggPSBzaXRlWzBdLFxuICAgICAgbGZvY3kgPSBzaXRlWzFdLFxuICAgICAgcGxieTIgPSBsZm9jeSAtIGRpcmVjdHJpeDtcblxuICBpZiAoIXBsYnkyKSByZXR1cm4gbGZvY3g7XG5cbiAgdmFyIGhsID0gbGZvY3ggLSByZm9jeCxcbiAgICAgIGFieTIgPSAxIC8gcGJ5MiAtIDEgLyBwbGJ5MixcbiAgICAgIGIgPSBobCAvIHBsYnkyO1xuXG4gIGlmIChhYnkyKSByZXR1cm4gKC1iICsgTWF0aC5zcXJ0KGIgKiBiIC0gMiAqIGFieTIgKiAoaGwgKiBobCAvICgtMiAqIHBsYnkyKSAtIGxmb2N5ICsgcGxieTIgLyAyICsgcmZvY3kgLSBwYnkyIC8gMikpKSAvIGFieTIgKyByZm9jeDtcblxuICByZXR1cm4gKHJmb2N4ICsgbGZvY3gpIC8gMjtcbn1cblxuZnVuY3Rpb24gcmlnaHRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gIHZhciByQXJjID0gYXJjLk47XG4gIGlmIChyQXJjKSByZXR1cm4gbGVmdEJyZWFrUG9pbnQockFyYywgZGlyZWN0cml4KTtcbiAgdmFyIHNpdGUgPSBhcmMuc2l0ZTtcbiAgcmV0dXJuIHNpdGVbMV0gPT09IGRpcmVjdHJpeCA/IHNpdGVbMF0gOiBJbmZpbml0eTtcbn1cblxudmFyIGVwc2lsb24gPSAxZS02O1xudmFyIGVwc2lsb24yID0gMWUtMTI7XG52YXIgYmVhY2hlcztcbnZhciBjZWxscztcbnZhciBjaXJjbGVzO1xudmFyIGVkZ2VzO1xuXG5mdW5jdGlvbiB0cmlhbmdsZUFyZWEoYSwgYiwgYykge1xuICByZXR1cm4gKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gYVsxXSkgLSAoYVswXSAtIGJbMF0pICogKGNbMV0gLSBhWzFdKTtcbn1cblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpYyhhLCBiKSB7XG4gIHJldHVybiBiWzFdIC0gYVsxXVxuICAgICAgfHwgYlswXSAtIGFbMF07XG59XG5cbmZ1bmN0aW9uIERpYWdyYW0oc2l0ZXMsIGV4dGVudCkge1xuICB2YXIgc2l0ZSA9IHNpdGVzLnNvcnQobGV4aWNvZ3JhcGhpYykucG9wKCksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNpcmNsZTtcblxuICBlZGdlcyA9IFtdO1xuICBjZWxscyA9IG5ldyBBcnJheShzaXRlcy5sZW5ndGgpO1xuICBiZWFjaGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcbiAgY2lyY2xlcyA9IG5ldyBSZWRCbGFja1RyZWU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjaXJjbGUgPSBmaXJzdENpcmNsZTtcbiAgICBpZiAoc2l0ZSAmJiAoIWNpcmNsZSB8fCBzaXRlWzFdIDwgY2lyY2xlLnkgfHwgKHNpdGVbMV0gPT09IGNpcmNsZS55ICYmIHNpdGVbMF0gPCBjaXJjbGUueCkpKSB7XG4gICAgICBpZiAoc2l0ZVswXSAhPT0geCB8fCBzaXRlWzFdICE9PSB5KSB7XG4gICAgICAgIGFkZEJlYWNoKHNpdGUpO1xuICAgICAgICB4ID0gc2l0ZVswXSwgeSA9IHNpdGVbMV07XG4gICAgICB9XG4gICAgICBzaXRlID0gc2l0ZXMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChjaXJjbGUpIHtcbiAgICAgIHJlbW92ZUJlYWNoKGNpcmNsZS5hcmMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzb3J0Q2VsbEhhbGZlZGdlcygpO1xuXG4gIGlmIChleHRlbnQpIHtcbiAgICB2YXIgeDAgPSArZXh0ZW50WzBdWzBdLFxuICAgICAgICB5MCA9ICtleHRlbnRbMF1bMV0sXG4gICAgICAgIHgxID0gK2V4dGVudFsxXVswXSxcbiAgICAgICAgeTEgPSArZXh0ZW50WzFdWzFdO1xuICAgIGNsaXBFZGdlcyh4MCwgeTAsIHgxLCB5MSk7XG4gICAgY2xpcENlbGxzKHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuXG4gIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgdGhpcy5jZWxscyA9IGNlbGxzO1xuXG4gIGJlYWNoZXMgPVxuICBjaXJjbGVzID1cbiAgZWRnZXMgPVxuICBjZWxscyA9IG51bGw7XG59XG5cbkRpYWdyYW0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlhZ3JhbSxcblxuICBwb2x5Z29uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcztcblxuICAgIHJldHVybiB0aGlzLmNlbGxzLm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICB2YXIgcG9seWdvbiA9IGNlbGwuaGFsZmVkZ2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlc1tpXSk7IH0pO1xuICAgICAgcG9seWdvbi5kYXRhID0gY2VsbC5zaXRlLmRhdGE7XG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9KTtcbiAgfSxcblxuICB0cmlhbmdsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmlhbmdsZXMgPSBbXSxcbiAgICAgICAgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuXG4gICAgdGhpcy5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgIGlmICghKG0gPSAoaGFsZmVkZ2VzID0gY2VsbC5oYWxmZWRnZXMpLmxlbmd0aCkpIHJldHVybjtcbiAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLFxuICAgICAgICAgIGhhbGZlZGdlcyxcbiAgICAgICAgICBqID0gLTEsXG4gICAgICAgICAgbSxcbiAgICAgICAgICBzMCxcbiAgICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1ttIC0gMV1dLFxuICAgICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcblxuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgZTEgPSBlZGdlc1toYWxmZWRnZXNbal1dO1xuICAgICAgICBzMSA9IGUxLmxlZnQgPT09IHNpdGUgPyBlMS5yaWdodCA6IGUxLmxlZnQ7XG4gICAgICAgIGlmIChzMCAmJiBzMSAmJiBpIDwgczAuaW5kZXggJiYgaSA8IHMxLmluZGV4ICYmIHRyaWFuZ2xlQXJlYShzaXRlLCBzMCwgczEpIDwgMCkge1xuICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKFtzaXRlLmRhdGEsIHMwLmRhdGEsIHMxLmRhdGFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgfSxcblxuICBsaW5rczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnJpZ2h0O1xuICAgIH0pLm1hcChmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IGVkZ2UubGVmdC5kYXRhLFxuICAgICAgICB0YXJnZXQ6IGVkZ2UucmlnaHQuZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcblxuICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsIGkwLCBpMSA9IHRoYXQuX2ZvdW5kIHx8IDAsIG4gPSB0aGF0LmNlbGxzLmxlbmd0aCwgY2VsbDtcblxuICAgIC8vIFVzZSB0aGUgcHJldmlvdXNseS1mb3VuZCBjZWxsLCBvciBzdGFydCB3aXRoIGFuIGFyYml0cmFyeSBvbmUuXG4gICAgd2hpbGUgKCEoY2VsbCA9IHRoYXQuY2VsbHNbaTFdKSkgaWYgKCsraTEgPj0gbikgcmV0dXJuIG51bGw7XG4gICAgdmFyIGR4ID0geCAtIGNlbGwuc2l0ZVswXSwgZHkgPSB5IC0gY2VsbC5zaXRlWzFdLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuXG4gICAgLy8gVHJhdmVyc2UgdGhlIGhhbGYtZWRnZXMgdG8gZmluZCBhIGNsb3NlciBjZWxsLCBpZiBhbnkuXG4gICAgZG8ge1xuICAgICAgY2VsbCA9IHRoYXQuY2VsbHNbaTAgPSBpMV0sIGkxID0gbnVsbDtcbiAgICAgIGNlbGwuaGFsZmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWRnZSA9IHRoYXQuZWRnZXNbZV0sIHYgPSBlZGdlLmxlZnQ7XG4gICAgICAgIGlmICgodiA9PT0gY2VsbC5zaXRlIHx8ICF2KSAmJiAhKHYgPSBlZGdlLnJpZ2h0KSkgcmV0dXJuO1xuICAgICAgICB2YXIgdnggPSB4IC0gdlswXSwgdnkgPSB5IC0gdlsxXSwgdjIgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcbiAgICAgICAgaWYgKHYyIDwgZDIpIGQyID0gdjIsIGkxID0gdi5pbmRleDtcbiAgICAgIH0pO1xuICAgIH0gd2hpbGUgKGkxICE9PSBudWxsKTtcblxuICAgIHRoYXQuX2ZvdW5kID0gaTA7XG5cbiAgICByZXR1cm4gcmFkaXVzID09IG51bGwgfHwgZDIgPD0gcmFkaXVzICogcmFkaXVzID8gY2VsbC5zaXRlIDogbnVsbDtcbiAgfVxufTtcblxuZnVuY3Rpb24gdm9yb25vaSgpIHtcbiAgdmFyIHgkJDEgPSB4LFxuICAgICAgeSQkMSA9IHksXG4gICAgICBleHRlbnQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHZvcm9ub2koZGF0YSkge1xuICAgIHJldHVybiBuZXcgRGlhZ3JhbShkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICB2YXIgcyA9IFtNYXRoLnJvdW5kKHgkJDEoZCwgaSwgZGF0YSkgLyBlcHNpbG9uKSAqIGVwc2lsb24sIE1hdGgucm91bmQoeSQkMShkLCBpLCBkYXRhKSAvIGVwc2lsb24pICogZXBzaWxvbl07XG4gICAgICBzLmluZGV4ID0gaTtcbiAgICAgIHMuZGF0YSA9IGQ7XG4gICAgICByZXR1cm4gcztcbiAgICB9KSwgZXh0ZW50KTtcbiAgfVxuXG4gIHZvcm9ub2kucG9seWdvbnMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkucG9seWdvbnMoKTtcbiAgfTtcblxuICB2b3Jvbm9pLmxpbmtzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiB2b3Jvbm9pKGRhdGEpLmxpbmtzKCk7XG4gIH07XG5cbiAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkudHJpYW5nbGVzKCk7XG4gIH07XG5cbiAgdm9yb25vaS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgdm9yb25vaSkgOiB4JCQxO1xuICB9O1xuXG4gIHZvcm9ub2kueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHZvcm9ub2kpIDogeSQkMTtcbiAgfTtcblxuICB2b3Jvbm9pLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSBfID09IG51bGwgPyBudWxsIDogW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0sIHZvcm9ub2kpIDogZXh0ZW50ICYmIFtbZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV1dLCBbZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gXyA9PSBudWxsID8gbnVsbCA6IFtbMCwgMF0sIFsrX1swXSwgK19bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW2V4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdXTtcbiAgfTtcblxuICByZXR1cm4gdm9yb25vaTtcbn1cblxuZXhwb3J0cy52b3Jvbm9pID0gdm9yb25vaTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtem9vbS8gdjEuOC4zIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtZGlzcGF0Y2gnKSwgcmVxdWlyZSgnZDMtZHJhZycpLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtdHJhbnNpdGlvbicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWRpc3BhdGNoJywgJ2QzLWRyYWcnLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtc2VsZWN0aW9uJywgJ2QzLXRyYW5zaXRpb24nXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzRGlzcGF0Y2gsIGQzRHJhZywgZDNJbnRlcnBvbGF0ZSwgZDNTZWxlY3Rpb24sIGQzVHJhbnNpdGlvbikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBab29tRXZlbnQodGFyZ2V0LCB0eXBlLCB0cmFuc2Zvcm0pIHtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oaywgeCwgeSkge1xuICB0aGlzLmsgPSBrO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNmb3JtLFxuICBzY2FsZTogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBrID09PSAxID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rICogaywgdGhpcy54LCB0aGlzLnkpO1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9PT0gMCAmIHkgPT09IDAgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmssIHRoaXMueCArIHRoaXMuayAqIHgsIHRoaXMueSArIHRoaXMuayAqIHkpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gW3BvaW50WzBdICogdGhpcy5rICsgdGhpcy54LCBwb2ludFsxXSAqIHRoaXMuayArIHRoaXMueV07XG4gIH0sXG4gIGFwcGx5WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4ICogdGhpcy5rICsgdGhpcy54O1xuICB9LFxuICBhcHBseVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geSAqIHRoaXMuayArIHRoaXMueTtcbiAgfSxcbiAgaW52ZXJ0OiBmdW5jdGlvbihsb2NhdGlvbikge1xuICAgIHJldHVybiBbKGxvY2F0aW9uWzBdIC0gdGhpcy54KSAvIHRoaXMuaywgKGxvY2F0aW9uWzFdIC0gdGhpcy55KSAvIHRoaXMua107XG4gIH0sXG4gIGludmVydFg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gKHggLSB0aGlzLngpIC8gdGhpcy5rO1xuICB9LFxuICBpbnZlcnRZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuICh5IC0gdGhpcy55KSAvIHRoaXMuaztcbiAgfSxcbiAgcmVzY2FsZVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geC5jb3B5KCkuZG9tYWluKHgucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRYLCB0aGlzKS5tYXAoeC5pbnZlcnQsIHgpKTtcbiAgfSxcbiAgcmVzY2FsZVk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4geS5jb3B5KCkuZG9tYWluKHkucmFuZ2UoKS5tYXAodGhpcy5pbnZlcnRZLCB0aGlzKS5tYXAoeS5pbnZlcnQsIHkpKTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpIHNjYWxlKFwiICsgdGhpcy5rICsgXCIpXCI7XG4gIH1cbn07XG5cbnZhciBpZGVudGl0eSA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybS5wcm90b3R5cGUgPSBUcmFuc2Zvcm0ucHJvdG90eXBlO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX196b29tKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuIGlkZW50aXR5O1xuICByZXR1cm4gbm9kZS5fX3pvb207XG59XG5cbmZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBub2V2ZW50KCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWQzU2VsZWN0aW9uLmV2ZW50LmN0cmxLZXkgJiYgIWQzU2VsZWN0aW9uLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICBpZiAoZS5oYXNBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIpKSB7XG4gICAgICBlID0gZS52aWV3Qm94LmJhc2VWYWw7XG4gICAgICByZXR1cm4gW1tlLngsIGUueV0sIFtlLnggKyBlLndpZHRoLCBlLnkgKyBlLmhlaWdodF1dO1xuICAgIH1cbiAgICByZXR1cm4gW1swLCAwXSwgW2Uud2lkdGguYmFzZVZhbC52YWx1ZSwgZS5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbZS5jbGllbnRXaWR0aCwgZS5jbGllbnRIZWlnaHRdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YSgpIHtcbiAgcmV0dXJuIC1kM1NlbGVjdGlvbi5ldmVudC5kZWx0YVkgKiAoZDNTZWxlY3Rpb24uZXZlbnQuZGVsdGFNb2RlID09PSAxID8gMC4wNSA6IGQzU2VsZWN0aW9uLmV2ZW50LmRlbHRhTW9kZSA/IDEgOiAwLjAwMik7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb25zdHJhaW4odHJhbnNmb3JtLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICB2YXIgZHgwID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzBdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVswXSxcbiAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXG4gICAgICBkeTAgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMF1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzFdLFxuICAgICAgZHkxID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzFdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVsxXTtcbiAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXG4gICAgZHgxID4gZHgwID8gKGR4MCArIGR4MSkgLyAyIDogTWF0aC5taW4oMCwgZHgwKSB8fCBNYXRoLm1heCgwLCBkeDEpLFxuICAgIGR5MSA+IGR5MCA/IChkeTAgKyBkeTEpIC8gMiA6IE1hdGgubWluKDAsIGR5MCkgfHwgTWF0aC5tYXgoMCwgZHkxKVxuICApO1xufVxuXG5mdW5jdGlvbiB6b29tKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVpvb20sXG4gICAgICBsaXN0ZW5lcnMgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJ6b29tXCIsIFwiZW5kXCIpLFxuICAgICAgdG91Y2hzdGFydGluZyxcbiAgICAgIHRvdWNoZW5kaW5nLFxuICAgICAgdG91Y2hEZWxheSA9IDUwMCxcbiAgICAgIHdoZWVsRGVsYXkgPSAxNTAsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gem9vbShzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pXG4gICAgICAgIC5vbihcIndoZWVsLnpvb21cIiwgd2hlZWxlZClcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vkb3duZWQpXG4gICAgICAgIC5vbihcImRibGNsaWNrLnpvb21cIiwgZGJsY2xpY2tlZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuem9vbVwiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC56b29tIHRvdWNoY2FuY2VsLnpvb21cIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgem9vbS50cmFuc2Zvcm0gPSBmdW5jdGlvbihjb2xsZWN0aW9uLCB0cmFuc2Zvcm0sIHBvaW50KSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW50ZXJydXB0KCkuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgICAgLnpvb20obnVsbCwgdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0cmFuc2Zvcm0pXG4gICAgICAgICAgICAuZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgem9vbS5zY2FsZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBrLCBwKSB7XG4gICAgem9vbS5zY2FsZVRvKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgazAgPSB0aGlzLl9fem9vbS5rLFxuICAgICAgICAgIGsxID0gdHlwZW9mIGsgPT09IFwiZnVuY3Rpb25cIiA/IGsuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGs7XG4gICAgICByZXR1cm4gazAgKiBrMTtcbiAgICB9LCBwKTtcbiAgfTtcblxuICB6b29tLnNjYWxlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHApIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0MCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcCxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5LCBwKSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAwID0gcCA9PSBudWxsID8gY2VudHJvaWQoZSkgOiB0eXBlb2YgcCA9PT0gXCJmdW5jdGlvblwiID8gcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcDtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHAwWzBdLCBwMFsxXSkuc2NhbGUodC5rKS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyAteC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyAteS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogLXlcbiAgICAgICksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSwgcCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2NhbGUodHJhbnNmb3JtLCBrKSB7XG4gICAgayA9IE1hdGgubWF4KHNjYWxlRXh0ZW50WzBdLCBNYXRoLm1pbihzY2FsZUV4dGVudFsxXSwgaykpO1xuICAgIHJldHVybiBrID09PSB0cmFuc2Zvcm0uayA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oaywgdHJhbnNmb3JtLngsIHRyYW5zZm9ybS55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHAwLCBwMSkge1xuICAgIHZhciB4ID0gcDBbMF0gLSBwMVswXSAqIHRyYW5zZm9ybS5rLCB5ID0gcDBbMV0gLSBwMVsxXSAqIHRyYW5zZm9ybS5rO1xuICAgIHJldHVybiB4ID09PSB0cmFuc2Zvcm0ueCAmJiB5ID09PSB0cmFuc2Zvcm0ueSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0odHJhbnNmb3JtLmssIHgsIHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiwgdHJhbnNmb3JtLCBwb2ludCkge1xuICAgIHRyYW5zaXRpb25cbiAgICAgICAgLm9uKFwic3RhcnQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLnN0YXJ0KCk7IH0pXG4gICAgICAgIC5vbihcImludGVycnVwdC56b29tIGVuZC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuZW5kKCk7IH0pXG4gICAgICAgIC50d2VlbihcInpvb21cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICBnID0gZ2VzdHVyZSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgZSA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKSxcbiAgICAgICAgICAgICAgcCA9IHBvaW50ID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwb2ludCA9PT0gXCJmdW5jdGlvblwiID8gcG9pbnQuYXBwbHkodGhhdCwgYXJncykgOiBwb2ludCxcbiAgICAgICAgICAgICAgdyA9IE1hdGgubWF4KGVbMV1bMF0gLSBlWzBdWzBdLCBlWzFdWzFdIC0gZVswXVsxXSksXG4gICAgICAgICAgICAgIGEgPSB0aGF0Ll9fem9vbSxcbiAgICAgICAgICAgICAgYiA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIiA/IHRyYW5zZm9ybS5hcHBseSh0aGF0LCBhcmdzKSA6IHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgaSA9IGludGVycG9sYXRlKGEuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYS5rKSwgYi5pbnZlcnQocCkuY29uY2F0KHcgLyBiLmspKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHQgPT09IDEpIHQgPSBiOyAvLyBBdm9pZCByb3VuZGluZyBlcnJvciBvbiBlbmQuXG4gICAgICAgICAgICBlbHNlIHsgdmFyIGwgPSBpKHQpLCBrID0gdyAvIGxbMl07IHQgPSBuZXcgVHJhbnNmb3JtKGssIHBbMF0gLSBsWzBdICogaywgcFsxXSAtIGxbMV0gKiBrKTsgfVxuICAgICAgICAgICAgZy56b29tKG51bGwsIHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VzdHVyZSh0aGF0LCBhcmdzLCBjbGVhbikge1xuICAgIHJldHVybiAoIWNsZWFuICYmIHRoYXQuX196b29taW5nKSB8fCBuZXcgR2VzdHVyZSh0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgdGhpcy50YXBzID0gMDtcbiAgfVxuXG4gIEdlc3R1cmUucHJvdG90eXBlID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB7XG4gICAgICAgIHRoaXMudGhhdC5fX3pvb21pbmcgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0pIHtcbiAgICAgIGlmICh0aGlzLm1vdXNlICYmIGtleSAhPT0gXCJtb3VzZVwiKSB0aGlzLm1vdXNlWzFdID0gdHJhbnNmb3JtLmludmVydCh0aGlzLm1vdXNlWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMCAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDBbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gwWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcbiAgICAgIHRoaXMudGhhdC5fX3pvb20gPSB0cmFuc2Zvcm07XG4gICAgICB0aGlzLmVtaXQoXCJ6b29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudGhhdC5fX3pvb21pbmc7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IFpvb21FdmVudCh6b29tLCB0eXBlLCB0aGlzLnRoYXQuX196b29tKSwgbGlzdGVuZXJzLmFwcGx5LCBsaXN0ZW5lcnMsIFt0eXBlLCB0aGlzLnRoYXQsIHRoaXMuYXJnc10pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCB0LmsgKiBNYXRoLnBvdygyLCB3aGVlbERlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSksXG4gICAgICAgIHAgPSBkM1NlbGVjdGlvbi5tb3VzZSh0aGlzKTtcblxuICAgIC8vIElmIHRoZSBtb3VzZSBpcyBpbiB0aGUgc2FtZSBsb2NhdGlvbiBhcyBiZWZvcmUsIHJldXNlIGl0LlxuICAgIC8vIElmIHRoZXJlIHdlcmUgcmVjZW50IHdoZWVsIGV2ZW50cywgcmVzZXQgdGhlIHdoZWVsIGlkbGUgdGltZW91dC5cbiAgICBpZiAoZy53aGVlbCkge1xuICAgICAgaWYgKGcubW91c2VbMF1bMF0gIT09IHBbMF0gfHwgZy5tb3VzZVswXVsxXSAhPT0gcFsxXSkge1xuICAgICAgICBnLm1vdXNlWzFdID0gdC5pbnZlcnQoZy5tb3VzZVswXSA9IHApO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGcud2hlZWwpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2hlZWwgZXZlbnQgd29u4oCZdCB0cmlnZ2VyIGEgdHJhbnNmb3JtIGNoYW5nZSwgaWdub3JlIGl0LlxuICAgIGVsc2UgaWYgKHQuayA9PT0gaykgcmV0dXJuO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBjYXB0dXJlIHRoZSBtb3VzZSBwb2ludCBhbmQgbG9jYXRpb24gYXQgdGhlIHN0YXJ0LlxuICAgIGVsc2Uge1xuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XG4gICAgICBkM1RyYW5zaXRpb24uaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoKTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cywgdHJ1ZSksXG4gICAgICAgIHYgPSBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZW1vdmVkLCB0cnVlKS5vbihcIm1vdXNldXAuem9vbVwiLCBtb3VzZXVwcGVkLCB0cnVlKSxcbiAgICAgICAgcCA9IGQzU2VsZWN0aW9uLm1vdXNlKHRoaXMpLFxuICAgICAgICB4MCA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFgsXG4gICAgICAgIHkwID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WTtcblxuICAgIGQzRHJhZy5kcmFnRGlzYWJsZShkM1NlbGVjdGlvbi5ldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhpcyk7XG4gICAgZy5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlZCgpIHtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IGQzU2VsZWN0aW9uLm1vdXNlKGcudGhhdCksIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkM0RyYWcuZHJhZ0VuYWJsZShkM1NlbGVjdGlvbi5ldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIGcuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgIHAwID0gZDNTZWxlY3Rpb24ubW91c2UodGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGQzU2VsZWN0aW9uLmV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDApO1xuICAgIGVsc2UgZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsXG4gICAgICAgIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cywgZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSBuKSxcbiAgICAgICAgc3RhcnRlZCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IGQzU2VsZWN0aW9uLnRvdWNoKHRoaXMsIHRvdWNoZXMsIHQuaWRlbnRpZmllcik7XG4gICAgICBwID0gW3AsIHRoaXMuX196b29tLmludmVydChwKSwgdC5pZGVudGlmaWVyXTtcbiAgICAgIGlmICghZy50b3VjaDApIGcudG91Y2gwID0gcCwgc3RhcnRlZCA9IHRydWUsIGcudGFwcyA9IDEgKyAhIXRvdWNoc3RhcnRpbmc7XG4gICAgICBlbHNlIGlmICghZy50b3VjaDEgJiYgZy50b3VjaDBbMl0gIT09IHBbMl0pIGcudG91Y2gxID0gcCwgZy50YXBzID0gMDtcbiAgICB9XG5cbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICBpZiAoZy50YXBzIDwgMikgdG91Y2hzdGFydGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoc3RhcnRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2htb3ZlZCgpIHtcbiAgICBpZiAoIXRoaXMuX196b29taW5nKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwLCBsO1xuXG4gICAgbm9ldmVudCgpO1xuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuICAgIGcudGFwcyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV0sIHAgPSBkM1NlbGVjdGlvbi50b3VjaCh0aGlzLCB0b3VjaGVzLCB0LmlkZW50aWZpZXIpO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gwWzBdID0gcDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGcudG91Y2gxWzBdID0gcDtcbiAgICB9XG4gICAgdCA9IGcudGhhdC5fX3pvb207XG4gICAgaWYgKGcudG91Y2gxKSB7XG4gICAgICB2YXIgcDAgPSBnLnRvdWNoMFswXSwgbDAgPSBnLnRvdWNoMFsxXSxcbiAgICAgICAgICBwMSA9IGcudG91Y2gxWzBdLCBsMSA9IGcudG91Y2gxWzFdLFxuICAgICAgICAgIGRwID0gKGRwID0gcDFbMF0gLSBwMFswXSkgKiBkcCArIChkcCA9IHAxWzFdIC0gcDBbMV0pICogZHAsXG4gICAgICAgICAgZGwgPSAoZGwgPSBsMVswXSAtIGwwWzBdKSAqIGRsICsgKGRsID0gbDFbMV0gLSBsMFsxXSkgKiBkbDtcbiAgICAgIHQgPSBzY2FsZSh0LCBNYXRoLnNxcnQoZHAgLyBkbCkpO1xuICAgICAgcCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcbiAgICAgIGwgPSBbKGwwWzBdICsgbDFbMF0pIC8gMiwgKGwwWzFdICsgbDFbMV0pIC8gMl07XG4gICAgfVxuICAgIGVsc2UgaWYgKGcudG91Y2gwKSBwID0gZy50b3VjaDBbMF0sIGwgPSBnLnRvdWNoMFsxXTtcbiAgICBlbHNlIHJldHVybjtcbiAgICBnLnpvb20oXCJ0b3VjaFwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHQsIHAsIGwpLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKCkge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQ7XG5cbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIHtcbiAgICAgIGcuZW5kKCk7XG4gICAgICAvLyBJZiB0aGlzIHdhcyBhIGRibHRhcCwgcmVyb3V0ZSB0byB0aGUgKG9wdGlvbmFsKSBkYmxjbGljay56b29tIGhhbmRsZXIuXG4gICAgICBpZiAoZy50YXBzID09PSAyKSB7XG4gICAgICAgIHZhciBwID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB6b29tLndoZWVsRGVsdGEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod2hlZWxEZWx0YSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB6b29tKSA6IHdoZWVsRGVsdGE7XG4gIH07XG5cbiAgem9vbS5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IGZpbHRlcjtcbiAgfTtcblxuICB6b29tLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIHpvb20uZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCB6b29tKSA6IGV4dGVudDtcbiAgfTtcblxuICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlRXh0ZW50WzBdID0gK19bMF0sIHNjYWxlRXh0ZW50WzFdID0gK19bMV0sIHpvb20pIDogW3NjYWxlRXh0ZW50WzBdLCBzY2FsZUV4dGVudFsxXV07XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlRXh0ZW50WzBdWzBdID0gK19bMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVswXSA9ICtfWzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV0gPSArX1swXVsxXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdID0gK19bMV1bMV0sIHpvb20pIDogW1t0cmFuc2xhdGVFeHRlbnRbMF1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXV0sIFt0cmFuc2xhdGVFeHRlbnRbMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXV1dO1xuICB9O1xuXG4gIHpvb20uY29uc3RyYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnN0cmFpbiA9IF8sIHpvb20pIDogY29uc3RyYWluO1xuICB9O1xuXG4gIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHVyYXRpb24gPSArXywgem9vbSkgOiBkdXJhdGlvbjtcbiAgfTtcblxuICB6b29tLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRlID0gXywgem9vbSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICB6b29tLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IHpvb20gOiB2YWx1ZTtcbiAgfTtcblxuICB6b29tLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIHpvb20pIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn1cblxuZXhwb3J0cy56b29tID0gem9vbTtcbmV4cG9ydHMuem9vbUlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnpvb21UcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGQzQXJyYXkgPSByZXF1aXJlKCdkMy1hcnJheScpO1xudmFyIGQzQXhpcyA9IHJlcXVpcmUoJ2QzLWF4aXMnKTtcbnZhciBkM0JydXNoID0gcmVxdWlyZSgnZDMtYnJ1c2gnKTtcbnZhciBkM0Nob3JkID0gcmVxdWlyZSgnZDMtY2hvcmQnKTtcbnZhciBkM0NvbGxlY3Rpb24gPSByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyk7XG52YXIgZDNDb2xvciA9IHJlcXVpcmUoJ2QzLWNvbG9yJyk7XG52YXIgZDNDb250b3VyID0gcmVxdWlyZSgnZDMtY29udG91cicpO1xudmFyIGQzRGlzcGF0Y2ggPSByZXF1aXJlKCdkMy1kaXNwYXRjaCcpO1xudmFyIGQzRHJhZyA9IHJlcXVpcmUoJ2QzLWRyYWcnKTtcbnZhciBkM0RzdiA9IHJlcXVpcmUoJ2QzLWRzdicpO1xudmFyIGQzRWFzZSA9IHJlcXVpcmUoJ2QzLWVhc2UnKTtcbnZhciBkM0ZldGNoID0gcmVxdWlyZSgnZDMtZmV0Y2gnKTtcbnZhciBkM0ZvcmNlID0gcmVxdWlyZSgnZDMtZm9yY2UnKTtcbnZhciBkM0Zvcm1hdCA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpO1xudmFyIGQzR2VvID0gcmVxdWlyZSgnZDMtZ2VvJyk7XG52YXIgZDNIaWVyYXJjaHkgPSByZXF1aXJlKCdkMy1oaWVyYXJjaHknKTtcbnZhciBkM0ludGVycG9sYXRlID0gcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKTtcbnZhciBkM1BhdGggPSByZXF1aXJlKCdkMy1wYXRoJyk7XG52YXIgZDNQb2x5Z29uID0gcmVxdWlyZSgnZDMtcG9seWdvbicpO1xudmFyIGQzUXVhZHRyZWUgPSByZXF1aXJlKCdkMy1xdWFkdHJlZScpO1xudmFyIGQzUmFuZG9tID0gcmVxdWlyZSgnZDMtcmFuZG9tJyk7XG52YXIgZDNTY2FsZSA9IHJlcXVpcmUoJ2QzLXNjYWxlJyk7XG52YXIgZDNTY2FsZUNocm9tYXRpYyA9IHJlcXVpcmUoJ2QzLXNjYWxlLWNocm9tYXRpYycpO1xudmFyIGQzU2VsZWN0aW9uID0gcmVxdWlyZSgnZDMtc2VsZWN0aW9uJyk7XG52YXIgZDNTaGFwZSA9IHJlcXVpcmUoJ2QzLXNoYXBlJyk7XG52YXIgZDNUaW1lID0gcmVxdWlyZSgnZDMtdGltZScpO1xudmFyIGQzVGltZUZvcm1hdCA9IHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0Jyk7XG52YXIgZDNUaW1lciA9IHJlcXVpcmUoJ2QzLXRpbWVyJyk7XG52YXIgZDNUcmFuc2l0aW9uID0gcmVxdWlyZSgnZDMtdHJhbnNpdGlvbicpO1xudmFyIGQzVm9yb25vaSA9IHJlcXVpcmUoJ2QzLXZvcm9ub2knKTtcbnZhciBkM1pvb20gPSByZXF1aXJlKCdkMy16b29tJyk7XG5cbnZhciB2ZXJzaW9uID0gXCI1LjE1LjBcIjtcblxuT2JqZWN0LmtleXMoZDNBcnJheSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNBcnJheVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0F4aXMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzQXhpc1trXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0JydXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0JydXNoW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzQ2hvcmQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzQ2hvcmRba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNDb2xsZWN0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0NvbGxlY3Rpb25ba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNDb2xvcikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNDb2xvcltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0NvbnRvdXIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzQ29udG91cltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0Rpc3BhdGNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0Rpc3BhdGNoW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzRHJhZykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNEcmFnW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzRHN2KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0RzdltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0Vhc2UpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzRWFzZVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0ZldGNoKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0ZldGNoW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzRm9yY2UpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzRm9yY2Vba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNGb3JtYXQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzRm9ybWF0W2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzR2VvKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0dlb1trXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0hpZXJhcmNoeSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNIaWVyYXJjaHlba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNJbnRlcnBvbGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNJbnRlcnBvbGF0ZVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1BhdGgpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzUGF0aFtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1BvbHlnb24pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzUG9seWdvbltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1F1YWR0cmVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM1F1YWR0cmVlW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzUmFuZG9tKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM1JhbmRvbVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1NjYWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM1NjYWxlW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzU2NhbGVDaHJvbWF0aWMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzU2NhbGVDaHJvbWF0aWNba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNTZWxlY3Rpb24pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzU2VsZWN0aW9uW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzU2hhcGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzU2hhcGVba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNUaW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM1RpbWVba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNUaW1lRm9ybWF0KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM1RpbWVGb3JtYXRba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNUaW1lcikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNUaW1lcltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1RyYW5zaXRpb24pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzVHJhbnNpdGlvbltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1Zvcm9ub2kpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzVm9yb25vaVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1pvb20pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzWm9vbVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuIiwiLy8gZnVsbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4XCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGNvbW1vbjtcblxudmFyIGNvbW1vblJlID0gL1xcL3xcXC4vO1xuXG4vKipcbiAqIFByb3ZpZGVzIGNvbW1vbiB0eXBlIGRlZmluaXRpb25zLlxuICogQ2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlIGFkZGl0aW9uYWwgZ29vZ2xlIHR5cGVzIG9yIHlvdXIgb3duIGN1c3RvbSB0eXBlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNob3J0IG5hbWUgYXMgaW4gYGdvb2dsZS9wcm90b2J1Zi9bbmFtZV0ucHJvdG9gIG9yIGZ1bGwgZmlsZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gZGVmaW5pdGlvbiB3aXRoaW4gYGdvb2dsZS5wcm90b2J1ZmAgaWYgYSBzaG9ydCBuYW1lLCBvdGhlcndpc2UgdGhlIGZpbGUncyByb290IGRlZmluaXRpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG8gQW55XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90byBEdXJhdGlvblxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG8gRW1wdHlcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG8gRmllbGRNYXNrXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9zdHJ1Y3QucHJvdG8gU3RydWN0LCBWYWx1ZSwgTnVsbFZhbHVlIGFuZCBMaXN0VmFsdWVcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcC5wcm90byBUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvIFdyYXBwZXJzXG4gKiBAZXhhbXBsZVxuICogLy8gbWFudWFsbHkgcHJvdmlkZXMgZGVzY3JpcHRvci5wcm90byAoYXNzdW1lcyBnb29nbGUvcHJvdG9idWYvIG5hbWVzcGFjZSBhbmQgLnByb3RvIGV4dGVuc2lvbilcbiAqIHByb3RvYnVmLmNvbW1vbihcImRlc2NyaXB0b3JcIiwgZGVzY3JpcHRvckpzb24pO1xuICpcbiAqIC8vIG1hbnVhbGx5IHByb3ZpZGVzIGEgY3VzdG9tIGRlZmluaXRpb24gKHVzZXMgbXkuZm9vIG5hbWVzcGFjZSlcbiAqIHByb3RvYnVmLmNvbW1vbihcIm15L2Zvby9iYXIucHJvdG9cIiwgbXlGb29CYXJKc29uKTtcbiAqL1xuZnVuY3Rpb24gY29tbW9uKG5hbWUsIGpzb24pIHtcbiAgICBpZiAoIWNvbW1vblJlLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IFwiZ29vZ2xlL3Byb3RvYnVmL1wiICsgbmFtZSArIFwiLnByb3RvXCI7XG4gICAgICAgIGpzb24gPSB7IG5lc3RlZDogeyBnb29nbGU6IHsgbmVzdGVkOiB7IHByb3RvYnVmOiB7IG5lc3RlZDoganNvbiB9IH0gfSB9IH07XG4gICAgfVxuICAgIGNvbW1vbltuYW1lXSA9IGpzb247XG59XG5cbi8vIE5vdCBwcm92aWRlZCBiZWNhdXNlIG9mIGxpbWl0ZWQgdXNlIChmZWVsIGZyZWUgdG8gZGlzY3VzcyBvciB0byBwcm92aWRlIHlvdXJzZWxmKTpcbi8vXG4vLyBnb29nbGUvcHJvdG9idWYvZGVzY3JpcHRvci5wcm90b1xuLy8gZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0LnByb3RvXG4vLyBnb29nbGUvcHJvdG9idWYvdHlwZS5wcm90b1xuLy9cbi8vIFN0cmlwcGVkIGFuZCBwcmUtcGFyc2VkIHZlcnNpb25zIG9mIHRoZXNlIG5vbi1idW5kbGVkIGZpbGVzIGFyZSBpbnN0ZWFkIGF2YWlsYWJsZSBhcyBwYXJ0IG9mXG4vLyB0aGUgcmVwb3NpdG9yeSBvciBwYWNrYWdlIHdpdGhpbiB0aGUgZ29vZ2xlL3Byb3RvYnVmIGRpcmVjdG9yeS5cblxuY29tbW9uKFwiYW55XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQW55IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQW55XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVVcmxdXG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbYnl0ZXNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEFueToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHR5cGVfdXJsOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJieXRlc1wiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxudmFyIHRpbWVUeXBlO1xuXG5jb21tb24oXCJkdXJhdGlvblwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRHVyYXRpb25cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFtzZWNvbmRzXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIER1cmF0aW9uOiB0aW1lVHlwZSA9IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICBzZWNvbmRzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQ2NFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFub3M6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJ0aW1lc3RhbXBcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXAgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElUaW1lc3RhbXBcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFtzZWNvbmRzXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbmFub3NdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFRpbWVzdGFtcDogdGltZVR5cGVcbn0pO1xuXG5jb21tb24oXCJlbXB0eVwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkVtcHR5IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRW1wdHlcbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRW1wdHk6IHtcbiAgICAgICAgZmllbGRzOiB7fVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJzdHJ1Y3RcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElTdHJ1Y3RcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSVZhbHVlPn0gW2ZpZWxkc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgU3RydWN0OiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBba2luZF1cbiAgICAgKiBAcHJvcGVydHkgezB9IFtudWxsVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1iZXJWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3N0cmluZ1ZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Jvb2xWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge0lTdHJ1Y3R9IFtzdHJ1Y3RWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge0lMaXN0VmFsdWV9IFtsaXN0VmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFZhbHVlOiB7XG4gICAgICAgIG9uZW9mczoge1xuICAgICAgICAgICAga2luZDoge1xuICAgICAgICAgICAgICAgIG9uZW9mOiBbXG4gICAgICAgICAgICAgICAgICAgIFwibnVsbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibnVtYmVyVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJvb2xWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInN0cnVjdFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwibGlzdFZhbHVlXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgbnVsbFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJOdWxsVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bWJlclZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJkb3VibGVcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cmluZ1ZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogM1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvb2xWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIGlkOiA0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RydWN0VmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlN0cnVjdFwiLFxuICAgICAgICAgICAgICAgIGlkOiA1XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXN0VmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogNlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIE51bGxWYWx1ZToge1xuICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgIE5VTExfVkFMVUU6IDBcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUxpc3RWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtBcnJheS48SVZhbHVlPn0gW3ZhbHVlc11cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgTGlzdFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgcnVsZTogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcIndyYXBwZXJzXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEb3VibGVWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRG91YmxlVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG91YmxlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElGbG9hdFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBGbG9hdFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDY0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElJbnQ2NFZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEludDY0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDY0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElVSW50NjRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBVSW50NjRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1aW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUludDMyVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEludDMyVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50MzJcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVUludDMyVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElVSW50MzJWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVUludDMyVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkJvb2xWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUJvb2xWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEJvb2xWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJU3RyaW5nVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFN0cmluZ1ZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5CeXRlc1ZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJQnl0ZXNWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEJ5dGVzVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmNvbW1vbihcImZpZWxkX21hc2tcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2sgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElEb3VibGVWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRmllbGRNYXNrOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgcGF0aHM6IHtcbiAgICAgICAgICAgICAgICBydWxlOiBcInJlcGVhdGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgcm9vdCBkZWZpbml0aW9uIG9mIHRoZSBzcGVjaWZpZWQgY29tbW9uIHByb3RvIGZpbGUuXG4gKlxuICogQnVuZGxlZCBkZWZpbml0aW9ucyBhcmU6XG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9hbnkucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2R1cmF0aW9uLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZmllbGRfbWFzay5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3dyYXBwZXJzLnByb3RvXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGUgUHJvdG8gZmlsZSBuYW1lXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZXxudWxsfSBSb290IGRlZmluaXRpb24gb3IgYG51bGxgIGlmIG5vdCBkZWZpbmVkXG4gKi9cbmNvbW1vbi5nZXQgPSBmdW5jdGlvbiBnZXQoZmlsZSkge1xuICAgIHJldHVybiBjb21tb25bZmlsZV0gfHwgbnVsbDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogUnVudGltZSBtZXNzYWdlIGZyb20vdG8gcGxhaW4gb2JqZWN0IGNvbnZlcnRlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBjb252ZXJ0ZXIgPSBleHBvcnRzO1xuXG52YXIgRW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSBmcm9tT2JqZWN0IGNvbnZldGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCBwcm9wKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goZCVzKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBmb3IgKHZhciB2YWx1ZXMgPSBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzLCBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnJlcGVhdGVkICYmIHZhbHVlc1trZXlzW2ldXSA9PT0gZmllbGQudHlwZURlZmF1bHQpIGdlblxuICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImNhc2UlajpcIiwga2V5c1tpXSlcbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz0lalwiLCBwcm9wLCB2YWx1ZXNba2V5c1tpXV0pXG4gICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBnZW5cbiAgICAgICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAgICAgKFwibSVzPXR5cGVzWyVpXS5mcm9tT2JqZWN0KGQlcylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPU51bWJlcihkJXMpXCIsIHByb3AsIHByb3ApOyAvLyBhbHNvIGNhdGNoZXMgXCJOYU5cIiwgXCJJbmZpbml0eVwiXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzPj4+MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXN8MFwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodXRpbC5Mb25nKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCIobSVzPXV0aWwuTG9uZy5mcm9tVmFsdWUoZCVzKSkudW5zaWduZWQ9JWpcIiwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwic3RyaW5nXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPXBhcnNlSW50KGQlcywxMClcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwibnVtYmVyXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImVsc2UgaWYodHlwZW9mIGQlcz09PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9bmV3IHV0aWwuTG9uZ0JpdHMoZCVzLmxvdz4+PjAsZCVzLmhpZ2g+Pj4wKS50b051bWJlciglcylcIiwgcHJvcCwgcHJvcCwgcHJvcCwgaXNVbnNpZ25lZCA/IFwidHJ1ZVwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mIGQlcz09PVxcXCJzdHJpbmdcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJ1dGlsLmJhc2U2NC5kZWNvZGUoZCVzLG0lcz11dGlsLm5ld0J1ZmZlcih1dGlsLmJhc2U2NC5sZW5ndGgoZCVzKSksMClcIiwgcHJvcCwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKGQlcy5sZW5ndGgpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1TdHJpbmcoZCVzKVwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1Cb29sZWFuKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBkZWZhdWx0OiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGxhaW4gb2JqZWN0IHRvIHJ1bnRpbWUgbWVzc2FnZSBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuY29udmVydGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBmaWVsZHMgPSBtdHlwZS5maWVsZHNBcnJheTtcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcImRcIl0sIG10eXBlLm5hbWUgKyBcIiRmcm9tT2JqZWN0XCIpXG4gICAgKFwiaWYoZCBpbnN0YW5jZW9mIHRoaXMuY3RvcilcIilcbiAgICAgICAgKFwicmV0dXJuIGRcIik7XG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKSByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG5ldyB0aGlzLmN0b3JcIik7XG4gICAgZ2VuXG4gICAgKFwidmFyIG09bmV3IHRoaXMuY3RvclwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHByb3AgICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXG4gICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogb2JqZWN0IGV4cGVjdGVkXCIpXG4gICAgICAgIChcIm0lcz17fVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKGQlcyksaT0wO2k8a3MubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJba3NbaV1dXCIpXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXG4gICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KGQlcykpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IGFycmF5IGV4cGVjdGVkXCIpXG4gICAgICAgIChcIm0lcz1bXVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGQlcy5sZW5ndGg7KytpKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCAvKiBub3Qgc29ydGVkICovIGksIHByb3AgKyBcIltpXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuIC8vIG5vIG5lZWQgdG8gdGVzdCBmb3IgbnVsbC91bmRlZmluZWQgaWYgYW4gZW51bSAodXNlcyBzd2l0Y2gpXG4gICAgKFwiaWYoZCVzIT1udWxsKXtcIiwgcHJvcCk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wKTtcbiAgICAgICAgICAgIGlmICghKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKSBnZW5cbiAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgdG9PYmplY3QgY29udmVydGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmVudW1zPT09U3RyaW5nP3R5cGVzWyVpXS52YWx1ZXNbbSVzXTptJXNcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCwgcHJvcCk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9dHlwZXNbJWldLnRvT2JqZWN0KG0lcyxvKVwiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNVbnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOiBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmpzb24mJiFpc0Zpbml0ZShtJXMpP1N0cmluZyhtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgICAgICBpc1Vuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgbSVzPT09XFxcIm51bWJlclxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAoXCJlbHNlXCIpIC8vIExvbmctbGlrZVxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP3V0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtJXMpOm8ubG9uZ3M9PT1OdW1iZXI/bmV3IHV0aWwuTG9uZ0JpdHMobSVzLmxvdz4+PjAsbSVzLmhpZ2g+Pj4wKS50b051bWJlciglcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIGlzVW5zaWduZWQgPyBcInRydWVcIjogXCJcIiwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5ieXRlcz09PVN0cmluZz91dGlsLmJhc2U2NC5lbmNvZGUobSVzLDAsbSVzLmxlbmd0aCk6by5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9bSVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcnVudGltZSBtZXNzYWdlIHRvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuY29udmVydGVyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGZpZWxkcyA9IG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcbiAgICBpZiAoIWZpZWxkcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiB1dGlsLmNvZGVnZW4oKShcInJldHVybiB7fVwiKTtcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIiwgXCJvXCJdLCBtdHlwZS5uYW1lICsgXCIkdG9PYmplY3RcIilcbiAgICAoXCJpZighbylcIilcbiAgICAgICAgKFwibz17fVwiKVxuICAgIChcInZhciBkPXt9XCIpO1xuXG4gICAgdmFyIHJlcGVhdGVkRmllbGRzID0gW10sXG4gICAgICAgIG1hcEZpZWxkcyA9IFtdLFxuICAgICAgICBub3JtYWxGaWVsZHMgPSBbXSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICghZmllbGRzW2ldLnBhcnRPZilcbiAgICAgICAgICAgICggZmllbGRzW2ldLnJlc29sdmUoKS5yZXBlYXRlZCA/IHJlcGVhdGVkRmllbGRzXG4gICAgICAgICAgICA6IGZpZWxkc1tpXS5tYXAgPyBtYXBGaWVsZHNcbiAgICAgICAgICAgIDogbm9ybWFsRmllbGRzKS5wdXNoKGZpZWxkc1tpXSk7XG5cbiAgICBpZiAocmVwZWF0ZWRGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8uYXJyYXlzfHxvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRlZEZpZWxkcy5sZW5ndGg7ICsraSkgZ2VuXG4gICAgICAgIChcImQlcz1bXVwiLCB1dGlsLnNhZmVQcm9wKHJlcGVhdGVkRmllbGRzW2ldLm5hbWUpKTtcbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWFwRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLm9iamVjdHN8fG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hcEZpZWxkcy5sZW5ndGg7ICsraSkgZ2VuXG4gICAgICAgIChcImQlcz17fVwiLCB1dGlsLnNhZmVQcm9wKG1hcEZpZWxkc1tpXS5uYW1lKSk7XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9ybWFsRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBub3JtYWxGaWVsZHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvcCAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIGdlblxuICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz8lajolalwiLCBwcm9wLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzQnlJZFtmaWVsZC50eXBlRGVmYXVsdF0sIGZpZWxkLnR5cGVEZWZhdWx0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmxvbmcpIGdlblxuICAgICAgICAoXCJpZih1dGlsLkxvbmcpe1wiKVxuICAgICAgICAgICAgKFwidmFyIG49bmV3IHV0aWwuTG9uZyglaSwlaSwlailcIiwgZmllbGQudHlwZURlZmF1bHQubG93LCBmaWVsZC50eXBlRGVmYXVsdC5oaWdoLCBmaWVsZC50eXBlRGVmYXVsdC51bnNpZ25lZClcbiAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP24udG9TdHJpbmcoKTpvLmxvbmdzPT09TnVtYmVyP24udG9OdW1iZXIoKTpuXCIsIHByb3ApXG4gICAgICAgIChcIn1lbHNlXCIpXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz8lajolaVwiLCBwcm9wLCBmaWVsZC50eXBlRGVmYXVsdC50b1N0cmluZygpLCBmaWVsZC50eXBlRGVmYXVsdC50b051bWJlcigpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5RGVmYXVsdCA9IFwiW1wiICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmllbGQudHlwZURlZmF1bHQpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgIChcImlmKG8uYnl0ZXM9PT1TdHJpbmcpZCVzPSVqXCIsIHByb3AsIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBmaWVsZC50eXBlRGVmYXVsdCkpXG4gICAgICAgIChcImVsc2V7XCIpXG4gICAgICAgICAgICAoXCJkJXM9JXNcIiwgcHJvcCwgYXJyYXlEZWZhdWx0KVxuICAgICAgICAgICAgKFwiaWYoby5ieXRlcyE9PUFycmF5KWQlcz11dGlsLm5ld0J1ZmZlcihkJXMpXCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgZ2VuXG4gICAgICAgIChcImQlcz0lalwiLCBwcm9wLCBmaWVsZC50eXBlRGVmYXVsdCk7IC8vIGFsc28gbWVzc2FnZXMgKD1udWxsKVxuICAgICAgICB9IGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuICAgIHZhciBoYXNLczIgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXSxcbiAgICAgICAgICAgIGluZGV4ID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgcHJvcCAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0tzMikgeyBoYXNLczIgPSB0cnVlOyBnZW5cbiAgICAoXCJ2YXIga3MyXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJpZihtJXMmJihrczI9T2JqZWN0LmtleXMobSVzKSkubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwiZCVzPXt9XCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaj0wO2o8a3MyLmxlbmd0aDsrK2ope1wiKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltrczJbal1dXCIpXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgKFwiaWYobSVzJiZtJXMubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwiZCVzPVtdXCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaj0wO2o8bSVzLmxlbmd0aDsrK2ope1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltqXVwiKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgeyBnZW5cbiAgICAoXCJpZihtJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcHJvcCwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCk7XG4gICAgICAgIGlmIChmaWVsZC5wYXJ0T2YpIGdlblxuICAgICAgICAoXCJpZihvLm9uZW9mcylcIilcbiAgICAgICAgICAgIChcImQlcz0lalwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLnBhcnRPZi5uYW1lKSwgZmllbGQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBkXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVyO1xuXG52YXIgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBtaXNzaW5nKGZpZWxkKSB7XG4gICAgcmV0dXJuIFwibWlzc2luZyByZXF1aXJlZCAnXCIgKyBmaWVsZC5uYW1lICsgXCInXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZGVjb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcInJcIiwgXCJsXCJdLCBtdHlwZS5uYW1lICsgXCIkZGVjb2RlXCIpXG4gICAgKFwiaWYoIShyIGluc3RhbmNlb2YgUmVhZGVyKSlcIilcbiAgICAgICAgKFwicj1SZWFkZXIuY3JlYXRlKHIpXCIpXG4gICAgKFwidmFyIGM9bD09PXVuZGVmaW5lZD9yLmxlbjpyLnBvcytsLG09bmV3IHRoaXMuY3RvclwiICsgKG10eXBlLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGQubWFwOyB9KS5sZW5ndGggPyBcIixrLHZhbHVlXCIgOiBcIlwiKSlcbiAgICAoXCJ3aGlsZShyLnBvczxjKXtcIilcbiAgICAgICAgKFwidmFyIHQ9ci51aW50MzIoKVwiKTtcbiAgICBpZiAobXR5cGUuZ3JvdXApIGdlblxuICAgICAgICAoXCJpZigodCY3KT09PTQpXCIpXG4gICAgICAgICAgICAoXCJicmVha1wiKTtcbiAgICBnZW5cbiAgICAgICAgKFwic3dpdGNoKHQ+Pj4zKXtcIik7XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgdHlwZSAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHJlZiAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpOyBnZW5cbiAgICAgICAgICAgIChcImNhc2UgJWk6XCIsIGZpZWxkLmlkKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoJXM9PT11dGlsLmVtcHR5T2JqZWN0KVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPXt9XCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgYzIgPSByLnVpbnQzMigpK3IucG9zXCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaz0lalwiLCB0eXBlcy5kZWZhdWx0c1tmaWVsZC5rZXlUeXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIms9bnVsbFwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW3R5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPSVqXCIsIHR5cGVzLmRlZmF1bHRzW3R5cGVdKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwidmFsdWU9bnVsbFwiKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgdGFnMj1yLnVpbnQzMigpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInN3aXRjaCh0YWcyPj4+Myl7XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJjYXNlIDE6IGs9ci4lcygpOyBicmVha1wiLCBmaWVsZC5rZXlUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAyOlwiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCBpKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInZhbHVlPXIuJXMoKVwiLCB0eXBlKTtcblxuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0YWcyJjcpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwifVwiKVxuICAgICAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5sb25nW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW3R5cGVvZiBrPT09XFxcIm9iamVjdFxcXCI/dXRpbC5sb25nVG9IYXNoKGspOmtdPXZhbHVlXCIsIHJlZik7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzW2tdPXZhbHVlXCIsIHJlZik7XG5cbiAgICAgICAgLy8gUmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG5cbiAgICAgICAgICAgICAgICAoXCJpZighKCVzJiYlcy5sZW5ndGgpKVwiLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwiJXM9W11cIiwgcmVmKTtcblxuICAgICAgICAgICAgLy8gUGFja2FibGUgKGFsd2F5cyBjaGVjayBmb3IgZm9yd2FyZCBhbmQgYmFja3dhcmQgY29tcGF0aWJsaXR5KVxuICAgICAgICAgICAgaWYgKHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZigodCY3KT09PTIpe1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ2YXIgYzI9ci51aW50MzIoKStyLnBvc1wiKVxuICAgICAgICAgICAgICAgICAgICAoXCJ3aGlsZShyLnBvczxjMilcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpXG4gICAgICAgICAgICAgICAgKFwifWVsc2VcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW4oZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXG4gICAgICAgICAgICAgICAgICAgID8gXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocikpXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiVzLnB1c2godHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpKVwiLCByZWYsIGkpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiJXMucHVzaChyLiVzKCkpXCIsIHJlZiwgdHlwZSk7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICAgICAgICAgID8gXCIlcz10eXBlc1slaV0uZGVjb2RlKHIpXCJcbiAgICAgICAgICAgICAgICA6IFwiJXM9dHlwZXNbJWldLmRlY29kZShyLHIudWludDMyKCkpXCIsIHJlZiwgaSk7XG4gICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgKFwiJXM9ci4lcygpXCIsIHJlZiwgdHlwZSk7XG4gICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpO1xuICAgIC8vIFVua25vd24gZmllbGRzXG4gICAgfSBnZW5cbiAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgKFwici5za2lwVHlwZSh0JjcpXCIpXG4gICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcblxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgIC8vIEZpZWxkIHByZXNlbmNlXG4gICAgZm9yIChpID0gMDsgaSA8IG10eXBlLl9maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldO1xuICAgICAgICBpZiAocmZpZWxkLnJlcXVpcmVkKSBnZW5cbiAgICAoXCJpZighbS5oYXNPd25Qcm9wZXJ0eSglaikpXCIsIHJmaWVsZC5uYW1lKVxuICAgICAgICAoXCJ0aHJvdyB1dGlsLlByb3RvY29sRXJyb3IoJWose2luc3RhbmNlOm19KVwiLCBtaXNzaW5nKHJmaWVsZCkpO1xuICAgIH1cblxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlcjtcblxudmFyIEVudW0gICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIG1lc3NhZ2UgdHlwZSBlbmNvZGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHJlZikge1xuICAgIHJldHVybiBmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcbiAgICAgICAgPyBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKSkudWludDMyKCVpKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMykgPj4+IDAsIChmaWVsZC5pZCA8PCAzIHwgNCkgPj4+IDApXG4gICAgICAgIDogZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkuZm9yaygpKS5sZGVsaW0oKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBlbmNvZGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZXIobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwid1wiXSwgbXR5cGUubmFtZSArIFwiJGVuY29kZVwiKVxuICAgIChcImlmKCF3KVwiKVxuICAgICAgICAoXCJ3PVdyaXRlci5jcmVhdGUoKVwiKTtcblxuICAgIHZhciBpLCByZWY7XG5cbiAgICAvLyBcIndoZW4gYSBtZXNzYWdlIGlzIHNlcmlhbGl6ZWQgaXRzIGtub3duIGZpZWxkcyBzaG91bGQgYmUgd3JpdHRlbiBzZXF1ZW50aWFsbHkgYnkgZmllbGQgbnVtYmVyXCJcbiAgICB2YXIgZmllbGRzID0gLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICAgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIGluZGV4ICAgID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgdHlwZSAgICAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHdpcmVUeXBlID0gdHlwZXMuYmFzaWNbdHlwZV07XG4gICAgICAgICAgICByZWYgICAgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgICAgIGdlblxuICAgIChcImlmKCVzIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSkgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKCVzKSxpPTA7aTxrcy5sZW5ndGg7KytpKXtcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLmZvcmsoKS51aW50MzIoJWkpLiVzKGtzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwLCA4IHwgdHlwZXMubWFwS2V5W2ZpZWxkLmtleVR5cGVdLCBmaWVsZC5rZXlUeXBlKTtcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgIChcInR5cGVzWyVpXS5lbmNvZGUoJXNba3NbaV1dLHcudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLmxkZWxpbSgpXCIsIGluZGV4LCByZWYpOyAvLyBjYW4ndCBiZSBncm91cHNcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCIudWludDMyKCVpKS4lcyglc1trc1tpXV0pLmxkZWxpbSgpXCIsIDE2IHwgd2lyZVR5cGUsIHR5cGUsIHJlZik7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKCVzIT1udWxsJiYlcy5sZW5ndGgpe1wiLCByZWYsIHJlZik7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgLy8gUGFja2VkIHJlcGVhdGVkXG4gICAgICAgICAgICBpZiAoZmllbGQucGFja2VkICYmIHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSB7IGdlblxuXG4gICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKClcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJ3LiVzKCVzW2ldKVwiLCB0eXBlLCByZWYpXG4gICAgICAgIChcIncubGRlbGltKClcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIH0gZWxzZSB7IGdlblxuXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYgKyBcIltpXVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpXCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiB3XCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEVudW07XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKEVudW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRW51bSkuY2xhc3NOYW1lID0gXCJFbnVtXCI7XG5cbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBlbnVtIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgZW51bS5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gW3ZhbHVlc10gRW51bSB2YWx1ZXMgYXMgYW4gb2JqZWN0LCBieSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBUaGUgY29tbWVudCBmb3IgdGhpcyBlbnVtXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLHN0cmluZz59IFtjb21tZW50c10gVGhlIHZhbHVlIGNvbW1lbnRzIGZvciB0aGlzIGVudW1cbiAqL1xuZnVuY3Rpb24gRW51bShuYW1lLCB2YWx1ZXMsIG9wdGlvbnMsIGNvbW1lbnQsIGNvbW1lbnRzKSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlcyAmJiB0eXBlb2YgdmFsdWVzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ2YWx1ZXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc0J5SWQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEVudW0gdmFsdWVzIGJ5IG5hbWUuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMudmFsdWVzQnlJZCk7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBFbnVtIGNvbW1lbnQgdGV4dC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGNvbW1lbnQgdGV4dHMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvLyBOb3RlIHRoYXQgdmFsdWVzIGluaGVyaXQgdmFsdWVzQnlJZCBvbiB0aGVpciBwcm90b3R5cGUgd2hpY2ggbWFrZXMgdGhlbSBhIFR5cGVTY3JpcHQtXG4gICAgLy8gY29tcGF0aWJsZSBlbnVtLiBUaGlzIGlzIHVzZWQgYnkgcGJ0cyB0byB3cml0ZSBhY3R1YWwgZW51bSBkZWZpbml0aW9ucyB0aGF0IHdvcmsgZm9yXG4gICAgLy8gc3RhdGljIGFuZCByZWZsZWN0aW9uIGNvZGUgYWxpa2UgaW5zdGVhZCBvZiBlbWl0dGluZyBnZW5lcmljIG9iamVjdCBkZWZpbml0aW9ucy5cblxuICAgIGlmICh2YWx1ZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlc1trZXlzW2ldXSA9PT0gXCJudW1iZXJcIikgLy8gdXNlIGZvcndhcmQgZW50cmllcyBvbmx5XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXNCeUlkWyB0aGlzLnZhbHVlc1trZXlzW2ldXSA9IHZhbHVlc1trZXlzW2ldXSBdID0ga2V5c1tpXTtcbn1cblxuLyoqXG4gKiBFbnVtIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFbnVtXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLG51bWJlcj59IHZhbHVlcyBFbnVtIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEVudW0gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtIGZyb20gYW4gZW51bSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRW51bSBuYW1lXG4gKiBAcGFyYW0ge0lFbnVtfSBqc29uIEVudW0gZGVzY3JpcHRvclxuICogQHJldHVybnMge0VudW19IENyZWF0ZWQgZW51bVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuRW51bS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgZW5tID0gbmV3IEVudW0obmFtZSwganNvbi52YWx1ZXMsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50LCBqc29uLmNvbW1lbnRzKTtcbiAgICBlbm0ucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIHJldHVybiBlbm07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgZW51bSB0byBhbiBlbnVtIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRW51bX0gRW51bSBkZXNjcmlwdG9yXG4gKi9cbkVudW0ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcInZhbHVlc1wiICAgLCB0aGlzLnZhbHVlcyxcbiAgICAgICAgXCJyZXNlcnZlZFwiICwgdGhpcy5yZXNlcnZlZCAmJiB0aGlzLnJlc2VydmVkLmxlbmd0aCA/IHRoaXMucmVzZXJ2ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50c1wiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50cyA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gdGhpcyBlbnVtLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFZhbHVlIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQsIGlmIGFueVxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgdmFsdWUgd2l0aCB0aGlzIG5hbWUgb3IgaWRcbiAqL1xuRW51bS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGlkLCBjb21tZW50KSB7XG4gICAgLy8gdXRpbGl6ZWQgYnkgdGhlIHBhcnNlciBidXQgbm90IGJ5IC5mcm9tSlNPTlxuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzW25hbWVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuaXNSZXNlcnZlZElkKGlkKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIGlkICsgXCIgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMudmFsdWVzQnlJZFtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmFsbG93X2FsaWFzKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlc1tuYW1lXSA9IGlkO1xuICAgIH0gZWxzZVxuICAgICAgICB0aGlzLnZhbHVlc0J5SWRbdGhpcy52YWx1ZXNbbmFtZV0gPSBpZF0gPSBuYW1lO1xuXG4gICAgdGhpcy5jb21tZW50c1tuYW1lXSA9IGNvbW1lbnQgfHwgbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhpcyBlbnVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXG4gKiBAcmV0dXJucyB7RW51bX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBuYW1lYCBpcyBub3QgYSBuYW1lIG9mIHRoaXMgZW51bVxuICovXG5FbnVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICB2YXIgdmFsID0gdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMudmFsdWVzQnlJZFt2YWxdO1xuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lXTtcbiAgICBkZWxldGUgdGhpcy5jb21tZW50c1tuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbkVudW0ucHJvdG90eXBlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChpZCkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBGaWVsZDtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRmllbGQpLmNsYXNzTmFtZSA9IFwiRmllbGRcIjtcblxudmFyIEVudW0gID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGU7IC8vIGN5Y2xpY1xuXG52YXIgcnVsZVJlID0gL15yZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZCQvO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBmaWVsZCBpbnN0YW5jZS4gTm90ZSB0aGF0IHtAbGluayBNYXBGaWVsZHxtYXAgZmllbGRzfSBoYXZlIHRoZWlyIG93biBjbGFzcy5cbiAqIEBuYW1lIEZpZWxkXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZmllbGQgZnJvbSBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lGaWVsZH0ganNvbiBGaWVsZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RmllbGR9IENyZWF0ZWQgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgRmllbGQobmFtZSwganNvbi5pZCwganNvbi50eXBlLCBqc29uLnJ1bGUsIGpzb24uZXh0ZW5kLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgY29uc3RydWN0b3IuIFVzZSB7QGxpbmsgRmllbGR9IGluc3RlYWQuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkcy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxuICogQGV4cG9ydHMgRmllbGRCYXNlXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gRmllbGQobmFtZSwgaWQsIHR5cGUsIHJ1bGUsIGV4dGVuZCwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocnVsZSkpIHtcbiAgICAgICAgY29tbWVudCA9IGV4dGVuZDtcbiAgICAgICAgb3B0aW9ucyA9IHJ1bGU7XG4gICAgICAgIHJ1bGUgPSBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGV4dGVuZCkpIHtcbiAgICAgICAgY29tbWVudCA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQ7XG4gICAgICAgIGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlkKSB8fCBpZCA8IDApXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlclwiKTtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyh0eXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKHJ1bGUgIT09IHVuZGVmaW5lZCAmJiAhcnVsZVJlLnRlc3QocnVsZSA9IHJ1bGUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnVsZSBtdXN0IGJlIGEgc3RyaW5nIHJ1bGVcIik7XG5cbiAgICBpZiAoZXh0ZW5kICE9PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNTdHJpbmcoZXh0ZW5kKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZXh0ZW5kIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBydWxlLCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5ydWxlID0gcnVsZSAmJiBydWxlICE9PSBcIm9wdGlvbmFsXCIgPyBydWxlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBmaWVsZCBpZC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBpZDsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5kID0gZXh0ZW5kIHx8IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1aXJlZCA9IHJ1bGUgPT09IFwicmVxdWlyZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBvcHRpb25hbC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbmFsID0gIXRoaXMucmVxdWlyZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgcmVwZWF0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBlYXRlZCA9IHJ1bGUgPT09IFwicmVwZWF0ZWRcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyBhIG1hcCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5tYXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5tZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE9uZU9mIHRoaXMgZmllbGQgYmVsb25ncyB0bywgaWYgYW55LFxuICAgICAqIEB0eXBlIHtPbmVPZnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFydE9mID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmaWVsZCdzIGRlZmF1bHQgdmFsdWUgb24gcHJvdG90eXBlcy5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIGxvbmcuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb25nID0gdXRpbC5Mb25nID8gdHlwZXMubG9uZ1t0eXBlXSAhPT0gdW5kZWZpbmVkIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQncyB2YWx1ZSBpcyBhIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJ5dGVzID0gdHlwZSA9PT0gXCJieXRlc1wiO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfEVudW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBleHRlbmRlZCB0eXBlIGlmIGEgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZC5cbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbkZpZWxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGRlY2xhcmluZyBuYW1lc3BhY2UgaWYgYW4gZXh0ZW5kZWQgZmllbGQuXG4gICAgICogQHR5cGUge0ZpZWxkfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kZWNsYXJpbmdGaWVsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbGx5IHJlbWVtYmVycyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLlxuICAgICAqIEB0eXBlIHtib29sZWFufG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBmaWVsZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCBpcyBwYWNrZWQuIE9ubHkgcmVsZXZhbnQgd2hlbiByZXBlYXRlZCBhbmQgd29ya2luZyB3aXRoIHByb3RvMi5cbiAqIEBuYW1lIEZpZWxkI3BhY2tlZFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJwYWNrZWRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIGlmIG5vdCBleHBsaWNpdHkgc2V0IHRvIGZhbHNlXG4gICAgICAgIGlmICh0aGlzLl9wYWNrZWQgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wYWNrZWQgPSB0aGlzLmdldE9wdGlvbihcInBhY2tlZFwiKSAhPT0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWNrZWQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGlmTm90U2V0KSB7XG4gICAgaWYgKG5hbWUgPT09IFwicGFja2VkXCIpIC8vIGNsZWFyIGNhY2hlZCBiZWZvcmUgc2V0dGluZ1xuICAgICAgICB0aGlzLl9wYWNrZWQgPSBudWxsO1xuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb24uY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpO1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIEZpZWxkIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBGaWVsZCBpZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEZpZWxkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uRmllbGRcbiAqIEBleHRlbmRzIElGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4dGVuZCBFeHRlbmRlZCB0eXBlXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGZpZWxkIHRvIGEgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lGaWVsZH0gRmllbGQgZGVzY3JpcHRvclxuICovXG5GaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcInJ1bGVcIiAgICAsIHRoaXMucnVsZSAhPT0gXCJvcHRpb25hbFwiICYmIHRoaXMucnVsZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXG4gICAgICAgIFwiZXh0ZW5kXCIgICwgdGhpcy5leHRlbmQsXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIGZpZWxkJ3MgdHlwZSByZWZlcmVuY2VzLlxuICogQHJldHVybnMge0ZpZWxkfSBgdGhpc2BcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgcmVmZXJlbmNlIGNhbm5vdCBiZSByZXNvbHZlZFxuICovXG5GaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG5cbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoKHRoaXMudHlwZURlZmF1bHQgPSB0eXBlcy5kZWZhdWx0c1t0aGlzLnR5cGVdKSA9PT0gdW5kZWZpbmVkKSB7IC8vIGlmIG5vdCBhIGJhc2ljIHR5cGUsIHJlc29sdmUgaXRcbiAgICAgICAgdGhpcy5yZXNvbHZlZFR5cGUgPSAodGhpcy5kZWNsYXJpbmdGaWVsZCA/IHRoaXMuZGVjbGFyaW5nRmllbGQucGFyZW50IDogdGhpcy5wYXJlbnQpLmxvb2t1cFR5cGVPckVudW0odGhpcy50eXBlKTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuICAgICAgICBlbHNlIC8vIGluc3RhbmNlb2YgRW51bVxuICAgICAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMucmVzb2x2ZWRUeXBlLnZhbHVlc1tPYmplY3Qua2V5cyh0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXMpWzBdXTsgLy8gZmlyc3QgZGVmaW5lZFxuICAgIH1cblxuICAgIC8vIHVzZSBleHBsaWNpdGx5IHNldCBkZWZhdWx0IHZhbHVlIGlmIHByZXNlbnRcbiAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5vcHRpb25zW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbdGhpcy50eXBlRGVmYXVsdF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IG9wdGlvbnNcbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2VkID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5wYWNrZWQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlc29sdmVkVHlwZSAmJiAhKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zLnBhY2tlZDtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGludGVybmFsIGRhdGEgdHlwZSBpZiBuZWNlc3NzYXJ5XG4gICAgaWYgKHRoaXMubG9uZykge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdXRpbC5Mb25nLmZyb21OdW1iZXIodGhpcy50eXBlRGVmYXVsdCwgdGhpcy50eXBlLmNoYXJBdCgwKSA9PT0gXCJ1XCIpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChPYmplY3QuZnJlZXplKVxuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzLnR5cGVEZWZhdWx0KTsgLy8gbG9uZyBpbnN0YW5jZXMgYXJlIG1lYW50IHRvIGJlIGltbXV0YWJsZSBhbnl3YXkgKGkuZS4gdXNlIHNtYWxsIGludCBjYWNoZSB0aGF0IGV2ZW4gcmVxdWlyZXMgaXQpXG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXMgJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIGJ1ZjtcbiAgICAgICAgaWYgKHV0aWwuYmFzZTY0LnRlc3QodGhpcy50eXBlRGVmYXVsdCkpXG4gICAgICAgICAgICB1dGlsLmJhc2U2NC5kZWNvZGUodGhpcy50eXBlRGVmYXVsdCwgYnVmID0gdXRpbC5uZXdCdWZmZXIodXRpbC5iYXNlNjQubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHV0aWwudXRmOC53cml0ZSh0aGlzLnR5cGVEZWZhdWx0LCBidWYgPSB1dGlsLm5ld0J1ZmZlcih1dGlsLnV0ZjgubGVuZ3RoKHRoaXMudHlwZURlZmF1bHQpKSwgMCk7XG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBidWY7XG4gICAgfVxuXG4gICAgLy8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgbWFwcyBhbmQgcmVwZWF0ZWQgZmllbGRzXG4gICAgaWYgKHRoaXMubWFwKVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgZWxzZSBpZiAodGhpcy5yZXBlYXRlZClcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB1dGlsLmVtcHR5QXJyYXk7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IHRoaXMudHlwZURlZmF1bHQ7XG5cbiAgICAvLyBlbnN1cmUgcHJvcGVyIHZhbHVlIG9uIHByb3RvdHlwZVxuICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgIHRoaXMucGFyZW50LmN0b3IucHJvdG90eXBlW3RoaXMubmFtZV0gPSB0aGlzLmRlZmF1bHRWYWx1ZTtcblxuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBmdW5jdGlvbiBhcyByZXR1cm5lZCBieSB7QGxpbmsgRmllbGQuZH0gYW5kIHtAbGluayBNYXBGaWVsZC5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBGaWVsZERlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGROYW1lIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBGaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcInN0cmluZ1wifFwiYm9vbFwifFwiYnl0ZXNcInxPYmplY3R9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXG4gKiBAcGFyYW0ge1wib3B0aW9uYWxcInxcInJlcXVpcmVkXCJ8XCJyZXBlYXRlZFwifSBbZmllbGRSdWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtUfSBbZGVmYXVsdFZhbHVlXSBEZWZhdWx0IHZhbHVlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBudW1iZXIgfCBudW1iZXJbXSB8IExvbmcgfCBMb25nW10gfCBzdHJpbmcgfCBzdHJpbmdbXSB8IGJvb2xlYW4gfCBib29sZWFuW10gfCBVaW50OEFycmF5IHwgVWludDhBcnJheVtdIHwgQnVmZmVyIHwgQnVmZmVyW11cbiAqL1xuRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlRmllbGQoZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIGRlZmF1bHRWYWx1ZSkge1xuXG4gICAgLy8gc3VibWVzc2FnZTogZGVjb3JhdGUgdGhlIHN1Ym1lc3NhZ2UgYW5kIHVzZSBpdHMgbmFtZSBhcyB0aGUgdHlwZVxuICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZpZWxkVHlwZSA9IHV0aWwuZGVjb3JhdGVUeXBlKGZpZWxkVHlwZSkubmFtZTtcblxuICAgIC8vIGVudW0gcmVmZXJlbmNlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxuICAgIGVsc2UgaWYgKGZpZWxkVHlwZSAmJiB0eXBlb2YgZmllbGRUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBmaWVsZFR5cGUgPSB1dGlsLmRlY29yYXRlRW51bShmaWVsZFR5cGUpLm5hbWU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZmllbGREZWNvcmF0b3IocHJvdG90eXBlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZFR5cGUsIGZpZWxkUnVsZSwgeyBcImRlZmF1bHRcIjogZGVmYXVsdFZhbHVlIH0pKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPnxzdHJpbmd9IGZpZWxkVHlwZSBGaWVsZCB0eXBlXG4gKiBAcGFyYW0ge1wib3B0aW9uYWxcInxcInJlcXVpcmVkXCJ8XCJyZXBlYXRlZFwifSBbZmllbGRSdWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxpa2UgRmllbGQuZCBidXQgd2l0aG91dCBhIGRlZmF1bHQgdmFsdWVcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5GaWVsZC5fY29uZmlndXJlID0gZnVuY3Rpb24gY29uZmlndXJlKFR5cGVfKSB7XG4gICAgVHlwZSA9IFR5cGVfO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pbmRleC1taW5pbWFsXCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwibGlnaHRcIjtcblxuLyoqXG4gKiBBIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgbG9hZH0gYW5kIHtAbGluayBSb290I2xvYWR9LlxuICogQHR5cGVkZWYgTG9hZENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QsIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgcm9vdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHJvb3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIH0gZWxzZSBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIHJldHVybiByb290LmxvYWQoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAbmFtZSBsb2FkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSb290Pn0gUHJvbWlzZVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICogQHZhcmlhdGlvbiAzXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbcm9vdDpSb290XSk6UHJvbWlzZTxSb290PlxuXG5wcm90b2J1Zi5sb2FkID0gbG9hZDtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkU3luY31cbiAqL1xuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIHJldHVybiByb290LmxvYWRTeW5jKGZpbGVuYW1lKTtcbn1cblxucHJvdG9idWYubG9hZFN5bmMgPSBsb2FkU3luYztcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuZW5jb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIik7XG5wcm90b2J1Zi5kZWNvZGVyICAgICAgICAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKTtcbnByb3RvYnVmLnZlcmlmaWVyICAgICAgICAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKTtcbnByb3RvYnVmLmNvbnZlcnRlciAgICAgICAgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIik7XG5cbi8vIFJlZmxlY3Rpb25cbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG5wcm90b2J1Zi5OYW1lc3BhY2UgICAgICAgID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xucHJvdG9idWYuUm9vdCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIik7XG5wcm90b2J1Zi5FbnVtICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbnByb3RvYnVmLlR5cGUgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xucHJvdG9idWYuRmllbGQgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpO1xucHJvdG9idWYuT25lT2YgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xucHJvdG9idWYuTWFwRmllbGQgICAgICAgICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpO1xucHJvdG9idWYuU2VydmljZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5wcm90b2J1Zi5NZXRob2QgICAgICAgICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpO1xuXG4vLyBSdW50aW1lXG5wcm90b2J1Zi5NZXNzYWdlICAgICAgICAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcbnByb3RvYnVmLndyYXBwZXJzICAgICAgICAgPSByZXF1aXJlKFwiLi93cmFwcGVyc1wiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudHlwZXMgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xucHJvdG9idWYudXRpbCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8vIFNldCB1cCBwb3NzaWJseSBjeWNsaWMgcmVmbGVjdGlvbiBkZXBlbmRlbmNpZXNcbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5Sb290KTtcbnByb3RvYnVmLk5hbWVzcGFjZS5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLlNlcnZpY2UsIHByb3RvYnVmLkVudW0pO1xucHJvdG9idWYuUm9vdC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUpO1xucHJvdG9idWYuRmllbGQuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbGlnaHRcIik7XG5cbnByb3RvYnVmLmJ1aWxkID0gXCJmdWxsXCI7XG5cbi8vIFBhcnNlclxucHJvdG9idWYudG9rZW5pemUgICAgICAgICA9IHJlcXVpcmUoXCIuL3Rva2VuaXplXCIpO1xucHJvdG9idWYucGFyc2UgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpO1xucHJvdG9idWYuY29tbW9uICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcblxuLy8gQ29uZmlndXJlIHBhcnNlclxucHJvdG9idWYuUm9vdC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLnBhcnNlLCBwcm90b2J1Zi5jb21tb24pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1hcEZpZWxkO1xuXG4vLyBleHRlbmRzIEZpZWxkXG52YXIgRmllbGQgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbigoTWFwRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGaWVsZC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE1hcEZpZWxkKS5jbGFzc05hbWUgPSBcIk1hcEZpZWxkXCI7XG5cbnZhciB0eXBlcyAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBtYXAgZmllbGQgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtYXAgZmllbGQuXG4gKiBAZXh0ZW5kcyBGaWVsZEJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIE1hcEZpZWxkKG5hbWUsIGlkLCBrZXlUeXBlLCB0eXBlLCBvcHRpb25zLCBjb21tZW50KSB7XG4gICAgRmllbGQuY2FsbCh0aGlzLCBuYW1lLCBpZCwgdHlwZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMsIGNvbW1lbnQpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKGtleVR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJrZXlUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKipcbiAgICAgKiBLZXkgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMua2V5VHlwZSA9IGtleVR5cGU7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBrZXkgdHlwZSBpZiBub3QgYSBiYXNpYyB0eXBlLlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZEtleVR5cGUgPSBudWxsO1xuXG4gICAgLy8gT3ZlcnJpZGVzIEZpZWxkI21hcFxuICAgIHRoaXMubWFwID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU1hcEZpZWxkXG4gKiBAZXh0ZW5kcyB7SUZpZWxkfVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleVR5cGUgS2V5IHR5cGVcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUV4dGVuc2lvbk1hcEZpZWxkXG4gKiBAZXh0ZW5kcyBJTWFwRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG1hcCBmaWVsZCBmcm9tIGEgbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lNYXBGaWVsZH0ganNvbiBNYXAgZmllbGQgZGVzY3JpcHRvclxuICogQHJldHVybnMge01hcEZpZWxkfSBDcmVhdGVkIG1hcCBmaWVsZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTWFwRmllbGQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBNYXBGaWVsZChuYW1lLCBqc29uLmlkLCBqc29uLmtleVR5cGUsIGpzb24udHlwZSwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1hcCBmaWVsZCB0byBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1hcEZpZWxkfSBNYXAgZmllbGQgZGVzY3JpcHRvclxuICovXG5NYXBGaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcImtleVR5cGVcIiAsIHRoaXMua2V5VHlwZSxcbiAgICAgICAgXCJ0eXBlXCIgICAgLCB0aGlzLnR5cGUsXG4gICAgICAgIFwiaWRcIiAgICAgICwgdGhpcy5pZCxcbiAgICAgICAgXCJleHRlbmRcIiAgLCB0aGlzLmV4dGVuZCxcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5NYXBGaWVsZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgLy8gQmVzaWRlcyBhIHZhbHVlIHR5cGUsIG1hcCBmaWVsZHMgaGF2ZSBhIGtleSB0eXBlIHRoYXQgbWF5IGJlIFwiYW55IHNjYWxhciB0eXBlIGV4Y2VwdCBmb3IgZmxvYXRpbmcgcG9pbnQgdHlwZXMgYW5kIGJ5dGVzXCJcbiAgICBpZiAodHlwZXMubWFwS2V5W3RoaXMua2V5VHlwZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGtleSB0eXBlOiBcIiArIHRoaXMua2V5VHlwZSk7XG5cbiAgICByZXR1cm4gRmllbGQucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogTWFwIGZpZWxkIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSBNYXBGaWVsZC5kXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZElkIEZpZWxkIGlkXG4gKiBAcGFyYW0ge1wiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwiYm9vbFwifFwic3RyaW5nXCJ9IGZpZWxkS2V5VHlwZSBGaWVsZCBrZXkgdHlwZVxuICogQHBhcmFtIHtcImRvdWJsZVwifFwiZmxvYXRcInxcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifFwiYnl0ZXNcInxPYmplY3R8Q29uc3RydWN0b3I8e30+fSBmaWVsZFZhbHVlVHlwZSBGaWVsZCB2YWx1ZSB0eXBlXG4gKiBAcmV0dXJucyB7RmllbGREZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IG51bWJlciB8IExvbmcgfCBzdHJpbmcgfCBib29sZWFuIHwgVWludDhBcnJheSB8IEJ1ZmZlciB8IG51bWJlcltdIHwgTWVzc2FnZTx7fT4gfVxuICovXG5NYXBGaWVsZC5kID0gZnVuY3Rpb24gZGVjb3JhdGVNYXBGaWVsZChmaWVsZElkLCBmaWVsZEtleVR5cGUsIGZpZWxkVmFsdWVUeXBlKSB7XG5cbiAgICAvLyBzdWJtZXNzYWdlIHZhbHVlOiBkZWNvcmF0ZSB0aGUgc3VibWVzc2FnZSBhbmQgdXNlIGl0cyBuYW1lIGFzIHRoZSB0eXBlXG4gICAgaWYgKHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVUeXBlKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xuXG4gICAgLy8gZW51bSByZWZlcmVuY2UgdmFsdWU6IGNyZWF0ZSBhIHJlZmxlY3RlZCBjb3B5IG9mIHRoZSBlbnVtIGFuZCBrZWVwIHJldXNlaW5nIGl0XG4gICAgZWxzZSBpZiAoZmllbGRWYWx1ZVR5cGUgJiYgdHlwZW9mIGZpZWxkVmFsdWVUeXBlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBmaWVsZFZhbHVlVHlwZSA9IHV0aWwuZGVjb3JhdGVFbnVtKGZpZWxkVmFsdWVUeXBlKS5uYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hcEZpZWxkRGVjb3JhdG9yKHByb3RvdHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IE1hcEZpZWxkKGZpZWxkTmFtZSwgZmllbGRJZCwgZmllbGRLZXlUeXBlLCBmaWVsZFZhbHVlVHlwZSkpO1xuICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQWJzdHJhY3QgcnVudGltZSBtZXNzYWdlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb3BlcnRpZXM8VD59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBvYmplY3QgPSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZShwcm9wZXJ0aWVzKSB7XG4gICAgLy8gbm90IHVzZWQgaW50ZXJuYWxseVxuICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLiR0eXBlXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEByZWFkb25seVxuICovXG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSByZWZsZWN0ZWQgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UjJHR5cGVcbiAqIEB0eXBlIHtUeXBlfVxuICogQHJlYWRvbmx5XG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPFQ+fSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5jcmVhdGUocHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7VHxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIHRvIGVuY29kZVxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtUfE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIHVzZVxuICogQHJldHVybnMge1dyaXRlcn0gV3JpdGVyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlKHJlYWRlcik7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIE1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZVxuICogQHJldHVybnMge1R9IERlY29kZWQgbWVzc2FnZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5kZWNvZGVEZWxpbWl0ZWQocmVhZGVyKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UudmVyaWZ5XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuTWVzc2FnZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnZlcmlmeShtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtZXNzYWdlIG9mIHRoaXMgdHlwZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICogQHJldHVybnMge1R9IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5mcm9tT2JqZWN0KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge1R9IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtJQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0byBKU09OLlxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICovXG5NZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudG9PYmplY3QodGhpcywgdXRpbC50b0pTT05PcHRpb25zKTtcbn07XG5cbi8qZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyovIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoTWV0aG9kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE1ldGhvZCkuY2xhc3NOYW1lID0gXCJNZXRob2RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgc2VydmljZSBtZXRob2QgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBzZXJ2aWNlIG1ldGhvZC5cbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdHlwZSBNZXRob2QgdHlwZSwgdXN1YWxseSBgXCJycGNcImBcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0VHlwZSBSZXF1ZXN0IG1lc3NhZ2UgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlVHlwZSBSZXNwb25zZSBtZXNzYWdlIHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3QuPHN0cmluZywqPn0gW3JlcXVlc3RTdHJlYW1dIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgc3RyZWFtZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3QuPHN0cmluZywqPn0gW3Jlc3BvbnNlU3RyZWFtXSBXaGV0aGVyIHRoZSByZXNwb25zZSBpcyBzdHJlYW1lZFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gVGhlIGNvbW1lbnQgZm9yIHRoaXMgbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIE1ldGhvZChuYW1lLCB0eXBlLCByZXF1ZXN0VHlwZSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0U3RyZWFtLCByZXNwb25zZVN0cmVhbSwgb3B0aW9ucywgY29tbWVudCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodXRpbC5pc09iamVjdChyZXF1ZXN0U3RyZWFtKSkge1xuICAgICAgICBvcHRpb25zID0gcmVxdWVzdFN0cmVhbTtcbiAgICAgICAgcmVxdWVzdFN0cmVhbSA9IHJlc3BvbnNlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChyZXNwb25zZVN0cmVhbSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlc3BvbnNlU3RyZWFtO1xuICAgICAgICByZXNwb25zZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoISh0eXBlID09PSB1bmRlZmluZWQgfHwgdXRpbC5pc1N0cmluZyh0eXBlKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhyZXF1ZXN0VHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3RUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcocmVzcG9uc2VUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVzcG9uc2VUeXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgXCJycGNcIjsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3RUeXBlID0gcmVxdWVzdFR5cGU7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBzdHJlYW1lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdFN0cmVhbSA9IHJlcXVlc3RTdHJlYW0gPyB0cnVlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNlIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlU3RyZWFtID0gcmVzcG9uc2VTdHJlYW0gPyB0cnVlIDogdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHJlcXVlc3QgdHlwZS5cbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCByZXNwb25zZSB0eXBlLlxuICAgICAqIEB0eXBlIHtUeXBlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIG1ldGhvZFxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG4vKipcbiAqIE1ldGhvZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJTWV0aG9kXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGU9XCJycGNcIl0gTWV0aG9kIHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXF1ZXN0VHlwZSBSZXF1ZXN0IHR5cGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXNwb25zZVR5cGUgUmVzcG9uc2UgdHlwZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWVzdFN0cmVhbT1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Jlc3BvbnNlU3RyZWFtPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBNZXRob2Qgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG1ldGhvZCBmcm9tIGEgbWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxuICogQHBhcmFtIHtJTWV0aG9kfSBqc29uIE1ldGhvZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7TWV0aG9kfSBDcmVhdGVkIG1ldGhvZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTWV0aG9kLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTWV0aG9kKG5hbWUsIGpzb24udHlwZSwganNvbi5yZXF1ZXN0VHlwZSwganNvbi5yZXNwb25zZVR5cGUsIGpzb24ucmVxdWVzdFN0cmVhbSwganNvbi5yZXNwb25zZVN0cmVhbSwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1ldGhvZCB0byBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU1ldGhvZH0gTWV0aG9kIGRlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwidHlwZVwiICAgICAgICAgICAsIHRoaXMudHlwZSAhPT0gXCJycGNcIiAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB0aGlzLnR5cGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInJlcXVlc3RUeXBlXCIgICAgLCB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBcInJlcXVlc3RTdHJlYW1cIiAgLCB0aGlzLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIFwicmVzcG9uc2VUeXBlXCIgICAsIHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBcInJlc3BvbnNlU3RyZWFtXCIgLCB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBcIm9wdGlvbnNcIiAgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwiY29tbWVudFwiICAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIHRoaXMucmVzb2x2ZWRSZXF1ZXN0VHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXF1ZXN0VHlwZSk7XG4gICAgdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZSA9IHRoaXMucGFyZW50Lmxvb2t1cFR5cGUodGhpcy5yZXNwb25zZVR5cGUpO1xuXG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTmFtZXNwYWNlO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChOYW1lc3BhY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTmFtZXNwYWNlKS5jbGFzc05hbWUgPSBcIk5hbWVzcGFjZVwiO1xuXG52YXIgRmllbGQgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICB1dGlsICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBUeXBlLCAgICAvLyBjeWNsaWNcbiAgICBTZXJ2aWNlLFxuICAgIEVudW07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBuYW1lc3BhY2UgaW5zdGFuY2UuXG4gKiBAbmFtZSBOYW1lc3BhY2VcbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG5hbWVzcGFjZS5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmFtZXNwYWNlIGZyb20gSlNPTi5cbiAqIEBtZW1iZXJvZiBOYW1lc3BhY2VcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGpzb24gSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IENyZWF0ZWQgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5OYW1lc3BhY2UuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lc3BhY2UobmFtZSwganNvbi5vcHRpb25zKS5hZGRKU09OKGpzb24ubmVzdGVkKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2YgcmVmbGVjdGlvbiBvYmplY3RzIHRvIEpTT04uXG4gKiBAbWVtYmVyb2YgTmFtZXNwYWNlXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3RbXX0gYXJyYXkgT2JqZWN0IGFycmF5XG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPnx1bmRlZmluZWR9IEpTT04gb2JqZWN0IG9yIGB1bmRlZmluZWRgIHdoZW4gYXJyYXkgaXMgZW1wdHlcbiAqL1xuZnVuY3Rpb24gYXJyYXlUb0pTT04oYXJyYXksIHRvSlNPTk9wdGlvbnMpIHtcbiAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBvYmpbYXJyYXlbaV0ubmFtZV0gPSBhcnJheVtpXS50b0pTT04odG9KU09OT3B0aW9ucyk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuTmFtZXNwYWNlLmFycmF5VG9KU09OID0gYXJyYXlUb0pTT047XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBpZCBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz58dW5kZWZpbmVkfSByZXNlcnZlZCBBcnJheSBvZiByZXNlcnZlZCByYW5nZXMgYW5kIG5hbWVzXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChyZXNlcnZlZCwgaWQpIHtcbiAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc2VydmVkW2ldICE9PSBcInN0cmluZ1wiICYmIHJlc2VydmVkW2ldWzBdIDw9IGlkICYmIHJlc2VydmVkW2ldWzFdID4gaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5OYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShyZXNlcnZlZCwgbmFtZSkge1xuICAgIGlmIChyZXNlcnZlZClcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNlcnZlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChyZXNlcnZlZFtpXSA9PT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIE5vdCBhbiBhY3R1YWwgY29uc3RydWN0b3IuIFVzZSB7QGxpbmsgTmFtZXNwYWNlfSBpbnN0ZWFkLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0aW9uIG9iamVjdHMgY29udGFpbmluZyBuZXN0ZWQgb2JqZWN0cy4gVGhpcyBpcyBub3QgYW4gYWN0dWFsIGNsYXNzIGJ1dCBoZXJlIGZvciB0aGUgc2FrZSBvZiBoYXZpbmcgY29uc2lzdGVudCB0eXBlIGRlZmluaXRpb25zLlxuICogQGV4cG9ydHMgTmFtZXNwYWNlQmFzZVxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGFic3RyYWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgTmFtZXNwYWNlfVxuICovXG5mdW5jdGlvbiBOYW1lc3BhY2UobmFtZSwgb3B0aW9ucykge1xuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE5lc3RlZCBvYmplY3RzIGJ5IG5hbWUuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLFJlZmxlY3Rpb25PYmplY3Q+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5lc3RlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgbmVzdGVkIG9iamVjdHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3RbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbmVzdGVkQXJyYXkgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjbGVhckNhY2hlKG5hbWVzcGFjZSkge1xuICAgIG5hbWVzcGFjZS5fbmVzdGVkQXJyYXkgPSBudWxsO1xuICAgIHJldHVybiBuYW1lc3BhY2U7XG59XG5cbi8qKlxuICogTmVzdGVkIG9iamVjdHMgb2YgdGhpcyBuYW1lc3BhY2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAqIEBuYW1lIE5hbWVzcGFjZUJhc2UjbmVzdGVkQXJyYXlcbiAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W119XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hbWVzcGFjZS5wcm90b3R5cGUsIFwibmVzdGVkQXJyYXlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXN0ZWRBcnJheSB8fCAodGhpcy5fbmVzdGVkQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5uZXN0ZWQpKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE5hbWVzcGFjZSBvcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLEFueU5lc3RlZE9iamVjdD59IFtuZXN0ZWRdIE5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnNcbiAqL1xuXG4vKipcbiAqIEFueSBleHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cbiAqIEB0eXBlZGVmIEFueUV4dGVuc2lvbkZpZWxkXG4gKiBAdHlwZSB7SUV4dGVuc2lvbkZpZWxkfElFeHRlbnNpb25NYXBGaWVsZH1cbiAqL1xuXG4vKipcbiAqIEFueSBuZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3IuXG4gKiBAdHlwZWRlZiBBbnlOZXN0ZWRPYmplY3RcbiAqIEB0eXBlIHtJRW51bXxJVHlwZXxJU2VydmljZXxBbnlFeHRlbnNpb25GaWVsZHxJTmFtZXNwYWNlfVxuICovXG4vLyBeIEJFV0FSRTogVlNDb2RlIGhhbmdzIGZvcmV2ZXIgd2hlbiB1c2luZyBtb3JlIHRoYW4gNSB0eXBlcyAodGhhdCdzIHdoeSBBbnlFeHRlbnNpb25GaWVsZCBleGlzdHMgaW4gdGhlIGZpcnN0IHBsYWNlKVxuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbmFtZXNwYWNlIHRvIGEgbmFtZXNwYWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJTmFtZXNwYWNlfSBOYW1lc3BhY2UgZGVzY3JpcHRvclxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBhcnJheVRvSlNPTih0aGlzLm5lc3RlZEFycmF5LCB0b0pTT05PcHRpb25zKVxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIG5lc3RlZCBvYmplY3RzIHRvIHRoaXMgbmFtZXNwYWNlIGZyb20gbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsQW55TmVzdGVkT2JqZWN0Pn0gbmVzdGVkSnNvbiBBbnkgbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yc1xuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuYWRkSlNPTiA9IGZ1bmN0aW9uIGFkZEpTT04obmVzdGVkSnNvbikge1xuICAgIHZhciBucyA9IHRoaXM7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobmVzdGVkSnNvbikge1xuICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKG5lc3RlZEpzb24pLCBpID0gMCwgbmVzdGVkOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5lc3RlZCA9IG5lc3RlZEpzb25bbmFtZXNbaV1dO1xuICAgICAgICAgICAgbnMuYWRkKCAvLyBtb3N0IHRvIGxlYXN0IGxpa2VseVxuICAgICAgICAgICAgICAgICggbmVzdGVkLmZpZWxkcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEVudW0uZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogTmFtZXNwYWNlLmZyb21KU09OICkobmFtZXNbaV0sIG5lc3RlZClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG5lc3RlZCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmVzdGVkIG9iamVjdCBuYW1lXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBUaGUgcmVmbGVjdGlvbiBvYmplY3Qgb3IgYG51bGxgIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXVxuICAgICAgICB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIG5lc3RlZCB7QGxpbmsgRW51bXxlbnVtfSBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gKiBUaGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjZ2V0fGdldH0gaW4gdGhhdCBpdCByZXR1cm5zIGFuIGVudW0ncyB2YWx1ZXMgZGlyZWN0bHkgYW5kIHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOZXN0ZWQgZW51bSBuYW1lXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn0gRW51bSB2YWx1ZXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBubyBzdWNoIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5nZXRFbnVtID0gZnVuY3Rpb24gZ2V0RW51bShuYW1lKSB7XG4gICAgaWYgKHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdIGluc3RhbmNlb2YgRW51bSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmVzdGVkW25hbWVdLnZhbHVlcztcbiAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggZW51bTogXCIgKyBuYW1lKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIG5lc3RlZCBvYmplY3QgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIGFkZFxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkIHx8IG9iamVjdCBpbnN0YW5jZW9mIFR5cGUgfHwgb2JqZWN0IGluc3RhbmNlb2YgRW51bSB8fCBvYmplY3QgaW5zdGFuY2VvZiBTZXJ2aWNlIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9iamVjdCBtdXN0IGJlIGEgdmFsaWQgbmVzdGVkIG9iamVjdFwiKTtcblxuICAgIGlmICghdGhpcy5uZXN0ZWQpXG4gICAgICAgIHRoaXMubmVzdGVkID0ge307XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXQob2JqZWN0Lm5hbWUpO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKHByZXYgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgb2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlICYmICEocHJldiBpbnN0YW5jZW9mIFR5cGUgfHwgcHJldiBpbnN0YW5jZW9mIFNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBwbGFpbiBuYW1lc3BhY2UgYnV0IGtlZXAgZXhpc3RpbmcgbmVzdGVkIGVsZW1lbnRzIGFuZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgdmFyIG5lc3RlZCA9IHByZXYubmVzdGVkQXJyYXk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXN0ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5hZGQobmVzdGVkW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZShwcmV2KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubmVzdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lc3RlZCA9IHt9O1xuICAgICAgICAgICAgICAgIG9iamVjdC5zZXRPcHRpb25zKHByZXYub3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5lc3RlZFtvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgb2JqZWN0Lm9uQWRkKHRoaXMpO1xuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgb2JqZWN0YCBpcyBub3QgYSBtZW1iZXIgb2YgdGhpcyBuYW1lc3BhY2VcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG5cbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBSZWZsZWN0aW9uT2JqZWN0KSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSBSZWZsZWN0aW9uT2JqZWN0XCIpO1xuICAgIGlmIChvYmplY3QucGFyZW50ICE9PSB0aGlzKVxuICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgIGRlbGV0ZSB0aGlzLm5lc3RlZFtvYmplY3QubmFtZV07XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLm5lc3RlZCkubGVuZ3RoKVxuICAgICAgICB0aGlzLm5lc3RlZCA9IHVuZGVmaW5lZDtcblxuICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhZGRpdGlhbCBuYW1lc3BhY2VzIHdpdGhpbiB0aGlzIG9uZSBpZiBub3QgeWV0IGV4aXN0aW5nLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBjcmVhdGVcbiAqIEBwYXJhbSB7Kn0gW2pzb25dIE5lc3RlZCB0eXBlcyB0byBjcmVhdGUgZnJvbSBKU09OXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBQb2ludGVyIHRvIHRoZSBsYXN0IG5hbWVzcGFjZSBjcmVhdGVkIG9yIGB0aGlzYCBpZiBwYXRoIGlzIGVtcHR5XG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKHBhdGgsIGpzb24pIHtcblxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHBhdGgpKVxuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocGF0aCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlsbGVnYWwgcGF0aFwiKTtcbiAgICBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCAmJiBwYXRoWzBdID09PSBcIlwiKVxuICAgICAgICB0aHJvdyBFcnJvcihcInBhdGggbXVzdCBiZSByZWxhdGl2ZVwiKTtcblxuICAgIHZhciBwdHIgPSB0aGlzO1xuICAgIHdoaWxlIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwdHIubmVzdGVkICYmIHB0ci5uZXN0ZWRbcGFydF0pIHtcbiAgICAgICAgICAgIHB0ciA9IHB0ci5uZXN0ZWRbcGFydF07XG4gICAgICAgICAgICBpZiAoIShwdHIgaW5zdGFuY2VvZiBOYW1lc3BhY2UpKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwicGF0aCBjb25mbGljdHMgd2l0aCBub24tbmFtZXNwYWNlIG9iamVjdHNcIik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcHRyLmFkZChwdHIgPSBuZXcgTmFtZXNwYWNlKHBhcnQpKTtcbiAgICB9XG4gICAgaWYgKGpzb24pXG4gICAgICAgIHB0ci5hZGRKU09OKGpzb24pO1xuICAgIHJldHVybiBwdHI7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgbmFtZXNwYWNlJ3MgYW5kIGFsbCBpdHMgbmVzdGVkIG9iamVjdHMnIHR5cGUgcmVmZXJlbmNlcy4gVXNlZnVsIHRvIHZhbGlkYXRlIGEgcmVmbGVjdGlvbiB0cmVlLCBidXQgY29tZXMgYXQgYSBjb3N0LlxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgdmFyIG5lc3RlZCA9IHRoaXMubmVzdGVkQXJyYXksIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbmVzdGVkLmxlbmd0aClcbiAgICAgICAgaWYgKG5lc3RlZFtpXSBpbnN0YW5jZW9mIE5hbWVzcGFjZSlcbiAgICAgICAgICAgIG5lc3RlZFtpKytdLnJlc29sdmVBbGwoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbmVzdGVkW2krK10ucmVzb2x2ZSgpO1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoKTtcbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbG9va3MgdXAgdGhlIHJlZmxlY3Rpb24gb2JqZWN0IG1hdGNoaW5nIHRoZSBzcGVjaWZpZWQgcGF0aCBpbiB0aGUgc2NvcGUgb2YgdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEBwYXJhbSB7KnxBcnJheS48Kj59IGZpbHRlclR5cGVzIEZpbHRlciB0eXBlcywgYW55IGNvbWJpbmF0aW9uIG9mIHRoZSBjb25zdHJ1Y3RvcnMgb2YgYHByb3RvYnVmLlR5cGVgLCBgcHJvdG9idWYuRW51bWAsIGBwcm90b2J1Zi5TZXJ2aWNlYCBldGMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJlbnRBbHJlYWR5Q2hlY2tlZD1mYWxzZV0gSWYga25vd24sIHdoZXRoZXIgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IExvb2tlZCB1cCBvYmplY3Qgb3IgYG51bGxgIGlmIG5vbmUgY291bGQgYmUgZm91bmRcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiBsb29rdXAocGF0aCwgZmlsdGVyVHlwZXMsIHBhcmVudEFscmVhZHlDaGVja2VkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZmlsdGVyVHlwZXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHBhcmVudEFscmVhZHlDaGVja2VkID0gZmlsdGVyVHlwZXM7XG4gICAgICAgIGZpbHRlclR5cGVzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyVHlwZXMgJiYgIUFycmF5LmlzQXJyYXkoZmlsdGVyVHlwZXMpKVxuICAgICAgICBmaWx0ZXJUeXBlcyA9IFsgZmlsdGVyVHlwZXMgXTtcblxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHBhdGgpICYmIHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBcIi5cIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBTdGFydCBhdCByb290IGlmIHBhdGggaXMgYWJzb2x1dGVcbiAgICBpZiAocGF0aFswXSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5sb29rdXAocGF0aC5zbGljZSgxKSwgZmlsdGVyVHlwZXMpO1xuXG4gICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgcGFydCBtYXRjaGVzIGFueSBuZXN0ZWQgb2JqZWN0LCBhbmQgaWYgc28sIHRyYXZlcnNlIGlmIHBhdGggY29udGFpbnMgbW9yZVxuICAgIHZhciBmb3VuZCA9IHRoaXMuZ2V0KHBhdGhbMF0pO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghZmlsdGVyVHlwZXMgfHwgZmlsdGVyVHlwZXMuaW5kZXhPZihmb3VuZC5jb25zdHJ1Y3RvcikgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgKGZvdW5kID0gZm91bmQubG9va3VwKHBhdGguc2xpY2UoMSksIGZpbHRlclR5cGVzLCB0cnVlKSkpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG5cbiAgICAvLyBPdGhlcndpc2UgdHJ5IGVhY2ggbmVzdGVkIG5hbWVzcGFjZVxuICAgIH0gZWxzZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAodGhpcy5fbmVzdGVkQXJyYXlbaV0gaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgKGZvdW5kID0gdGhpcy5fbmVzdGVkQXJyYXlbaV0ubG9va3VwKHBhdGgsIGZpbHRlclR5cGVzLCB0cnVlKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuXG4gICAgLy8gSWYgdGhlcmUgaGFzbid0IGJlZW4gYSBtYXRjaCwgdHJ5IGFnYWluIGF0IHRoZSBwYXJlbnRcbiAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwgfHwgcGFyZW50QWxyZWFkeUNoZWNrZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5sb29rdXAocGF0aCwgZmlsdGVyVHlwZXMpO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEBuYW1lIE5hbWVzcGFjZUJhc2UjbG9va3VwXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHtib29sZWFufSBbcGFyZW50QWxyZWFkeUNoZWNrZWQ9ZmFsc2VdIFdoZXRoZXIgdGhlIHBhcmVudCBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fG51bGx9IExvb2tlZCB1cCBvYmplY3Qgb3IgYG51bGxgIGlmIG5vbmUgY291bGQgYmUgZm91bmRcbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBsb29rdXAocGF0aDogc3RyaW5nLCBbcGFyZW50QWxyZWFkeUNoZWNrZWQ6IGJvb2xlYW5dKVxuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGVcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYSB0eXBlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwVHlwZSA9IGZ1bmN0aW9uIGxvb2t1cFR5cGUocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgVHlwZSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggdHlwZTogXCIgKyBwYXRoKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB2YWx1ZXMgb2YgdGhlIHtAbGluayBFbnVtfGVudW19IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtFbnVtfSBMb29rZWQgdXAgZW51bVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhbiBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwRW51bSA9IGZ1bmN0aW9uIGxvb2t1cEVudW0ocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgRW51bSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFR5cGV8dHlwZX0gb3Ige0BsaW5rIEVudW18ZW51bX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1R5cGV9IExvb2tlZCB1cCB0eXBlIG9yIGVudW1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYSB0eXBlIG9yIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBUeXBlT3JFbnVtID0gZnVuY3Rpb24gbG9va3VwVHlwZU9yRW51bShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlLCBFbnVtIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBUeXBlIG9yIEVudW0gJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBTZXJ2aWNlfHNlcnZpY2V9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtTZXJ2aWNlfSBMb29rZWQgdXAgc2VydmljZVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHNlcnZpY2VcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBTZXJ2aWNlID0gZnVuY3Rpb24gbG9va3VwU2VydmljZShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBTZXJ2aWNlIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBTZXJ2aWNlICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcbk5hbWVzcGFjZS5fY29uZmlndXJlID0gZnVuY3Rpb24oVHlwZV8sIFNlcnZpY2VfLCBFbnVtXykge1xuICAgIFR5cGUgICAgPSBUeXBlXztcbiAgICBTZXJ2aWNlID0gU2VydmljZV87XG4gICAgRW51bSAgICA9IEVudW1fO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0aW9uT2JqZWN0O1xuXG5SZWZsZWN0aW9uT2JqZWN0LmNsYXNzTmFtZSA9IFwiUmVmbGVjdGlvbk9iamVjdFwiO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBSb290OyAvLyBjeWNsaWNcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3Rpb24gb2JqZWN0IGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0aW9uIG9iamVjdHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9iamVjdCBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQGFic3RyYWN0XG4gKi9cbmZ1bmN0aW9uIFJlZmxlY3Rpb25PYmplY3QobmFtZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAob3B0aW9ucyAmJiAhdXRpbC5pc09iamVjdChvcHRpb25zKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFBhcnNlZCBPcHRpb25zLlxuICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0LjxzdHJpbmcsKj4+fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogUGFyZW50IG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7TmFtZXNwYWNlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBhbHJlYWR5IHJlc29sdmVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IHRleHQsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIERlZmluaW5nIGZpbGUgbmFtZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5maWxlbmFtZSA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJvb3QgbmFtZXNwYWNlLlxuICAgICAqIEBuYW1lIFJlZmxlY3Rpb25PYmplY3Qjcm9vdFxuICAgICAqIEB0eXBlIHtSb290fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIHJvb3Q6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwdHIgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKHB0ci5wYXJlbnQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBwdHI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRnVsbCBuYW1lIGluY2x1ZGluZyBsZWFkaW5nIGRvdC5cbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I2Z1bGxOYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmdWxsTmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBbIHRoaXMubmFtZSBdLFxuICAgICAgICAgICAgICAgIHB0ciA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHB0cikge1xuICAgICAgICAgICAgICAgIHBhdGgudW5zaGlmdChwdHIubmFtZSk7XG4gICAgICAgICAgICAgICAgcHRyID0gcHRyLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oXCIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyByZWZsZWN0aW9uIG9iamVjdCB0byBpdHMgZGVzY3JpcHRvciByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzY3JpcHRvclxuICogQGFic3RyYWN0XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICB0aHJvdyBFcnJvcigpOyAvLyBub3QgaW1wbGVtZW50ZWQsIHNob3VsZG4ndCBoYXBwZW5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgYWRkZWQgdG8gYSBwYXJlbnQuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IHBhcmVudCBQYXJlbnQgYWRkZWQgdG9cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50ICE9PSBwYXJlbnQpXG4gICAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3QgPSBwYXJlbnQucm9vdDtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHJvb3QuX2hhbmRsZUFkZCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhpcyBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGEgcGFyZW50LlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IHJlbW92ZWQgZnJvbVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcbiAgICB2YXIgcm9vdCA9IHBhcmVudC5yb290O1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgcm9vdC5faGFuZGxlUmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoaXMgb2JqZWN0cyB0eXBlIHJlZmVyZW5jZXMuXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHRydWU7IC8vIG9ubHkgaWYgcGFydCBvZiBhIHJvb3RcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyBhbiBvcHRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPcHRpb24gbmFtZVxuICogQHJldHVybnMgeyp9IE9wdGlvbiB2YWx1ZSBvciBgdW5kZWZpbmVkYCBpZiBub3Qgc2V0XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIGdldE9wdGlvbihuYW1lKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucylcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTZXRzIGFuIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9wdGlvbiBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbiB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXRdIFNldHMgdGhlIG9wdGlvbiBvbmx5IGlmIGl0IGlzbid0IGN1cnJlbnRseSBzZXRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBpZk5vdFNldCkge1xuICAgIGlmICghaWZOb3RTZXQgfHwgIXRoaXMub3B0aW9ucyB8fCB0aGlzLm9wdGlvbnNbbmFtZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgKHRoaXMub3B0aW9ucyB8fCAodGhpcy5vcHRpb25zID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcGFyc2VkIG9wdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHBhcnNlZCBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBkb3QgJy4nIGRlbGltaXRlZCBmdWxsIHBhdGggb2YgcHJvcGVydHkgd2l0aGluIHRoZSBvcHRpb24gdG8gc2V0LiBpZiB1bmRlZmluZWRcXGVtcHR5LCB3aWxsIGFkZCBhIG5ldyBvcHRpb24gd2l0aCB0aGF0IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldFBhcnNlZE9wdGlvbiA9IGZ1bmN0aW9uIHNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICBpZiAoIXRoaXMucGFyc2VkT3B0aW9ucykge1xuICAgICAgICB0aGlzLnBhcnNlZE9wdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgdmFyIHBhcnNlZE9wdGlvbnMgPSB0aGlzLnBhcnNlZE9wdGlvbnM7XG4gICAgaWYgKHByb3BOYW1lKSB7XG4gICAgICAgIC8vIElmIHNldHRpbmcgYSBzdWIgcHJvcGVydHkgb2YgYW4gb3B0aW9uIHRoZW4gdHJ5IHRvIG1lcmdlIGl0XG4gICAgICAgIC8vIHdpdGggYW4gZXhpc3Rpbmcgb3B0aW9uXG4gICAgICAgIHZhciBvcHQgPSBwYXJzZWRPcHRpb25zLmZpbmQoZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHQsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYW4gZXhpc3Rpbmcgb3B0aW9uIC0ganVzdCBtZXJnZSB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IG9wdFtuYW1lXTtcbiAgICAgICAgICAgIHV0aWwuc2V0UHJvcGVydHkobmV3VmFsdWUsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBvcHRpb24sIHNldCBpdCdzIHByb3BlcnR5IGFuZCBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIG9wdCA9IHt9O1xuICAgICAgICAgICAgb3B0W25hbWVdID0gdXRpbC5zZXRQcm9wZXJ0eSh7fSwgcHJvcE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHBhcnNlZE9wdGlvbnMucHVzaChvcHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWx3YXlzIGNyZWF0ZSBhIG5ldyBvcHRpb24gd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGl0c2VsZlxuICAgICAgICB2YXIgbmV3T3B0ID0ge307XG4gICAgICAgIG5ld09wdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICBwYXJzZWRPcHRpb25zLnB1c2gobmV3T3B0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgbXVsdGlwbGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9wdGlvbnMgT3B0aW9ucyB0byBzZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIGFuIG9wdGlvbiBvbmx5IGlmIGl0IGlzbid0IGN1cnJlbnRseSBzZXRcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaWZOb3RTZXQpIHtcbiAgICBpZiAob3B0aW9ucylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvbihrZXlzW2ldLCBvcHRpb25zW2tleXNbaV1dLCBpZk5vdFNldCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgaW5zdGFuY2UgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IENsYXNzIG5hbWVbLCBzcGFjZSwgZnVsbCBuYW1lXVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmNsYXNzTmFtZSxcbiAgICAgICAgZnVsbE5hbWUgID0gdGhpcy5mdWxsTmFtZTtcbiAgICBpZiAoZnVsbE5hbWUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lICsgXCIgXCIgKyBmdWxsTmFtZTtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xufTtcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUgPSBmdW5jdGlvbihSb290Xykge1xuICAgIFJvb3QgPSBSb290Xztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gT25lT2Y7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE9uZU9mLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE9uZU9mKS5jbGFzc05hbWUgPSBcIk9uZU9mXCI7XG5cbnZhciBGaWVsZCA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG9uZW9mIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgb25lb2YuXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZW9mIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nW118T2JqZWN0LjxzdHJpbmcsKj59IFtmaWVsZE5hbWVzXSBGaWVsZCBuYW1lc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBPbmVPZihuYW1lLCBmaWVsZE5hbWVzLCBvcHRpb25zLCBjb21tZW50KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkTmFtZXMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBmaWVsZE5hbWVzO1xuICAgICAgICBmaWVsZE5hbWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZE5hbWVzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkTmFtZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcblxuICAgIC8qKlxuICAgICAqIEZpZWxkIG5hbWVzIHRoYXQgYmVsb25nIHRvIHRoaXMgb25lb2YuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMub25lb2YgPSBmaWVsZE5hbWVzIHx8IFtdOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRmllbGRzIHRoYXQgYmVsb25nIHRvIHRoaXMgb25lb2YgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkc0FycmF5ID0gW107IC8vIGRlY2xhcmVkIHJlYWRvbmx5IGZvciBjb25mb3JtYW5jZSwgcG9zc2libHkgbm90IHlldCBhZGRlZCB0byBwYXJlbnRcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbi8qKlxuICogT25lb2YgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU9uZU9mXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBvbmVvZiBPbmVvZiBmaWVsZCBuYW1lc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE9uZW9mIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBvbmVvZiBmcm9tIGEgb25lb2YgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZW9mIG5hbWVcbiAqIEBwYXJhbSB7SU9uZU9mfSBqc29uIE9uZW9mIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtPbmVPZn0gQ3JlYXRlZCBvbmVvZlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuT25lT2YuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBPbmVPZihuYW1lLCBqc29uLm9uZW9mLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgb25lb2YgdG8gYSBvbmVvZiBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU9uZU9mfSBPbmVvZiBkZXNjcmlwdG9yXG4gKi9cbk9uZU9mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcIm9uZW9mXCIgICAsIHRoaXMub25lb2YsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGZpZWxkcyBvZiB0aGUgc3BlY2lmaWVkIG9uZW9mIHRvIHRoZSBwYXJlbnQgaWYgbm90IGFscmVhZHkgZG9uZSBzby5cbiAqIEBwYXJhbSB7T25lT2Z9IG9uZW9mIFRoZSBvbmVvZlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBpbm5lclxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBhZGRGaWVsZHNUb1BhcmVudChvbmVvZikge1xuICAgIGlmIChvbmVvZi5wYXJlbnQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25lb2YuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoIW9uZW9mLmZpZWxkc0FycmF5W2ldLnBhcmVudClcbiAgICAgICAgICAgICAgICBvbmVvZi5wYXJlbnQuYWRkKG9uZW9mLmZpZWxkc0FycmF5W2ldKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgdG8gdGhpcyBvbmVvZiBhbmQgcmVtb3ZlcyBpdCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudCwgaWYgYW55LlxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRmllbGQgdG8gYWRkXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxuICovXG5PbmVPZi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGZpZWxkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIEZpZWxkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuXG4gICAgaWYgKGZpZWxkLnBhcmVudCAmJiBmaWVsZC5wYXJlbnQgIT09IHRoaXMucGFyZW50KVxuICAgICAgICBmaWVsZC5wYXJlbnQucmVtb3ZlKGZpZWxkKTtcbiAgICB0aGlzLm9uZW9mLnB1c2goZmllbGQubmFtZSk7XG4gICAgdGhpcy5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcbiAgICBmaWVsZC5wYXJ0T2YgPSB0aGlzOyAvLyBmaWVsZC5wYXJlbnQgcmVtYWlucyBudWxsXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBmaWVsZCBmcm9tIHRoaXMgb25lb2YgYW5kIHB1dHMgaXQgYmFjayB0byB0aGUgb25lb2YncyBwYXJlbnQuXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBGaWVsZCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtPbmVPZn0gYHRoaXNgXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoZmllbGQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgRmllbGQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZCBtdXN0IGJlIGEgRmllbGRcIik7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgdGhyb3cgRXJyb3IoZmllbGQgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgIHRoaXMuZmllbGRzQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpbmRleCA9IHRoaXMub25lb2YuaW5kZXhPZihmaWVsZC5uYW1lKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluZGV4ID4gLTEpIC8vIHRoZW9yZXRpY2FsXG4gICAgICAgIHRoaXMub25lb2Yuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGZpZWxkLnBhcnRPZiA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5PbmVPZi5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiBvbkFkZChwYXJlbnQpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIENvbGxlY3QgcHJlc2VudCBmaWVsZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub25lb2YubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gcGFyZW50LmdldCh0aGlzLm9uZW9mW2ldKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFmaWVsZC5wYXJ0T2YpIHtcbiAgICAgICAgICAgIGZpZWxkLnBhcnRPZiA9IHNlbGY7XG4gICAgICAgICAgICBzZWxmLmZpZWxkc0FycmF5LnB1c2goZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBub3QgeWV0IHByZXNlbnQgZmllbGRzXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5PbmVPZi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKGZpZWxkID0gdGhpcy5maWVsZHNBcnJheVtpXSkucGFyZW50KVxuICAgICAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBwYXJlbnQpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIE9uZU9mLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIE9uZU9mRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBwcm90b3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVvZk5hbWUgT25lT2YgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIE9uZU9mIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZEZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBzdHJpbmdcbiAqL1xuT25lT2YuZCA9IGZ1bmN0aW9uIGRlY29yYXRlT25lT2YoKSB7XG4gICAgdmFyIGZpZWxkTmFtZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICBmaWVsZE5hbWVzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25lT2ZEZWNvcmF0b3IocHJvdG90eXBlLCBvbmVvZk5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgT25lT2Yob25lb2ZOYW1lLCBmaWVsZE5hbWVzKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG9uZW9mTmFtZSwge1xuICAgICAgICAgICAgZ2V0OiB1dGlsLm9uZU9mR2V0dGVyKGZpZWxkTmFtZXMpLFxuICAgICAgICAgICAgc2V0OiB1dGlsLm9uZU9mU2V0dGVyKGZpZWxkTmFtZXMpXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG5wYXJzZS5maWxlbmFtZSA9IG51bGw7XG5wYXJzZS5kZWZhdWx0cyA9IHsga2VlcENhc2U6IGZhbHNlIH07XG5cbnZhciB0b2tlbml6ZSAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKSxcbiAgICBSb290ICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpLFxuICAgIFR5cGUgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVcIiksXG4gICAgRmllbGQgICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgTWFwRmllbGQgID0gcmVxdWlyZShcIi4vbWFwZmllbGRcIiksXG4gICAgT25lT2YgICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXG4gICAgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1ldGhvZCAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKSxcbiAgICB0eXBlcyAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgYmFzZTEwUmUgICAgPSAvXlsxLTldWzAtOV0qJC8sXG4gICAgYmFzZTEwTmVnUmUgPSAvXi0/WzEtOV1bMC05XSokLyxcbiAgICBiYXNlMTZSZSAgICA9IC9eMFt4XVswLTlhLWZBLUZdKyQvLFxuICAgIGJhc2UxNk5lZ1JlID0gL14tPzBbeF1bMC05YS1mQS1GXSskLyxcbiAgICBiYXNlOFJlICAgICA9IC9eMFswLTddKyQvLFxuICAgIGJhc2U4TmVnUmUgID0gL14tPzBbMC03XSskLyxcbiAgICBudW1iZXJSZSAgICA9IC9eKD8hW2VFXSlbMC05XSooPzpcXC5bMC05XSopPyg/OltlRV1bKy1dP1swLTldKyk/JC8sXG4gICAgbmFtZVJlICAgICAgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSokLyxcbiAgICB0eXBlUmVmUmUgICA9IC9eKD86XFwuP1thLXpBLVpfXVthLXpBLVpfMC05XSopKD86XFwuW2EtekEtWl9dW2EtekEtWl8wLTldKikqJC8sXG4gICAgZnFUeXBlUmVmUmUgPSAvXig/OlxcLlthLXpBLVpfXVthLXpBLVpfMC05XSopKyQvO1xuXG4vKipcbiAqIFJlc3VsdCBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgcGFyc2V9LlxuICogQGludGVyZmFjZSBJUGFyc2VyUmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHBhY2thZ2UgUGFja2FnZSBuYW1lLCBpZiBkZWNsYXJlZFxuICogQHByb3BlcnR5IHtzdHJpbmdbXXx1bmRlZmluZWR9IGltcG9ydHMgSW1wb3J0cywgaWYgYW55XG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfHVuZGVmaW5lZH0gd2Vha0ltcG9ydHMgV2VhayBpbXBvcnRzLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfHVuZGVmaW5lZH0gc3ludGF4IFN5bnRheCwgaWYgc3BlY2lmaWVkIChlaXRoZXIgYFwicHJvdG8yXCJgIG9yIGBcInByb3RvM1wiYClcbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBQb3B1bGF0ZWQgcm9vdCBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogT3B0aW9ucyBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9mIHtAbGluayBwYXJzZX0uXG4gKiBAaW50ZXJmYWNlIElQYXJzZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlZXBDYXNlPWZhbHNlXSBLZWVwcyBmaWVsZCBjYXNpbmcgaW5zdGVhZCBvZiBjb252ZXJ0aW5nIHRvIGNhbWVsIGNhc2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsdGVybmF0ZUNvbW1lbnRNb2RlPWZhbHNlXSBSZWNvZ25pemUgZG91YmxlLXNsYXNoIGNvbW1lbnRzIGluIGFkZGl0aW9uIHRvIGRvYy1ibG9jayBjb21tZW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ByZWZlclRyYWlsaW5nQ29tbWVudD1mYWxzZV0gVXNlIHRyYWlsaW5nIGNvbW1lbnQgd2hlbiBib3RoIGxlYWRpbmcgY29tbWVudCBhbmQgdHJhaWxpbmcgY29tbWVudCBleGlzdC5cbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiBKU09OIHNlcmlhbGl6YXRpb24uXG4gKiBAaW50ZXJmYWNlIElUb0pTT05PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwQ29tbWVudHM9ZmFsc2VdIFNlcmlhbGl6ZXMgY29tbWVudHMuXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCB0byBwb3B1bGF0ZVxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7SVBhcnNlclJlc3VsdH0gUGFyc2VyIHJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSwgcm9vdCwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbGxiYWNrLXJldHVybiAqL1xuICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBSb290KSkge1xuICAgICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlLmRlZmF1bHRzO1xuXG4gICAgdmFyIHByZWZlclRyYWlsaW5nQ29tbWVudCA9IG9wdGlvbnMucHJlZmVyVHJhaWxpbmdDb21tZW50IHx8IGZhbHNlO1xuICAgIHZhciB0biA9IHRva2VuaXplKHNvdXJjZSwgb3B0aW9ucy5hbHRlcm5hdGVDb21tZW50TW9kZSB8fCBmYWxzZSksXG4gICAgICAgIG5leHQgPSB0bi5uZXh0LFxuICAgICAgICBwdXNoID0gdG4ucHVzaCxcbiAgICAgICAgcGVlayA9IHRuLnBlZWssXG4gICAgICAgIHNraXAgPSB0bi5za2lwLFxuICAgICAgICBjbW50ID0gdG4uY21udDtcblxuICAgIHZhciBoZWFkID0gdHJ1ZSxcbiAgICAgICAgcGtnLFxuICAgICAgICBpbXBvcnRzLFxuICAgICAgICB3ZWFrSW1wb3J0cyxcbiAgICAgICAgc3ludGF4LFxuICAgICAgICBpc1Byb3RvMyA9IGZhbHNlO1xuXG4gICAgdmFyIHB0ciA9IHJvb3Q7XG5cbiAgICB2YXIgYXBwbHlDYXNlID0gb3B0aW9ucy5rZWVwQ2FzZSA/IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH0gOiB1dGlsLmNhbWVsQ2FzZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gaWxsZWdhbCh0b2tlbiwgbmFtZSwgaW5zaWRlVHJ5Q2F0Y2gpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIGlmICghaW5zaWRlVHJ5Q2F0Y2gpXG4gICAgICAgICAgICBwYXJzZS5maWxlbmFtZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBFcnJvcihcImlsbGVnYWwgXCIgKyAobmFtZSB8fCBcInRva2VuXCIpICsgXCIgJ1wiICsgdG9rZW4gKyBcIicgKFwiICsgKGZpbGVuYW1lID8gZmlsZW5hbWUgKyBcIiwgXCIgOiBcIlwiKSArIFwibGluZSBcIiArIHRuLmxpbmUgKyBcIilcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFN0cmluZygpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgICAgICAgdG9rZW47XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCh0b2tlbiA9IG5leHQoKSkgIT09IFwiXFxcIlwiICYmIHRva2VuICE9PSBcIidcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgdmFsdWVzLnB1c2gobmV4dCgpKTtcbiAgICAgICAgICAgIHNraXAodG9rZW4pO1xuICAgICAgICAgICAgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgIH0gd2hpbGUgKHRva2VuID09PSBcIlxcXCJcIiB8fCB0b2tlbiA9PT0gXCInXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmpvaW4oXCJcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFZhbHVlKGFjY2VwdFR5cGVSZWYpIHtcbiAgICAgICAgdmFyIHRva2VuID0gbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgY2FzZSBcIlxcXCJcIjpcbiAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZFN0cmluZygpO1xuICAgICAgICAgICAgY2FzZSBcInRydWVcIjogY2FzZSBcIlRSVUVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiBjYXNlIFwiRkFMU0VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlcih0b2tlbiwgLyogaW5zaWRlVHJ5Q2F0Y2ggKi8gdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChhY2NlcHRUeXBlUmVmICYmIHR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZFJhbmdlcyh0YXJnZXQsIGFjY2VwdFN0cmluZ3MpIHtcbiAgICAgICAgdmFyIHRva2VuLCBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGFjY2VwdFN0cmluZ3MgJiYgKCh0b2tlbiA9IHBlZWsoKSkgPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIikpXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gocmVhZFN0cmluZygpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChbIHN0YXJ0ID0gcGFyc2VJZChuZXh0KCkpLCBza2lwKFwidG9cIiwgdHJ1ZSkgPyBwYXJzZUlkKG5leHQoKSkgOiBzdGFydCBdKTtcbiAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU51bWJlcih0b2tlbiwgaW5zaWRlVHJ5Q2F0Y2gpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAxO1xuICAgICAgICBpZiAodG9rZW4uY2hhckF0KDApID09PSBcIi1cIikge1xuICAgICAgICAgICAgc2lnbiA9IC0xO1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcImluZlwiOiBjYXNlIFwiSU5GXCI6IGNhc2UgXCJJbmZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiAqIEluZmluaXR5O1xuICAgICAgICAgICAgY2FzZSBcIm5hblwiOiBjYXNlIFwiTkFOXCI6IGNhc2UgXCJOYW5cIjogY2FzZSBcIk5hTlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlMTBSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKGJhc2UxNlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgMTYpO1xuICAgICAgICBpZiAoYmFzZThSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChudW1iZXJSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VGbG9hdCh0b2tlbik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJudW1iZXJcIiwgaW5zaWRlVHJ5Q2F0Y2gpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSWQodG9rZW4sIGFjY2VwdE5lZ2F0aXZlKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjogY2FzZSBcIk1BWFwiOiBjYXNlIFwiTWF4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMTtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFhY2NlcHROZWdhdGl2ZSAmJiB0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJpZFwiKTtcblxuICAgICAgICBpZiAoYmFzZTEwTmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDEwKTtcbiAgICAgICAgaWYgKGJhc2UxNk5lZ1JlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCAxNik7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGJhc2U4TmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiaWRcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VQYWNrYWdlKCkge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocGtnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwicGFja2FnZVwiKTtcblxuICAgICAgICBwa2cgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QocGtnKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwocGtnLCBcIm5hbWVcIik7XG5cbiAgICAgICAgcHRyID0gcHRyLmRlZmluZShwa2cpO1xuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUltcG9ydCgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gcGVlaygpO1xuICAgICAgICB2YXIgd2hpY2hJbXBvcnRzO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwid2Vha1wiOlxuICAgICAgICAgICAgICAgIHdoaWNoSW1wb3J0cyA9IHdlYWtJbXBvcnRzIHx8ICh3ZWFrSW1wb3J0cyA9IFtdKTtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgd2hpY2hJbXBvcnRzID0gaW1wb3J0cyB8fCAoaW1wb3J0cyA9IFtdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0b2tlbiA9IHJlYWRTdHJpbmcoKTtcbiAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgIHdoaWNoSW1wb3J0cy5wdXNoKHRva2VuKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN5bnRheCgpIHtcbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHN5bnRheCA9IHJlYWRTdHJpbmcoKTtcbiAgICAgICAgaXNQcm90bzMgPSBzeW50YXggPT09IFwicHJvdG8zXCI7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghaXNQcm90bzMgJiYgc3ludGF4ICE9PSBcInByb3RvMlwiKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChzeW50YXgsIFwic3ludGF4XCIpO1xuXG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tbW9uKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VUeXBlKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlRW51bShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcInNlcnZpY2VcIjpcbiAgICAgICAgICAgICAgICBwYXJzZVNlcnZpY2UocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJleHRlbmRcIjpcbiAgICAgICAgICAgICAgICBwYXJzZUV4dGVuc2lvbihwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaWZCbG9jayhvYmosIGZuSWYsIGZuRWxzZSkge1xuICAgICAgICB2YXIgdHJhaWxpbmdMaW5lID0gdG4ubGluZTtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgaWYodHlwZW9mIG9iai5jb21tZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIG9iai5jb21tZW50ID0gY21udCgpOyAvLyB0cnkgYmxvY2stdHlwZSBjb21tZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmouZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tpcChcIntcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHdoaWxlICgodG9rZW4gPSBuZXh0KCkpICE9PSBcIn1cIilcbiAgICAgICAgICAgICAgICBmbklmKHRva2VuKTtcbiAgICAgICAgICAgIHNraXAoXCI7XCIsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZuRWxzZSlcbiAgICAgICAgICAgICAgICBmbkVsc2UoKTtcbiAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgaWYgKG9iaiAmJiAodHlwZW9mIG9iai5jb21tZW50ICE9PSBcInN0cmluZ1wiIHx8IHByZWZlclRyYWlsaW5nQ29tbWVudCkpXG4gICAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KHRyYWlsaW5nTGluZSkgfHwgb2JqLmNvbW1lbnQ7IC8vIHRyeSBsaW5lLXR5cGUgY29tbWVudFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VUeXBlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInR5cGUgbmFtZVwiKTtcblxuICAgICAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayh0eXBlLCBmdW5jdGlvbiBwYXJzZVR5cGVfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbih0eXBlLCB0b2tlbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTWFwRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VPbmVPZih0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImV4dGVuc2lvbnNcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJhbmdlcyh0eXBlLmV4dGVuc2lvbnMgfHwgKHR5cGUuZXh0ZW5zaW9ucyA9IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5yZXNlcnZlZCB8fCAodHlwZS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm90bzMgfHwgIXR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwib3B0aW9uYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZpZWxkKHBhcmVudCwgcnVsZSwgZXh0ZW5kKSB7XG4gICAgICAgIHZhciB0eXBlID0gbmV4dCgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICBwYXJzZUdyb3VwKHBhcmVudCwgcnVsZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0eXBlKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgbmFtZSA9IGFwcGx5Q2FzZShuYW1lKTtcbiAgICAgICAgc2tpcChcIj1cIik7XG5cbiAgICAgICAgdmFyIGZpZWxkID0gbmV3IEZpZWxkKG5hbWUsIHBhcnNlSWQobmV4dCgpKSwgdHlwZSwgcnVsZSwgZXh0ZW5kKTtcbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VGaWVsZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZmllbGQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRmllbGRfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhmaWVsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGZpZWxkKTtcblxuICAgICAgICAvLyBKU09OIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIGlmIG5vdCBzZXQgc28gd2UgaGF2ZSB0byBzZXQgcGFja2VkPWZhbHNlIGV4cGxpY2l0eSB3aGVuXG4gICAgICAgIC8vIHBhcnNpbmcgcHJvdG8yIGRlc2NyaXB0b3JzIHdpdGhvdXQgdGhlIG9wdGlvbiwgd2hlcmUgYXBwbGljYWJsZS4gVGhpcyBtdXN0IGJlIGRvbmUgZm9yXG4gICAgICAgIC8vIGFsbCBrbm93biBwYWNrYWJsZSB0eXBlcyBhbmQgYW55dGhpbmcgdGhhdCBjb3VsZCBiZSBhbiBlbnVtICg9IGlzIG5vdCBhIGJhc2ljIHR5cGUpLlxuICAgICAgICBpZiAoIWlzUHJvdG8zICYmIGZpZWxkLnJlcGVhdGVkICYmICh0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCB8fCB0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInBhY2tlZFwiLCBmYWxzZSwgLyogaWZOb3RTZXQgKi8gdHJ1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKG5hbWUsIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgZmllbGROYW1lID0gdXRpbC5sY0ZpcnN0KG5hbWUpO1xuICAgICAgICBpZiAobmFtZSA9PT0gZmllbGROYW1lKVxuICAgICAgICAgICAgbmFtZSA9IHV0aWwudWNGaXJzdChuYW1lKTtcbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSWQobmV4dCgpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lKTtcbiAgICAgICAgdHlwZS5ncm91cCA9IHRydWU7XG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChmaWVsZE5hbWUsIGlkLCBuYW1lLCBydWxlKTtcbiAgICAgICAgZmllbGQuZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgaWZCbG9jayh0eXBlLCBmdW5jdGlvbiBwYXJzZUdyb3VwX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7IC8vIHRoZXJlIGFyZSBubyBncm91cHMgd2l0aCBwcm90bzMgc2VtYW50aWNzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHR5cGUpXG4gICAgICAgICAgICAgIC5hZGQoZmllbGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGQocGFyZW50KSB7XG4gICAgICAgIHNraXAoXCI8XCIpO1xuICAgICAgICB2YXIga2V5VHlwZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGVzLm1hcEtleVtrZXlUeXBlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChrZXlUeXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgc2tpcChcIixcIik7XG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodmFsdWVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodmFsdWVUeXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgc2tpcChcIj5cIik7XG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBNYXBGaWVsZChhcHBseUNhc2UobmFtZSksIHBhcnNlSWQobmV4dCgpKSwga2V5VHlwZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZmllbGQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGRfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhmaWVsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGZpZWxkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9uZU9mKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG9uZW9mID0gbmV3IE9uZU9mKGFwcGx5Q2FzZSh0b2tlbikpO1xuICAgICAgICBpZkJsb2NrKG9uZW9mLCBmdW5jdGlvbiBwYXJzZU9uZU9mX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihvbmVvZiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKG9uZW9mLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChvbmVvZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIGVubSA9IG5ldyBFbnVtKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayhlbm0sIGZ1bmN0aW9uIHBhcnNlRW51bV9ibG9jayh0b2tlbikge1xuICAgICAgICAgIHN3aXRjaCh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICBwYXJzZU9wdGlvbihlbm0sIHRva2VuKTtcbiAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicmVzZXJ2ZWRcIjpcbiAgICAgICAgICAgICAgcmVhZFJhbmdlcyhlbm0ucmVzZXJ2ZWQgfHwgKGVubS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBwYXJzZUVudW1WYWx1ZShlbm0sIHRva2VuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGVubSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWUocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJZChuZXh0KCksIHRydWUpLFxuICAgICAgICAgICAgZHVtbXkgPSB7fTtcbiAgICAgICAgaWZCbG9jayhkdW1teSwgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGR1bW15LCB0b2tlbik7IC8vIHNraXBcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZHVtbXkpOyAvLyBza2lwXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHRva2VuLCB2YWx1ZSwgZHVtbXkuY29tbWVudCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb24ocGFyZW50LCB0b2tlbikge1xuICAgICAgICB2YXIgaXNDdXN0b20gPSBza2lwKFwiKFwiLCB0cnVlKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0b2tlbjtcbiAgICAgICAgdmFyIG9wdGlvbiA9IG5hbWU7XG4gICAgICAgIHZhciBwcm9wTmFtZTtcblxuICAgICAgICBpZiAoaXNDdXN0b20pIHtcbiAgICAgICAgICAgIHNraXAoXCIpXCIpO1xuICAgICAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgICAgICAgb3B0aW9uID0gbmFtZTtcbiAgICAgICAgICAgIHRva2VuID0gcGVlaygpO1xuICAgICAgICAgICAgaWYgKGZxVHlwZVJlZlJlLnRlc3QodG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcHJvcE5hbWUgPSB0b2tlbi5zdWJzdHIoMSk7IC8vcmVtb3ZlICcuJyBiZWZvcmUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgIG5hbWUgKz0gdG9rZW47XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgb3B0aW9uVmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHNldFBhcnNlZE9wdGlvbihwYXJlbnQsIG9wdGlvbiwgb3B0aW9uVmFsdWUsIHByb3BOYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSkge1xuICAgICAgICBpZiAoc2tpcChcIntcIiwgdHJ1ZSkpIHsgLy8geyBhOiBcImZvb1wiIGIgeyBjOiBcImJhclwiIH0gfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgd2hpbGUgKCFza2lwKFwifVwiLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gdG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gXCJ7XCIpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2tpcChcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwie1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU9wdGlvblZhbHVlKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcmVhZFZhbHVlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gcmVzdWx0W3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHNraXAoXCIsXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW1wbGVWYWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgc2ltcGxlVmFsdWUpO1xuICAgICAgICByZXR1cm4gc2ltcGxlVmFsdWU7XG4gICAgICAgIC8vIERvZXMgbm90IGVuZm9yY2UgYSBkZWxpbWl0ZXIgdG8gYmUgdW5pdmVyc2FsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHBhcmVudC5zZXRPcHRpb24pXG4gICAgICAgICAgICBwYXJlbnQuc2V0T3B0aW9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRQYXJzZWRPcHRpb24ocGFyZW50LCBuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpIHtcbiAgICAgICAgaWYgKHBhcmVudC5zZXRQYXJzZWRPcHRpb24pXG4gICAgICAgICAgICBwYXJlbnQuc2V0UGFyc2VkT3B0aW9uKG5hbWUsIHZhbHVlLCBwcm9wTmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbmxpbmVPcHRpb25zKHBhcmVudCkge1xuICAgICAgICBpZiAoc2tpcChcIltcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwYXJlbnQsIFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICAgICAgc2tpcChcIl1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVNlcnZpY2UocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwic2VydmljZSBuYW1lXCIpO1xuXG4gICAgICAgIHZhciBzZXJ2aWNlID0gbmV3IFNlcnZpY2UodG9rZW4pO1xuICAgICAgICBpZkJsb2NrKHNlcnZpY2UsIGZ1bmN0aW9uIHBhcnNlU2VydmljZV9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHBhcnNlQ29tbW9uKHNlcnZpY2UsIHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicnBjXCIpXG4gICAgICAgICAgICAgICAgcGFyc2VNZXRob2Qoc2VydmljZSwgdG9rZW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChzZXJ2aWNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1ldGhvZChwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgIC8vIEdldCB0aGUgY29tbWVudCBvZiB0aGUgcHJlY2VkaW5nIGxpbmUgbm93IChpZiBvbmUgZXhpc3RzKSBpbiBjYXNlIHRoZVxuICAgICAgICAvLyBtZXRob2QgaXMgZGVmaW5lZCBhY3Jvc3MgbXVsdGlwbGUgbGluZXMuXG4gICAgICAgIHZhciBjb21tZW50VGV4dCA9IGNtbnQoKTtcblxuICAgICAgICB2YXIgdHlwZSA9IHRva2VuO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHRva2VuLFxuICAgICAgICAgICAgcmVxdWVzdFR5cGUsIHJlcXVlc3RTdHJlYW0sXG4gICAgICAgICAgICByZXNwb25zZVR5cGUsIHJlc3BvbnNlU3RyZWFtO1xuXG4gICAgICAgIHNraXAoXCIoXCIpO1xuICAgICAgICBpZiAoc2tpcChcInN0cmVhbVwiLCB0cnVlKSlcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW0gPSB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIHJlcXVlc3RUeXBlID0gdG9rZW47XG4gICAgICAgIHNraXAoXCIpXCIpOyBza2lwKFwicmV0dXJuc1wiKTsgc2tpcChcIihcIik7XG4gICAgICAgIGlmIChza2lwKFwic3RyZWFtXCIsIHRydWUpKVxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSB0cnVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIHJlc3BvbnNlVHlwZSA9IHRva2VuO1xuICAgICAgICBza2lwKFwiKVwiKTtcblxuICAgICAgICB2YXIgbWV0aG9kID0gbmV3IE1ldGhvZChuYW1lLCB0eXBlLCByZXF1ZXN0VHlwZSwgcmVzcG9uc2VUeXBlLCByZXF1ZXN0U3RyZWFtLCByZXNwb25zZVN0cmVhbSk7XG4gICAgICAgIG1ldGhvZC5jb21tZW50ID0gY29tbWVudFRleHQ7XG4gICAgICAgIGlmQmxvY2sobWV0aG9kLCBmdW5jdGlvbiBwYXJzZU1ldGhvZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24obWV0aG9kLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChtZXRob2QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInJlZmVyZW5jZVwiKTtcblxuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdG9rZW47XG4gICAgICAgIGlmQmxvY2sobnVsbCwgZnVuY3Rpb24gcGFyc2VFeHRlbnNpb25fYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgdG9rZW4sIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm90bzMgfHwgIXR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIFwib3B0aW9uYWxcIiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0b2tlbjtcbiAgICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgIGNhc2UgXCJwYWNrYWdlXCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VQYWNrYWdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbXBvcnRcIjpcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghaGVhZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgICAgICBwYXJzZUltcG9ydCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VTeW50YXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuXG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocHRyLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbihwdHIsIHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZS5maWxlbmFtZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJwYWNrYWdlXCIgICAgIDogcGtnLFxuICAgICAgICBcImltcG9ydHNcIiAgICAgOiBpbXBvcnRzLFxuICAgICAgICAgd2Vha0ltcG9ydHMgIDogd2Vha0ltcG9ydHMsXG4gICAgICAgICBzeW50YXggICAgICAgOiBzeW50YXgsXG4gICAgICAgICByb290ICAgICAgICAgOiByb290XG4gICAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cbiAqIEBuYW1lIHBhcnNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtJUGFyc2VyUmVzdWx0fSBQYXJzZXIgcmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWU9bnVsbCBDdXJyZW50bHkgcHJvY2Vzc2luZyBmaWxlIG5hbWUgZm9yIGVycm9yIHJlcG9ydGluZywgaWYga25vd25cbiAqIEBwcm9wZXJ0eSB7SVBhcnNlT3B0aW9uc30gZGVmYXVsdHMgRGVmYXVsdCB7QGxpbmsgSVBhcnNlT3B0aW9uc31cbiAqIEB2YXJpYXRpb24gMlxuICovXG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSb290O1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoUm9vdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFJvb3QpLmNsYXNzTmFtZSA9IFwiUm9vdFwiO1xuXG52YXIgRmllbGQgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIE9uZU9mICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGUsICAgLy8gY3ljbGljXG4gICAgcGFyc2UsICAvLyBtaWdodCBiZSBleGNsdWRlZFxuICAgIGNvbW1vbjsgLy8gXCJcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJvb3QgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSb290IG5hbWVzcGFjZSB3cmFwcGluZyBhbGwgdHlwZXMsIGVudW1zLCBzZXJ2aWNlcywgc3ViLW5hbWVzcGFjZXMgZXRjLiB0aGF0IGJlbG9uZyB0b2dldGhlci5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFRvcCBsZXZlbCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJvb3Qob3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIFwiXCIsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogRGVmZXJyZWQgZXh0ZW5zaW9uIGZpZWxkcy5cbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKi9cbiAgICB0aGlzLmRlZmVycmVkID0gW107XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBmaWxlIG5hbWVzIG9mIGxvYWRlZCBmaWxlcy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICovXG4gICAgdGhpcy5maWxlcyA9IFtdO1xufVxuXG4vKipcbiAqIExvYWRzIGEgbmFtZXNwYWNlIGRlc2NyaXB0b3IgaW50byBhIHJvb3QgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtJTmFtZXNwYWNlfSBqc29uIE5hbWVlc3BhY2UgZGVzY3JpcHRvclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZFxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKi9cblJvb3QuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihqc29uLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IFJvb3QoKTtcbiAgICBpZiAoanNvbi5vcHRpb25zKVxuICAgICAgICByb290LnNldE9wdGlvbnMoanNvbi5vcHRpb25zKTtcbiAgICByZXR1cm4gcm9vdC5hZGRKU09OKGpzb24ubmVzdGVkKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhlIHBhdGggb2YgYW4gaW1wb3J0ZWQgZmlsZSwgcmVsYXRpdmUgdG8gdGhlIGltcG9ydGluZyBvcmlnaW4uXG4gKiBUaGlzIG1ldGhvZCBleGlzdHMgc28geW91IGNhbiBvdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duIGxvZ2ljIGluIGNhc2UgeW91ciBpbXBvcnRzIGFyZSBzY2F0dGVyZWQgb3ZlciBtdWx0aXBsZSBkaXJlY3Rvcmllcy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiBUaGUgZmlsZSBuYW1lIG9mIHRoZSBpbXBvcnRpbmcgZmlsZVxuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUaGUgZmlsZSBuYW1lIGJlaW5nIGltcG9ydGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFJlc29sdmVkIHBhdGggdG8gYHRhcmdldGAgb3IgYG51bGxgIHRvIHNraXAgdGhlIGZpbGVcbiAqL1xuUm9vdC5wcm90b3R5cGUucmVzb2x2ZVBhdGggPSB1dGlsLnBhdGgucmVzb2x2ZTtcblxuLyoqXG4gKiBGZXRjaCBjb250ZW50IGZyb20gZmlsZSBwYXRoIG9yIHVybFxuICogVGhpcyBtZXRob2QgZXhpc3RzIHNvIHlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93biBsb2dpYy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZSBwYXRoIG9yIHVybFxuICogQHBhcmFtIHtGZXRjaENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUm9vdC5wcm90b3R5cGUuZmV0Y2ggPSB1dGlsLmZldGNoO1xuXG4vLyBBIHN5bWJvbC1saWtlIGZ1bmN0aW9uIHRvIHNhZmVseSBzaWduYWwgc3luY2hyb25vdXMgbG9hZGluZ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIFNZTkMoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gb3B0aW9ucyBQYXJzZSBvcHRpb25zXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJvb3QucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShsb2FkLCBzZWxmLCBmaWxlbmFtZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3luYyA9IGNhbGxiYWNrID09PSBTWU5DOyAvLyB1bmRvY3VtZW50ZWRcblxuICAgIC8vIEZpbmlzaGVzIGxvYWRpbmcgYnkgY2FsbGluZyB0aGUgY2FsbGJhY2sgKGV4YWN0bHkgb25jZSlcbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyLCByb290KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY2IgPSBjYWxsYmFjaztcbiAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgY2IoZXJyLCByb290KTtcbiAgICB9XG5cbiAgICAvLyBCdW5kbGVkIGRlZmluaXRpb24gZXhpc3RlbmNlIGNoZWNraW5nXG4gICAgZnVuY3Rpb24gZ2V0QnVuZGxlZEZpbGVOYW1lKGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBpZHggPSBmaWxlbmFtZS5sYXN0SW5kZXhPZihcImdvb2dsZS9wcm90b2J1Zi9cIik7XG4gICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgdmFyIGFsdG5hbWUgPSBmaWxlbmFtZS5zdWJzdHJpbmcoaWR4KTtcbiAgICAgICAgICAgIGlmIChhbHRuYW1lIGluIGNvbW1vbikgcmV0dXJuIGFsdG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gUHJvY2Vzc2VzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHNvdXJjZSkgJiYgc291cmNlLmNoYXJBdCgwKSA9PT0gXCJ7XCIpXG4gICAgICAgICAgICAgICAgc291cmNlID0gSlNPTi5wYXJzZShzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHNvdXJjZSkpXG4gICAgICAgICAgICAgICAgc2VsZi5zZXRPcHRpb25zKHNvdXJjZS5vcHRpb25zKS5hZGRKU09OKHNvdXJjZS5uZXN0ZWQpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2UuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2Uoc291cmNlLCBzZWxmLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuaW1wb3J0cylcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBwYXJzZWQuaW1wb3J0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9IGdldEJ1bmRsZWRGaWxlTmFtZShwYXJzZWQuaW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLmltcG9ydHNbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLndlYWtJbXBvcnRzKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyc2VkLndlYWtJbXBvcnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID0gZ2V0QnVuZGxlZEZpbGVOYW1lKHBhcnNlZC53ZWFrSW1wb3J0c1tpXSkgfHwgc2VsZi5yZXNvbHZlUGF0aChmaWxlbmFtZSwgcGFyc2VkLndlYWtJbXBvcnRzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaChyZXNvbHZlZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzeW5jICYmICFxdWV1ZWQpXG4gICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7IC8vIG9ubHkgb25jZSBhbnl3YXlcbiAgICB9XG5cbiAgICAvLyBGZXRjaGVzIGEgc2luZ2xlIGZpbGVcbiAgICBmdW5jdGlvbiBmZXRjaChmaWxlbmFtZSwgd2Vhaykge1xuXG4gICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBsb2FkZWQgLyBhdHRlbXB0ZWRcbiAgICAgICAgaWYgKHNlbGYuZmlsZXMuaW5kZXhPZihmaWxlbmFtZSkgPiAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc2VsZi5maWxlcy5wdXNoKGZpbGVuYW1lKTtcblxuICAgICAgICAvLyBTaG9ydGN1dCBidW5kbGVkIGRlZmluaXRpb25zXG4gICAgICAgIGlmIChmaWxlbmFtZSBpbiBjb21tb24pIHtcbiAgICAgICAgICAgIGlmIChzeW5jKVxuICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIGNvbW1vbltmaWxlbmFtZV0pO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKytxdWV1ZWQ7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1xdWV1ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIGNvbW1vbltmaWxlbmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZldGNoIGZyb20gZGlzayBvciBuZXR3b3JrXG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3ZWFrKVxuICAgICAgICAgICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytxdWV1ZWQ7XG4gICAgICAgICAgICBzZWxmLmZldGNoKGZpbGVuYW1lLCBmdW5jdGlvbihlcnIsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIC0tcXVldWVkO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGVybWluYXRlZCBtZWFud2hpbGVcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2VhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcXVldWVkKSAvLyBjYW4ndCBiZSBjb3ZlcmVkIHJlbGlhYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBxdWV1ZWQgPSAwO1xuXG4gICAgLy8gQXNzZW1ibGluZyB0aGUgcm9vdCBuYW1lc3BhY2UgZG9lc24ndCByZXF1aXJlIHdvcmtpbmcgdHlwZVxuICAgIC8vIHJlZmVyZW5jZXMgYW55bW9yZSwgc28gd2UgY2FuIGxvYWQgZXZlcnl0aGluZyBpbiBwYXJhbGxlbFxuICAgIGlmICh1dGlsLmlzU3RyaW5nKGZpbGVuYW1lKSlcbiAgICAgICAgZmlsZW5hbWUgPSBbIGZpbGVuYW1lIF07XG4gICAgZm9yICh2YXIgaSA9IDAsIHJlc29sdmVkOyBpIDwgZmlsZW5hbWUubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChyZXNvbHZlZCA9IHNlbGYucmVzb2x2ZVBhdGgoXCJcIiwgZmlsZW5hbWVbaV0pKVxuICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xuXG4gICAgaWYgKHN5bmMpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICghcXVldWVkKVxuICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgb3B0aW9uczpJUGFyc2VPcHRpb25zLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSb290Pn0gUHJvbWlzZVxuICogQHZhcmlhdGlvbiAzXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbb3B0aW9uczpJUGFyc2VPcHRpb25zXSk6UHJvbWlzZTxSb290PlxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFN5bmNcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxuICovXG5Sb290LnByb3RvdHlwZS5sb2FkU3luYyA9IGZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCF1dGlsLmlzTm9kZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub3Qgc3VwcG9ydGVkXCIpO1xuICAgIHJldHVybiB0aGlzLmxvYWQoZmlsZW5hbWUsIG9wdGlvbnMsIFNZTkMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuUm9vdC5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgaWYgKHRoaXMuZGVmZXJyZWQubGVuZ3RoKVxuICAgICAgICB0aHJvdyBFcnJvcihcInVucmVzb2x2YWJsZSBleHRlbnNpb25zOiBcIiArIHRoaXMuZGVmZXJyZWQubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCInZXh0ZW5kIFwiICsgZmllbGQuZXh0ZW5kICsgXCInIGluIFwiICsgZmllbGQucGFyZW50LmZ1bGxOYW1lO1xuICAgICAgICB9KS5qb2luKFwiLCBcIikpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbn07XG5cbi8vIG9ubHkgdXBwZXJjYXNlZCAoYW5kIHRodXMgY29uZmxpY3QtZnJlZSkgY2hpbGRyZW4gYXJlIGV4cG9zZWQsIHNlZSBiZWxvd1xudmFyIGV4cG9zZVJlID0gL15bQS1aXS87XG5cbi8qKlxuICogSGFuZGxlcyBhIGRlZmVycmVkIGRlY2xhcmluZyBleHRlbnNpb24gZmllbGQgYnkgY3JlYXRpbmcgYSBzaXN0ZXIgZmllbGQgdG8gcmVwcmVzZW50IGl0IHdpdGhpbiBpdHMgZXh0ZW5kZWQgdHlwZS5cbiAqIEBwYXJhbSB7Um9vdH0gcm9vdCBSb290IGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBEZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkIHdpdGluIHRoZSBkZWNsYXJpbmcgdHlwZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBzdWNjZXNzZnVsbHkgYWRkZWQgdG8gdGhlIGV4dGVuZGVkIHR5cGUsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAaW5uZXJcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gdHJ5SGFuZGxlRXh0ZW5zaW9uKHJvb3QsIGZpZWxkKSB7XG4gICAgdmFyIGV4dGVuZGVkVHlwZSA9IGZpZWxkLnBhcmVudC5sb29rdXAoZmllbGQuZXh0ZW5kKTtcbiAgICBpZiAoZXh0ZW5kZWRUeXBlKSB7XG4gICAgICAgIHZhciBzaXN0ZXJGaWVsZCA9IG5ldyBGaWVsZChmaWVsZC5mdWxsTmFtZSwgZmllbGQuaWQsIGZpZWxkLnR5cGUsIGZpZWxkLnJ1bGUsIHVuZGVmaW5lZCwgZmllbGQub3B0aW9ucyk7XG4gICAgICAgIHNpc3RlckZpZWxkLmRlY2xhcmluZ0ZpZWxkID0gZmllbGQ7XG4gICAgICAgIGZpZWxkLmV4dGVuc2lvbkZpZWxkID0gc2lzdGVyRmllbGQ7XG4gICAgICAgIGV4dGVuZGVkVHlwZS5hZGQoc2lzdGVyRmllbGQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIGFueSBvYmplY3QgaXMgYWRkZWQgdG8gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCBhZGRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cblJvb3QucHJvdG90eXBlLl9oYW5kbGVBZGQgPSBmdW5jdGlvbiBfaGFuZGxlQWRkKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xuXG4gICAgICAgIGlmICgvKiBhbiBleHRlbnNpb24gZmllbGQgKGltcGxpZXMgbm90IHBhcnQgb2YgYSBvbmVvZikgKi8gb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkICYmIC8qIG5vdCBhbHJlYWR5IGhhbmRsZWQgKi8gIW9iamVjdC5leHRlbnNpb25GaWVsZClcbiAgICAgICAgICAgIGlmICghdHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIG9iamVjdCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5wdXNoKG9iamVjdCk7XG5cbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEVudW0pIHtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdC52YWx1ZXM7IC8vIGV4cG9zZSBlbnVtIHZhbHVlcyBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XG5cbiAgICB9IGVsc2UgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpKSAvKiBldmVyeXRoaW5nIGVsc2UgaXMgYSBuYW1lc3BhY2UgKi8ge1xuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUeXBlKSAvLyBUcnkgdG8gaGFuZGxlIGFueSBkZWZlcnJlZCBleHRlbnNpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVmZXJyZWQubGVuZ3RoOylcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIHRoaXMuZGVmZXJyZWRbaV0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2opIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBZGQob2JqZWN0Ll9uZXN0ZWRBcnJheVtqXSk7XG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0OyAvLyBleHBvc2UgbmFtZXNwYWNlIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcbiAgICB9XG5cbiAgICAvLyBUaGUgYWJvdmUgYWxzbyBhZGRzIHVwcGVyY2FzZWQgKGFuZCB0aHVzIGNvbmZsaWN0LWZyZWUpIG5lc3RlZCB0eXBlcywgc2VydmljZXMgYW5kIGVudW1zIGFzXG4gICAgLy8gcHJvcGVydGllcyBvZiBuYW1lc3BhY2VzIGp1c3QgbGlrZSBzdGF0aWMgY29kZSBkb2VzLiBUaGlzIGFsbG93cyB1c2luZyBhIC5kLnRzIGdlbmVyYXRlZCBmb3JcbiAgICAvLyBhIHN0YXRpYyBtb2R1bGUgd2l0aCByZWZsZWN0aW9uLWJhc2VkIHNvbHV0aW9ucyB3aGVyZSB0aGUgY29uZGl0aW9uIGlzIG1ldC5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gYW55IG9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCByZW1vdmVkXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByaXZhdGVcbiAqL1xuUm9vdC5wcm90b3R5cGUuX2hhbmRsZVJlbW92ZSA9IGZ1bmN0aW9uIF9oYW5kbGVSZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG5cbiAgICAgICAgaWYgKC8qIGFuIGV4dGVuc2lvbiBmaWVsZCAqLyBvYmplY3QuZXh0ZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgvKiBhbHJlYWR5IGhhbmRsZWQgKi8gb2JqZWN0LmV4dGVuc2lvbkZpZWxkKSB7IC8vIHJlbW92ZSBpdHMgc2lzdGVyIGZpZWxkXG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVuc2lvbkZpZWxkLnBhcmVudC5yZW1vdmUob2JqZWN0LmV4dGVuc2lvbkZpZWxkKTtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gY2FuY2VsIHRoZSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmRlZmVycmVkLmluZGV4T2Yob2JqZWN0KTtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgRW51bSkge1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXTsgLy8gdW5leHBvc2UgZW51bSB2YWx1ZXNcblxuICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVSZW1vdmUob2JqZWN0Ll9uZXN0ZWRBcnJheVtpXSk7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBuYW1lc3BhY2VzXG5cbiAgICB9XG59O1xuXG4vLyBTZXRzIHVwIGN5Y2xpYyBkZXBlbmRlbmNpZXMgKGNhbGxlZCBpbiBpbmRleC1saWdodClcblJvb3QuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBwYXJzZV8sIGNvbW1vbl8pIHtcbiAgICBUeXBlICAgPSBUeXBlXztcbiAgICBwYXJzZSAgPSBwYXJzZV87XG4gICAgY29tbW9uID0gY29tbW9uXztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2UpLmNsYXNzTmFtZSA9IFwiU2VydmljZVwiO1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpLFxuICAgIHV0aWwgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgcnBjICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIHNlcnZpY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFNlcnZpY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIFNlcnZpY2Ugb3B0aW9uc1xuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShuYW1lLCBvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXJ2aWNlIG1ldGhvZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLE1ldGhvZD59XG4gICAgICovXG4gICAgdGhpcy5tZXRob2RzID0ge307IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgbWV0aG9kcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7TWV0aG9kW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21ldGhvZHNBcnJheSA9IG51bGw7XG59XG5cbi8qKlxuICogU2VydmljZSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJU2VydmljZVxuICogQGV4dGVuZHMgSU5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJTWV0aG9kPn0gbWV0aG9kcyBNZXRob2QgZGVzY3JpcHRvcnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzZXJ2aWNlIGZyb20gYSBzZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSB7SVNlcnZpY2V9IGpzb24gU2VydmljZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7U2VydmljZX0gQ3JlYXRlZCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5TZXJ2aWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciBzZXJ2aWNlID0gbmV3IFNlcnZpY2UobmFtZSwganNvbi5vcHRpb25zKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChqc29uLm1ldGhvZHMpXG4gICAgICAgIGZvciAodmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5tZXRob2RzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHNlcnZpY2UuYWRkKE1ldGhvZC5mcm9tSlNPTihuYW1lc1tpXSwganNvbi5tZXRob2RzW25hbWVzW2ldXSkpO1xuICAgIGlmIChqc29uLm5lc3RlZClcbiAgICAgICAgc2VydmljZS5hZGRKU09OKGpzb24ubmVzdGVkKTtcbiAgICBzZXJ2aWNlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgcmV0dXJuIHNlcnZpY2U7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgc2VydmljZSB0byBhIHNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lTZXJ2aWNlfSBTZXJ2aWNlIGRlc2NyaXB0b3JcbiAqL1xuU2VydmljZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwibWV0aG9kc1wiICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMubWV0aG9kc0FycmF5LCB0b0pTT05PcHRpb25zKSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fSxcbiAgICAgICAgXCJuZXN0ZWRcIiAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZHMgb2YgdGhpcyBzZXJ2aWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBTZXJ2aWNlI21ldGhvZHNBcnJheVxuICogQHR5cGUge01ldGhvZFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJtZXRob2RzQXJyYXlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2RzQXJyYXkgfHwgKHRoaXMuX21ldGhvZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm1ldGhvZHMpKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gY2xlYXJDYWNoZShzZXJ2aWNlKSB7XG4gICAgc2VydmljZS5fbWV0aG9kc0FycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gc2VydmljZTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RzW25hbWVdXG4gICAgICAgIHx8IE5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0LmNhbGwodGhpcywgbmFtZSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgbWV0aG9kcyA9IHRoaXMubWV0aG9kc0FycmF5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7ICsraSlcbiAgICAgICAgbWV0aG9kc1tpXS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1ldGhvZCkge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5tZXRob2RzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJ1bnRpbWUgc2VydmljZSB1c2luZyB0aGUgc3BlY2lmaWVkIHJwYyBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBSUEMgc2VydmljZS4gVXNlZnVsIHdoZXJlIHJlcXVlc3RzIGFuZC9vciByZXNwb25zZXMgYXJlIHN0cmVhbWVkLlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcbiAgICB2YXIgcnBjU2VydmljZSA9IG5ldyBycGMuU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG1ldGhvZDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gdXRpbC5sY0ZpcnN0KChtZXRob2QgPSB0aGlzLl9tZXRob2RzQXJyYXlbaV0pLnJlc29sdmUoKS5uYW1lKS5yZXBsYWNlKC9bXiRcXHdfXS9nLCBcIlwiKTtcbiAgICAgICAgcnBjU2VydmljZVttZXRob2ROYW1lXSA9IHV0aWwuY29kZWdlbihbXCJyXCIsXCJjXCJdLCB1dGlsLmlzUmVzZXJ2ZWQobWV0aG9kTmFtZSkgPyBtZXRob2ROYW1lICsgXCJfXCIgOiBtZXRob2ROYW1lKShcInJldHVybiB0aGlzLnJwY0NhbGwobSxxLHMscixjKVwiKSh7XG4gICAgICAgICAgICBtOiBtZXRob2QsXG4gICAgICAgICAgICBxOiBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZS5jdG9yLFxuICAgICAgICAgICAgczogbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlLmN0b3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBycGNTZXJ2aWNlO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB0b2tlbml6ZTtcblxudmFyIGRlbGltUmUgICAgICAgID0gL1tcXHN7fT07OltcXF0sJ1wiKCk8Pl0vZyxcbiAgICBzdHJpbmdEb3VibGVSZSA9IC8oPzpcIihbXlwiXFxcXF0qKD86XFxcXC5bXlwiXFxcXF0qKSopXCIpL2csXG4gICAgc3RyaW5nU2luZ2xlUmUgPSAvKD86JyhbXidcXFxcXSooPzpcXFxcLlteJ1xcXFxdKikqKScpL2c7XG5cbnZhciBzZXRDb21tZW50UmUgPSAvXiAqWyovXSsgKi8sXG4gICAgc2V0Q29tbWVudEFsdFJlID0gL15cXHMqXFwqP1xcLyovLFxuICAgIHNldENvbW1lbnRTcGxpdFJlID0gL1xcbi9nLFxuICAgIHdoaXRlc3BhY2VSZSA9IC9cXHMvLFxuICAgIHVuZXNjYXBlUmUgPSAvXFxcXCguPykvZztcblxudmFyIHVuZXNjYXBlTWFwID0ge1xuICAgIFwiMFwiOiBcIlxcMFwiLFxuICAgIFwiclwiOiBcIlxcclwiLFxuICAgIFwiblwiOiBcIlxcblwiLFxuICAgIFwidFwiOiBcIlxcdFwiXG59O1xuXG4vKipcbiAqIFVuZXNjYXBlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHVuZXNjYXBlXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVbmVzY2FwZWQgc3RyaW5nXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLHN0cmluZz59IG1hcCBTcGVjaWFsIGNoYXJhY3RlcnMgbWFwXG4gKiBAbWVtYmVyb2YgdG9rZW5pemVcbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVuZXNjYXBlUmUsIGZ1bmN0aW9uKCQwLCAkMSkge1xuICAgICAgICBzd2l0Y2ggKCQxKSB7XG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZXNjYXBlTWFwWyQxXSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbnRva2VuaXplLnVuZXNjYXBlID0gdW5lc2NhcGU7XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMuXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVOZXh0XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICovXG5cbi8qKlxuICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUGVla1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAqL1xuXG4vKipcbiAqIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlUHVzaFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRva2VuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgdG9rZW4uXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVTa2lwXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsPWZhbHNlXSBJZiBvcHRpb25hbFxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRva2VuIG1hdGNoZWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgdG9rZW4gZGlkbid0IG1hdGNoIGFuZCBpcyBub3Qgb3B0aW9uYWxcbiAqL1xuXG4vKipcbiAqIEdldHMgdGhlIGNvbW1lbnQgb24gdGhlIHByZXZpb3VzIGxpbmUgb3IsIGFsdGVybmF0aXZlbHksIHRoZSBsaW5lIGNvbW1lbnQgb24gdGhlIHNwZWNpZmllZCBsaW5lLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlQ21udFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtudW1iZXJ9IFtsaW5lXSBMaW5lIG51bWJlclxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBDb21tZW50IHRleHQgb3IgYG51bGxgIGlmIG5vbmVcbiAqL1xuXG4vKipcbiAqIEhhbmRsZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgdG9rZW5pemV9LlxuICogQGludGVyZmFjZSBJVG9rZW5pemVySGFuZGxlXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZU5leHR9IG5leHQgR2V0cyB0aGUgbmV4dCB0b2tlbiBhbmQgYWR2YW5jZXMgKGBudWxsYCBvbiBlb2YpXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVBlZWt9IHBlZWsgUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuIChgbnVsbGAgb24gZW9mKVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVQdXNofSBwdXNoIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVNraXB9IHNraXAgU2tpcHMgYSB0b2tlbiwgcmV0dXJucyBpdHMgcHJlc2VuY2UgYW5kIGFkdmFuY2VzIG9yLCBpZiBub24tb3B0aW9uYWwgYW5kIG5vdCBwcmVzZW50LCB0aHJvd3NcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlQ21udH0gY21udCBHZXRzIHRoZSBjb21tZW50IG9uIHRoZSBwcmV2aW91cyBsaW5lIG9yIHRoZSBsaW5lIGNvbW1lbnQgb24gdGhlIHNwZWNpZmllZCBsaW5lLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lIEN1cnJlbnQgbGluZSBudW1iZXJcbiAqL1xuXG4vKipcbiAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gLnByb3RvIHNvdXJjZSBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtib29sZWFufSBhbHRlcm5hdGVDb21tZW50TW9kZSBXaGV0aGVyIHdlIHNob3VsZCBhY3RpdmF0ZSBhbHRlcm5hdGUgY29tbWVudCBwYXJzaW5nIG1vZGUuXG4gKiBAcmV0dXJucyB7SVRva2VuaXplckhhbmRsZX0gVG9rZW5pemVyIGhhbmRsZVxuICovXG5mdW5jdGlvbiB0b2tlbml6ZShzb3VyY2UsIGFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FsbGJhY2stcmV0dXJuICovXG4gICAgc291cmNlID0gc291cmNlLnRvU3RyaW5nKCk7XG5cbiAgICB2YXIgb2Zmc2V0ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aCxcbiAgICAgICAgbGluZSA9IDEsXG4gICAgICAgIGNvbW1lbnRUeXBlID0gbnVsbCxcbiAgICAgICAgY29tbWVudFRleHQgPSBudWxsLFxuICAgICAgICBjb21tZW50TGluZSA9IDAsXG4gICAgICAgIGNvbW1lbnRMaW5lRW1wdHkgPSBmYWxzZSxcbiAgICAgICAgY29tbWVudElzTGVhZGluZyA9IGZhbHNlO1xuXG4gICAgdmFyIHN0YWNrID0gW107XG5cbiAgICB2YXIgc3RyaW5nRGVsaW0gPSBudWxsO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVycm9yIGZvciBpbGxlZ2FsIHN5bnRheC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViamVjdCBTdWJqZWN0XG4gICAgICogQHJldHVybnMge0Vycm9yfSBFcnJvciBjcmVhdGVkXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWxsZWdhbChzdWJqZWN0KSB7XG4gICAgICAgIHJldHVybiBFcnJvcihcImlsbGVnYWwgXCIgKyBzdWJqZWN0ICsgXCIgKGxpbmUgXCIgKyBsaW5lICsgXCIpXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgc3RyaW5nIHRpbGwgaXRzIGVuZC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciByZSA9IHN0cmluZ0RlbGltID09PSBcIidcIiA/IHN0cmluZ1NpbmdsZVJlIDogc3RyaW5nRG91YmxlUmU7XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IG9mZnNldCAtIDE7XG4gICAgICAgIHZhciBtYXRjaCA9IHJlLmV4ZWMoc291cmNlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJzdHJpbmdcIik7XG4gICAgICAgIG9mZnNldCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcHVzaChzdHJpbmdEZWxpbSk7XG4gICAgICAgIHN0cmluZ0RlbGltID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHVuZXNjYXBlKG1hdGNoWzFdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjaGFyYWN0ZXIgYXQgYHBvc2Agd2l0aGluIHRoZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvcyBQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IENoYXJhY3RlclxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoYXJBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5jaGFyQXQocG9zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGNvbW1lbnQgdGV4dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0xlYWRpbmcgc2V0IGlmIGEgbGVhZGluZyBjb21tZW50XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDb21tZW50KHN0YXJ0LCBlbmQsIGlzTGVhZGluZykge1xuICAgICAgICBjb21tZW50VHlwZSA9IHNvdXJjZS5jaGFyQXQoc3RhcnQrKyk7XG4gICAgICAgIGNvbW1lbnRMaW5lID0gbGluZTtcbiAgICAgICAgY29tbWVudExpbmVFbXB0eSA9IGZhbHNlO1xuICAgICAgICBjb21tZW50SXNMZWFkaW5nID0gaXNMZWFkaW5nO1xuICAgICAgICB2YXIgbG9va2JhY2s7XG4gICAgICAgIGlmIChhbHRlcm5hdGVDb21tZW50TW9kZSkge1xuICAgICAgICAgICAgbG9va2JhY2sgPSAyOyAgLy8gYWx0ZXJuYXRlIGNvbW1lbnQgcGFyc2luZzogXCIvL1wiIG9yIFwiLypcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9va2JhY2sgPSAzOyAgLy8gXCIvLy9cIiBvciBcIi8qKlwiXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1lbnRPZmZzZXQgPSBzdGFydCAtIGxvb2tiYWNrLFxuICAgICAgICAgICAgYztcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKC0tY29tbWVudE9mZnNldCA8IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgKGMgPSBzb3VyY2UuY2hhckF0KGNvbW1lbnRPZmZzZXQpKSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGNvbW1lbnRMaW5lRW1wdHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChjID09PSBcIiBcIiB8fCBjID09PSBcIlxcdFwiKTtcbiAgICAgICAgdmFyIGxpbmVzID0gc291cmNlXG4gICAgICAgICAgICAuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAuc3BsaXQoc2V0Q29tbWVudFNwbGl0UmUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgbGluZXNbaV0gPSBsaW5lc1tpXVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGFsdGVybmF0ZUNvbW1lbnRNb2RlID8gc2V0Q29tbWVudEFsdFJlIDogc2V0Q29tbWVudFJlLCBcIlwiKVxuICAgICAgICAgICAgICAgIC50cmltKCk7XG4gICAgICAgIGNvbW1lbnRUZXh0ID0gbGluZXNcbiAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAudHJpbSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRG91YmxlU2xhc2hDb21tZW50TGluZShzdGFydE9mZnNldCkge1xuICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZmluZEVuZE9mTGluZShzdGFydE9mZnNldCk7XG5cbiAgICAgICAgLy8gc2VlIGlmIHJlbWFpbmluZyBsaW5lIG1hdGNoZXMgY29tbWVudCBwYXR0ZXJuXG4gICAgICAgIHZhciBsaW5lVGV4dCA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgIC8vIGxvb2sgZm9yIDEgb3IgMiBzbGFzaGVzIHNpbmNlIHN0YXJ0T2Zmc2V0IHdvdWxkIGFscmVhZHkgcG9pbnQgcGFzdFxuICAgICAgICAvLyB0aGUgZmlyc3Qgc2xhc2ggdGhhdCBzdGFydGVkIHRoZSBjb21tZW50LlxuICAgICAgICB2YXIgaXNDb21tZW50ID0gL15cXHMqXFwvezEsMn0vLnRlc3QobGluZVRleHQpO1xuICAgICAgICByZXR1cm4gaXNDb21tZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRFbmRPZkxpbmUoY3Vyc29yKSB7XG4gICAgICAgIC8vIGZpbmQgZW5kIG9mIGN1cnNvcidzIGxpbmVcbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGN1cnNvcjtcbiAgICAgICAgd2hpbGUgKGVuZE9mZnNldCA8IGxlbmd0aCAmJiBjaGFyQXQoZW5kT2Zmc2V0KSAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgZW5kT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuZE9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIHRoZSBuZXh0IHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTmV4dCB0b2tlbiBvciBgbnVsbGAgb24gZW9mXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgaWYgKHN0cmluZ0RlbGltKVxuICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoKTtcbiAgICAgICAgdmFyIHJlcGVhdCxcbiAgICAgICAgICAgIHByZXYsXG4gICAgICAgICAgICBjdXJyLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBpc0RvYyxcbiAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSBvZmZzZXQgPT09IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJlcGVhdCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKHdoaXRlc3BhY2VSZS50ZXN0KGN1cnIgPSBjaGFyQXQob2Zmc2V0KSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyciA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFyQXQob2Zmc2V0KSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJBdChvZmZzZXQpID09PSBcIi9cIikgeyAvLyBMaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciB0cmlwbGUtc2xhc2ggY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBjaGFyQXQoc3RhcnQgPSBvZmZzZXQgKyAxKSA9PT0gXCIvXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQXQoKytvZmZzZXQpICE9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICsrb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29tbWVudChzdGFydCwgb2Zmc2V0IC0gMSwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRvdWJsZS1zbGFzaCBjb21tZW50cywgY29uc29saWRhdGluZyBjb25zZWN1dGl2ZSBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZEVuZE9mTGluZShvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4obGVuZ3RoLCBmaW5kRW5kT2ZMaW5lKG9mZnNldCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCwgaXNMZWFkaW5nQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoY3VyciA9IGNoYXJBdChvZmZzZXQpKSA9PT0gXCIqXCIpIHsgLyogQmxvY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIC8qKiAocmVndWxhciBjb21tZW50IG1vZGUpIG9yIC8qIChhbHRlcm5hdGUgY29tbWVudCBtb2RlKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlzRG9jID0gYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY2hhckF0KHN0YXJ0KSA9PT0gXCIqXCI7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGNoYXJBdChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwcmV2ICE9PSBcIipcIiB8fCBjdXJyICE9PSBcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICsrb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCAtIDIsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocmVwZWF0KTtcblxuICAgICAgICAvLyBvZmZzZXQgIT09IGxlbmd0aCBpZiB3ZSBnb3QgaGVyZVxuXG4gICAgICAgIHZhciBlbmQgPSBvZmZzZXQ7XG4gICAgICAgIGRlbGltUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGRlbGltID0gZGVsaW1SZS50ZXN0KGNoYXJBdChlbmQrKykpO1xuICAgICAgICBpZiAoIWRlbGltKVxuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCAmJiAhZGVsaW1SZS50ZXN0KGNoYXJBdChlbmQpKSlcbiAgICAgICAgICAgICAgICArK2VuZDtcbiAgICAgICAgdmFyIHRva2VuID0gc291cmNlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCA9IGVuZCk7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKVxuICAgICAgICAgICAgc3RyaW5nRGVsaW0gPSB0b2tlbjtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlblxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVzaCh0b2tlbikge1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUb2tlbiBvciBgbnVsbGAgb24gZW9mXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTa2lwcyBhIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCB0b2tlblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsPWZhbHNlXSBXaGV0aGVyIHRoZSB0b2tlbiBpcyBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBza2lwcGVkLCBgZmFsc2VgIGlmIG5vdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIGEgcmVxdWlyZWQgdG9rZW4gaXMgbm90IHByZXNlbnRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBza2lwKGV4cGVjdGVkLCBvcHRpb25hbCkge1xuICAgICAgICB2YXIgYWN0dWFsID0gcGVlaygpLFxuICAgICAgICAgICAgZXF1YWxzID0gYWN0dWFsID09PSBleHBlY3RlZDtcbiAgICAgICAgaWYgKGVxdWFscykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25hbClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJ0b2tlbiAnXCIgKyBhY3R1YWwgKyBcIicsICdcIiArIGV4cGVjdGVkICsgXCInIGV4cGVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNvbW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0cmFpbGluZ0xpbmVdIExpbmUgbnVtYmVyIGlmIGxvb2tpbmcgZm9yIGEgdHJhaWxpbmcgY29tbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gQ29tbWVudCB0ZXh0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY21udCh0cmFpbGluZ0xpbmUpIHtcbiAgICAgICAgdmFyIHJldCA9IG51bGw7XG4gICAgICAgIGlmICh0cmFpbGluZ0xpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRMaW5lID09PSBsaW5lIC0gMSAmJiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY29tbWVudFR5cGUgPT09IFwiKlwiIHx8IGNvbW1lbnRMaW5lRW1wdHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29tbWVudElzTGVhZGluZyA/IGNvbW1lbnRUZXh0IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoY29tbWVudExpbmUgPCB0cmFpbGluZ0xpbmUpIHtcbiAgICAgICAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWVudExpbmUgPT09IHRyYWlsaW5nTGluZSAmJiAhY29tbWVudExpbmVFbXB0eSAmJiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY29tbWVudFR5cGUgPT09IFwiL1wiKSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbW1lbnRJc0xlYWRpbmcgPyBudWxsIDogY29tbWVudFRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICAgICAgbmV4dDogbmV4dCxcbiAgICAgICAgcGVlazogcGVlayxcbiAgICAgICAgcHVzaDogcHVzaCxcbiAgICAgICAgc2tpcDogc2tpcCxcbiAgICAgICAgY21udDogY21udFxuICAgIH0sIFwibGluZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lOyB9XG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBUeXBlO1xuXG4vLyBleHRlbmRzIE5hbWVzcGFjZVxudmFyIE5hbWVzcGFjZSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbigoVHlwZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hbWVzcGFjZS5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFR5cGUpLmNsYXNzTmFtZSA9IFwiVHlwZVwiO1xuXG52YXIgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBTZXJ2aWNlICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpLFxuICAgIE1lc3NhZ2UgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIiksXG4gICAgUmVhZGVyICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpLFxuICAgIFdyaXRlciAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIGVuY29kZXIgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIiksXG4gICAgZGVjb2RlciAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKSxcbiAgICB2ZXJpZmllciAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKSxcbiAgICBjb252ZXJ0ZXIgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIiksXG4gICAgd3JhcHBlcnMgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0ZWQgbWVzc2FnZSB0eXBlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSB0eXBlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFR5cGUobmFtZSwgb3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBmaWVsZHMuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLEZpZWxkPn1cbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkcyA9IHt9OyAgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBkZWNsYXJlZCB3aXRoaW4gdGhpcyBuYW1lc3BhY2UsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsT25lT2Y+fVxuICAgICAqL1xuICAgIHRoaXMub25lb2ZzID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIEV4dGVuc2lvbiByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyW11bXX1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZWQgcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyo/XG4gICAgICogV2hldGhlciB0aGlzIHR5cGUgaXMgYSBsZWdhY3kgZ3JvdXAuXG4gICAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMuZ3JvdXAgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZHNCeUlkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBmaWVsZHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge0ZpZWxkW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBvbmVvZnMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge09uZU9mW118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29uZW9mc0FycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY3RvciA9IG51bGw7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFR5cGUucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcyBieSBpZC5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0J5SWRcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsRmllbGQ+fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZpZWxkc0J5SWQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcblxuICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc1tuYW1lc1tpXV0sXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZmllbGQuaWQ7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZFtpZF0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIGlkIFwiICsgaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQnlJZFtpZF0gPSBmaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI2ZpZWxkc0FycmF5XG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNBcnJheSB8fCAodGhpcy5fZmllbGRzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5maWVsZHMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPbmVvZnMgb2YgdGhpcyBtZXNzYWdlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQG5hbWUgVHlwZSNvbmVvZnNBcnJheVxuICAgICAqIEB0eXBlIHtPbmVPZltdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIG9uZW9mc0FycmF5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lb2ZzQXJyYXkgfHwgKHRoaXMuX29uZW9mc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMub25lb2ZzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJlZ2lzdGVyZWQgY29uc3RydWN0b3IsIGlmIGFueSByZWdpc3RlcmVkLCBvdGhlcndpc2UgYSBnZW5lcmljIGNvbnN0cnVjdG9yLlxuICAgICAqIEFzc2lnbmluZyBhIGZ1bmN0aW9uIHJlcGxhY2VzIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGV4dGVuZCB7QGxpbmsgTWVzc2FnZX0geWV0LCBpdHMgcHJvdG90eXBlIHdpbGwgYmUgc2V0dXAgYWNjb3JkaW5nbHkgYW5kIHN0YXRpYyBtZXRob2RzIHdpbGwgYmUgcG9wdWxhdGVkLiBJZiBpdCBhbHJlYWR5IGV4dGVuZHMge0BsaW5rIE1lc3NhZ2V9LCBpdCB3aWxsIGp1c3QgcmVwbGFjZSB0aGUgaW50ZXJuYWwgY29uc3RydWN0b3IuXG4gICAgICogQG5hbWUgVHlwZSNjdG9yXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cbiAgICAgKi9cbiAgICBjdG9yOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY3RvciB8fCAodGhpcy5jdG9yID0gVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yKHRoaXMpKCkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHByb3BlciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBjdG9yLnByb3RvdHlwZTtcbiAgICAgICAgICAgIGlmICghKHByb3RvdHlwZSBpbnN0YW5jZW9mIE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgKGN0b3IucHJvdG90eXBlID0gbmV3IE1lc3NhZ2UoKSkuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UoY3Rvci5wcm90b3R5cGUsIHByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENsYXNzZXMgYW5kIG1lc3NhZ2VzIHJlZmVyZW5jZSB0aGVpciByZWZsZWN0ZWQgdHlwZVxuICAgICAgICAgICAgY3Rvci4kdHlwZSA9IGN0b3IucHJvdG90eXBlLiR0eXBlID0gdGhpcztcblxuICAgICAgICAgICAgLy8gTWl4IGluIHN0YXRpYyBtZXRob2RzXG4gICAgICAgICAgICB1dGlsLm1lcmdlKGN0b3IsIE1lc3NhZ2UsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9jdG9yID0gY3RvcjtcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBkZWZhdWx0IHZhbHVlcyBvbiB0aGVpciBwcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCk7IC8vIGVuc3VyZXMgYSBwcm9wZXIgdmFsdWVcblxuICAgICAgICAgICAgLy8gTWVzc2FnZXMgaGF2ZSBub24tZW51bWVyYWJsZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIGZvciBlYWNoIHZpcnR1YWwgb25lb2YgZmllbGRcbiAgICAgICAgICAgIHZhciBjdG9yUHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgY3RvclByb3BlcnRpZXNbdGhpcy5fb25lb2ZzQXJyYXlbaV0ucmVzb2x2ZSgpLm5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IHV0aWwub25lT2ZHZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHV0aWwub25lT2ZTZXR0ZXIodGhpcy5fb25lb2ZzQXJyYXlbaV0ub25lb2YpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGN0b3IucHJvdG90eXBlLCBjdG9yUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIHNwZWNpZmllZCB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cblR5cGUuZ2VuZXJhdGVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIGdlbmVyYXRlQ29uc3RydWN0b3IobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wicFwiXSwgbXR5cGUubmFtZSk7XG4gICAgLy8gZXhwbGljaXRseSBpbml0aWFsaXplIG11dGFibGUgb2JqZWN0L2FycmF5IGZpZWxkcyBzbyB0aGF0IHRoZXNlIGFyZW4ndCBqdXN0IGluaGVyaXRlZCBmcm9tIHRoZSBwcm90b3R5cGVcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXSkubWFwKSBnZW5cbiAgICAgICAgICAgIChcInRoaXMlcz17fVwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpKTtcbiAgICAgICAgZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPVtdXCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgIHJldHVybiBnZW5cbiAgICAoXCJpZihwKWZvcih2YXIga3M9T2JqZWN0LmtleXMocCksaT0wO2k8a3MubGVuZ3RoOysraSlpZihwW2tzW2ldXSE9bnVsbClcIikgLy8gb21pdCB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAoXCJ0aGlzW2tzW2ldXT1wW2tzW2ldXVwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59O1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHR5cGUpIHtcbiAgICB0eXBlLl9maWVsZHNCeUlkID0gdHlwZS5fZmllbGRzQXJyYXkgPSB0eXBlLl9vbmVvZnNBcnJheSA9IG51bGw7XG4gICAgZGVsZXRlIHR5cGUuZW5jb2RlO1xuICAgIGRlbGV0ZSB0eXBlLmRlY29kZTtcbiAgICBkZWxldGUgdHlwZS52ZXJpZnk7XG4gICAgcmV0dXJuIHR5cGU7XG59XG5cbi8qKlxuICogTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElUeXBlXG4gKiBAZXh0ZW5kcyBJTmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElPbmVPZj59IFtvbmVvZnNdIE9uZW9mIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElGaWVsZD59IGZpZWxkcyBGaWVsZCBkZXNjcmlwdG9yc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbZXh0ZW5zaW9uc10gRXh0ZW5zaW9uIHJhbmdlc1xuICogQHByb3BlcnR5IHtudW1iZXJbXVtdfSBbcmVzZXJ2ZWRdIFJlc2VydmVkIHJhbmdlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXA9ZmFsc2VdIFdoZXRoZXIgYSBsZWdhY3kgZ3JvdXAgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWVzc2FnZSB0eXBlIGZyb20gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtJVHlwZX0ganNvbiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge1R5cGV9IENyZWF0ZWQgbWVzc2FnZSB0eXBlXG4gKi9cblR5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcbiAgICB0eXBlLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLmZpZWxkcyksXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGUuYWRkKFxuICAgICAgICAgICAgKCB0eXBlb2YganNvbi5maWVsZHNbbmFtZXNbaV1dLmtleVR5cGUgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gTWFwRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgIDogRmllbGQuZnJvbUpTT04gKShuYW1lc1tpXSwganNvbi5maWVsZHNbbmFtZXNbaV1dKVxuICAgICAgICApO1xuICAgIGlmIChqc29uLm9uZW9mcylcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ub25lb2ZzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm9uZW9mc1tuYW1lc1tpXV0pKTtcbiAgICBpZiAoanNvbi5uZXN0ZWQpXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm5lc3RlZCksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBqc29uLm5lc3RlZFtuYW1lc1tpXV07XG4gICAgICAgICAgICB0eXBlLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLmZpZWxkcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEVudW0uZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnMubGVuZ3RoKVxuICAgICAgICB0eXBlLmV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnM7XG4gICAgaWYgKGpzb24ucmVzZXJ2ZWQgJiYganNvbi5yZXNlcnZlZC5sZW5ndGgpXG4gICAgICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIGlmIChqc29uLmdyb3VwKVxuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcbiAgICBpZiAoanNvbi5jb21tZW50KVxuICAgICAgICB0eXBlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0eXBlIHRvIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJVHlwZX0gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAgICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQub3B0aW9ucyB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwib25lb2ZzXCIgICAgICwgTmFtZXNwYWNlLmFycmF5VG9KU09OKHRoaXMub25lb2ZzQXJyYXksIHRvSlNPTk9wdGlvbnMpLFxuICAgICAgICBcImZpZWxkc1wiICAgICAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLmZpZWxkc0FycmF5LmZpbHRlcihmdW5jdGlvbihvYmopIHsgcmV0dXJuICFvYmouZGVjbGFyaW5nRmllbGQ7IH0pLCB0b0pTT05PcHRpb25zKSB8fCB7fSxcbiAgICAgICAgXCJleHRlbnNpb25zXCIgLCB0aGlzLmV4dGVuc2lvbnMgJiYgdGhpcy5leHRlbnNpb25zLmxlbmd0aCA/IHRoaXMuZXh0ZW5zaW9ucyA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJyZXNlcnZlZFwiICAgLCB0aGlzLnJlc2VydmVkICYmIHRoaXMucmVzZXJ2ZWQubGVuZ3RoID8gdGhpcy5yZXNlcnZlZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJncm91cFwiICAgICAgLCB0aGlzLmdyb3VwIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJuZXN0ZWRcIiAgICAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm5lc3RlZCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudFwiICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UeXBlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHNBcnJheSwgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBmaWVsZHMubGVuZ3RoKVxuICAgICAgICBmaWVsZHNbaSsrXS5yZXNvbHZlKCk7XG4gICAgdmFyIG9uZW9mcyA9IHRoaXMub25lb2ZzQXJyYXk7IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgb25lb2ZzLmxlbmd0aClcbiAgICAgICAgb25lb2ZzW2krK10ucmVzb2x2ZSgpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW25hbWVdXG4gICAgICAgIHx8IHRoaXMub25lb2ZzICYmIHRoaXMub25lb2ZzW25hbWVdXG4gICAgICAgIHx8IHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXG4gICAgICAgIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lIG9yLCBpZiBhIGZpZWxkLCB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYSBmaWVsZCB3aXRoIHRoaXMgaWRcbiAqL1xuVHlwZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBFeHRlbnNpb24gZmllbGRzIGFyZW4ndCBhY3R1YWwgZmllbGRzIG9uIHRoZSBkZWNsYXJpbmcgdHlwZSwgYnV0IG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAvLyBUaGUgcm9vdCBvYmplY3QgdGFrZXMgY2FyZSBvZiBhZGRpbmcgZGlzdGluY3Qgc2lzdGVyLWZpZWxkcyB0byB0aGUgcmVzcGVjdGl2ZSBleHRlbmRlZFxuICAgICAgICAvLyB0eXBlIGluc3RlYWQuXG5cbiAgICAgICAgLy8gYXZvaWRzIGNhbGxpbmcgdGhlIGdldHRlciBpZiBub3QgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIGNhbGxlZCBxdWl0ZSBmcmVxdWVudGx5XG4gICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdGhpcy5fZmllbGRzQnlJZFtvYmplY3QuaWRdIDogdGhpcy5maWVsZHNCeUlkW29iamVjdC5pZF0pXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIG9iamVjdC5pZCArIFwiIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChvYmplY3QuaWQpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIG9iamVjdC5pZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGlmIChvYmplY3QucGFyZW50KVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QubWVzc2FnZSA9IHRoaXM7XG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzKVxuICAgICAgICAgICAgdGhpcy5vbmVvZnMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIHR5cGVcbiAqL1xuVHlwZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU2VlIFR5cGUjYWRkIGZvciB0aGUgcmVhc29uIHdoeSBleHRlbnNpb24gZmllbGRzIGFyZSBleGNsdWRlZCBoZXJlLlxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzIHx8IHRoaXMuZmllbGRzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzIHx8IHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKGlkKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgaWQpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblR5cGUucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUodGhpcy5yZXNlcnZlZCwgbmFtZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqL1xuVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCB7QGxpbmsgVHlwZSNlbmNvZGV8ZW5jb2RlfSwge0BsaW5rIFR5cGUjZGVjb2RlfGRlY29kZX0gYW5kIHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9LlxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICovXG5UeXBlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIC8vIFNldHMgdXAgZXZlcnl0aGluZyBhdCBvbmNlIHNvIHRoYXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkb2VzIG5vdCBoYXZlIHRvIGJlIHJlLWV2YWx1YXRlZFxuICAgIC8vIG11bHRpcGxlIHRpbWVzIChWOCwgc29mdC1kZW9wdCBwcm90b3R5cGUtY2hlY2spLlxuXG4gICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5mdWxsTmFtZSxcbiAgICAgICAgdHlwZXMgICAgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLnJlc29sdmVkVHlwZSk7XG5cbiAgICAvLyBSZXBsYWNlIHNldHVwIG1ldGhvZHMgd2l0aCB0eXBlLXNwZWNpZmljIGdlbmVyYXRlZCBmdW5jdGlvbnNcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZXIodGhpcykoe1xuICAgICAgICBXcml0ZXIgOiBXcml0ZXIsXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxuICAgICAgICB1dGlsICAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy5kZWNvZGUgPSBkZWNvZGVyKHRoaXMpKHtcbiAgICAgICAgUmVhZGVyIDogUmVhZGVyLFxuICAgICAgICB0eXBlcyAgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudmVyaWZ5ID0gdmVyaWZpZXIodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLmZyb21PYmplY3QgPSBjb252ZXJ0ZXIuZnJvbU9iamVjdCh0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudG9PYmplY3QgPSBjb252ZXJ0ZXIudG9PYmplY3QodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcblxuICAgIC8vIEluamVjdCBjdXN0b20gd3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlc1xuICAgIHZhciB3cmFwcGVyID0gd3JhcHBlcnNbZnVsbE5hbWVdO1xuICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFRoaXMgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAvLyBpZiAod3JhcHBlci5mcm9tT2JqZWN0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbFRoaXMuZnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuZnJvbU9iamVjdCA9IHdyYXBwZXIuZnJvbU9iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHdyYXBwZXIudG9PYmplY3QpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy50b09iamVjdCA9IHRoaXMudG9PYmplY3Q7XG4gICAgICAgICAgICB0aGlzLnRvT2JqZWN0ID0gd3JhcHBlci50b09iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGVfc2V0dXAobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciAmJiB3cml0ZXIubGVuID8gd3JpdGVyLmZvcmsoKSA6IHdyaXRlcikubGRlbGltKCk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIG9mIHRoZSBtZXNzYWdlLCBpZiBrbm93biBiZWZvcmVoYW5kXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcjx7fT59IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICovXG5UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGVfc2V0dXAocmVhZGVyLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmRlY29kZShyZWFkZXIsIGxlbmd0aCk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiBSZWFkZXIpKVxuICAgICAgICByZWFkZXIgPSBSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBmaWVsZCB2YWx1ZXMgYXJlIHZhbGlkIGFuZCB0aGF0IHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge251bGx8c3RyaW5nfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuVHlwZS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5X3NldHVwKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnZlcmlmeShtZXNzYWdlKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKi9cblR5cGUucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9wdGlvbnMgYXMgdXNlZCBieSB7QGxpbmsgVHlwZSN0b09iamVjdH0gYW5kIHtAbGluayBNZXNzYWdlLnRvT2JqZWN0fS5cbiAqIEBpbnRlcmZhY2UgSUNvbnZlcnNpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbG9uZ3NdIExvbmcgY29udmVyc2lvbiB0eXBlLlxuICogVmFsaWQgdmFsdWVzIGFyZSBgU3RyaW5nYCBhbmQgYE51bWJlcmAgKHRoZSBnbG9iYWwgdHlwZXMpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgYSBwb3NzaWJseSB1bnNhZmUgbnVtYmVyIHdpdGhvdXQgYW5kIGEge0BsaW5rIExvbmd9IHdpdGggYSBsb25nIGxpYnJhcnkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZW51bXNdIEVudW0gdmFsdWUgY29udmVyc2lvbiB0eXBlLlxuICogT25seSB2YWxpZCB2YWx1ZSBpcyBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIGlzIHRoZSBudW1lcmljIGlkLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2J5dGVzXSBCeXRlcyB2YWx1ZSBjb252ZXJzaW9uIHR5cGUuXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBBcnJheWAgYW5kIChhIGJhc2U2NCBlbmNvZGVkKSBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlcykuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCB1c3VhbGx5IGlzIGEgQnVmZmVyIHVuZGVyIG5vZGUgYW5kIGFuIFVpbnQ4QXJyYXkgaW4gdGhlIGJyb3dzZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWZhdWx0cz1mYWxzZV0gQWxzbyBzZXRzIGRlZmF1bHQgdmFsdWVzIG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheXM9ZmFsc2VdIFNldHMgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIHJlcGVhdGVkIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29iamVjdHM9ZmFsc2VdIFNldHMgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBtYXAgZmllbGRzIGV2ZW4gaWYgYGRlZmF1bHRzPWZhbHNlYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25lb2ZzPWZhbHNlXSBJbmNsdWRlcyB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgc2V0IHRvIHRoZSBwcmVzZW50IGZpZWxkJ3MgbmFtZSwgaWYgYW55XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqc29uPWZhbHNlXSBQZXJmb3JtcyBhZGRpdGlvbmFsIEpTT04gY29tcGF0aWJpbGl0eSBjb252ZXJzaW9ucywgaS5lLiBOYU4gYW5kIEluZmluaXR5IHRvIHN0cmluZ3NcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICovXG5UeXBlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIFR5cGUuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgVHlwZURlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPn0gdGFyZ2V0IFRhcmdldCBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICovXG5cbi8qKlxuICogVHlwZSBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXG4gKiBAcmV0dXJucyB7VHlwZURlY29yYXRvcjxUPn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqL1xuVHlwZS5kID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHR5cGVEZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHRhcmdldCwgdHlwZU5hbWUpO1xuICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29tbW9uIHR5cGUgY29uc3RhbnRzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgdHlwZXMgPSBleHBvcnRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBzID0gW1xuICAgIFwiZG91YmxlXCIsICAgLy8gMFxuICAgIFwiZmxvYXRcIiwgICAgLy8gMVxuICAgIFwiaW50MzJcIiwgICAgLy8gMlxuICAgIFwidWludDMyXCIsICAgLy8gM1xuICAgIFwic2ludDMyXCIsICAgLy8gNFxuICAgIFwiZml4ZWQzMlwiLCAgLy8gNVxuICAgIFwic2ZpeGVkMzJcIiwgLy8gNlxuICAgIFwiaW50NjRcIiwgICAgLy8gN1xuICAgIFwidWludDY0XCIsICAgLy8gOFxuICAgIFwic2ludDY0XCIsICAgLy8gOVxuICAgIFwiZml4ZWQ2NFwiLCAgLy8gMTBcbiAgICBcInNmaXhlZDY0XCIsIC8vIDExXG4gICAgXCJib29sXCIsICAgICAvLyAxMlxuICAgIFwic3RyaW5nXCIsICAgLy8gMTNcbiAgICBcImJ5dGVzXCIgICAgIC8vIDE0XG5dO1xuXG5mdW5jdGlvbiBiYWtlKHZhbHVlcywgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAwLCBvID0ge307XG4gICAgb2Zmc2V0IHw9IDA7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZXMubGVuZ3RoKSBvW3NbaSArIG9mZnNldF1dID0gdmFsdWVzW2krK107XG4gICAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogQmFzaWMgdHlwZSB3aXJlIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBieXRlcz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMuYmFzaWMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDIsXG4gICAgLyogYnl0ZXMgICAgKi8gMlxuXSk7XG5cbi8qKlxuICogQmFzaWMgdHlwZSBkZWZhdWx0cy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRvdWJsZT0wIERvdWJsZSBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9MCBGbG9hdCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBJbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVWludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9MCBGaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj0wIFNmaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIEludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBVaW50NjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFNpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0wIEZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTAgU2ZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBib29sPWZhbHNlIEJvb2wgZGVmYXVsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0cmluZz1cIlwiIFN0cmluZyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBieXRlcz1BcnJheSgwKSBCeXRlcyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bGx9IG1lc3NhZ2U9bnVsbCBNZXNzYWdlIGRlZmF1bHRcbiAqL1xudHlwZXMuZGVmYXVsdHMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAwLFxuICAgIC8qIGZsb2F0ICAgICovIDAsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gMCxcbiAgICAvKiBzZml4ZWQzMiAqLyAwLFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDAsXG4gICAgLyogc2ZpeGVkNjQgKi8gMCxcbiAgICAvKiBib29sICAgICAqLyBmYWxzZSxcbiAgICAvKiBzdHJpbmcgICAqLyBcIlwiLFxuICAgIC8qIGJ5dGVzICAgICovIHV0aWwuZW1wdHlBcnJheSxcbiAgICAvKiBtZXNzYWdlICAqLyBudWxsXG5dKTtcblxuLyoqXG4gKiBCYXNpYyBsb25nIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmxvbmcgPSBiYWtlKFtcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDFcbl0sIDcpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIG1hcCBrZXlzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3aXJlIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvb2w9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RyaW5nPTIgTGRlbGltIHdpcmUgdHlwZVxuICovXG50eXBlcy5tYXBLZXkgPSBiYWtlKFtcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxuICAgIC8qIHNmaXhlZDMyICovIDUsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxuICAgIC8qIGJvb2wgICAgICovIDAsXG4gICAgLyogc3RyaW5nICAgKi8gMlxuXSwgMik7XG5cbi8qKlxuICogQWxsb3dlZCB0eXBlcyBmb3IgcGFja2VkIHJlcGVhdGVkIGZpZWxkcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICovXG50eXBlcy5wYWNrZWQgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwXG5dKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFZhcmlvdXMgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciByb290cyA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xuXG52YXIgVHlwZSwgLy8gY3ljbGljXG4gICAgRW51bTtcblxudXRpbC5jb2RlZ2VuID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2NvZGVnZW5cIik7XG51dGlsLmZldGNoICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmV0Y2hcIik7XG51dGlsLnBhdGggICAgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcGF0aFwiKTtcblxuLyoqXG4gKiBOb2RlJ3MgZnMgbW9kdWxlIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqL1xudXRpbC5mcyA9IHV0aWwuaW5xdWlyZShcImZzXCIpO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCdzIHZhbHVlcyB0byBhbiBhcnJheS5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBPYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge0FycmF5LjwqPn0gQ29udmVydGVkIGFycmF5XG4gKi9cbnV0aWwudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCkge1xuICAgICAgICB2YXIga2V5cyAgPSBPYmplY3Qua2V5cyhvYmplY3QpLFxuICAgICAgICAgICAgYXJyYXkgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBrZXlzLmxlbmd0aClcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IG9iamVjdFtrZXlzW2luZGV4KytdXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIGtleXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlaXIgcmVzcGVjdGl2ZSB2YWx1ZSB0byBhbiBvYmplY3QsIG9taXR0aW5nIHVuZGVmaW5lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5LjwqPn0gYXJyYXkgQXJyYXkgdG8gY29udmVydFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBDb252ZXJ0ZWQgb2JqZWN0XG4gKi9cbnV0aWwudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChhcnJheSkge1xuICAgIHZhciBvYmplY3QgPSB7fSxcbiAgICAgICAgaW5kZXggID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGFycmF5W2luZGV4KytdLFxuICAgICAgICAgICAgdmFsID0gYXJyYXlbaW5kZXgrK107XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxudmFyIHNhZmVQcm9wQmFja3NsYXNoUmUgPSAvXFxcXC9nLFxuICAgIHNhZmVQcm9wUXVvdGVSZSAgICAgPSAvXCIvZztcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSlMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNSZXNlcnZlZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWQobmFtZSkge1xuICAgIHJldHVybiAvXig/OmRvfGlmfGlufGZvcnxsZXR8bmV3fHRyeXx2YXJ8Y2FzZXxlbHNlfGVudW18ZXZhbHxmYWxzZXxudWxsfHRoaXN8dHJ1ZXx2b2lkfHdpdGh8YnJlYWt8Y2F0Y2h8Y2xhc3N8Y29uc3R8c3VwZXJ8dGhyb3d8d2hpbGV8eWllbGR8ZGVsZXRlfGV4cG9ydHxpbXBvcnR8cHVibGljfHJldHVybnxzdGF0aWN8c3dpdGNofHR5cGVvZnxkZWZhdWx0fGV4dGVuZHN8ZmluYWxseXxwYWNrYWdlfHByaXZhdGV8Y29udGludWV8ZGVidWdnZXJ8ZnVuY3Rpb258YXJndW1lbnRzfGludGVyZmFjZXxwcm90ZWN0ZWR8aW1wbGVtZW50c3xpbnN0YW5jZW9mKSQvLnRlc3QobmFtZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzYWZlIHByb3BlcnR5IGFjY2Vzc29yIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTYWZlIGFjY2Vzc29yXG4gKi9cbnV0aWwuc2FmZVByb3AgPSBmdW5jdGlvbiBzYWZlUHJvcChwcm9wKSB7XG4gICAgaWYgKCEvXlskXFx3X10rJC8udGVzdChwcm9wKSB8fCB1dGlsLmlzUmVzZXJ2ZWQocHJvcCkpXG4gICAgICAgIHJldHVybiBcIltcXFwiXCIgKyBwcm9wLnJlcGxhY2Uoc2FmZVByb3BCYWNrc2xhc2hSZSwgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKHNhZmVQcm9wUXVvdGVSZSwgXCJcXFxcXFxcIlwiKSArIFwiXFxcIl1cIjtcbiAgICByZXR1cm4gXCIuXCIgKyBwcm9wO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIHVwcGVyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwudWNGaXJzdCA9IGZ1bmN0aW9uIHVjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG52YXIgY2FtZWxDYXNlUmUgPSAvXyhbYS16XSkvZztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmNhbWVsQ2FzZSA9IGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLCAxKVxuICAgICAgICAgKyBzdHIuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgICAgICAucmVwbGFjZShjYW1lbENhc2VSZSwgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiAkMS50b1VwcGVyQ2FzZSgpOyB9KTtcbn07XG5cbi8qKlxuICogQ29tcGFyZXMgcmVmbGVjdGVkIGZpZWxkcyBieSBpZC5cbiAqIEBwYXJhbSB7RmllbGR9IGEgRmlyc3QgZmllbGRcbiAqIEBwYXJhbSB7RmllbGR9IGIgU2Vjb25kIGZpZWxkXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBDb21wYXJpc29uIHZhbHVlXG4gKi9cbnV0aWwuY29tcGFyZUZpZWxkc0J5SWQgPSBmdW5jdGlvbiBjb21wYXJlRmllbGRzQnlJZChhLCBiKSB7XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciB0eXBlcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFQ+fSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVOYW1lXSBUeXBlIG5hbWUsIGRlZmF1bHRzIHRvIHRoZSBjb25zdHJ1Y3RvcidzIG5hbWVcbiAqIEByZXR1cm5zIHtUeXBlfSBSZWZsZWN0ZWQgdHlwZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAcHJvcGVydHkge1Jvb3R9IHJvb3QgRGVjb3JhdG9ycyByb290XG4gKi9cbnV0aWwuZGVjb3JhdGVUeXBlID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKGN0b3IsIHR5cGVOYW1lKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3Rvci4kdHlwZSkge1xuICAgICAgICBpZiAodHlwZU5hbWUgJiYgY3Rvci4kdHlwZS5uYW1lICE9PSB0eXBlTmFtZSkge1xuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QucmVtb3ZlKGN0b3IuJHR5cGUpO1xuICAgICAgICAgICAgY3Rvci4kdHlwZS5uYW1lID0gdHlwZU5hbWU7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoY3Rvci4kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3IuJHR5cGU7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIVR5cGUpXG4gICAgICAgIFR5cGUgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xuXG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZSh0eXBlTmFtZSB8fCBjdG9yLm5hbWUpO1xuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZCh0eXBlKTtcbiAgICB0eXBlLmN0b3IgPSBjdG9yOyAvLyBzZXRzIHVwIC5lbmNvZGUsIC5kZWNvZGUgZXRjLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gdHlwZTtcbn07XG5cbnZhciBkZWNvcmF0ZUVudW1JbmRleCA9IDA7XG5cbi8qKlxuICogRGVjb3JhdG9yIGhlbHBlciBmb3IgZW51bXMgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBFbnVtIG9iamVjdFxuICogQHJldHVybnMge0VudW19IFJlZmxlY3RlZCBlbnVtXG4gKi9cbnV0aWwuZGVjb3JhdGVFbnVtID0gZnVuY3Rpb24gZGVjb3JhdGVFbnVtKG9iamVjdCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG9iamVjdC4kdHlwZSlcbiAgICAgICAgcmV0dXJuIG9iamVjdC4kdHlwZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFFbnVtKVxuICAgICAgICBFbnVtID0gcmVxdWlyZShcIi4vZW51bVwiKTtcblxuICAgIHZhciBlbm0gPSBuZXcgRW51bShcIkVudW1cIiArIGRlY29yYXRlRW51bUluZGV4KyssIG9iamVjdCk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGVubSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgXCIkdHlwZVwiLCB7IHZhbHVlOiBlbm0sIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiBlbm07XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBieSBwcm9wZXJ0eSBwYXRoLiBJZiBhIHZhbHVlIGFscmVhZHkgZXhpc3RzLCBpdCBpcyB0dXJuZWQgdG8gYW4gYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGRvdCAnLicgZGVsaW1pdGVkIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbnV0aWwuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgZnVuY3Rpb24gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSBzZXRQcm9wKGRzdFtwYXJ0XSB8fCB7fSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGRzdFtwYXJ0XTtcbiAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQocHJldlZhbHVlKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgZHN0W3BhcnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRzdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZHN0IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICAgIGlmICghcGF0aClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicGF0aCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICByZXR1cm4gc2V0UHJvcChkc3QsIHBhdGgsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIHJvb3QgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgdXRpbC5kZWNvcmF0ZVJvb3RcbiAqIEB0eXBlIHtSb290fVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1dGlsLCBcImRlY29yYXRlUm9vdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RzW1wiZGVjb3JhdGVkXCJdIHx8IChyb290c1tcImRlY29yYXRlZFwiXSA9IG5ldyAocmVxdWlyZShcIi4vcm9vdFwiKSkoKSk7XG4gICAgfVxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTG9uZ0JpdHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXG4gKiBAY2xhc3NkZXNjIEhlbHBlciBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbyBMb3cgMzIgYml0cywgdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXG4gKi9cbmZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcbiAgICAvLyBnZW5lcmF0ZWQgY29udmVydGVyIGNvZGUgbWlnaHQgc3RpbGwgY2FsbCB0aGUgY3RvciB3aXRoIHNpZ25lZCAzMmJpdHMuIGtlcHQgZm9yIGNvbXBhdC5cblxuICAgIC8qKlxuICAgICAqIExvdyBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuXG4gICAgLyoqXG4gICAgICogSGlnaCBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaSA9IGhpID4+PiAwO1xufVxuXG4vKipcbiAqIFplcm8gYml0cy5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7dXRpbC5Mb25nQml0c31cbiAqL1xudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG56ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcblxuLyoqXG4gKiBaZXJvIGhhc2guXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcbiAgICAgICAgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcbiAgICAgICAgICAgIGhpID0gfnRoaXMuaGkgICAgID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5Njtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBsb25nLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xuICAgICAgICA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbn07XG5cbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXG4gKi9cbkxvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcbiAgICAsXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICApO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xuICAgIHRoaXMuaGkgID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZGVjb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5oaSAgPSAoIHRoaXMuaGkgPj4+IDEgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBMZW5ndGhcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgcGFydDAgPSAgdGhpcy5sbyxcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcbiAgICByZXR1cm4gcGFydDIgPT09IDBcbiAgICAgICAgID8gcGFydDEgPT09IDBcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4ID8gNSA6IDZcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5hbWU7IH0gfSk7XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB2ZXJpZmllcjtcblxudmFyIEVudW0gICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gaW52YWxpZChmaWVsZCwgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmllbGQubmFtZSArIFwiOiBcIiArIGV4cGVjdGVkICsgKGZpZWxkLnJlcGVhdGVkICYmIGV4cGVjdGVkICE9PSBcImFycmF5XCIgPyBcIltdXCIgOiBmaWVsZC5tYXAgJiYgZXhwZWN0ZWQgIT09IFwib2JqZWN0XCIgPyBcIntrOlwiK2ZpZWxkLmtleVR5cGUrXCJ9XCIgOiBcIlwiKSArIFwiIGV4cGVjdGVkXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCB2YWx1ZSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUpIHtcbiAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHsgZ2VuXG4gICAgICAgICAgICAoXCJzd2l0Y2goJXMpe1wiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJlbnVtIHZhbHVlXCIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzKSwgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJjYXNlICVpOlwiLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzW2tleXNbal1dKTtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwie1wiKVxuICAgICAgICAgICAgICAgIChcInZhciBlPXR5cGVzWyVpXS52ZXJpZnkoJXMpO1wiLCBmaWVsZEluZGV4LCByZWYpXG4gICAgICAgICAgICAgICAgKFwiaWYoZSlcIilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWorZVwiLCBmaWVsZC5uYW1lICsgXCIuXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNJbnRlZ2VyKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykmJiEoJXMmJnV0aWwuaXNJbnRlZ2VyKCVzLmxvdykmJnV0aWwuaXNJbnRlZ2VyKCVzLmhpZ2gpKSlcIiwgcmVmLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJ8TG9uZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcIm51bWJlclxcXCIpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJudW1iZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYodHlwZW9mICVzIT09XFxcImJvb2xlYW5cXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhblwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzU3RyaW5nKCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcInN0cmluZ1wiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmdHlwZW9mICVzLmxlbmd0aD09PVxcXCJudW1iZXJcXFwifHx1dGlsLmlzU3RyaW5nKCVzKSkpXCIsIHJlZiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYnVmZmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIGtleSB2ZXJpZmllci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCByZWYpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuICAgIHN3aXRjaCAoZmllbGQua2V5VHlwZSkge1xuICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTMyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXIga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTY0UmUudGVzdCglcykpXCIsIHJlZikgLy8gc2VlIGNvbW1lbnQgYWJvdmU6IHggaXMgb2ssIGQgaXMgbm90XG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmcga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmtleTJSZS50ZXN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYm9vbGVhbiBrZXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHZlcmlmaWVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIHZlcmlmaWVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cblxuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiXSwgbXR5cGUubmFtZSArIFwiJHZlcmlmeVwiKVxuICAgIChcImlmKHR5cGVvZiBtIT09XFxcIm9iamVjdFxcXCJ8fG09PT1udWxsKVwiKVxuICAgICAgICAoXCJyZXR1cm4lalwiLCBcIm9iamVjdCBleHBlY3RlZFwiKTtcbiAgICB2YXIgb25lb2ZzID0gbXR5cGUub25lb2ZzQXJyYXksXG4gICAgICAgIHNlZW5GaXJzdEZpZWxkID0ge307XG4gICAgaWYgKG9uZW9mcy5sZW5ndGgpIGdlblxuICAgIChcInZhciBwPXt9XCIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyBtdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLFxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwiaWYoJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcmVmLCBmaWVsZC5uYW1lKTsgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuXG4gICAgICAgIC8vIG1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCF1dGlsLmlzT2JqZWN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwib2JqZWN0XCIpKVxuICAgICAgICAgICAgKFwidmFyIGs9T2JqZWN0LmtleXMoJXMpXCIsIHJlZilcbiAgICAgICAgICAgIChcImZvcih2YXIgaT0wO2k8ay5sZW5ndGg7KytpKXtcIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5S2V5KGdlbiwgZmllbGQsIFwia1tpXVwiKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltrW2ldXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAgICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiYXJyYXlcIikpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpe1wiLCByZWYpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2ldXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIHJlcXVpcmVkIG9yIHByZXNlbnQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uZW9mUHJvcCA9IHV0aWwuc2FmZVByb3AoZmllbGQucGFydE9mLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPT09IDEpIGdlblxuICAgICAgICAgICAgKFwiaWYocCVzPT09MSlcIiwgb25lb2ZQcm9wKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGZpZWxkLnBhcnRPZi5uYW1lICsgXCI6IG11bHRpcGxlIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICBzZWVuRmlyc3RGaWVsZFtmaWVsZC5wYXJ0T2YubmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgKFwicCVzPTFcIiwgb25lb2ZQcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAgICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBudWxsXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBXcmFwcGVycyBmb3IgY29tbW9uIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLElXcmFwcGVyPn1cbiAqIEBjb25zdFxuICovXG52YXIgd3JhcHBlcnMgPSBleHBvcnRzO1xuXG52YXIgTWVzc2FnZSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG5cbi8qKlxuICogRnJvbSBvYmplY3QgY29udmVydGVyIHBhcnQgb2YgYW4ge0BsaW5rIElXcmFwcGVyfS5cbiAqIEB0eXBlZGVmIFdyYXBwZXJGcm9tT2JqZWN0Q29udmVydGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0aGlzIFR5cGVcbiAqL1xuXG4vKipcbiAqIFRvIG9iamVjdCBjb252ZXJ0ZXIgcGFydCBvZiBhbiB7QGxpbmsgSVdyYXBwZXJ9LlxuICogQHR5cGVkZWYgV3JhcHBlclRvT2JqZWN0Q29udmVydGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICogQHRoaXMgVHlwZVxuICovXG5cbi8qKlxuICogQ29tbW9uIHR5cGUgd3JhcHBlciBwYXJ0IG9mIHtAbGluayB3cmFwcGVyc30uXG4gKiBAaW50ZXJmYWNlIElXcmFwcGVyXG4gKiBAcHJvcGVydHkge1dyYXBwZXJGcm9tT2JqZWN0Q29udmVydGVyfSBbZnJvbU9iamVjdF0gRnJvbSBvYmplY3QgY29udmVydGVyXG4gKiBAcHJvcGVydHkge1dyYXBwZXJUb09iamVjdENvbnZlcnRlcn0gW3RvT2JqZWN0XSBUbyBvYmplY3QgY29udmVydGVyXG4gKi9cblxuLy8gQ3VzdG9tIHdyYXBwZXIgZm9yIEFueVxud3JhcHBlcnNbXCIuZ29vZ2xlLnByb3RvYnVmLkFueVwiXSA9IHtcblxuICAgIGZyb21PYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICAgIC8vIHVud3JhcCB2YWx1ZSB0eXBlIGlmIG1hcHBlZFxuICAgICAgICBpZiAob2JqZWN0ICYmIG9iamVjdFtcIkB0eXBlXCJdKSB7XG4gICAgICAgICAgICAgLy8gT25seSB1c2UgZnVsbHkgcXVhbGlmaWVkIHR5cGUgbmFtZSBhZnRlciB0aGUgbGFzdCAnLydcbiAgICAgICAgICAgIHZhciBuYW1lID0gb2JqZWN0W1wiQHR5cGVcIl0uc3Vic3RyaW5nKG9iamVjdFtcIkB0eXBlXCJdLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIHR5cGVfdXJsIGRvZXMgbm90IGFjY2VwdCBsZWFkaW5nIFwiLlwiXG4gICAgICAgICAgICAgICAgdmFyIHR5cGVfdXJsID0gb2JqZWN0W1wiQHR5cGVcIl0uY2hhckF0KDApID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtcIkB0eXBlXCJdLnN1YnN0cigxKSA6IG9iamVjdFtcIkB0eXBlXCJdO1xuICAgICAgICAgICAgICAgIC8vIHR5cGVfdXJsIHByZWZpeCBpcyBvcHRpb25hbCwgYnV0IHBhdGggc2VwZXJhdG9yIGlzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfdXJsLmluZGV4T2YoXCIvXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybCA9IFwiL1wiICsgdHlwZV91cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVfdXJsOiB0eXBlX3VybCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR5cGUuZW5jb2RlKHR5cGUuZnJvbU9iamVjdChvYmplY3QpKS5maW5pc2goKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbU9iamVjdChvYmplY3QpO1xuICAgIH0sXG5cbiAgICB0b09iamVjdDogZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuXG4gICAgICAgIC8vIERlZmF1bHQgcHJlZml4XG4gICAgICAgIHZhciBnb29nbGVBcGkgPSBcInR5cGUuZ29vZ2xlYXBpcy5jb20vXCI7XG4gICAgICAgIHZhciBwcmVmaXggPSBcIlwiO1xuICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLy8gZGVjb2RlIHZhbHVlIGlmIHJlcXVlc3RlZCBhbmQgdW5tYXBwZWRcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICYmIG1lc3NhZ2UudHlwZV91cmwgJiYgbWVzc2FnZS52YWx1ZSkge1xuICAgICAgICAgICAgLy8gT25seSB1c2UgZnVsbHkgcXVhbGlmaWVkIHR5cGUgbmFtZSBhZnRlciB0aGUgbGFzdCAnLydcbiAgICAgICAgICAgIG5hbWUgPSBtZXNzYWdlLnR5cGVfdXJsLnN1YnN0cmluZyhtZXNzYWdlLnR5cGVfdXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgICAgICAgICAgLy8gU2VwYXJhdGUgdGhlIHByZWZpeCB1c2VkXG4gICAgICAgICAgICBwcmVmaXggPSBtZXNzYWdlLnR5cGVfdXJsLnN1YnN0cmluZygwLCBtZXNzYWdlLnR5cGVfdXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdHlwZS5kZWNvZGUobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3cmFwIHZhbHVlIGlmIHVubWFwcGVkXG4gICAgICAgIGlmICghKG1lc3NhZ2UgaW5zdGFuY2VvZiB0aGlzLmN0b3IpICYmIG1lc3NhZ2UgaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gbWVzc2FnZS4kdHlwZS50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlTmFtZSA9IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWVbMF0gPT09IFwiLlwiID9cbiAgICAgICAgICAgICAgICBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lLnN1YnN0cigxKSA6IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWU7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHR5cGUuZ29vZ2xlYXBpcy5jb20gcHJlZml4IGlmIG5vIHByZWZpeCBpcyB1c2VkXG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gZ29vZ2xlQXBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IHByZWZpeCArIG1lc3NhZ2VOYW1lO1xuICAgICAgICAgICAgb2JqZWN0W1wiQHR5cGVcIl0gPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwiY29uc3QgcXVpY2tTZWxlY3QgPSByZXF1aXJlKCcuL3NyYy9xdWlja1NlbGVjdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gcXVpY2tTZWxlY3RcbiIsImNvbnN0IHJhbmRJbnRCZXR3ZWVuID0gKG1pbiwgbWF4KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpICsgbWluXG5cbmNvbnN0IGRlZmF1bHRBY2Nlc3NvciA9IGVsZW1lbnQgPT4gZWxlbWVudFxuXG5jb25zdCBjaGVja0FyZ3VtZW50cyA9IChhcnJheSwgaywgYWNjZXNzb3IpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGEgamF2YXNjcmlwdCBhcnJheSEnKVxuICBpZiAodHlwZW9mIGsgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzZWNvbmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgamF2YXNjcmlwdCBudW1iZXIhJylcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGhpcmQgYXJndW1lbnQgc2hvdWxkIGJlIGEgamF2YXNjcmlwdCBmdW5jdGlvbiEnKVxuICBpZiAoYXJyYXkubGVuZ3RoIDwgaykge1xuICAgIHRocm93IG5ldyBFcnJvcignSyBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBhcnJheSBsZW5ndGghJylcbiAgfVxufVxuXG4vKipcbiAqIFF1aWNrc2VsZWN0XG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlja3NlbGVjdFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgLSBEYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gayAtIFBvc2l0aW9uIG9mIHNtYWxsZXN0IGVsZW1lbnQgKHN0YXJ0cyBmcm9tIDApXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhY2Nlc3NvciAtIEZ1bmN0aW9uIHdoaWNoIHJldHVybiB2YWx1ZSBmb3IgcHJvY2Vzc2luZyAob3B0aW9uYWwpXG4gKi9cbmNvbnN0IHF1aWNrU2VsZWN0ID0gKGFycmF5LCBrLCBhY2Nlc3NvciA9IGRlZmF1bHRBY2Nlc3NvcikgPT4ge1xuICBjaGVja0FyZ3VtZW50cyhhcnJheSwgaywgYWNjZXNzb3IpXG4gIGlmIChhcnJheS5sZW5ndGggPT09IDEgJiYgayA9PT0gMCkgcmV0dXJuIGFycmF5WzBdXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBwaXZvdCA9IGFjY2Vzc29yKGFycmF5W3JhbmRJbnRCZXR3ZWVuKDAsIGFycmF5Lmxlbmd0aCAtIDEpXSlcbiAgICBjb25zdCBsb3dzID0gW11cbiAgICBjb25zdCBoaWdocyA9IFtdXG4gICAgY29uc3QgcGl2b3RzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoYWNjZXNzb3IoYXJyYXlbaV0pIDwgcGl2b3QpIGxvd3MucHVzaChhcnJheVtpXSlcbiAgICAgIGlmIChhY2Nlc3NvcihhcnJheVtpXSkgPiBwaXZvdCkgaGlnaHMucHVzaChhcnJheVtpXSlcbiAgICAgIGlmIChhY2Nlc3NvcihhcnJheVtpXSkgPT09IHBpdm90KSBwaXZvdHMucHVzaChhcnJheVtpXSlcbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICAgIGlmIChrIDwgbG93cy5sZW5ndGgpIHtcbiAgICAgIGFycmF5ID0gbG93c1xuICAgIH0gZWxzZSBpZiAoayA8IGxvd3MubGVuZ3RoICsgcGl2b3RzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHBpdm90c1swXVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheSA9IGhpZ2hzXG4gICAgICBrID0gayAtIGxvd3MubGVuZ3RoIC0gcGl2b3RzLmxlbmd0aFxuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdWlja1NlbGVjdFxuIiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHtCYXNlV2lkZ2V0fSBmcm9tICcuL0NvbXBvbmVudHMvQmFzZVdpZGdldCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4vQ29tcG9uZW50cy9CYXNlQ29tcG9uZW50JztcbmltcG9ydCB7VG9vbGJhcn0gZnJvbSAnLi9Db21wb25lbnRzL1Rvb2xiYXInO1xuaW1wb3J0IHtQbG90MmRQYXRoc1dpZGdldH0gZnJvbSAnLi9Db21wb25lbnRzL1Bsb3QyZFBhdGhzV2lkZ2V0JztcbmltcG9ydCB7TWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0fSBmcm9tICcuL0NvbXBvbmVudHMvTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0JztcbmltcG9ydCB7SW1hZ2VTZWxlY3Rpb25XaWRnZXR9IGZyb20gJy4vQ29tcG9uZW50cy9JbWFnZVNlbGVjdGlvbldpZGdldCc7XG5pbXBvcnQge0xheW91dEZyYW1ld29ya30gZnJvbSAnLi9MYXlvdXRGcmFtZXdvcmsnO1xuaW1wb3J0IHtGcmFtZSwgQ29tcG9uZW50VHlwZSwgQ29tcG9uZW50SW5pdEluZm8sIEFyZ3VtZW50cywgQXBwRGF0YX0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge0tleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb24sIEtleWVkUG9pbnREZXJpdmF0aW9uRnVuY3Rpb259IGZyb20gJy4vZGV2bGliL0RldkxpYlR5cGVzJztcbmltcG9ydCB7RGF0YUV2ZW50c30gZnJvbSAnLi9EYXRhTW9kZWwvRGF0YUV2ZW50cyc7XG5pbXBvcnQgeyBEZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldCB9IGZyb20gJy4vQ29tcG9uZW50cy9EZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldCc7XG5pbXBvcnQgeyBEZXZsaWJUU1V0aWwgfSBmcm9tICcuL2RldmxpYi9EZXZsaWJUU1V0aWwnO1xuXG5leHBvcnQgY2xhc3MgQXBwPERhdGFUeXBlIGV4dGVuZHMgQXBwRGF0YTxEYXRhU3BlY1R5cGU+LCBEYXRhU3BlY1R5cGU+IHtcblx0XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG5cdFx0XHRcdGZyb21Dc3ZPYmplY3Q6IChcblx0XHRcdFx0XHRkYXRhOiBkMy5EU1ZSb3dBcnJheTxzdHJpbmc+LFxuXHRcdFx0XHRcdGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSxcblx0XHRcdFx0XHRkZXJpdmVkUG9pbnREYXRhRnVuY3Rpb25zOiBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uW10sXG5cdFx0XHRcdFx0ZGF0YVNwZWM6IERhdGFTcGVjVHlwZVxuXHRcdFx0XHRcdCkgPT4gRGF0YVR5cGUsXG5cdFx0XHRcdGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSxcblx0XHRcdFx0ZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9uczogS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbltdKSB7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdHRoaXMuX2NvbXBvbmVudExpc3QgPSBbXTtcblx0XHR0aGlzLl9sYXlvdXRGcmFtZXdvcmsgPSBuZXcgTGF5b3V0RnJhbWV3b3JrKGNvbnRhaW5lcik7XG5cdFx0dGhpcy5fZGF0YUZyb21DU1ZPYmplY3QgPSBmcm9tQ3N2T2JqZWN0O1xuXHRcdHRoaXMuX3RyYWNrRGVyaXZhdGlvbkZ1bmN0aW9ucyA9IGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM7XG5cdFx0dGhpcy5fcG9pbnREZXJpdmF0aW9uRnVuY3Rpb25zID0gZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9ucztcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKERhdGFFdmVudHMuYnJ1c2hDaGFuZ2UsIChlOiBFdmVudCkgPT4ge3RoaXMub25CcnVzaENoYW5nZSgpfSk7XG5cdH1cblxuXHRcblx0cHJpdmF0ZSBfZGF0YSA6IERhdGFUeXBlO1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IERhdGFUeXBlIHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fVxuXHRcblx0cHJpdmF0ZSBfY29udGFpbmVyIDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY29udGFpbmVyKCkgOiBIVE1MRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fVxuXG5cdHByaXZhdGUgX2NvbXBvbmVudExpc3QgOiBCYXNlQ29tcG9uZW50W107XG5cdHB1YmxpYyBnZXQgY29tcG9uZW50TGlzdCgpIDogQmFzZUNvbXBvbmVudFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fY29tcG9uZW50TGlzdDtcblx0fVxuXG5cdHByaXZhdGUgX2xheW91dEZyYW1ld29yayA6IExheW91dEZyYW1ld29yaztcblx0cHVibGljIGdldCBsYXlvdXRGcmFtZXdvcmsoKSA6IExheW91dEZyYW1ld29yayB7XG5cdFx0cmV0dXJuIHRoaXMuX2xheW91dEZyYW1ld29yaztcblx0fVxuXG5cdHByaXZhdGUgX2NvbXBvbmVudENvbnRhaW5lcnMgOiBNYXA8SFRNTEVsZW1lbnQsIENvbXBvbmVudEluaXRJbmZvIHwgQ29tcG9uZW50VHlwZT47XG5cdHB1YmxpYyBnZXQgY29tcG9uZW50Q29udGFpbmVycygpIDogTWFwPEhUTUxFbGVtZW50LCBDb21wb25lbnRJbml0SW5mbyB8IENvbXBvbmVudFR5cGU+IHtcblx0XHRyZXR1cm4gdGhpcy5fY29tcG9uZW50Q29udGFpbmVycztcblx0fVxuXG5cdHByaXZhdGUgX2RhdGFGcm9tQ1NWT2JqZWN0IDogKGRhdGE6IGQzLkRTVlJvd0FycmF5PHN0cmluZz4sIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSwgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9uczogS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbltdLCBkYXRhU3BlYzogRGF0YVNwZWNUeXBlKSA9PiBEYXRhVHlwZTtcblx0cHVibGljIGdldCBkYXRhRnJvbUNTVk9iamVjdCgpIDogKGRhdGE6IGQzLkRTVlJvd0FycmF5PHN0cmluZz4sIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSwgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9uczogS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbltdLCBkYXRhU3BlYzogRGF0YVNwZWNUeXBlKSA9PiBEYXRhVHlwZXtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YUZyb21DU1ZPYmplY3Q7XG5cdH1cblxuXHRcblx0cHJpdmF0ZSBfdHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25zIDogS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbltdO1xuXHRwdWJsaWMgZ2V0IHRyYWNrRGVyaXZhdGlvbkZ1bmN0aW9ucygpIDogS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbltdIHtcblx0XHRyZXR1cm4gdGhpcy5fdHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25zO1xuXHR9XG5cblx0cHJpdmF0ZSBfcG9pbnREZXJpdmF0aW9uRnVuY3Rpb25zIDogS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbltdO1xuXHRwdWJsaWMgZ2V0IHBvaW50RGVyaXZhdGlvbkZ1bmN0aW9ucygpIDogS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbltdIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnREZXJpdmF0aW9uRnVuY3Rpb25zO1xuXHR9XG5cblx0cHVibGljIEluaXRpYWxpemVMYXlvdXQoZnJhbWU6IEZyYW1lPENvbXBvbmVudEluaXRJbmZvIHwgQ29tcG9uZW50VHlwZT4pOiB2b2lkXG5cdHtcblx0XHQvLyBjb25zb2xlLmxvZyhmcmFtZSk7XG5cdFx0dGhpcy5fY29tcG9uZW50Q29udGFpbmVycyA9IHRoaXMubGF5b3V0RnJhbWV3b3JrLkluaXRpYWxpemVMYXlvdXQoZnJhbWUpO1xuXHRcdERldmxpYlRTVXRpbC5sYXVuY2hTcGlubmVyKCk7XG5cdFx0Zm9yIChsZXQgW2NvbnRhaW5lciwgY29tcG9uZW50SW5mb10gb2YgdGhpcy5jb21wb25lbnRDb250YWluZXJzKVxuXHRcdHtcblx0XHRcdHRoaXMuSW5pdGlhbGl6ZUNvbXBvbmVudChjb21wb25lbnRJbmZvLCBjb250YWluZXIpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgSW5pdGlhbGl6ZUNvbXBvbmVudChjb21wb250ZW50SW5mbzogQ29tcG9uZW50SW5pdEluZm8gfCBDb21wb25lbnRUeXBlLCBjb250YWluZXI6IEhUTUxFbGVtZW50KTogdm9pZFxuXHR7XG5cdFx0bGV0IG5ld0NvbXBvbmVudDogQmFzZUNvbXBvbmVudDtcblx0XHRsZXQgY29tcG9uZW50VHlwZTogQ29tcG9uZW50VHlwZTtcblx0XHRsZXQgaW5pdEFyZ3M6IEFyZ3VtZW50cyB8IG51bGwgPSBudWxsO1xuXHRcdGlmICh0eXBlb2YoY29tcG9udGVudEluZm8pID09PSBcInN0cmluZ1wiKVxuXHRcdHtcblx0XHRcdGNvbXBvbmVudFR5cGUgPSBjb21wb250ZW50SW5mbztcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvbXBvbmVudFR5cGUgPSBjb21wb250ZW50SW5mby50eXBlO1xuXHRcdFx0aW5pdEFyZ3MgPSBjb21wb250ZW50SW5mby5pbml0QXJncztcblx0XHR9XG5cdFx0c3dpdGNoIChjb21wb25lbnRUeXBlKSB7XG5cdFx0XHRjYXNlIENvbXBvbmVudFR5cGUuUGxvdDJkUGF0aHNXaWRnZXQ6XG5cdFx0XHRcdGxldCBzcXVhcmVBc3BlY3RSYXRpbyA9IHRydWU7XG5cdFx0XHRcdGlmICh0eXBlb2YoaW5pdEFyZ3Muc3F1YXJlQXNwZWN0UmF0aW8pICE9PSAndW5kZWZpbmVkJylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNxdWFyZUFzcGVjdFJhdGlvID0gaW5pdEFyZ3Muc3F1YXJlQXNwZWN0UmF0aW87XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgZGVmYXVsdE9wdGlvbiA9IDA7XG5cdFx0XHRcdG5ld0NvbXBvbmVudCA9IG5ldyBQbG90MmRQYXRoc1dpZGdldChjb250YWluZXIsIGluaXRBcmdzLnF1aWNrUGlja09wdGlvbnMsIGRlZmF1bHRPcHRpb24sIHNxdWFyZUFzcGVjdFJhdGlvKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIENvbXBvbmVudFR5cGUuTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0OlxuXHRcdFx0XHRuZXdDb21wb25lbnQgPSBuZXcgTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0KGNvbnRhaW5lciwgaW5pdEFyZ3MubWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIENvbXBvbmVudFR5cGUuSW1hZ2VTZWxlY3Rpb25XaWRnZXQ6XG5cdFx0XHRcdG5ld0NvbXBvbmVudCA9IG5ldyBJbWFnZVNlbGVjdGlvbldpZGdldChjb250YWluZXIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgQ29tcG9uZW50VHlwZS5EZXRhaWxlZERpc3RyaWJ1dGlvbjpcblx0XHRcdFx0bmV3Q29tcG9uZW50ID0gbmV3IERldGFpbGVkRGlzdHJpYnV0aW9uV2lkZ2V0KGNvbnRhaW5lciwgaW5pdEFyZ3MubWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLCBpbml0QXJncy5hdHRyaWJ1dGVLZXkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgQ29tcG9uZW50VHlwZS5Ub29sYmFyOlxuXHRcdFx0XHRuZXdDb21wb25lbnQgPSBuZXcgVG9vbGJhcihjb250YWluZXIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoYENhbm5vdCBJbml0aWFsaXplIENvbXBvbmVudCBvZiB0eXBlOiAke2NvbXBvbmVudFR5cGV9YCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLmNvbXBvbmVudExpc3QucHVzaChuZXdDb21wb25lbnQpO1xuXHR9XG5cblx0cHVibGljIExvYWREYXRhc2V0KGRhdGFzZXRJZDogc3RyaW5nKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5mZXRjaEpzb24oYCR7ZGF0YXNldElkfS5qc29uYCk7XG5cdH1cblx0XG5cdHByaXZhdGUgYXN5bmMgZmV0Y2hKc29uKGZpbGVuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG5cdHtcblx0XHRhd2FpdCBkMy5qc29uKFwiLi4vLi4vLi4vZGF0YS9cIiArIGZpbGVuYW1lKS50aGVuKChkYXRhOiBhbnkpID0+XG5cdFx0e1xuXHRcdFx0dGhpcy5mZXRjaENzdihgJHtkYXRhLmdvb2dsZURyaXZlSWR9L21hc3NPdmVyVGltZS5jc3ZgLCBkYXRhKTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZmV0Y2hDc3YoZmlsZW5hbWU6IHN0cmluZywgZGF0YVNwZWM6IERhdGFTcGVjVHlwZSk6IFByb21pc2U8dm9pZD5cblx0e1xuXHRcdGF3YWl0IGQzLmNzdihcIi4uLy4uLy4uL2RhdGEvXCIgKyBmaWxlbmFtZSkudGhlbihkYXRhID0+XG5cdFx0e1xuXHRcdFx0Ly8gY29uc29sZS5sb2coZGF0YSk7XG5cdFx0XHRsZXQgbmV3RGF0YTogRGF0YVR5cGUgPSB0aGlzLmRhdGFGcm9tQ1NWT2JqZWN0KGRhdGEsIHRoaXMudHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25zLCB0aGlzLnBvaW50RGVyaXZhdGlvbkZ1bmN0aW9ucywgZGF0YVNwZWMpO1xuXHRcdFx0Ly8gY29uc29sZS5sb2cobmV3RGF0YSk7XG5cdFx0XHR0aGlzLlNldERhdGEobmV3RGF0YSk7XG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgU2V0RGF0YShuZXdEYXRhOiBEYXRhVHlwZSk6IHZvaWRcblx0e1xuXHRcdGNvbnNvbGUubG9nKFwiQXBwLlNldERhdGE6IFwiKTtcblx0XHRjb25zb2xlLmxvZyhuZXdEYXRhKTtcblx0XHR0aGlzLl9kYXRhID0gbmV3RGF0YTtcblx0XHRmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRMaXN0KVxuXHRcdHtcblx0XHRcdGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBCYXNlV2lkZ2V0KVxuXHRcdFx0e1xuXHRcdFx0XHRcdGNvbXBvbmVudC5TZXREYXRhKG5ld0RhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBPbldpbmRvd1Jlc2l6ZSgpOiB2b2lkXG5cdHtcblx0XHRmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRMaXN0KVxuXHRcdHtcblx0XHRcdGNvbXBvbmVudC5SZXNpemUoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cblx0XHR0aGlzLmRhdGEuT25CcnVzaENoYW5nZSgpO1xuXHRcdGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudExpc3QpXG5cdFx0e1xuXHRcdFx0aWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIEJhc2VXaWRnZXQpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbXBvbmVudC5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0iLCJleHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvbXBvbmVudCB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEVsZW1lbnQsIC4uLnByb3BzOiBhbnlbXSlcblx0e1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHR0aGlzLl9jb21wb25lbnRJbmRleCA9IEJhc2VDb21wb25lbnQuX2NvbXBvbmVudENvdW50O1xuXHRcdEJhc2VDb21wb25lbnQuX2NvbXBvbmVudENvdW50Kys7XG5cdFx0dGhpcy5pbml0UHJvcHMocHJvcHMpO1xuXHRcdHRoaXMuc2V0V2lkdGhIZWlnaHQoKTtcblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXG5cdHByaXZhdGUgX2NvbnRhaW5lciA6IEVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY29udGFpbmVyKCkgOiBFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfd2lkdGggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgd2lkdGgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9XG5cblx0cHJpdmF0ZSBfaGVpZ2h0IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGhlaWdodCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY29tcG9uZW50SW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgQ29tcG9uZW50SWQoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiX1wiICsgdGhpcy5fY29tcG9uZW50SW5kZXg7XG5cdH1cdFxuXG5cdHByaXZhdGUgc3RhdGljIF9jb21wb25lbnRDb3VudDogbnVtYmVyID0gMDtcblxuXHRwcm90ZWN0ZWQgaW5pdFByb3BzKHByb3BzPzogYW55W10pOiB2b2lkXG5cdHtcblx0XHRcblx0fVxuXG5cdHByb3RlY3RlZCBpbml0KCk6IHZvaWRcblx0e1xuXHRcdGxldCBub3RJbXBsZW1lbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdG5vdEltcGxlbWVudERpdi50ZXh0Q29udGVudCA9IGBDbGFzcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gaGFzIG5vdCBpbXBsZW1lbnQgJ2luaXQnIGZ1bmN0aW9uYDtcblx0XHRub3RJbXBsZW1lbnREaXYuY2xhc3NMaXN0LmFkZChcIm5vdEltcGxlbWVudGVkV2FybmluZ1wiKTtcblx0XHR0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBudWxsO1xuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKG5vdEltcGxlbWVudERpdik7XG5cdH1cblxuXHRwdWJsaWMgUmVzaXplKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuc2V0V2lkdGhIZWlnaHQoKTtcblx0XHR0aGlzLk9uUmVzaXplKCk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0V2lkdGhIZWlnaHQoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fd2lkdGggPSB0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gbnVsbDtcblx0XHRsZXQgbm90SW1wbGVtZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRub3RJbXBsZW1lbnREaXYudGV4dENvbnRlbnQgPSBgUmVzaXplZCB0bzogKCR7dGhpcy53aWR0aH0sICR7dGhpcy5oZWlnaHR9KVxub3ZlcnJpZGUgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9Lk9uUmVzaXplRHJhdygpIHRvIGVuc3VyZSBjb250ZW50IGlzIHJlc2l6ZWQgY29ycmVjdGx5YDtcblx0XHRub3RJbXBsZW1lbnREaXYuY2xhc3NMaXN0LmFkZChcIm5vdEltcGxlbWVudGVkV2FybmluZ1wiKTtcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChub3RJbXBsZW1lbnREaXYpO1xuXHR9XG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJnaW4gfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0ICB7IERldmxpYlRTVXRpbCB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUU1V0aWwnO1xuaW1wb3J0IHsgQXBwRGF0YSwgRmFjZXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHcm91cEJ5V2lkZ2V0IH0gZnJvbSAnLi9Hcm91cEJ5V2lkZ2V0JztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VXaWRnZXQ8RGF0YVR5cGUgZXh0ZW5kcyBBcHBEYXRhPERhdGFTcGVjVHlwZT4sIERhdGFTcGVjVHlwZT4gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcblx0XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogRWxlbWVudCwgY2FuRmFjZXQ6IGJvb2xlYW4gPSBmYWxzZSwgLi4ucHJvcHM6IGFueVtdKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCAuLi5wcm9wcyk7XG5cdFx0dGhpcy5fY2FuRmFjZXQgPSBjYW5GYWNldDtcblx0XHRpZiAoY2FuRmFjZXQpXG5cdFx0e1xuXHRcdFx0dGhpcy5hZGRGYWNldEJ1dHRvbigpO1xuXHRcdH1cblx0XHR0aGlzLmluaXRCdXR0b25MaXN0Q29udGFpbmVyKCk7XHRcdFxuXHRcdHRoaXMuX2RhdGFTdXBlcnNldCA9IG51bGw7XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdncm91cEJ5Q2hhbmdlZCcsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuc2hvd2luZ0ZhY2V0UG9wdXApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZHJhd0ZhY2V0ZWREYXRhKGUuZGV0YWlsLmdyb3VwSW5kZXgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuX3Nob3dpbmdGYWNldFBvcHVwID0gZmFsc2U7XG5cdH1cblxuXHRwcml2YXRlIF9kYXRhIDogRGF0YVR5cGUgfCBudWxsO1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IERhdGFUeXBlIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH1cblxuXHRwcml2YXRlIF9kYXRhU3VwZXJzZXQgOiBEYXRhVHlwZSB8IG51bGw7XG5cdHB1YmxpYyBnZXQgZGF0YVN1cGVyc2V0KCkgOiBEYXRhVHlwZSB8IG51bGwge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhU3VwZXJzZXQ7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IGZ1bGxEYXRhKCkgOiBEYXRhVHlwZSB8IG51bGwge1xuXHRcdGlmICh0aGlzLl9kYXRhU3VwZXJzZXQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YVN1cGVyc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kYXRhO1xuXHR9XG5cblx0cHJvdGVjdGVkIF9tYXJnaW4gOiBNYXJnaW47XG5cdHB1YmxpYyBnZXQgbWFyZ2luKCkgOiBNYXJnaW4ge1xuXHRcdHJldHVybiB0aGlzLl9tYXJnaW47XG5cdH1cblxuXHRwcml2YXRlIF92aXpXaWR0aCA6IG51bWJlcjtcblx0cHVibGljIGdldCB2aXpXaWR0aCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fdml6V2lkdGg7XG5cdH1cblxuXHRwcml2YXRlIF92aXpIZWlnaHQgOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgdml6SGVpZ2h0KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl92aXpIZWlnaHQ7XG5cdH1cblxuXHRwcml2YXRlIF9jYW5GYWNldCA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgY2FuRmFjZXQoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9jYW5GYWNldDtcblx0fVxuXG5cdHB1YmxpYyBzZXQgY2FuRmFjZXQodjogYm9vbGVhbikge1xuXHRcdGlmICghdilcblx0XHR7XG5cdFx0XHR0aGlzLnJlbW92ZUZhY2V0QnV0dG9uKCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NhbkZhY2V0ID0gdjtcblx0fVxuXG5cdHByaXZhdGUgX3Nob3dpbmdGYWNldFBvcHVwIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBzaG93aW5nRmFjZXRQb3B1cCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3Nob3dpbmdGYWNldFBvcHVwO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnV0dG9uTGlzdCA6IEhUTUxCdXR0b25FbGVtZW50W107XG5cdHB1YmxpYyBnZXQgYnV0dG9uTGlzdCgpIDogSFRNTEJ1dHRvbkVsZW1lbnRbXSB7XG5cdFx0aWYgKCF0aGlzLl9idXR0b25MaXN0KVxuXHRcdHtcblx0XHRcdHRoaXMuX2J1dHRvbkxpc3QgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2J1dHRvbkxpc3Q7XG5cdH1cblx0XG5cdHByaXZhdGUgX2J1dHRvbkxpc3RDb250YWluZXIgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBidXR0b25MaXN0Q29udGFpbmVyKCkgOiBIVE1MRGl2RWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2J1dHRvbkxpc3RDb250YWluZXI7XG5cdH1cblxuXHRwcml2YXRlIF9mYWNldEJ1dHRvbiA6IEhUTUxCdXR0b25FbGVtZW50O1xuXHRwdWJsaWMgZ2V0IGZhY2V0QnV0dG9uKCkgOiBIVE1MQnV0dG9uRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZhY2V0QnV0dG9uO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9sYXJnZVBvcHVwT3V0ZXIgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBsYXJnZVBvcHVwT3V0ZXIoKSA6IEhUTUxEaXZFbGVtZW50IHtcblx0XHRpZiAodGhpcy5fbGFyZ2VQb3B1cE91dGVyKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9sYXJnZVBvcHVwT3V0ZXI7XG5cdFx0fVxuXHRcdGxldCBsYXJnZVBvcHVwT3V0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFyZ2VQb3B1cENvbnRhaW5lck91dGVyJyk7XG5cdFx0aWYgKGxhcmdlUG9wdXBPdXRlcilcblx0XHR7XG5cdFx0XHR0aGlzLl9sYXJnZVBvcHVwT3V0ZXIgPSBsYXJnZVBvcHVwT3V0ZXIgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFyZ2VQb3B1cE91dGVyO1xuXHRcdH1cblx0XHR0aGlzLmluaXRMYXJnZVBvcHVwKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2xhcmdlUG9wdXBPdXRlcjtcblx0fVxuXG5cdHByaXZhdGUgX2xhcmdlUG9wdXAgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBsYXJnZVBvcHVwKCkgOiBIVE1MRGl2RWxlbWVudCB7XG5cdFx0aWYgKHRoaXMuX2xhcmdlUG9wdXApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2xhcmdlUG9wdXA7XG5cdFx0fVxuXHRcdGxldCBsYXJnZVBvcHVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhcmdlUG9wdXBDb250YWluZXInKTtcblx0XHRpZiAobGFyZ2VQb3B1cClcblx0XHR7XG5cdFx0XHR0aGlzLl9sYXJnZVBvcHVwID0gbGFyZ2VQb3B1cCBhcyBIVE1MRGl2RWxlbWVudDtcblx0XHRcdHJldHVybiB0aGlzLl9sYXJnZVBvcHVwO1xuXHRcdH1cblx0XHR0aGlzLmluaXRMYXJnZVBvcHVwKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2xhcmdlUG9wdXA7XG5cdH1cblx0XG5cdHByaXZhdGUgX2xhcmdlUG9wdXBDb250ZW50IDogSFRNTERpdkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgbGFyZ2VQb3B1cENvbnRlbnQoKSA6IEhUTUxEaXZFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fbGFyZ2VQb3B1cENvbnRlbnQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgaW5pdFByb3BzKHByb3BzPzogYW55W10pOiB2b2lkXG5cdHtcblx0XHR0aGlzLnNldE1hcmdpbigpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNldE1hcmdpbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tYXJnaW4gPSB7XG5cdFx0XHR0b3A6IDIwLFxuXHRcdFx0cmlnaHQ6IDIwLFxuXHRcdFx0Ym90dG9tOiAyMCxcblx0XHRcdGxlZnQ6IDIwXG5cdFx0fVxuXHR9XG5cblx0cHVibGljIFNldERhdGEoZGF0YTogRGF0YVR5cGUsIGRhdGFTdXBlcnNldD86IERhdGFUeXBlKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0aWYgKGRhdGFTdXBlcnNldClcblx0XHR7XG5cdFx0XHR0aGlzLl9kYXRhU3VwZXJzZXQgPSBkYXRhU3VwZXJzZXQ7XG5cdFx0fVxuXHRcdGxldCBmYWNldE9wdGlvbnMgPSBkYXRhLkdldEZhY2V0T3B0aW9ucygpO1xuXHRcdGlmIChmYWNldE9wdGlvbnMubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHRoaXMuY2FuRmFjZXQgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5PbkRhdGFDaGFuZ2UoKTtcblx0fVxuXG5cdHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdGNvbnNvbGUubG9nKCdiYXNlOiBPbkJydXNoQ2hhbmdlJyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0V2lkdGhIZWlnaHQoKTogdm9pZFxuXHR7XG5cdFx0c3VwZXIuc2V0V2lkdGhIZWlnaHQoKTtcblx0XHR0aGlzLl92aXpXaWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5tYXJnaW4ucmlnaHQ7XG5cdFx0dGhpcy5fdml6SGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSB0aGlzLm1hcmdpbi50b3AgLSB0aGlzLm1hcmdpbi5ib3R0b207XG5cdH1cblxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgT25EYXRhQ2hhbmdlKCk6IHZvaWRcblxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8RGF0YVR5cGUsIERhdGFTcGVjVHlwZT5cblxuXHRwcml2YXRlIGluaXRCdXR0b25MaXN0Q29udGFpbmVyKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX2J1dHRvbkxpc3RDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0aGlzLmJ1dHRvbkxpc3RDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbm9EaXNwJyk7XG5cdFx0bGV0IHN0eWxlID0gdGhpcy5idXR0b25MaXN0Q29udGFpbmVyLnN0eWxlO1xuXG5cdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdHN0eWxlLnJpZ2h0ID0gJzBweCc7XG5cdFx0c3R5bGUudG9wID0gJzBweCc7XHRcdFxuXHRcdHN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdFx0c3R5bGUuZGlzcGxheSA9ICdmbGV4Jztcblx0XHRzdHlsZS5mbGV4RGlyZWN0aW9uID0gJ3Jvdy1yZXZlcnNlJztcblxuXHRcdHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcigpKTtcblxuXHRcdHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSgpKTtcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmJ1dHRvbkxpc3RDb250YWluZXIpO1xuXHRcdFxuXHRcdGZvciAobGV0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbkxpc3QpXG5cdFx0e1xuXHRcdFx0dGhpcy5idXR0b25MaXN0Q29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhZGRGYWNldEJ1dHRvbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9mYWNldEJ1dHRvbiA9IHRoaXMuQWRkQnV0dG9uKCdsYXllci1ncm91cCcsICgpID0+XG5cdFx0e1xuXHRcdFx0dGhpcy5kcmF3RmFjZXRDb250ZW50KCk7XG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgQWRkQnV0dG9uKGljb25LZXk6IHN0cmluZywgY2FsbGJhY2s6IChldjogTW91c2VFdmVudCkgPT4gdm9pZCk6IEhUTUxCdXR0b25FbGVtZW50XG5cdHtcblx0XHRsZXQgYnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24oaWNvbktleSwgY2FsbGJhY2spO1xuXHRcdGJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG5cdFx0dGhpcy5idXR0b25MaXN0LnVuc2hpZnQoYnV0dG9uKTtcblx0XHRyZXR1cm4gYnV0dG9uO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVGYWNldEJ1dHRvbigpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5mYWNldEJ1dHRvbilcblx0XHR7XHRcblx0XHRcdHRoaXMuYnV0dG9uTGlzdENvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLmZhY2V0QnV0dG9uKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG9uTW91c2VFbnRlcigpOiAoKSA9PiB2b2lkXG5cdHtcblx0XHRyZXR1cm4gKCkgPT4gRGV2bGliVFNVdGlsLnNob3codGhpcy5idXR0b25MaXN0Q29udGFpbmVyKTtcblx0fVxuXG5cdHByaXZhdGUgb25Nb3VzZUxlYXZlKCk6ICgpID0+IHZvaWRcblx0e1xuXHRcdHJldHVybiAoKSA9PiBEZXZsaWJUU1V0aWwuaGlkZSh0aGlzLmJ1dHRvbkxpc3RDb250YWluZXIpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3RmFjZXRDb250ZW50KCk6IHZvaWRcblx0e1xuXHRcdHRoaXMubGFyZ2VQb3B1cC5pbm5lckhUTUwgPSBudWxsO1xuXG5cdFx0RGV2bGliVFNVdGlsLnNob3codGhpcy5sYXJnZVBvcHVwT3V0ZXIpO1xuXHRcdHRoaXMuX3Nob3dpbmdGYWNldFBvcHVwID0gdHJ1ZTtcblx0XHRjb25zdCBncm91cEJ5V2lkZ2V0ID0gbmV3IEdyb3VwQnlXaWRnZXQoZDMuc2VsZWN0KHRoaXMubGFyZ2VQb3B1cCkpO1xuXHRcdGdyb3VwQnlXaWRnZXQudXBkYXRlR3JvdXBCeU9wdGlvbnModGhpcy5kYXRhKTtcblxuXHRcdGxldCBjb250ZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0Y29udGVudENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdsYXJnZVBvcHVwQ29udGVudCcpO1xuXHRcdHRoaXMubGFyZ2VQb3B1cC5hcHBlbmRDaGlsZChjb250ZW50Q29udGFpbmVyKTtcblx0XHR0aGlzLl9sYXJnZVBvcHVwQ29udGVudCA9IGNvbnRlbnRDb250YWluZXI7XG5cdFx0dGhpcy5kcmF3RmFjZXRlZERhdGEoZ3JvdXBCeVdpZGdldC5jdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0KTtcblx0fVxuXG5cdHByb3RlY3RlZCBkcmF3RmFjZXRlZERhdGEoZmFjZXRPcHRpb25JbmRleExpc3Q6IG51bWJlcltdKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5kcmF3RmFjZXRlZERhdGFEZWZhdWx0UmVjdXJzZShmYWNldE9wdGlvbkluZGV4TGlzdCk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZHJhd0ZhY2V0ZWREYXRhRGVmYXVsdFJlY3Vyc2UocmVtYWluaW5nU3ViRmFjZXRJbmRpY2VzOiBudW1iZXJbXSwgd2lkdGg6IHN0cmluZyA9ICc1MDBweCcsIGhlaWdodDogc3RyaW5nID0gJzI1MHB4JywgdGl0bGVTb0Zhcj86IHN0cmluZywgZmFjZXQ/OiBGYWNldCk6IHZvaWRcblx0e1xuXHRcdGlmIChyZW1haW5pbmdTdWJGYWNldEluZGljZXMubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHRoaXMuZHJhd0ZhY2V0ZWREYXRhRGVmYXVsdCh0aXRsZVNvRmFyLCBmYWNldC5kYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IGRhdGE6IERhdGFUeXBlO1xuXHRcdGlmIChmYWNldClcblx0XHR7XG5cdFx0XHRkYXRhID0gZmFjZXQuZGF0YTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGRhdGEgPSB0aGlzLmRhdGE7XG5cdFx0XHR0aGlzLmxhcmdlUG9wdXBDb250ZW50LmlubmVySFRNTCA9IG51bGw7XG5cdFx0fVxuXHRcdGxldCBmYWNldE9wdGlvbnMgPSBkYXRhLkdldEZhY2V0T3B0aW9ucygpO1xuXHRcdGxldCB0aGlzRmFjZXRPcHRpb24gPSBmYWNldE9wdGlvbnNbcmVtYWluaW5nU3ViRmFjZXRJbmRpY2VzWzBdXTtcblx0XHRcblx0XHRmb3IgKGxldCBjaGlsZEZhY2V0IG9mIHRoaXNGYWNldE9wdGlvbi5HZXRGYWNldHMoKSlcblx0XHR7XG5cdFx0XHRsZXQgbmV4dFRpdGxlOiBzdHJpbmcgPSB0aXRsZVNvRmFyID8gdGl0bGVTb0ZhciArICcsICcgKyBjaGlsZEZhY2V0Lm5hbWUgOiBjaGlsZEZhY2V0Lm5hbWU7XG5cdFx0XHR0aGlzLmRyYXdGYWNldGVkRGF0YURlZmF1bHRSZWN1cnNlKHJlbWFpbmluZ1N1YkZhY2V0SW5kaWNlcy5zbGljZSgxKSwgd2lkdGgsIGhlaWdodCwgbmV4dFRpdGxlLCBjaGlsZEZhY2V0KVxuXHRcdH1cblxuXHR9XG5cblx0cHJpdmF0ZSBkcmF3RmFjZXRlZERhdGFEZWZhdWx0KHRpdGxlOiBzdHJpbmcsIGRhdGE6IERhdGFUeXBlLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZyk6IHZvaWRcblx0e1xuXHRcdGxldCBvdXRlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0b3V0ZXJDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnb3V0ZXJGYWNldENvbnRhaW5lcicpO1xuXHRcdFx0b3V0ZXJDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdG91dGVyQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0bGV0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdHRpdGxlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZhY2V0VGl0bGUnKVxuXHRcdFx0XHR0aXRsZUNvbnRhaW5lci5pbm5lclRleHQgPSB0aXRsZTtcblxuXHRcdG91dGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcblxuXHRcdFx0bGV0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRuZXdDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZmFjZXRDb250YWluZXInKTtcblx0XG5cdFx0b3V0ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQobmV3Q29udGFpbmVyKTtcblxuXHRcdHRoaXMubGFyZ2VQb3B1cENvbnRlbnQuYXBwZW5kQ2hpbGQob3V0ZXJDb250YWluZXIpO1xuXHRcdHRoaXMuaW5pdFN1YldpZGdldChuZXdDb250YWluZXIsIHRpdGxlLCBkYXRhKTtcblx0fVxuXG5cdHByaXZhdGUgaW5pdFN1YldpZGdldChuZXdDb250YWluZXI6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIGRhdGE6IERhdGFUeXBlKTogdm9pZFxuXHR7XG5cdFx0bGV0IHN1YldpZGdldCA9IHRoaXMuQ2xvbmUobmV3Q29udGFpbmVyKTtcblx0XHRzdWJXaWRnZXQuY2FuRmFjZXQgPSBmYWxzZTtcblx0XHRzdWJXaWRnZXQuU2V0RGF0YShkYXRhLCB0aGlzLmRhdGEpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0TGFyZ2VQb3B1cCgpOiB2b2lkXG5cdHtcblx0XHRsZXQgbGFyZ2VQb3B1cE91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0bGFyZ2VQb3B1cE91dGVyLmlkID0gXCJsYXJnZVBvcHVwQ29udGFpbmVyT3V0ZXJcIjtcblx0XHRsYXJnZVBvcHVwT3V0ZXIuY2xhc3NMaXN0LmFkZCgnbGFyZ2VQb3B1cENvbnRhaW5lck91dGVyJyk7XG5cdFx0bGFyZ2VQb3B1cE91dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT5cblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLmxhcmdlUG9wdXBPdXRlcik7XG5cdFx0XHR0aGlzLl9zaG93aW5nRmFjZXRQb3B1cCA9IGZhbHNlO1xuXHRcdH0pO1xuXG5cdFx0bGV0IGxhcmdlUG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRsYXJnZVBvcHVwLmlkID0gJ2xhcmdlUG9wdXBDb250YWluZXInO1xuXHRcdGxhcmdlUG9wdXAuY2xhc3NMaXN0LmFkZCgnbGFyZ2VQb3B1cENvbnRhaW5lcicpO1xuXHRcdGxhcmdlUG9wdXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXY6IEV2ZW50KSA9PiBcblx0XHR7XG5cdFx0XHRldi5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9KTtcblx0XHR0aGlzLl9sYXJnZVBvcHVwID0gbGFyZ2VQb3B1cDtcblx0XHRsYXJnZVBvcHVwT3V0ZXIuYXBwZW5kQ2hpbGQobGFyZ2VQb3B1cCk7XG5cblx0XHREZXZsaWJUU1V0aWwuaGlkZShsYXJnZVBvcHVwT3V0ZXIpO1xuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGFyZ2VQb3B1cE91dGVyKTtcblx0XHR0aGlzLl9sYXJnZVBvcHVwT3V0ZXIgPSBsYXJnZVBvcHVwT3V0ZXIgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBQb2ludENvbGxlY3Rpb24gfSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IEJhc2VXaWRnZXQgfSBmcm9tICcuL0Jhc2VXaWRnZXQnO1xuaW1wb3J0IHsgTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLCBEYXRhc2V0U3BlYyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFN2Z1NlbGVjdGlvbiwgTkRpbSwgSHRtbFNlbGVjdGlvbiB9IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcyc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3QgfSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVMaXN0JztcblxuaW50ZXJmYWNlIEJveHBsb3RTdGF0cyB7XG4gICAgbWVkaWFuOiBudW1iZXIsXG4gICAgcXVhcnRpbGVSYW5nZTogW251bWJlciwgbnVtYmVyXSxcbiAgICB3aGlza2VyUmFuZ2U6IFtudW1iZXIsIG51bWJlcl1cbn1cblxuZXhwb3J0IGNsYXNzIERldGFpbGVkRGlzdHJpYnV0aW9uV2lkZ2V0IGV4dGVuZHMgQmFzZVdpZGdldDxDdXJ2ZUxpc3QsIERhdGFzZXRTcGVjPiB7XG5cblxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogRWxlbWVudCwgbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsOiBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwsIGF0dHJpYnV0ZUtleTogc3RyaW5nKVxuICAgIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsID0gbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsO1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVLZXkgPSBhdHRyaWJ1dGVLZXk7XG4gICAgICAgIHRoaXMuc2V0TGFiZWwoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz5cbiAgICB7XG4gICAgICAgIGxldCBjbG9uZSA9IG5ldyBEZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldChjb250YWluZXIsIHRoaXMubWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLCB0aGlzLmF0dHJpYnV0ZUtleSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwgOiBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw7XG4gICAgcHVibGljIGdldCBtZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwoKSA6IE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2F0dHJpYnV0ZUtleSA6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IGF0dHJpYnV0ZUtleSgpIDogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZUtleTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9wb2ludENvbGxlY3Rpb24gOiBQb2ludENvbGxlY3Rpb247XG4gICAgcHVibGljIGdldCBwb2ludENvbGxlY3Rpb24oKSA6IFBvaW50Q29sbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludENvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnVsbFBvaW50Q29sbGVjdGlvbiA6IFBvaW50Q29sbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGZ1bGxQb2ludENvbGxlY3Rpb24oKSA6IFBvaW50Q29sbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWxsUG9pbnRDb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3JhbmRvbU5vaXNlTGlzdCA6IG51bWJlcltdO1xuICAgIHB1YmxpYyBnZXQgcmFuZG9tTm9pc2VMaXN0KCkgOiBudW1iZXJbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5kb21Ob2lzZUxpc3Q7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX3NjYWxlWCA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcbiAgICBwdWJsaWMgZ2V0IHNjYWxlWCgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zY2FsZVkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG4gICAgcHVibGljIGdldCBzY2FsZVkoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVk7XG4gICAgfVxuXG5cdHByaXZhdGUgX3N2Z1NlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBzdmdTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N2Z1NlbGVjdDtcblx0fVxuXG4gICAgcHJpdmF0ZSBfbWFpbkdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IG1haW5Hcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFpbkdyb3VwU2VsZWN0O1xuICAgIH1cblxuXHRwcml2YXRlIF9jYW52YXNFbGVtZW50IDogSFRNTENhbnZhc0VsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY2FudmFzRWxlbWVudCgpIDogSFRNTENhbnZhc0VsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXNFbGVtZW50O1xuXHR9XG4gICAgXG4gICAgcHJpdmF0ZSBfdG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgdG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0O1xuICAgIH0gIFxuXG4gICAgcHJpdmF0ZSBfZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0O1xuICAgIH0gICAgXG5cblx0cHJpdmF0ZSBfYnJ1c2hHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBicnVzaEdyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaEdyb3VwU2VsZWN0O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdCA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBib3hwbG90U3RhdHNQb3B1cFNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdDtcbiAgICB9XG4gICAgcHVibGljIHNldCBib3hwbG90U3RhdHNQb3B1cFNlbGVjdCh2IDogSHRtbFNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLl9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdCA9IHY7XG4gICAgfVxuICAgIFxuXG5cdHByaXZhdGUgX2F4aXNQYWRkaW5nIDogIG51bWJlcjtcblx0cHVibGljIGdldCBheGlzUGFkZGluZygpIDogIG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2F4aXNQYWRkaW5nO1xuXHR9XG5cblx0cHJpdmF0ZSBfeEF4aXNHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4QXhpc0dyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94QXhpc0dyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeExhYmVsVGV4dFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4TGFiZWxUZXh0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94TGFiZWxUZXh0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2ggOiBkMy5CcnVzaEJlaGF2aW9yPGFueT47XG5cdHB1YmxpYyBnZXQgYnJ1c2goKSA6IGQzLkJydXNoQmVoYXZpb3I8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF90b3RhbEJveHBsb3RTdGF0cyA6IEJveHBsb3RTdGF0cztcbiAgICBwdWJsaWMgZ2V0IHRvdGFsQm94cGxvdFN0YXRzKCkgOiBCb3hwbG90U3RhdHMge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxCb3hwbG90U3RhdHM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmlsdGVyZWRCb3hwbG90U3RhdHMgOiBCb3hwbG90U3RhdHM7XG4gICAgcHVibGljIGdldCBmaWx0ZXJlZEJveHBsb3RTdGF0cygpIDogQm94cGxvdFN0YXRzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkQm94cGxvdFN0YXRzO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zY2F0dGVycGxvdFBhZGRpbmcgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBzY2F0dGVycGxvdFBhZGRpbmcoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2F0dGVycGxvdFBhZGRpbmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYmV0d2VlbkJveHBsb3RQYWRkaW5nIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgYmV0d2VlbkJveHBsb3RQYWRkaW5nKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmV0d2VlbkJveHBsb3RQYWRkaW5nO1xuICAgIH1cblxuXHRwcm90ZWN0ZWQgc2V0TWFyZ2luKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX21hcmdpbiA9IHtcblx0XHRcdHRvcDogNixcblx0XHRcdHJpZ2h0OiA4LFxuXHRcdFx0Ym90dG9tOiA1Nixcblx0XHRcdGxlZnQ6IDhcblx0XHR9XG5cdH1cblxuICAgIHB1YmxpYyBpbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX3NjYXR0ZXJwbG90UGFkZGluZyA9IDg7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnQgPSBjb250YWluZXJTZWxlY3RcbiAgICAgICAgICAgIC5hcHBlbmQoJ3hodG1sOmNhbnZhcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy52aXpXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQgLSAyICogdGhpcy5zY2F0dGVycGxvdFBhZGRpbmcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICBgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH1weCwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnNjYXR0ZXJwbG90UGFkZGluZ31weCk7XG4gICAgICAgICAgICAgICAgei1pbmRleDogLTFgKVxuICAgICAgICAgICAgLm5vZGUoKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgICAgXG4gICAgICAgIC8vIEkgb3JpZ2luYWxseSBwdXQgdGhlIGNhbnZhcyBpbnNpZGUgdGhlIHN2ZyBpbiBhIGZvcmVpZ25PYmplY3QuIFRoaXMgZGlkbid0IHdvcmsgYmVjYXVzZVxuICAgICAgICAvLyBvZiBDaHJvbWUgYnVnIDE0ODQ5OVxuICAgICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNDg0OTlcblxuICAgICAgICB0aGlzLl9zdmdTZWxlY3QgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKFwic3ZnXCIpXG4gICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHRoaXMud2lkdGgpXG4gICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aGlzLmhlaWdodCk7XG5cbiAgICAgICAgdGhpcy5fYm94cGxvdFN0YXRzUG9wdXBTZWxlY3QgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2JveHBsb3RTdGF0c1BvcHVwJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5oaWRlQm94cGxvdFN0YXRzUG9wdXAoKTtcblxuICAgICAgICB0aGlzLl9tYWluR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMuc2NhdHRlcnBsb3RQYWRkaW5nfSlgKTtcblxuICAgICAgICB0aGlzLl90b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5fYnJ1c2hHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuXHRcdFx0LmNsYXNzZWQoXCJicnVzaENvbnRhaW5lclwiLCB0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLl9heGlzUGFkZGluZyA9IDQ7XG4gICAgICAgIHRoaXMuX3hBeGlzR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIHRoaXMuYXhpc1BhZGRpbmd9KWApXG4gICAgICAgICAgICAuY2xhc3NlZChcImxhYmVsQ29sb3JcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fYmV0d2VlbkJveHBsb3RQYWRkaW5nID0gNDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldExhYmVsKCk6IHZvaWRcblx0e1x0XG5cdFx0dGhpcy5feExhYmVsVGV4dFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgndGV4dCcpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKVxuICAgICAgICAgICAgLnRleHQodGhpcy5hdHRyaWJ1dGVLZXkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkxhYmVscygpOiB2b2lkXG4gICAge1xuXHRcdGxldCBidWZmZXJGb3JBeGlzID0gMzIgKyB0aGlzLmF4aXNQYWRkaW5nOztcblx0XHR0aGlzLnhMYWJlbFRleHRTZWxlY3Rcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdCArIHRoaXMudml6V2lkdGggLyAyfSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIGJ1ZmZlckZvckF4aXN9KWApO1xuICAgIH1cblxuXG5cbiAgICBwdWJsaWMgT25EYXRhQ2hhbmdlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UgTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLlBvaW50OlxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50Q29sbGVjdGlvbiA9IHRoaXMuZGF0YSBhcyBQb2ludENvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFBvaW50Q29sbGVjdGlvbiA9IHRoaXMuZnVsbERhdGEgYXMgUG9pbnRDb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwuQ3VydmU6XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRDb2xsZWN0aW9uID0gdGhpcy5kYXRhLmN1cnZlQ29sbGVjdGlvbiBhcyBQb2ludENvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFBvaW50Q29sbGVjdGlvbiA9IHRoaXMuZnVsbERhdGEuY3VydmVDb2xsZWN0aW9uIGFzIFBvaW50Q29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGV0YWlsZWREaXN0cmlidXRpb24gbmVlZHMgYSB2YWxpZCBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRDb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsUG9pbnRDb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JhbmRvbU5vaXNlTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9pbnRDb2xsZWN0aW9uLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJhbmRvbU5vaXNlTGlzdC5wdXNoKE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVG90YWxCb3hwbG90U3RhdHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsZXMoKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIHRoaXMuc2hvd0xhYmVsKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUb3RhbEJveHBsb3RTdGF0cygpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdmFsaWROdW1iZXJzOiBudW1iZXJbXSA9IHRoaXMucG9pbnRDb2xsZWN0aW9uLkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZ2V0KHRoaXMuYXR0cmlidXRlS2V5KSkgLy8gZ2V0IGFjdHVhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiAhaXNOYU4oZCkpIC8vIGZpbHRlciBvdXQgTmFOIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpOyAvLyBkMy5xdWFudGlsZSByZXF1aXJlcyBpdCB0byBiZSBzb3J0ZWQuIFRoaXMgY291bGQgdGVjaG5pY2FsbHkgYmUgZG9uZSBmYXN0ZXIgd2l0aG91dCBzb3J0aW5nLlxuXG4gICAgICAgIHRoaXMuX3RvdGFsQm94cGxvdFN0YXRzID0gRGV0YWlsZWREaXN0cmlidXRpb25XaWRnZXQuY2FsY3VsYXRlQm94cGxvdFN0YXRzKHZhbGlkTnVtYmVycyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVGaWx0ZXJlZEJveHBsb3RTdGF0cygpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdmFsaWRCcnVzaGVkTnVtYmVyczogbnVtYmVyW10gPSB0aGlzLnBvaW50Q29sbGVjdGlvbi5BcnJheVxuICAgICAgICAgICAgLmZpbHRlcihkID0+IGQuaW5CcnVzaClcbiAgICAgICAgICAgIC5tYXAoZCA9PiBkLmdldCh0aGlzLmF0dHJpYnV0ZUtleSkpIC8vIGdldCBhY3R1YWwgdmFsdWVcbiAgICAgICAgICAgIC5maWx0ZXIoZCA9PiAhaXNOYU4oZCkpIC8vIGZpbHRlciBvdXQgTmFOIHZhbHVlcy5cbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7IC8vIGQzLnF1YW50aWxlIHJlcXVpcmVzIGl0IHRvIGJlIHNvcnRlZC4gVGhpcyBjb3VsZCB0ZWNobmljYWxseSBiZSBkb25lIGZhc3RlciB3aXRob3V0IHNvcnRpbmcuXG5cbiAgICAgICAgdGhpcy5fZmlsdGVyZWRCb3hwbG90U3RhdHMgPSBEZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldC5jYWxjdWxhdGVCb3hwbG90U3RhdHModmFsaWRCcnVzaGVkTnVtYmVycyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlQm94cGxvdFN0YXRzKG51bWJlcnM6IG51bWJlcltdKTogQm94cGxvdFN0YXRzXG4gICAge1xuICAgICAgICBjb25zdCBtZWRpYW4gPSBkMy5tZWRpYW4obnVtYmVycyk7XG4gICAgICAgIGxldCBsb3dRdWFydGlsZSA9IGQzLnF1YW50aWxlKG51bWJlcnMsIDAuMjUpO1xuICAgICAgICBsZXQgaGlnaFF1YXJ0aWxlID0gZDMucXVhbnRpbGUobnVtYmVycywgMC43NSk7XG4gICAgICAgIGNvbnN0IHF1YXJ0aWxlUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gPSBbbG93UXVhcnRpbGUsIGhpZ2hRdWFydGlsZV07XG4gICAgICAgIFxuICAgICAgICBsZXQgaW50ZXJRdWFydGlsZVJhbmdlID0gaGlnaFF1YXJ0aWxlIC0gbG93UXVhcnRpbGU7XG4gICAgICAgIGxldCBsb3dXaGlza2VyICA9IGxvd1F1YXJ0aWxlICAtIDEuNSAqIGludGVyUXVhcnRpbGVSYW5nZTtcbiAgICAgICAgbGV0IGhpZ2hXaGlza2VyID0gaGlnaFF1YXJ0aWxlICsgMS41ICogaW50ZXJRdWFydGlsZVJhbmdlO1xuICAgICAgICBjb25zdCB3aGlza2VyUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gPSBbbG93V2hpc2tlciwgaGlnaFdoaXNrZXJdO1xuXG4gICAgICAgIGxldCBib3hwbG90U3RhdHM6IEJveHBsb3RTdGF0cyA9IHtcbiAgICAgICAgICAgIG1lZGlhbjogbWVkaWFuLFxuICAgICAgICAgICAgcXVhcnRpbGVSYW5nZTogcXVhcnRpbGVSYW5nZSxcbiAgICAgICAgICAgIHdoaXNrZXJSYW5nZTogd2hpc2tlclJhbmdlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJveHBsb3RTdGF0cztcblxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU2NhbGVzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBkaXN0cmlidXRpb25NaW5NYXggPSB0aGlzLmZ1bGxQb2ludENvbGxlY3Rpb24uZ2V0TWluTWF4KHRoaXMuYXR0cmlidXRlS2V5KTtcbiAgICAgICAgdGhpcy5fc2NhbGVYID0gZDMuc2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oZGlzdHJpYnV0aW9uTWluTWF4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFswLCB0aGlzLnZpeldpZHRoXSk7XG5cblxuICAgICAgICB0aGlzLl9zY2FsZVkgPSBkMy5zY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgMV0pIC8vIGJvdW5kcyBvZiBNYXRoLnJhbmRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFt0aGlzLnZpekhlaWdodCAtIDIgKiB0aGlzLnNjYXR0ZXJwbG90UGFkZGluZywgMF0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhdygpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIC8vIGl0J3MgcHJvYmFibHkgZmFzdGVyIHRvIGZpbHRlciBvdXQgYWxsIHRoZSBOYU5zIG9uY2UgdGhhbiBub0Rpc3AgdGhlbSBhbGwuIFRoZXJlIG1pZ2h0IGJlIGFzIG1hbnkgYXMgNTAlIE5hTnNcbiAgICAgICAgbGV0IHZhbGlkUG9pbnRzID0gdGhpcy5wb2ludENvbGxlY3Rpb24uQXJyYXkuZmlsdGVyKGQgPT4gIWlzTmFOKGQuZ2V0KHRoaXMuYXR0cmlidXRlS2V5KSkpO1xuXG4gICAgICAgIC8vIGRyYXcgaml0dGVyZWQgc2NhdHRlcnBsb3RcbiAgICAgICAgY29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLDAsIHRoaXMudml6V2lkdGgsIHRoaXMudml6SGVpZ2h0IC0gMiAqIHRoaXMuc2NhdHRlcnBsb3RQYWRkaW5nKTtcbiAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICBjYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhID0gMC42O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkUG9pbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcG9pbnQgPSB2YWxpZFBvaW50c1tpXTtcbiAgICAgICAgICAgIGxldCB4ID0gdGhpcy5zY2FsZVgocG9pbnQuZ2V0KHRoaXMuYXR0cmlidXRlS2V5KSk7XG4gICAgICAgICAgICBsZXQgeSA9IHRoaXMuc2NhbGVZKHRoaXMucmFuZG9tTm9pc2VMaXN0W2ldKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSAwLjU7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5icnVzaEFwcGxpZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHNtYWxsQm94cGxvdEhlaWdodCA9ICh0aGlzLnZpekhlaWdodCAtIHRoaXMuYmV0d2VlbkJveHBsb3RQYWRkaW5nKSAvIDI7XG4gICAgICAgICAgICB0aGlzLmRyYXdCb3hwbG90KHRoaXMudG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0LCB0aGlzLnRvdGFsQm94cGxvdFN0YXRzLCAwLCBzbWFsbEJveHBsb3RIZWlnaHQpOyAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZHJhd0JveHBsb3QodGhpcy5maWx0ZXJlZEJveHBsb3RDb250YWluZXJTZWxlY3QsIHRoaXMuZmlsdGVyZWRCb3hwbG90U3RhdHMsIHNtYWxsQm94cGxvdEhlaWdodCArIHRoaXMuYmV0d2VlbkJveHBsb3RQYWRkaW5nLCBzbWFsbEJveHBsb3RIZWlnaHQpXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCb3hwbG90KHRoaXMudG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0LCB0aGlzLnRvdGFsQm94cGxvdFN0YXRzLCAwLCB0aGlzLnZpekhlaWdodCk7ICAgICAgIFxuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZEJveHBsb3RDb250YWluZXJTZWxlY3QuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYXdBeGlzKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25MYWJlbHMoKTtcbiAgICB9XG5cblx0cHJvdGVjdGVkIGRyYXdGYWNldGVkRGF0YShmYWNldE9wdGlvbkluZGV4TGlzdDogbnVtYmVyW10pOiB2b2lkXG5cdHtcbiAgICAgICAgdGhpcy5kcmF3RmFjZXRlZERhdGFEZWZhdWx0UmVjdXJzZShmYWNldE9wdGlvbkluZGV4TGlzdCwgXCI5NSVcIiwgXCIxNzBweFwiKTtcblx0fVxuXG4gICAgcHJpdmF0ZSBzaG93TGFiZWwoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy54TGFiZWxUZXh0U2VsZWN0LmNsYXNzZWQoJ25vRGlzcCcsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdCb3hwbG90KGNvbnRhaW5lclNlbGVjdDogU3ZnU2VsZWN0aW9uLCBib3hwbG90U3RhdHM6IEJveHBsb3RTdGF0cywgdG9wOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gTWVkaWFuXG4gICAgICAgIGNvbnRhaW5lclNlbGVjdC5zZWxlY3RBbGwoJy5ib3hwbG90TWVkaWFuTGluZScpXG4gICAgICAgICAgICAuZGF0YTxudW1iZXI+KFtib3hwbG90U3RhdHMubWVkaWFuXSlcbiAgICAgICAgICAuam9pbignbGluZScpXG4gICAgICAgICAgICAuYXR0cigneDEnLCBkID0+IHRoaXMuc2NhbGVYKGQpKVxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgdG9wKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB0aGlzLnNjYWxlWChkKSlcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHRvcCArIGhlaWdodClcbiAgICAgICAgICAgIC5jbGFzc2VkKCdib3hwbG90TWVkaWFuTGluZScsIHRydWUpO1xuXG4gICAgICAgIC8vIElRUiBCb3hcbiAgICAgICAgY29udGFpbmVyU2VsZWN0LnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAuZGF0YTxbbnVtYmVyLCBudW1iZXJdPihbYm94cGxvdFN0YXRzLnF1YXJ0aWxlUmFuZ2VdKVxuICAgICAgICAgIC5qb2luKCdyZWN0JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdJUVItQm94JywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd4JywgZCA9PiB0aGlzLnNjYWxlWChkWzBdKSlcbiAgICAgICAgICAgIC5hdHRyKCd5JywgdG9wKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZCA9PiB0aGlzLnNjYWxlWChkWzFdKSAtIHRoaXMuc2NhbGVYKGRbMF0pKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dCb3hwbG90U3RhdHNQb3B1cChib3hwbG90U3RhdHMsIGNvbnRhaW5lclNlbGVjdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsICgpID0+IFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUJveHBsb3RTdGF0c1BvcHVwKClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgLy8gSG9yaXpvbnRhbCB3aGlza2VyIGxpbmVzXG4gICAgICAgIGNvbnN0IHZlcnRNaWRkbGUgPSB0b3AgKyAoaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRhaW5lclNlbGVjdC5zZWxlY3RBbGwoJy5ib3hwbG90V2hpc2tlcnMnKVxuICAgICAgICAgICAgLmRhdGE8W251bWJlciwgbnVtYmVyXT4oW1xuICAgICAgICAgICAgICAgIFtib3hwbG90U3RhdHMud2hpc2tlclJhbmdlWzBdLCBib3hwbG90U3RhdHMucXVhcnRpbGVSYW5nZVswXV0sXG4gICAgICAgICAgICAgICAgW2JveHBsb3RTdGF0cy53aGlza2VyUmFuZ2VbMV0sIGJveHBsb3RTdGF0cy5xdWFydGlsZVJhbmdlWzFdXV0pXG4gICAgICAgICAgLmpvaW4oJ2xpbmUnKVxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgZCA9PiB0aGlzLnNjYWxlWChkWzBdKSlcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIHZlcnRNaWRkbGUpXG4gICAgICAgICAgICAuYXR0cigneDInLCBkID0+IHRoaXMuc2NhbGVYKGRbMV0pKVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgdmVydE1pZGRsZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdib3hwbG90V2hpc2tlcnMnLCB0cnVlKTtcblxuICAgICAgICAvLyB2ZXJ0aWNhbCB3aGlza2VyIGVuZHBvaW50c1xuICAgICAgICBjb25zdCByZWxhdGl2ZVNpemUgPSAwLjY2OyAvLyBoZWlnaHQgb2Ygd2hpc2tlciBlbmRwb2ludHMgY29tcGFyZWQgdG8gYm94IGhlaWdodFxuICAgICAgICBjb25zdCBwYWRTaXplID0gaGVpZ2h0ICogKDEgLSByZWxhdGl2ZVNpemUpIC8gMjtcbiAgICAgICAgY29udGFpbmVyU2VsZWN0LnNlbGVjdEFsbCgnLmJveHBsb3RXaGlza2VyRW5kcycpXG4gICAgICAgICAgICAuZGF0YTxudW1iZXI+KGJveHBsb3RTdGF0cy53aGlza2VyUmFuZ2UpXG4gICAgICAgICAgLmpvaW4oJ2xpbmUnKVxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgZCA9PiB0aGlzLnNjYWxlWChkKSlcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIHRvcCArIHBhZFNpemUpXG4gICAgICAgICAgICAuYXR0cigneDInLCBkID0+IHRoaXMuc2NhbGVYKGQpKVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgdG9wICsgaGVpZ2h0IC0gcGFkU2l6ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdib3hwbG90V2hpc2tlckVuZHMnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNob3dCb3hwbG90U3RhdHNQb3B1cChib3hwbG90U3RhdHM6IEJveHBsb3RTdGF0cywgYm94cGxvdENvbnRhaW5lcjogU3ZnU2VsZWN0aW9uKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5ib3hwbG90U3RhdHNQb3B1cFNlbGVjdC5odG1sKG51bGwpO1xuICAgICAgICBjb25zdCBib3VuZFJlY3QgPSBib3hwbG90Q29udGFpbmVyLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0XG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLCBgbGVmdDogJHsoYm91bmRSZWN0LmxlZnQgKyBib3VuZFJlY3QucmlnaHQpIC8gMn1weDsgdG9wOiR7Ym91bmRSZWN0LmJvdHRvbX1weGApO1xuXG4gICAgICAgIHRoaXMuYm94cGxvdFN0YXRzUG9wdXBTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2JveHBsb3RTdGF0c1BvcHVwLXExJylcbiAgICAgICAgICAgIC50ZXh0KCdRMTogJyArIGJveHBsb3RTdGF0cy5xdWFydGlsZVJhbmdlWzBdLnRvRml4ZWQoNCkpO1xuXG4gICAgICAgIHRoaXMuYm94cGxvdFN0YXRzUG9wdXBTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2JveHBsb3RTdGF0c1BvcHVwLW1lZGlhbicpXG4gICAgICAgICAgICAudGV4dCgnTWVkaWFuOiAnICsgYm94cGxvdFN0YXRzLm1lZGlhbi50b0ZpeGVkKDQpKTtcblxuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0LmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdib3hwbG90U3RhdHNQb3B1cC1xMycpXG4gICAgICAgICAgICAudGV4dCgnUTM6ICcgKyBib3hwbG90U3RhdHMucXVhcnRpbGVSYW5nZVsxXS50b0ZpeGVkKDQpKTtcblxuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0LmNsYXNzZWQoJ25vRGlzcCcsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhpZGVCb3hwbG90U3RhdHNQb3B1cCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0LmNsYXNzZWQoJ25vRGlzcCcsIHRydWUpO1xuICAgIH1cblxuXHRwcml2YXRlIGRyYXdBeGlzKCk6IHZvaWRcblx0e1xuICAgICAgICB0aGlzLnhBeGlzR3JvdXBTZWxlY3RcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgKyB0aGlzLmF4aXNQYWRkaW5nfSlgKVxuXHRcdFx0LmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlWCkpO1xuXHR9XG5cbiAgICBwdWJsaWMgT25SZXNpemUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdmdTZWxlY3RcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLmNhbnZhc0VsZW1lbnQpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMudml6SGVpZ2h0IC0gMiAqIHRoaXMuc2NhdHRlcnBsb3RQYWRkaW5nKVxuICBcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsZXMoKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuXG4gICAgcHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJlZEJveHBsb3RTdGF0cygpO1xuICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBPcHRpb25TZWxlY3QgfSBmcm9tIFwiLi9PcHRpb25TZWxlY3RcIjtcbmltcG9ydCB7IEh0bWxTZWxlY3Rpb24sIEJ1dHRvblByb3BzIH0gZnJvbSBcIi4uL2RldmxpYi9EZXZMaWJUeXBlc1wiO1xuaW1wb3J0IHsgQXBwRGF0YSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSBcIi4uL2RldmxpYi9EZXZsaWJUU1V0aWxcIjtcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzJztcblxuZXhwb3J0IGNsYXNzIEdyb3VwQnlXaWRnZXRcbntcblxuXHRwcml2YXRlIHN0YXRpYyBfY29tcG9uZW50Q291bnQ6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIF9vdXRlckNvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBvdXRlckNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdXRlckNvbnRhaW5lcjtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfaW5uZXJDb21wb25lbnRJZCA6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IGlubmVyQ29tcG9uZW50SWQoKSA6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lckNvbXBvbmVudElkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21haW5Db250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgbWFpbkNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluQ29udGFpbmVyO1xuICAgIH0gICAgXG5cbiAgICBwcml2YXRlIF9ncm91cEJ5T3V0ZXJDb250YWluZXJMaXN0IDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGdyb3VwQnlPdXRlckNvbnRhaW5lckxpc3QoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBCeU91dGVyQ29udGFpbmVyTGlzdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kYXRhIDogQXBwRGF0YTxhbnk+O1xuICAgIHB1YmxpYyBnZXQgZGF0YSgpIDogQXBwRGF0YTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgZGF0YSh2IDogQXBwRGF0YTxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0IDogc3RyaW5nW107XG4gICAgcHVibGljIGdldCBncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdCgpIDogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3Q7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX2dyb3VwQnlPcHRpb25TZWxlY3RMaXN0IDogT3B0aW9uU2VsZWN0W107XG4gICAgcHVibGljIGdldCBncm91cEJ5T3B0aW9uU2VsZWN0TGlzdCgpIDogT3B0aW9uU2VsZWN0W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBCeU9wdGlvblNlbGVjdExpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBjdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0KCk6IG51bWJlcltdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEJ5T3B0aW9uU2VsZWN0TGlzdC5tYXAob3B0aW9uU2VsZWN0ID0+IG9wdGlvblNlbGVjdC5jdXJyZW50U2VsZWN0aW9uSW5kZXgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEh0bWxTZWxlY3Rpb24pXG4gICAge1xuICAgICAgICB0aGlzLl9vdXRlckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fbWFpbkNvbnRhaW5lciA9IHRoaXMub3V0ZXJDb250YWluZXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2dyb3VwQnlNYWluQ29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5faW5uZXJDb21wb25lbnRJZCA9ICdncm91cEJ5SW5uZXJDb250YWluZXJfJyArIEdyb3VwQnlXaWRnZXQuX2NvbXBvbmVudENvdW50ICsgJ18nO1xuICAgICAgICBHcm91cEJ5V2lkZ2V0Ll9jb21wb25lbnRDb3VudCsrO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0ID0gW107XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50SWQoKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZXMoWzBdKTtcblxuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0xpbmVzKHByZXZpb3VzU2VsZWN0aW9uczogbnVtYmVyW10pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9ncm91cEJ5T3V0ZXJDb250YWluZXJMaXN0ID0gdGhpcy5tYWluQ29udGFpbmVyLnNlbGVjdEFsbDxIVE1MRWxlbWVudCwgYW55PignLmdyb3VwQnlFbGVtZW50Q29udGFpbmVyJylcbiAgICAgICAgICAgIC5kYXRhKHRoaXMuZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3QpXG4gICAgICAgICAgICAuam9pbignZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdncm91cEJ5RWxlbWVudENvbnRhaW5lcicsIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuZ3JvdXBCeU91dGVyQ29udGFpbmVyTGlzdC5odG1sKG51bGwpO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBCeU91dGVyQ29udGFpbmVyTGlzdC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZ3JvdXBCeUNvbnRhaW5lcicsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignaWQnLCBkID0+IGQpO1xuXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZ3JvdXBCeU91dGVyQ29udGFpbmVyTGlzdFxuICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCwgaSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgaWNvbktleTogc3RyaW5nO1xuICAgICAgICAgICAgICAgIGxldCBjYWxsYmFjazogKGV2OiBNb3VzZUV2ZW50KSA9PiB2b2lkO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvbktleSA9ICdwbHVzJztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSAoKSA9PiBzZWxmLmFkZEdyb3VwQnlMaW5lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb25LZXkgPSAnbWludXMnXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gKCkgPT4gc2VsZi5yZW1vdmVHcm91cEJ5TGluZShpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGljb25CdXR0b24gPSBEZXZsaWJUU1V0aWwuZ2V0SWNvbkJ1dHRvbihpY29uS2V5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLm5vZGUoKS5hcHBlbmRDaGlsZChpY29uQnV0dG9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwQnlPcHRpb25TZWxlY3RMaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGNvbnRhaW5lcklkOiBzdHJpbmcgPSB0aGlzLmdyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0W2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uOiBudW1iZXI7XG4gICAgICAgICAgICBpZiAoaSA8IHByZXZpb3VzU2VsZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gcHJldmlvdXNTZWxlY3Rpb25zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHRoaXMuZ2V0Rmlyc3RVbnNlbGVjdGVkT3B0aW9uKHByZXZpb3VzU2VsZWN0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbGFiZWw6IHN0cmluZztcbiAgICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gXCJHcm91cCBieVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gJ2FuZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3B0aW9uU2VsZWN0ID0gbmV3IE9wdGlvblNlbGVjdChjb250YWluZXJJZCwgbGFiZWwsIHNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBCeU9wdGlvblNlbGVjdExpc3QucHVzaChvcHRpb25TZWxlY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlR3JvdXBCeU9wdGlvbnModGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Rmlyc3RVbnNlbGVjdGVkT3B0aW9uKHNlbGVjdGlvbnM6IG51bWJlcltdKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgbWF4SW5kZXg6IG51bWJlcjtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgbWF4SW5kZXggPSB0aGlzLmRhdGEuR2V0RmFjZXRPcHRpb25zKCkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbWF4SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSAwO1xuICAgICAgICB3aGlsZSAoc2VsZWN0aW9ucy5pbmNsdWRlcyhjYW5kaWRhdGUpICYmIGNhbmRpZGF0ZSA8PSBtYXhJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgY2FuZGlkYXRlKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkR3JvdXBCeUxpbmUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb25zID0gdGhpcy5jdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0O1xuICAgICAgICBjb25zdCBhZGRlZCA9IHRoaXMuYWRkQ29tcG9uZW50SWQoKTtcbiAgICAgICAgaWYgKCFhZGRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0xpbmVzKHByZXZpb3VzU2VsZWN0aW9ucyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRDb21wb25lbnRJZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBjb25zdCBudW1iZXJPZkV4aXN0aW5nTGluZXMgPSB0aGlzLmdyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGZhY2V0T3B0aW9ucyA9IHRoaXMuZGF0YS5HZXRGYWNldE9wdGlvbnMoKTtcbiAgICAgICAgICAgIGlmIChmYWNldE9wdGlvbnMubGVuZ3RoID09PSBudW1iZXJPZkV4aXN0aW5nTGluZXMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3SWQgPSB0aGlzLmlubmVyQ29tcG9uZW50SWQgKyBudW1iZXJPZkV4aXN0aW5nTGluZXM7XG4gICAgICAgIHRoaXMuZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3QucHVzaChuZXdJZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlR3JvdXBCeUxpbmUobGluZUluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdGlvbnMgPSB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleExpc3Q7XG4gICAgICAgIHByZXZpb3VzU2VsZWN0aW9ucy5zcGxpY2UobGluZUluZGV4LCAxKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3QubGVuZ3RoID4gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5ncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdMaW5lcyhwcmV2aW91c1NlbGVjdGlvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyB1cGRhdGVHcm91cEJ5T3B0aW9ucyhkYXRhOiBBcHBEYXRhPGFueT4sIHNraXBFdmVudFRyaWdnZXI6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICBsZXQgZmFjZXRPcHRpb25zID0gZGF0YS5HZXRGYWNldE9wdGlvbnMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmdyb3VwQnlPcHRpb25TZWxlY3RMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgYnV0dG9uUHJvcHNMaXN0OiBCdXR0b25Qcm9wc1tdID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBmYWNldE9wdGlvbiBvZiBmYWNldE9wdGlvbnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1dHRvblByb3BzOiBCdXR0b25Qcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGZhY2V0T3B0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLm9uR3JvdXBTZWxlY3Rpb24oKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidXR0b25Qcm9wc0xpc3QucHVzaChidXR0b25Qcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdyb3VwQnlPcHRpb25TZWxlY3RMaXN0W2ldLm9uRGF0YUNoYW5nZShidXR0b25Qcm9wc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcEV2ZW50VHJpZ2dlcilcbiAgICAgICAgeyAgIFxuICAgICAgICAgICAgdGhpcy5vbkdyb3VwU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uR3JvdXBTZWxlY3Rpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnQ6IEN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdncm91cEJ5Q2hhbmdlZCcsIHsgZGV0YWlsOlxuICAgICAgICB7XG4gICAgICAgICAgICBncm91cEluZGV4OiB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleExpc3RcbiAgICAgICAgfX0pO1xuICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQge1N2Z1NlbGVjdGlvbn0gZnJvbSAnLi4vZGV2bGliL0RldkxpYlR5cGVzJztcbmltcG9ydCB7QmFzZVdpZGdldH0gZnJvbSAnLi9CYXNlV2lkZ2V0JztcbmltcG9ydCB7IHZhbHVlRmlsdGVyLCBQb2ludENvbGxlY3Rpb24gfSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IE5EaW0gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVHlwZXMnO1xuaW1wb3J0IHsgRGF0YXNldFNwZWMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBEZXZsaWJBbGdvIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYkFsZ28nO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlRTVXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBIaXN0b2dyYW1XaWRnZXQgZXh0ZW5kcyBCYXNlV2lkZ2V0PFBvaW50Q29sbGVjdGlvbiwgRGF0YXNldFNwZWM+IHtcblxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCB2YWx1ZUtleTogc3RyaW5nLCBjYW5CcnVzaDogYm9vbGVhbiA9IHRydWUsIGluY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uOiBib29sZWFuID0gZmFsc2UpXG5cdHtcblx0XHRzdXBlcihjb250YWluZXIsIHRydWUsIGNhbkJydXNoLCBpbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbik7XG5cdFx0dGhpcy5fdmFsdWVLZXkgPSB2YWx1ZUtleTtcblx0XHR0aGlzLnNldExhYmVsKCk7XG5cdH1cblxuICAgIHByb3RlY3RlZCBDbG9uZShjb250YWluZXI6IEhUTUxFbGVtZW50KTogQmFzZVdpZGdldDxQb2ludENvbGxlY3Rpb24sIERhdGFzZXRTcGVjPlxuICAgIHtcblx0XHRjb25zdCBjYW5CcnVzaCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2xvbmUgPSBuZXcgSGlzdG9ncmFtV2lkZ2V0KGNvbnRhaW5lciwgdGhpcy52YWx1ZUtleSwgY2FuQnJ1c2gpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG5cdHByb3RlY3RlZCBpbml0UHJvcHMocHJvcHM/OiBhbnlbXSk6IHZvaWRcblx0e1xuXHRcdHN1cGVyLmluaXRQcm9wcygpO1xuXHRcdHRoaXMuX2NhbkJydXNoID0gcHJvcHNbMF07XG5cdFx0dGhpcy5faW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24gPSBwcm9wc1sxXTtcblx0fVxuXG5cdHByaXZhdGUgX3ZhbHVlS2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHZhbHVlS2V5KCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZUtleTtcblx0fVxuXHRcblx0cHJpdmF0ZSBfc29ydGVkRGF0YSA6IE5EaW1bXTtcblx0cHVibGljIGdldCBzb3J0ZWREYXRhKCkgOiBORGltW10ge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0ZWREYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBfc3ZnU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHN2Z1NlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ZnU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbWFpbkdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IG1haW5Hcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFpbkdyb3VwU2VsZWN0O1xuXHR9XG5cdFxuXHRwcml2YXRlIF90b3RhbEhpc3RvZ3JhbUdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHRvdGFsSGlzdG9ncmFtR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvdGFsSGlzdG9ncmFtR3JvdXBTZWxlY3Q7XG5cdH1cblx0XG5cdHByaXZhdGUgX2JydXNoZWRIaXN0b2dyYW1Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBicnVzaGVkSGlzdG9ncmFtR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoZWRIaXN0b2dyYW1Hcm91cFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3RvdGFsS0RFR3JvdXBTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgdG90YWxLREVHcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fdG90YWxLREVHcm91cFNlbGVjdDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfYnJ1c2hlZEtERUdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGJydXNoZWRLREVHcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fYnJ1c2hlZEtERUdyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FuQnJ1c2ggOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGNhbkJydXNoKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FuQnJ1c2g7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaEdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGJydXNoR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9heGlzR3JvdXBTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgYXhpc0dyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9heGlzR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9sYWJlbFRleHRTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgbGFiZWxUZXh0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9sYWJlbFRleHRTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVggOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVYKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVg7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVlIaXN0b2dyYW1BYnNvbHV0ZSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcblx0cHVibGljIGdldCBzY2FsZVlIaXN0b2dyYW1BYnNvbHV0ZSgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGVZSGlzdG9ncmFtQWJzb2x1dGU7XG5cdH1cblx0cHJpdmF0ZSBfc2NhbGVZSGlzdG9ncmFtUmVsYXRpdmUgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVZSGlzdG9ncmFtUmVsYXRpdmUoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYWxlWUhpc3RvZ3JhbVJlbGF0aXZlO1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhbGVZS2RlQWJzb2x1dGUgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVZS2RlQWJzb2x1dGUoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYWxlWUtkZUFic29sdXRlO1xuXHR9XG5cdHByaXZhdGUgX3NjYWxlWUtkZVJlbGF0aXZlIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IHNjYWxlWUtkZVJlbGF0aXZlKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVlLZGVSZWxhdGl2ZTtcblx0fVxuXG5cblx0cHJpdmF0ZSBfYWxsQmlucyA6IGQzLkJpbjxORGltLCBudW1iZXI+W107XG5cdHB1YmxpYyBnZXQgYWxsQmlucygpIDogZDMuQmluPE5EaW0sIG51bWJlcj5bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FsbEJpbnM7XG5cdH1cblx0XG5cdHByaXZhdGUgX2JydXNoZWRCaW5zIDogZDMuQmluPE5EaW0sIG51bWJlcj5bXTtcblx0cHVibGljIGdldCBicnVzaGVkQmlucygpIDogZDMuQmluPE5EaW0sIG51bWJlcj5bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoZWRCaW5zO1xuXHR9XG5cdHB1YmxpYyBzZXQgYnJ1c2hlZEJpbnModiA6IGQzLkJpbjxORGltLCBudW1iZXI+W10pIHtcblx0XHR0aGlzLl9icnVzaGVkQmlucyA9IHY7XG5cdH1cblxuXHRwcml2YXRlIF9hbGxQYXRoUG9pbnRzIDogW251bWJlciwgbnVtYmVyXVtdO1xuXHRwdWJsaWMgZ2V0IGFsbFBhdGhQb2ludHMoKSA6IFtudW1iZXIsIG51bWJlcl1bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FsbFBhdGhQb2ludHM7XG5cdH1cblxuXHRwcml2YXRlIF9tYXhEZW5zaXR5QWxsIDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IG1heERlbnNpdHlBbGwoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERlbnNpdHlBbGw7XG5cdH1cdFxuXG5cdHByaXZhdGUgX2JydXNoZWRQYXRoUG9pbnRzIDogW251bWJlciwgbnVtYmVyXVtdO1xuXHRwdWJsaWMgZ2V0IGJydXNoZWRQYXRoUG9pbnRzKCkgOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaGVkUGF0aFBvaW50cztcblx0fVxuXG5cdHByaXZhdGUgX2JydXNoZWRQb2ludHNMZW5ndGggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgYnJ1c2hlZFBvaW50c0xlbmd0aCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fYnJ1c2hlZFBvaW50c0xlbmd0aDtcblx0fVx0XG5cblx0cHJpdmF0ZSBfYXhpc1BhZGRpbmcgOiAgbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGF4aXNQYWRkaW5nKCkgOiAgbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fYXhpc1BhZGRpbmc7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaCA6IGQzLkJydXNoQmVoYXZpb3I8YW55Pjtcblx0cHVibGljIGdldCBicnVzaCgpIDogZDMuQnJ1c2hCZWhhdmlvcjxhbnk+IHtcblx0XHRyZXR1cm4gdGhpcy5fYnJ1c2g7XG5cdH1cblx0XG5cdFxuXHRwcml2YXRlIF91c2VIaXN0b2dyYW1CdXR0b24gOiBIVE1MQnV0dG9uRWxlbWVudDtcblx0cHVibGljIGdldCB1c2VIaXN0b2dyYW1CdXR0b24oKSA6IEhUTUxCdXR0b25FbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fdXNlSGlzdG9ncmFtQnV0dG9uO1xuXHR9XG5cblx0cHJpdmF0ZSBfdXNlS0RFQnV0dG9uIDogSFRNTEJ1dHRvbkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgdXNlS0RFQnV0dG9uKCkgOiBIVE1MQnV0dG9uRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX3VzZUtERUJ1dHRvbjtcblx0fVxuXHRcblx0cHJpdmF0ZSBzdGF0aWMgX3VzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbSA6IGJvb2xlYW4gPSBmYWxzZTtcblx0XG5cdHByaXZhdGUgc3RhdGljIGdldCB1c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0oKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBIaXN0b2dyYW1XaWRnZXQuX3VzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIHNldCB1c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0odiA6IGJvb2xlYW4pIHtcblx0XHRIaXN0b2dyYW1XaWRnZXQuX3VzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbSA9IHY7XG5cdFx0bGV0IGV2ZW50ID0gbmV3IEV2ZW50KCdzd2l0Y2hCZXR3ZWVuS2RlQW5kSGlzdG9ncmFtJyk7XG5cdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH1cdFxuXHRcblx0XG5cdHByaXZhdGUgX3VzZUFic29sdXRlQnV0dG9uIDogSFRNTEJ1dHRvbkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgdXNlQWJzb2x1dGVCdXR0b24oKSA6IEhUTUxCdXR0b25FbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fdXNlQWJzb2x1dGVCdXR0b247XG5cdH1cblxuXHRwcml2YXRlIF91c2VSZWxhdGl2ZUJ1dHRvbiA6IEhUTUxCdXR0b25FbGVtZW50O1xuXHRwdWJsaWMgZ2V0IHVzZVJlbGF0aXZlQnV0dG9uKCkgOiBIVE1MQnV0dG9uRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX3VzZVJlbGF0aXZlQnV0dG9uO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgX3VzZUFic29sdXRlU2NhbGluZyA6IGJvb2xlYW4gPSB0cnVlO1xuXHRcblx0cHJpdmF0ZSBzdGF0aWMgZ2V0IHVzZUFic29sdXRlU2NhbGluZygpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIEhpc3RvZ3JhbVdpZGdldC5fdXNlQWJzb2x1dGVTY2FsaW5nO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgc2V0IHVzZUFic29sdXRlU2NhbGluZyh2IDogYm9vbGVhbikge1xuXHRcdEhpc3RvZ3JhbVdpZGdldC5fdXNlQWJzb2x1dGVTY2FsaW5nID0gdjtcblx0XHRsZXQgZXZlbnQgPSBuZXcgRXZlbnQoJ3N3aXRjaEJldHdlZW5BYnNvbHV0ZUFuZFJlbGF0aXZlU2NhbGluZycpO1xuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9XG5cblx0XG5cdHByaXZhdGUgX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbigpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uO1xuXHR9XG5cdHB1YmxpYyBzZXQgaW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24odiA6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9pbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbiA9IHY7XG5cdH1cblx0XG5cblx0cHJvdGVjdGVkIHNldE1hcmdpbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tYXJnaW4gPSB7XG5cdFx0XHR0b3A6IDYsXG5cdFx0XHRyaWdodDogOCxcblx0XHRcdGJvdHRvbTogNTAsXG5cdFx0XHRsZWZ0OiA4XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGluaXQoKTogdm9pZFxuXHR7XG5cdFx0XG5cdFx0dGhpcy5pbml0S0RFSElzdG9ncmFtVG9nZ2xlKCk7XG5cdFx0dGhpcy5pbml0QWJzb2x1dGVSZWxhdGl2ZVRvZ2dsZSgpO1xuXHRcdGlmICh0aGlzLmluY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uKVxuXHRcdHtcblx0XHRcdHRoaXMuaW5pdEV4ZW1wbGFyVHJhY2tCdXR0b24oKTtcblx0XHR9XG5cblx0XHR0aGlzLl9zdmdTZWxlY3QgPSBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpLmFwcGVuZChcInN2Z1wiKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0dGhpcy5fbWFpbkdyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApO1xuXHRcdFxuXHRcdGlmICh0aGlzLmNhbkJydXNoKVxuXHRcdHtcblx0XHRcdHRoaXMuX2JydXNoR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuXHRcdFx0XHQuY2xhc3NlZChcImJydXNoQ29udGFpbmVyXCIsIHRydWUpO1xuXG5cdFx0XHR0aGlzLl9icnVzaCA9IGQzLmJydXNoWCgpXG5cdFx0XHRcdC5leHRlbnQoW1swLCAwXSwgW3RoaXMudml6V2lkdGgsIHRoaXMudml6SGVpZ2h0XV0pXG5cdFx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7IHRoaXMuYnJ1c2hIYW5kbGVyKCkgfSk7XG5cdFx0XG5cdFx0XHR0aGlzLmJydXNoR3JvdXBTZWxlY3QuY2FsbCh0aGlzLmJydXNoKTtcblx0XHR9XG5cblx0XHR0aGlzLl90b3RhbEhpc3RvZ3JhbUdyb3VwU2VsZWN0ID0gdGhpcy5tYWluR3JvdXBTZWxlY3QuYXBwZW5kKCdnJyk7XG5cdFx0dGhpcy5fYnJ1c2hlZEhpc3RvZ3JhbUdyb3VwU2VsZWN0ID0gdGhpcy5tYWluR3JvdXBTZWxlY3QuYXBwZW5kKCdnJyk7XG5cblx0XHR0aGlzLl90b3RhbEtERUdyb3VwU2VsZWN0ID0gdGhpcy5tYWluR3JvdXBTZWxlY3QuYXBwZW5kKCdnJyk7XG5cdFx0dGhpcy5fYnJ1c2hlZEtERUdyb3VwU2VsZWN0ID0gdGhpcy5tYWluR3JvdXBTZWxlY3QuYXBwZW5kKCdnJyk7XG5cblx0XHR0aGlzLl9heGlzUGFkZGluZyA9IDI7XG5cblx0XHR0aGlzLl9heGlzR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIHRoaXMuYXhpc1BhZGRpbmd9KWApXG5cdFx0XHQuY2xhc3NlZCgnbGFiZWxDb2xvcicsIHRydWUpO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZXhlbXBsYXJBdHRyaWJ1dGVDaGFuZ2UnLCAoZTogQ3VzdG9tRXZlbnQpID0+IFxuXHRcdHtcblx0XHRcdGxldCBuZXdFeGVtcGxhckF0dHJpYnV0ZSA9IGUuZGV0YWlsO1xuXHRcdFx0aWYgKG5ld0V4ZW1wbGFyQXR0cmlidXRlID09PSB0aGlzLnZhbHVlS2V5KVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0S0RFSElzdG9ncmFtVG9nZ2xlKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3VzZUhpc3RvZ3JhbUJ1dHRvbiA9IHRoaXMuQWRkQnV0dG9uKCdjaGFydC1iYXInLCAoKSA9PlxuXHRcdHtcblx0XHRcdEhpc3RvZ3JhbVdpZGdldC51c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0gPSBmYWxzZTtcblx0XHR9KTtcblx0XHRcblx0XHR0aGlzLl91c2VLREVCdXR0b24gPSB0aGlzLkFkZEJ1dHRvbignY2hhcnQtYXJlYScsICgpID0+XG5cdFx0e1xuXHRcdFx0SGlzdG9ncmFtV2lkZ2V0LnVzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbSA9IHRydWU7XG5cdFx0fSk7XG5cdFx0aWYgKEhpc3RvZ3JhbVdpZGdldC51c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0pXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VLREVCdXR0b24pO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VIaXN0b2dyYW1CdXR0b24pO1xuXHRcdH1cblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXRjaEJldHdlZW5LZGVBbmRIaXN0b2dyYW0nLCAoZTogRXZlbnQpID0+IFxuXHRcdHtcblx0XHRcdGlmIChIaXN0b2dyYW1XaWRnZXQudXNlS2RlSW5zdGVhZE9mSGlzdG9ncmFtKVxuXHRcdFx0e1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyh0aGlzLnVzZUhpc3RvZ3JhbUJ1dHRvbik7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMudXNlS0RFQnV0dG9uKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VIaXN0b2dyYW1CdXR0b24pO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyh0aGlzLnVzZUtERUJ1dHRvbik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLk9uRGF0YUNoYW5nZSgpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0QWJzb2x1dGVSZWxhdGl2ZVRvZ2dsZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl91c2VBYnNvbHV0ZUJ1dHRvbiA9IHRoaXMuQWRkQnV0dG9uKCdoYXNodGFnJywgKCkgPT5cblx0XHR7XG5cdFx0XHRIaXN0b2dyYW1XaWRnZXQudXNlQWJzb2x1dGVTY2FsaW5nID0gdHJ1ZTtcblx0XHR9KTtcblx0XHRcblx0XHR0aGlzLl91c2VSZWxhdGl2ZUJ1dHRvbiA9IHRoaXMuQWRkQnV0dG9uKCdwZXJjZW50JywgKCkgPT5cblx0XHR7XG5cdFx0XHRIaXN0b2dyYW1XaWRnZXQudXNlQWJzb2x1dGVTY2FsaW5nID0gZmFsc2U7XG5cdFx0fSk7XG5cdFx0aWYgKEhpc3RvZ3JhbVdpZGdldC51c2VBYnNvbHV0ZVNjYWxpbmcpXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VBYnNvbHV0ZUJ1dHRvbik7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnVzZVJlbGF0aXZlQnV0dG9uKTtcblx0XHR9XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzd2l0Y2hCZXR3ZWVuQWJzb2x1dGVBbmRSZWxhdGl2ZVNjYWxpbmcnLCAoZTogRXZlbnQpID0+IFxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJub0Rpc3BcIikpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChIaXN0b2dyYW1XaWRnZXQudXNlQWJzb2x1dGVTY2FsaW5nKVxuXHRcdFx0e1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyh0aGlzLnVzZVJlbGF0aXZlQnV0dG9uKTtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VBYnNvbHV0ZUJ1dHRvbik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMudXNlUmVsYXRpdmVCdXR0b24pO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyh0aGlzLnVzZUFic29sdXRlQnV0dG9uKTtcblx0XHRcdH1cblx0XHRcdGlmIChIaXN0b2dyYW1XaWRnZXQudXNlS2RlSW5zdGVhZE9mSGlzdG9ncmFtKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmRyYXdBbGxLREUoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmRyYXdBbGxIaXN0b2dyYW1zKFtdLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgaW5pdEV4ZW1wbGFyVHJhY2tCdXR0b24oKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5BZGRCdXR0b24oJ3JvY2tldCcsIGFzeW5jICgpID0+XG5cdFx0e1xuXHRcdFx0bGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdsYXVuY2hFeGVtcGxhckN1cnZlJywge2RldGFpbDogdGhpcy52YWx1ZUtleX0pO1xuXHRcdFx0RGV2bGliVFNVdGlsLmxhdW5jaFNwaW5uZXIoKTtcblx0XHRcdGF3YWl0IERldmxpYlRTVXRpbC5tYWtlQXN5bmMoKCkgPT4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCkpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRMYWJlbCgpOiB2b2lkXG5cdHtcdFxuXHRcdGNvbnN0IGJ1ZmZlckZvckF4aXMgPSAzMiArIHRoaXMuYXhpc1BhZGRpbmc7XG5cdFx0dGhpcy5fbGFiZWxUZXh0U2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdCArIHRoaXMudml6V2lkdGggLyAyfSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIGJ1ZmZlckZvckF4aXN9KWApXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcblx0XHRcdC50ZXh0KHRoaXMudmFsdWVLZXkpO1xuXHR9XG5cblx0cHVibGljIE9uRGF0YUNoYW5nZSgpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwibm9EaXNwXCIpKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IHZhbGlkTnVtYmVycyA9IHRoaXMuZGF0YS5BcnJheS5maWx0ZXIoZCA9PiAhaXNOYU4oZC5nZXQodGhpcy52YWx1ZUtleSkpKTtcdFxuXHRcdHRoaXMuX2FsbEJpbnMgPSB0aGlzLmNhbGN1bGF0ZUJpbnModmFsaWROdW1iZXJzKTtcblx0XHR0aGlzLnVwZGF0ZVNjYWxlcyh2YWxpZE51bWJlcnMubGVuZ3RoKTtcblx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0Ll91c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0pXG5cdFx0e1xuXHRcdFx0bGV0IHNoYWxsb3dDb3B5ID0gWy4uLnZhbGlkTnVtYmVyc107XG5cdFx0XHRjb25zdCBrZXkgPSB0aGlzLnZhbHVlS2V5O1xuXHRcdFx0dGhpcy5fc29ydGVkRGF0YSA9IHNoYWxsb3dDb3B5LnNvcnQoKGEsYikgPT4gZDMuYXNjZW5kaW5nKGEuZ2V0KGtleSksIGIuZ2V0KGtleSkpKTtcblxuXHRcdFx0dGhpcy5fYWxsUGF0aFBvaW50cyA9IHRoaXMua2RlKHRoaXMuc29ydGVkRGF0YSk7XG5cdFx0XHR0aGlzLl9tYXhEZW5zaXR5QWxsID0gZDMubWF4KHRoaXMuYWxsUGF0aFBvaW50cywgZCA9PiBkWzFdKTtcblx0XHRcdHRoaXMuZHJhd0FsbEtERShmYWxzZSlcblx0XHRcdHRoaXMucmVtb3ZlSGlzdG9ncmFtcygpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5kcmF3QWxsSGlzdG9ncmFtcyh2YWxpZE51bWJlcnMpO1xuXHRcdFx0dGhpcy5yZW1vdmVLREVzKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kcmF3QXhpcygpO1xuXHR9XG5cblx0cHJpdmF0ZSBjYWxjdWxhdGVCaW5zKHBvaW50czogTkRpbVtdKTogZDMuQmluPE5EaW0sIG51bWJlcj5bXVxuXHR7XG5cdFx0bGV0IGNvdW50ID0gTWF0aC5yb3VuZChNYXRoLnNxcnQodGhpcy5mdWxsRGF0YS5sZW5ndGgpKSAvIDM7XG5cdFx0bGV0IG1pbk1heCA9IHRoaXMuZnVsbERhdGEuZ2V0TWluTWF4KHRoaXMudmFsdWVLZXkpO1xuXHRcdGxldCB4ID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0LmRvbWFpbihtaW5NYXgpXG5cdFx0XHQubmljZShjb3VudCk7XG5cblx0XHRsZXQgYmlucyA9IGQzLmhpc3RvZ3JhbTxORGltLCBudW1iZXI+KClcblx0XHRcdC5kb21haW4oeC5kb21haW4oKSBhcyBbbnVtYmVyLCBudW1iZXJdKVxuXHRcdFx0LnRocmVzaG9sZHMoeC50aWNrcyhjb3VudCkpXG5cdFx0XHQudmFsdWUoZCA9PiBkLmdldCh0aGlzLnZhbHVlS2V5KSlcblx0XHRcdChwb2ludHMpO1xuXG5cdFx0Ly8gYWNjb3VudCBmb3IgZGVnZW5lcmF0ZSBsYXN0IGJpbiAtXy1cblx0XHRsZXQgdWx0aW1hdGVCaW4gPSBiaW5zW2JpbnMubGVuZ3RoIC0gMV07XG5cdFx0aWYgKHVsdGltYXRlQmluLngwID09PSB1bHRpbWF0ZUJpbi54MSlcblx0XHR7XG5cdFx0XHRsZXQgcGVudWx0aW1hdGVCaW4gPSBiaW5zW2JpbnMubGVuZ3RoIC0gMl1cblx0XHRcdGlmIChwZW51bHRpbWF0ZUJpbilcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgdWx0aW1hdGVCaW4pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwZW51bHRpbWF0ZUJpbi5wdXNoKHBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYmlucztcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlSGlzdG9ncmFtcygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnRvdGFsSGlzdG9ncmFtR3JvdXBTZWxlY3QuaHRtbChudWxsKTtcblx0XHR0aGlzLmJydXNoZWRIaXN0b2dyYW1Hcm91cFNlbGVjdC5odG1sKG51bGwpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3QWxsSGlzdG9ncmFtcyh2YWxpZE51bWJlcnM/OiBORGltW10sIHNraXBSZWNhbGN1bGF0aW9uID0gZmFsc2UpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwibm9EaXNwXCIpKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCFza2lwUmVjYWxjdWxhdGlvbilcblx0XHR7XG5cdFx0XHRsZXQgYnJ1c2hlZE51bWJlcnMgPSB2YWxpZE51bWJlcnMuZmlsdGVyKGQgPT4gZC5pbkJydXNoKTtcblx0XHRcdGlmICh2YWxpZE51bWJlcnMubGVuZ3RoID09PSBicnVzaGVkTnVtYmVycy5sZW5ndGgpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYnJ1c2hlZEhpc3RvZ3JhbUdyb3VwU2VsZWN0Lmh0bWwobnVsbCk7XG5cdFx0XHRcdHRoaXMuX2JydXNoZWRCaW5zID0gW11cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fYnJ1c2hlZEJpbnMgPSB0aGlzLmNhbGN1bGF0ZUJpbnMoYnJ1c2hlZE51bWJlcnMpO1xuXHRcdFx0fVx0XG5cdFx0XHRcblx0XHRcdGxldCBiaWdnZXN0QmluUmVsYXRpdmVBbGwgPSBkMy5tYXgodGhpcy5hbGxCaW5zLCBkID0+IGQubGVuZ3RoIC8gdmFsaWROdW1iZXJzLmxlbmd0aCk7XG5cdFx0XHRsZXQgYmlnZ2VzdEJpblJlbGF0aXZlQnJ1c2hlZCA9IGQzLm1heCh0aGlzLmJydXNoZWRCaW5zLCBkID0+IGQubGVuZ3RoIC8gYnJ1c2hlZE51bWJlcnMubGVuZ3RoKTtcblx0XHRcdHRoaXMuX3NjYWxlWUhpc3RvZ3JhbVJlbGF0aXZlID0gZDMuc2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+KClcblx0XHRcdFx0LmRvbWFpbihbMCwgZDMubWF4KFtiaWdnZXN0QmluUmVsYXRpdmVBbGwsIGJpZ2dlc3RCaW5SZWxhdGl2ZUJydXNoZWRdKV0pXG5cdFx0XHRcdC5yYW5nZShbMCwgdGhpcy52aXpIZWlnaHRdKTtcblx0XHR9XG5cblxuXHRcdHRoaXMuZHJhd0hpc3RvZ3JhbSh0aGlzLnRvdGFsSGlzdG9ncmFtR3JvdXBTZWxlY3QsIHRoaXMuYWxsQmlucyk7XG5cdFx0dGhpcy5kcmF3SGlzdG9ncmFtKHRoaXMuYnJ1c2hlZEhpc3RvZ3JhbUdyb3VwU2VsZWN0LCB0aGlzLmJydXNoZWRCaW5zLCB0cnVlKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0hpc3RvZ3JhbShzZWxlY3Q6IFN2Z1NlbGVjdGlvbiwgYmluczogZDMuQmluPE5EaW0sIG51bWJlcj5bXSwgaW5CcnVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0aWYgKGJpbnMubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHNlbGVjdC5odG1sKG51bGwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgcGF0aFBvaW50cyA9IHRoaXMuZ2V0SGlzdG9ncmFtU2t5bGluZShiaW5zKTtcblx0XHRsZXQgbGluZUZ1bmMgPSBkMy5saW5lKClcblx0XHRcdC54KGQgPT4gZFswXSlcblx0XHRcdC55KGQgPT4gZFsxXSlcblx0XHRcdC5kZWZpbmVkKGQgPT4gZFswXSAhPT0gbnVsbCk7XG5cblxuXHRcdHNlbGVjdC5zZWxlY3RBbGwoJ3BhdGgnKVxuXHRcdFx0LmRhdGEoW2xpbmVGdW5jKHBhdGhQb2ludHMpXSlcblx0XHRcdC5qb2luKCdwYXRoJylcblx0XHRcdC5jbGFzc2VkKCdrZGVQYXRoJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdpbkJydXNoJywgaW5CcnVzaClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5hdHRyKCdkJywgZCA9PiBkKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0SGlzdG9ncmFtU2t5bGluZShiaW5zOiBkMy5CaW48TkRpbSwgbnVtYmVyPltdLCBzaW5nbGVXaWR0aDogbnVtYmVyID0gMTgpOiBbbnVtYmVyLCBudW1iZXJdW11cblx0e1xuXHRcdFxuXHRcdGxldCBwYXRoUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcblxuXHRcdGlmIChiaW5zLmxlbmd0aCA9PT0gMSlcblx0XHR7XG5cdFx0XHRsZXQgbGVmdCA9ICh0aGlzLnZpeldpZHRoIC0gc2luZ2xlV2lkdGgpIC8gMjtcblx0XHRcdGxldCByaWdodCA9ICh0aGlzLnZpeldpZHRoICsgc2luZ2xlV2lkdGgpIC8gMlxuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFtsZWZ0LCB0aGlzLnZpekhlaWdodF0pO1xuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFtsZWZ0LCAwXSk7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3JpZ2h0LCAwXSk7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3JpZ2h0LCB0aGlzLnZpekhlaWdodF0pO1xuXHRcdFx0cmV0dXJuIHBhdGhQb2ludHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdG90YWxDb3VudCA9IGQzLnN1bShiaW5zLCBiaW4gPT4gYmluLmxlbmd0aCk7XG5cblx0XHRmb3IgKGxldCBiaW4gb2YgYmlucylcblx0XHR7XG5cdFx0XHRsZXQgeDE6IG51bWJlciA9IHRoaXMuc2NhbGVYKGJpbi54MCk7XG5cdFx0XHRsZXQgb2Zmc2V0OiBudW1iZXI7XG5cdFx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0LnVzZUFic29sdXRlU2NhbGluZylcblx0XHRcdHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5zY2FsZVlIaXN0b2dyYW1BYnNvbHV0ZShiaW4ubGVuZ3RoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5zY2FsZVlIaXN0b2dyYW1SZWxhdGl2ZShiaW4ubGVuZ3RoIC8gdG90YWxDb3VudCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgeTogbnVtYmVyID0gdGhpcy52aXpIZWlnaHQgLSBvZmZzZXQ7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3gxLCB5XSk7XG5cblx0XHRcdGlmIChiaW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgc3BsaXRQb2ludDogW251bWJlciwgbnVtYmVyXSA9IFtudWxsLCBudWxsXTtcblx0XHRcdFx0cGF0aFBvaW50cy5wdXNoKHNwbGl0UG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgeDI6IG51bWJlciA9IHRoaXMuc2NhbGVYKGJpbi54MSk7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3gyLCB5XSk7XG5cdFx0fVxuXHRcdFxuXG5cdFx0cGF0aFBvaW50cy51bnNoaWZ0KFswLCB0aGlzLnZpekhlaWdodF0pO1xuXHRcdHBhdGhQb2ludHMucHVzaChbdGhpcy52aXpXaWR0aCwgdGhpcy52aXpIZWlnaHRdKTtcblxuXHRcdHJldHVybiBwYXRoUG9pbnRzO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVLREVzKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMudG90YWxLREVHcm91cFNlbGVjdC5odG1sKG51bGwpO1xuXHRcdHRoaXMuYnJ1c2hlZEtERUdyb3VwU2VsZWN0Lmh0bWwobnVsbCk7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdBbGxLREUoZmlsdGVyQ2hhbmdlZDogYm9vbGVhbik6IHZvaWRcblx0e1xuXG5cdFx0bGV0IGJydXNoZWRQb2ludHMgPSB0aGlzLnNvcnRlZERhdGEuZmlsdGVyKGQgPT4gZC5pbkJydXNoKTtcblx0XHR0aGlzLl9icnVzaGVkUGF0aFBvaW50cyA9IHRoaXMua2RlKGJydXNoZWRQb2ludHMpO1xuXHRcdHRoaXMuX2JydXNoZWRQb2ludHNMZW5ndGggPSBicnVzaGVkUG9pbnRzLmxlbmd0aDtcblxuXHRcdGxldCBtYXhEb21haW4gPSB0aGlzLm1heERlbnNpdHlBbGw7XG5cdFx0aWYgKCFIaXN0b2dyYW1XaWRnZXQudXNlQWJzb2x1dGVTY2FsaW5nKVxuXHRcdHtcblx0XHRcdGxldCBtYXhWYWxCcnVzaGVkID0gZDMubWF4KHRoaXMuYnJ1c2hlZFBhdGhQb2ludHMsIGQgPT4gZFsxXSk7XG5cdFx0XHRtYXhEb21haW4gPSBkMy5tYXgoW21heERvbWFpbiwgbWF4VmFsQnJ1c2hlZF0pXG5cdFx0fVxuXG5cdFx0dGhpcy5fc2NhbGVZS2RlUmVsYXRpdmUgPSBkMy5zY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4oKVxuXHRcdFx0LmRvbWFpbihbMCwgbWF4RG9tYWluXSlcblx0XHRcdC5yYW5nZShbdGhpcy52aXpIZWlnaHQsIDBdKTtcblxuXHRcdGlmICghZmlsdGVyQ2hhbmdlZCB8fCBIaXN0b2dyYW1XaWRnZXQudXNlQWJzb2x1dGVTY2FsaW5nKVxuXHRcdHtcdFxuXHRcdFx0dGhpcy5kcmF3S0RFKHRoaXMuc29ydGVkRGF0YS5sZW5ndGgsIHRoaXMuYWxsUGF0aFBvaW50cywgZmFsc2UsIHRoaXMudG90YWxLREVHcm91cFNlbGVjdCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmJydXNoZWRQb2ludHNMZW5ndGggPT09IHRoaXMuc29ydGVkRGF0YS5sZW5ndGgpXG5cdFx0e1xuXHRcdFx0dGhpcy5icnVzaGVkS0RFR3JvdXBTZWxlY3QuaHRtbChudWxsKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuZHJhd0tERSh0aGlzLmJydXNoZWRQb2ludHNMZW5ndGgsIHRoaXMuYnJ1c2hlZFBhdGhQb2ludHMsIHRydWUsIHRoaXMuYnJ1c2hlZEtERUdyb3VwU2VsZWN0KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGRyYXdLREUobnVtUG9pbnRzOiBudW1iZXIsIHBhdGhQb2ludHM6IFtudW1iZXIsIG51bWJlcl1bXSwgaW5CcnVzaDogYm9vbGVhbiwgc2VsZWN0OiBTdmdTZWxlY3Rpb24pOiB2b2lkXG5cdHtcblx0XHRsZXQgeUZ1bmM6IChkOiBbbnVtYmVyLCBudW1iZXJdKSA9PiBudW1iZXI7XG5cblx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0LnVzZUFic29sdXRlU2NhbGluZylcblx0XHR7XG5cdFx0XHR5RnVuYyA9IGQgPT4gdGhpcy5zY2FsZVlLZGVSZWxhdGl2ZSgobnVtUG9pbnRzIC8gdGhpcy5zb3J0ZWREYXRhLmxlbmd0aCApICogZFsxXSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR5RnVuYyA9IGQgPT4gdGhpcy5zY2FsZVlLZGVSZWxhdGl2ZShkWzFdKVxuXHRcdH1cblxuXHRcdGxldCBsaW5lRnVuYyA9IGQzLmxpbmUoKVxuXHRcdFx0Ly8gLmN1cnZlKGQzLmN1cnZlQmFzaXMpXG5cdFx0XHQueChkID0+IHRoaXMuc2NhbGVYKGRbMF0pKVxuXHRcdFx0LnkoeUZ1bmMpXG5cblx0XHRzZWxlY3Quc2VsZWN0QWxsKCdwYXRoJylcblx0XHRcdC5kYXRhKFtsaW5lRnVuYyhwYXRoUG9pbnRzKV0pXG5cdFx0XHQuam9pbigncGF0aCcpXG5cdFx0XHQuY2xhc3NlZCgna2RlUGF0aCcsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnaW5CcnVzaCcsIGluQnJ1c2gpXG5cdFx0XHQudHJhbnNpdGlvbigpXG5cdFx0XHQuYXR0cignZCcsIGQgPT4gZCk7XG5cdH1cblxuXHRwcml2YXRlIGtkZShwb2ludHM6IE5EaW1bXSk6IFtudW1iZXIsIG51bWJlcl1bXVxuXHR7XG5cdFx0Ly8gQXNzdW1lcyB0aGF0IHBvaW50cyBpcyBzb3J0ZWQgYmFzZWQgb24gdmFsdWVLZXlcblx0XHRjb25zdCBrZXJuZWw6IEZ1bmN0aW9uID0gdGhpcy5lcGFuZWNobmlrb3Y7XG5cdFx0bGV0IFtsb3csIGhpZ2hdID0gdGhpcy5zY2FsZVguZG9tYWluKCk7XG5cdFx0Y29uc3QgYmFuZHdpZHRoOiBudW1iZXIgPSAwLjAxICogKGhpZ2ggLSBsb3cpO1xuXHRcdGxldCB0aWNrcyA9IHRoaXMuc2NhbGVYLnRpY2tzKDEwMCk7XG5cblx0XHRsZXQgcGF0aFBvaW50czogW251bWJlciwgbnVtYmVyXVtdID0gW107XG5cdFx0Zm9yIChsZXQgdCBvZiB0aWNrcylcblx0XHR7XG5cdFx0XHQvLyBnZXQgaW5kZXggd2l0aCB2YWx1ZSBjbG9zZXN0IHRvIHRcblx0XHRcdGxldCBjb21wYXJlRnVuY3Rpb24gPSBEZXZsaWJBbGdvLmNvbXBhcmVQcm9wZXJ0eTxORGltPih0LCAocG9pbnQ6IE5EaW0pID0+IFxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gcG9pbnQuZ2V0KHRoaXMudmFsdWVLZXkpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGxldCBzdGFydEluZGV4OiBudW1iZXI7XG5cdFx0XHRsZXQgc2VhcmNoUmVzdWx0OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdID0gRGV2bGliQWxnby5CaW5hcnlTZWFyY2hJbmRleChwb2ludHMsIGNvbXBhcmVGdW5jdGlvbik7XG5cdFxuXHRcdFx0aWYgKHR5cGVvZiBzZWFyY2hSZXN1bHQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHR7XG5cdFx0XHRcdHN0YXJ0SW5kZXggPSBzZWFyY2hSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IFtpZHgxLCBpZHgyXSA9IHNlYXJjaFJlc3VsdDtcblx0XHRcdFx0aWYgKHR5cGVvZiBpZHgxICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3RhcnRJbmRleCA9IGlkeDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3RhcnRJbmRleCA9IGlkeDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bGV0IGtlcm5lbFN1bSA9IDA7XG5cdFx0XHQvLyBsb29rIGZvcndhcmRcblx0XHRcdGZvciAobGV0IGkgPSBzdGFydEluZGV4ICsgMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0bGV0IHBvaW50ID0gcG9pbnRzW2ldO1xuXHRcdFx0XHRsZXQgdTogbnVtYmVyID0gKHQgLSBwb2ludC5nZXQodGhpcy52YWx1ZUtleSkpIC8gYmFuZHdpZHRoO1xuXHRcdFx0XHRpZiAoTWF0aC5hYnModSkgPiAxKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2VybmVsU3VtICs9IGtlcm5lbCh1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9vayBiYWNrd2FyZFxuXHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPj0gMDsgaS0tKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgcG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdGxldCB1OiBudW1iZXIgPSAodCAtIHBvaW50LmdldCh0aGlzLnZhbHVlS2V5KSkgLyBiYW5kd2lkdGg7XG5cdFx0XHRcdGlmIChNYXRoLmFicyh1KSA+IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXJuZWxTdW0gKz0ga2VybmVsKHUpO1xuXHRcdFx0fVxuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFt0LCBrZXJuZWxTdW0gLyBwb2ludHMubGVuZ3RoXSk7XG5cdFx0fVxuXG5cdFx0cGF0aFBvaW50cy51bnNoaWZ0KFtsb3csIDBdKTtcblx0XHRwYXRoUG9pbnRzLnB1c2goW2hpZ2gsIDBdKTtcblx0XHRyZXR1cm4gcGF0aFBvaW50cztcblx0fVxuXG5cdHByaXZhdGUgZXBhbmVjaG5pa292KHU6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0Ly9odHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9LZXJuZWxfKHN0YXRpc3RpY3MpI0tlcm5lbF9mdW5jdGlvbnNfaW5fY29tbW9uX3VzZVxuXHRcdGlmIChNYXRoLmFicyh1KSA8PSAxKVxuXHRcdHtcblx0XHRcdHJldHVybiAwLjc1ICogKDEgLSB1ICogdSk7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVTY2FsZXModG90YWxDb3VudDogbnVtYmVyKTogdm9pZFxuXHR7XG5cblx0XHRsZXQgbWluQmluQm91bmRhcnkgPSB0aGlzLmFsbEJpbnNbMF0ueDA7XG5cdFx0bGV0IG1heEJpbkJvdW5kYXJ5ID0gdGhpcy5hbGxCaW5zW3RoaXMuYWxsQmlucy5sZW5ndGggLSAxXS54MTtcblxuXHRcdHRoaXMuX3NjYWxlWCA9IGQzLnNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPigpXG5cdFx0XHQuZG9tYWluKFttaW5CaW5Cb3VuZGFyeSwgbWF4QmluQm91bmRhcnldKVxuXHRcdFx0LnJhbmdlKFswLCB0aGlzLnZpeldpZHRoXSk7XG5cblx0XHRsZXQgYmlnZ2VzdEJpbkNvdW50ID0gZDMubWF4KHRoaXMuYWxsQmlucywgZCA9PiBkLmxlbmd0aCk7XG5cdFx0dGhpcy5fc2NhbGVZSGlzdG9ncmFtQWJzb2x1dGUgPSBkMy5zY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4oKVxuXHRcdFx0LmRvbWFpbihbMCwgYmlnZ2VzdEJpbkNvdW50XSlcblx0XHRcdC5yYW5nZShbMCwgdGhpcy52aXpIZWlnaHRdKTtcblx0fVxuXG5cdHB1YmxpYyBNb3ZlQnJ1c2gobmV3UmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gfCBudWxsKTogdm9pZFxuXHR7XG5cdFx0aWYgKG5ld1JhbmdlKVxuXHRcdHtcblx0XHRcdG5ld1JhbmdlWzBdID0gdGhpcy5zY2FsZVgobmV3UmFuZ2VbMF0pO1xuXHRcdFx0bmV3UmFuZ2VbMV0gPSB0aGlzLnNjYWxlWChuZXdSYW5nZVsxXSk7XG5cdFx0fVxuXHRcdHRoaXMuYnJ1c2hHcm91cFNlbGVjdC5jYWxsKHRoaXMuYnJ1c2gubW92ZSwgbmV3UmFuZ2UpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3QXhpcygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmF4aXNHcm91cFNlbGVjdFxuXHRcdFx0LmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlWCkudGlja3MoNSkpXG5cdH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5PbkRhdGFDaGFuZ2UoKTtcblx0fVxuXG5cdHByaXZhdGUgYnJ1c2hIYW5kbGVyKCk6ICB2b2lkXG5cdHtcblx0XHRjb25zdCBzZWxlY3Rpb246IFtudW1iZXIsIG51bWJlcl0gfCBudWxsICB8IHVuZGVmaW5lZCA9IGQzLmV2ZW50LnNlbGVjdGlvbjtcblx0XHRpZiAodHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBzZWxlY3Rpb24gPT09IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhpcy5kYXRhLnJlbW92ZUJydXNoKHRoaXMuQ29tcG9uZW50SWQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgW21pbkJvdW5kLCBtYXhCb3VuZF0gPSBzZWxlY3Rpb247XG5cdFx0bGV0IG1pblYgPSB0aGlzLnNjYWxlWC5pbnZlcnQobWluQm91bmQpO1xuXHRcdGxldCBtYXhWID0gdGhpcy5zY2FsZVguaW52ZXJ0KG1heEJvdW5kKTtcblxuXHRcdGxldCB2YWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRoaXMudmFsdWVLZXksXG5cdFx0XHRib3VuZDogW21pblYsIG1heFZdXG5cdFx0fVxuXG5cdFx0dGhpcy5kYXRhLmFkZEJydXNoKHRoaXMuQ29tcG9uZW50SWQsIHZhbHVlRmlsdGVyKTtcblx0fVxuXG5cdHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJub0Rpc3BcIikpXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0Ll91c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0pXG5cdFx0e1xuXHRcdFx0Ly8gdGhpcy5kcmF3QnJ1c2hlZEtERSgpO1xuXHRcdFx0dGhpcy5kcmF3QWxsS0RFKHRydWUpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0bGV0IHZhbGlkTnVtYmVycyA9IHRoaXMuZGF0YS5BcnJheS5maWx0ZXIoZCA9PiAhaXNOYU4oZC5nZXQodGhpcy52YWx1ZUtleSkpKTtcblx0XHRcdHRoaXMuZHJhd0FsbEhpc3RvZ3JhbXModmFsaWROdW1iZXJzKTtcblx0XHR9XG5cdH1cblxuXG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHtIdG1sU2VsZWN0aW9uLCBTdmdTZWxlY3Rpb24sIEJ1dHRvblByb3BzfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHtCYXNlV2lkZ2V0fSBmcm9tICcuL0Jhc2VXaWRnZXQnO1xuaW1wb3J0IHtJbWFnZVN0YWNrV2lkZ2V0fSBmcm9tICcuL0ltYWdlU3RhY2tXaWRnZXQnO1xuaW1wb3J0IHtJbWFnZU1ldGFEYXRhfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VNZXRhRGF0YSc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3QgfSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVMaXN0JztcbmltcG9ydCB7IERhdGFzZXRTcGVjLCBGYWNldCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEltYWdlRnJhbWUgfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VGcmFtZSc7XG5pbXBvcnQgeyBEZXZsaWJNYXRoIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYk1hdGgnO1xuaW1wb3J0IHsgUmljaFRvb2x0aXAgfSBmcm9tICcuL1JpY2hUb29sdGlwJztcbmltcG9ydCB7IEltYWdlTG9jYXRpb24gfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VMb2NhdGlvbic7XG5pbXBvcnQgeyBHcm91cEJ5V2lkZ2V0IH0gZnJvbSAnLi9Hcm91cEJ5V2lkZ2V0JztcbmltcG9ydCB7IEltYWdlU3RhY2tEYXRhUmVxdWVzdCB9IGZyb20gJy4uL0RhdGFNb2RlbC9JbWFnZVN0YWNrRGF0YVJlcXVlc3QnO1xuXG5leHBvcnQgY2xhc3MgSW1hZ2VTZWxlY3Rpb25XaWRnZXQgZXh0ZW5kcyBCYXNlV2lkZ2V0PEN1cnZlTGlzdCwgRGF0YXNldFNwZWM+IHtcbiAgICBcbiAgICBwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz5cbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VTZWxlY3Rpb25XaWRnZXQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbWFnZU1ldGFEYXRhIDogSW1hZ2VNZXRhRGF0YTtcbiAgICBwdWJsaWMgZ2V0IGltYWdlTWV0YURhdGEoKSA6IEltYWdlTWV0YURhdGEge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VNZXRhRGF0YTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfaW1hZ2VTdGFja0RhdGFSZXF1ZXN0IDogSW1hZ2VTdGFja0RhdGFSZXF1ZXN0O1xuICAgIHB1YmxpYyBnZXQgaW1hZ2VTdGFja0RhdGFSZXF1ZXN0KCkgOiBJbWFnZVN0YWNrRGF0YVJlcXVlc3Qge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VTdGFja0RhdGFSZXF1ZXN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2lubmVyQ29udGFpbmVyIDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGlubmVyQ29udGFpbmVyKCkgOiBIdG1sU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyQ29udGFpbmVyO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9pbWFnZVRyYWNrQ29udGFpbmVyIDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGltYWdlVHJhY2tDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VUcmFja0NvbnRhaW5lcjtcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25TZWxlY3Rpb25Db250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgbG9jYXRpb25TZWxlY3Rpb25Db250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25TZWxlY3Rpb25Db250YWluZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ3JvdXBCeVdpZGdldCA6IEdyb3VwQnlXaWRnZXQ7XG4gICAgcHVibGljIGdldCBncm91cEJ5V2lkZ2V0KCkgOiBHcm91cEJ5V2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwQnlXaWRnZXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25MaXN0Q29udGFpbmVyIDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGxvY2F0aW9uTGlzdENvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbkxpc3RDb250YWluZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW1hZ2VTdGFja0NvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBpbWFnZVN0YWNrQ29udGFpbmVyKCkgOiBIdG1sU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlU3RhY2tDb250YWluZXI7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2ltYWdlU3RhY2tXaWRnZXQgOiBJbWFnZVN0YWNrV2lkZ2V0O1xuICAgIHB1YmxpYyBnZXQgaW1hZ2VTdGFja1dpZGdldCgpIDogSW1hZ2VTdGFja1dpZGdldCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVN0YWNrV2lkZ2V0O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zZWxlY3RlZExvY2F0aW9uSWQgOiBudW1iZXIgfCBudWxsO1xuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWRMb2NhdGlvbklkKCkgOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkTG9jYXRpb25JZDtcbiAgICB9XG4gICAgXG4gICAgLy8gbG9jYXRpb24gSUQgZm9yIGhvdmVyZWQgdHJhY2tcbiAgICBwcml2YXRlIF9ob3ZlcmVkTG9jYXRpb25JZCA6IG51bWJlciB8IG51bGw7XG4gICAgcHVibGljIGdldCBob3ZlcmVkTG9jYXRpb25JZCgpIDogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3ZlcmVkTG9jYXRpb25JZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mcmFtZVRvb2x0aXAgOiBSaWNoVG9vbHRpcDtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lVG9vbHRpcCgpIDogUmljaFRvb2x0aXAge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVUb29sdGlwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ZyYW1lSGVpZ2h0IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgZnJhbWVIZWlnaHQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUhlaWdodDtcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfZnJhbWVIZWlnaHRTZWxlY3RlZCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lSGVpZ2h0U2VsZWN0ZWQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUhlaWdodFNlbGVjdGVkO1xuICAgIH0gICAgXG5cbiAgICBwcml2YXRlIF9mcmFtZU1hcmdpblRvcEJvdCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lTWFyZ2luVG9wQm90KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVNYXJnaW5Ub3BCb3Q7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2ZyYW1lU2NhbGVYIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuICAgIHB1YmxpYyBnZXQgZnJhbWVTY2FsZVgoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZVNjYWxlWDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mcmFtZVNjYWxlSGVpZ2h0IDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuICAgIHB1YmxpYyBnZXQgZnJhbWVTY2FsZUhlaWdodCgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lU2NhbGVIZWlnaHQ7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2hvdmVyZWRMb2NGcmFtZSA6IFtudW1iZXIsIG51bWJlcl0gfCBudWxsO1xuICAgIHB1YmxpYyBnZXQgaG92ZXJlZExvY0ZyYW1lKCkgOiBbbnVtYmVyLCBudW1iZXJdIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3ZlcmVkTG9jRnJhbWU7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX3NlbGVjdGVkTG9jRnJhbWUgOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWRMb2NGcmFtZSgpIDogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZExvY0ZyYW1lO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hvdmVyZWRMb2NJZCA6IG51bWJlciB8IG51bGw7XG4gICAgcHVibGljIGdldCBob3ZlcmVkTG9jSWQoKSA6IG51bWJlciB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJlZExvY0lkO1xuICAgIH1cblxuXHRwdWJsaWMgaW5pdCgpOiB2b2lkXG5cdHtcbiAgICAgICAgdGhpcy5fZnJhbWVIZWlnaHQgPSAyNDsgLy8gaGFyZGNvZGVkIGJhc2VkIG9uIENTU1xuICAgICAgICB0aGlzLl9mcmFtZUhlaWdodFNlbGVjdGVkID0gNDA7IC8vIGFsc28gYmFzZWQgb24gQ1NTXG4gICAgICAgIHRoaXMuX2ZyYW1lTWFyZ2luVG9wQm90ID0gODtcbiAgICAgICAgdGhpcy5fZnJhbWVUb29sdGlwID0gbmV3IFJpY2hUb29sdGlwKDAsIDApO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZExvY0ZyYW1lID0gWzEsIDFdO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkTG9jRnJhbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9ob3ZlcmVkTG9jSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzLmNvbnRhaW5lcikuYXBwZW5kKCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbm5lckNvbnRhaW5lci5jbGFzc2VkKCdpbWFnZVNlbGVjdGlvbkNvbnRhaW5lcicsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlVHJhY2tDb250YWluZXIgPSBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpLmFwcGVuZCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW1hZ2VUcmFja0NvbnRhaW5lclxuICAgICAgICAgICAgLmNsYXNzZWQoJ2ltYWdlVHJhY2tDb250YWluZXInLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9sb2NhdGlvblNlbGVjdGlvbkNvbnRhaW5lciA9IHRoaXMuaW5uZXJDb250YWluZXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2xvY2F0aW9uU2VsZWN0aW9uQ29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgZG9jdW1lbnQub25rZXlkb3duID0gKGV2ZW50KSA9PiB7dGhpcy5oYW5kbGVLZXlEb3duKGV2ZW50KX07XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBCeVdpZGdldCA9IG5ldyBHcm91cEJ5V2lkZ2V0KHRoaXMubG9jYXRpb25TZWxlY3Rpb25Db250YWluZXIpO1xuXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uTGlzdENvbnRhaW5lciA9IHRoaXMubG9jYXRpb25TZWxlY3Rpb25Db250YWluZXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2xvY2F0aW9uTGlzdENvbnRhaW5lcicsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlU3RhY2tDb250YWluZXIgPSB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdpbWFnZVN0YWNrQ29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdmVyZmxvdy1zY3JvbGwnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5faW1hZ2VTdGFja1dpZGdldCA9IG5ldyBJbWFnZVN0YWNrV2lkZ2V0KHRoaXMuaW1hZ2VTdGFja0NvbnRhaW5lci5ub2RlKCksIHRoaXMuaW1hZ2VUcmFja0NvbnRhaW5lci5ub2RlKCksIHRoaXMudml6SGVpZ2h0KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmcmFtZUhvdmVyQ2hhbmdlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbG9jSWQgPSBlLmRldGFpbC5sb2NhdGlvbklkO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVJZCA9IGUuZGV0YWlsLmZyYW1lSWQ7XG4gICAgICAgICAgICBjb25zdCBjZWxsSWQgPSBlLmRldGFpbC5jZWxsSWQ7XG4gICAgICAgICAgICB0aGlzLm9uSG92ZXJMb2NhdGlvbkZyYW1lKGxvY0lkLCBmcmFtZUlkLCBjZWxsSWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9jRnJhbWVDbGlja2VkJywgKGU6IEN1c3RvbUV2ZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBsb2NJZCA9IGUuZGV0YWlsLmxvY2F0aW9uSWQ7XG4gICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gZS5kZXRhaWwuZnJhbWVJZDtcbiAgICAgICAgICAgIHRoaXMub25DbGlja0xvY2F0aW9uRnJhbWUobG9jSWQsIGZyYW1lSWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdncm91cEJ5Q2hhbmdlZCcsIChlOiBDdXN0b21FdmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vZGVDaGFuZ2VSZWRyYXcnLCAoZTogQ3VzdG9tRXZlbnQpID0+IFxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5PblJlc2l6ZSgpO1xuXHR9XG5cblx0cHVibGljIE9uRGF0YUNoYW5nZSgpXG5cdHtcbiAgICAgICAgdGhpcy5faW1hZ2VNZXRhRGF0YSA9IEltYWdlTWV0YURhdGEuZnJvbVBvaW50Q29sbGVjdGlvbih0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLl9pbWFnZVN0YWNrRGF0YVJlcXVlc3QgPSBuZXcgSW1hZ2VTdGFja0RhdGFSZXF1ZXN0KHRoaXMuZGF0YS5TcGVjaWZpY2F0aW9uLmdvb2dsZURyaXZlSWQpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZExvY2F0aW9uSWQgPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25MaXN0WzBdLmxvY2F0aW9uSWQ7XG4gICAgICAgIHRoaXMuX2hvdmVyZWRMb2NhdGlvbklkID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRJbWFnZVN0YWNrV2lkZ2V0KCk7XG4gICAgICAgIHRoaXMuT25CcnVzaENoYW5nZSgpO1xuICAgICAgICB0aGlzLmdyb3VwQnlXaWRnZXQudXBkYXRlR3JvdXBCeU9wdGlvbnModGhpcy5kYXRhLCB0cnVlKTtcblxuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgc2V0SW1hZ2VTdGFja1dpZGdldChza2lwSW1hZ2VUcmFja0RyYXcgPSBmYWxzZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IFtsb2NJZCwgZnJhbWVJZF0gPSB0aGlzLnNlbGVjdGVkTG9jRnJhbWU7XG4gICAgICAgIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldEltYWdlKGxvY0lkLCBmcmFtZUlkLCAodG9wLCBsZWZ0LCBibG9iKSA9PiBcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LlNldEltYWdlUHJvcGVydGllcyhza2lwSW1hZ2VUcmFja0RyYXcsIGJsb2IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gdGhpcy5pbWFnZU1ldGFEYXRhLmxvY2F0aW9uTG9va3VwLmdldCh0aGlzLnNlbGVjdGVkTG9jYXRpb25JZCk7XG4gICAgICAgIHRoaXMuaW1hZ2VTdGFja1dpZGdldC5TZXREYXRhKHRoaXMuZGF0YSwgY3VycmVudExvY2F0aW9uLCB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdCwgc2tpcEltYWdlVHJhY2tEcmF3KTtcbiAgICB9XG5cblx0cHJvdGVjdGVkIE9uUmVzaXplKCk6IHZvaWRcblx0e1xuICAgICAgICBjb25zdCB0b3BIZWlnaHRNYXggPSAwLjUgKiB0aGlzLmhlaWdodDtcbiAgICAgICAgY29uc3QgYm90SGVpZ2h0TWF4ID0gdGhpcy5oZWlnaHQgLSB0b3BIZWlnaHRNYXg7XG4gICAgICAgIHRoaXMuaW1hZ2VTdGFja1dpZGdldC5PblJlc2l6ZSh0b3BIZWlnaHRNYXgsIGJvdEhlaWdodE1heCwgdGhpcy53aWR0aCk7XG4gICAgICAgIHRoaXMubG9jYXRpb25TZWxlY3Rpb25Db250YWluZXJcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdmVyZmxvdy1zY3JvbGwnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgYG1heC1oZWlnaHQ6ICR7dG9wSGVpZ2h0TWF4fXB4YClcbiAgICAgICAgdGhpcy5pbWFnZVRyYWNrQ29udGFpbmVyXG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLFxuICAgICAgICAgICAgYG1heC13aWR0aDogJHt0aGlzLndpZHRofXB4O1xuICAgICAgICAgICAgbWF4LWhlaWdodDogJHtib3RIZWlnaHRNYXh9cHg7XG4gICAgICAgICAgICB3aWR0aDogJHt0aGlzLndpZHRofXB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAke2JvdEhlaWdodE1heH1weDtgKVxuXHR9XG5cbiAgICBwdWJsaWMgT25CcnVzaENoYW5nZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmltYWdlTWV0YURhdGEudXBkYXRlSW5CcnVzaFByb3AodGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIHRoaXMuaW1hZ2VTdGFja1dpZGdldC5PbkJydXNoQ2hhbmdlKCk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgZHJhdygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmxvY2F0aW9uTGlzdENvbnRhaW5lci5odG1sKG51bGwpO1xuICAgICAgICB0aGlzLmRyYXdGYWNldFJlY3Vyc2UodGhpcy5ncm91cEJ5V2lkZ2V0LmN1cnJlbnRTZWxlY3Rpb25JbmRleExpc3QpO1xuICAgICAgICB0aGlzLmRyYXdTZWxlY3RlZERvdHMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdGYWNldFJlY3Vyc2UocmVtYWluaW5nU3ViRmFjZXRJbmRpY2VzOiBudW1iZXJbXSwgdmVydGljYWxQb3NpdGlvbjogbnVtYmVyID0gMCwgZmFjZXQ/OiBGYWNldCwgY29udGFpbmVyU2VsZWN0aW9uPzogSHRtbFNlbGVjdGlvbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBjb250YWluZXI6IEh0bWxTZWxlY3Rpb247XG4gICAgICAgIGlmIChjb250YWluZXJTZWxlY3Rpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMubG9jYXRpb25MaXN0Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5pbmdTdWJGYWNldEluZGljZXMubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRyYXdUZXJtaW5hbEZhY2V0KGNvbnRhaW5lciwgZmFjZXQubmFtZSwgZmFjZXQuZGF0YSwgdmVydGljYWxQb3NpdGlvbiwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGF0YTogQ3VydmVMaXN0O1xuICAgICAgICBpZiAoZmFjZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRhdGEgPSBmYWNldC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZhY2V0SW5kZXggPSByZW1haW5pbmdTdWJGYWNldEluZGljZXNbMF07XG4gICAgICAgIGxldCBmYWNldE9wdGlvbnMgPSBkYXRhLkdldEZhY2V0T3B0aW9ucygpO1xuXG4gICAgICAgIGxldCBoYXJkQ29kZWRPcHRpb24gPSBmYWNldE9wdGlvbnNbZmFjZXRJbmRleF07XG4gICAgICAgIGxldCBmYWNldExpc3QgPSBoYXJkQ29kZWRPcHRpb24uR2V0RmFjZXRzKCk7XG4gICAgICAgIGxldCBncm91cGVyRGl2XG4gICAgICAgIGlmIChmYWNldClcbiAgICAgICAge1xuICAgICAgICAgICAgZ3JvdXBlckRpdiAgPSB0aGlzLmRyYXdHcm91cGVyRmFjZXQoY29udGFpbmVyLCBmYWNldC5uYW1lLCB2ZXJ0aWNhbFBvc2l0aW9uLCByZW1haW5pbmdTdWJGYWNldEluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRQb3NpdGlvbiA9IHZlcnRpY2FsUG9zaXRpb247XG4gICAgICAgIGZvciAobGV0IGNoaWxkRmFjZXQgb2YgZmFjZXRMaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZFBvc2l0aW9uKys7XG4gICAgICAgICAgICB0aGlzLmRyYXdGYWNldFJlY3Vyc2UocmVtYWluaW5nU3ViRmFjZXRJbmRpY2VzLnNsaWNlKDEpLCBjaGlsZFBvc2l0aW9uLCBjaGlsZEZhY2V0LCBncm91cGVyRGl2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0dyb3VwZXJGYWNldChjb250YWluZXJTZWxlY3Rpb246IEh0bWxTZWxlY3Rpb24sIG5hbWU6IHN0cmluZywgdmVydGljYWxQb3NpdGlvbjogbnVtYmVyLCB6SW5kZXg6IG51bWJlcik6IEh0bWxTZWxlY3Rpb25cbiAgICB7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlRWxlbWVudChjb250YWluZXJTZWxlY3Rpb24sIG5hbWUsIHZlcnRpY2FsUG9zaXRpb24sIHpJbmRleCk7XG5cbiAgICAgICAgY29uc3QgZ3JvdXBlckRpdiA9IGNvbnRhaW5lclNlbGVjdGlvbi5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbG9jYXRpb25MaXN0R3JvdXBlcicsIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBncm91cGVyRGl2O1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd1RpdGxlRWxlbWVudChjb250YWluZXJTZWxlY3Rpb246IEh0bWxTZWxlY3Rpb24sIG5hbWU6IHN0cmluZywgdmVydGljYWxQb3NpdGlvbjogbnVtYmVyLCB6SW5kZXg6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IHRvcFBvcyA9ICh2ZXJ0aWNhbFBvc2l0aW9uIC0gMSkgKiAxOTtcblxuICAgICAgICBsZXQgc3R5bGVTdHJpbmcgPSBgdG9wOiAke3RvcFBvc31weDtgO1xuICAgICAgICBpZiAoekluZGV4ID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgc3R5bGVTdHJpbmcgKz0gYCB6LWluZGV4OiAke3pJbmRleH07YDtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXJTZWxlY3Rpb24uYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLnRleHQobmFtZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdsb2NhdGlvbkxpc3RDYXRUaXRsZScsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLCBzdHlsZVN0cmluZyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3VGVybWluYWxGYWNldChjb250YWluZXJTZWxlY3Rpb246IEh0bWxTZWxlY3Rpb24sIG5hbWU6IHN0cmluZywgZGF0YTogQ3VydmVMaXN0LCB2ZXJ0aWNhbFBvc2l0aW9uOiBudW1iZXIsIHpJbmRleDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGVFbGVtZW50KGNvbnRhaW5lclNlbGVjdGlvbiwgbmFtZSwgdmVydGljYWxQb3NpdGlvbiwgekluZGV4KTtcblxuICAgICAgICBjb25zdCBzdWJMaXN0Q29udGFpbmVyID0gY29udGFpbmVyU2VsZWN0aW9uLmFwcGVuZCgndWwnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3N1Ykxpc3RDb250YWluZXInLCB0cnVlKTtcblxuICAgICAgICBsZXQgbG9jYXRpb25MaXN0OiBudW1iZXJbXSA9IGRhdGEubG9jYXRpb25MaXN0O1xuICAgICAgICBpZiAodGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbG9jYXRpb25MaXN0ID0gbG9jYXRpb25MaXN0LmZpbHRlcihsb2MgPT4gdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmV4ZW1wbGFyTG9jYXRpb25zLmhhcyhsb2MpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGlzdEVsZW1lbnQgPSBzdWJMaXN0Q29udGFpbmVyLnNlbGVjdEFsbCgnbGknKVxuICAgICAgICAgICAgLmRhdGEobG9jYXRpb25MaXN0KVxuICAgICAgICAgICAgLmpvaW4oJ2xpJyk7XG5cbiAgICAgICAgbGlzdEVsZW1lbnQuaHRtbChudWxsKVxuICAgICAgICAgICAgLmFwcGVuZCgnYnV0dG9uJylcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZClcbiAgICAgICAgICAgIC5jbGFzc2VkKCdsb2NhdGlvbkJ1dHRvbicsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgndG9nZ2xlQnV0dG9uJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZCcsIGQgPT4gZCA9PSB0aGlzLnNlbGVjdGVkTG9jYXRpb25JZClcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGQgPT4gJ2ltYWdlTG9jYXRpb24tJyArIGQpXG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLCBkID0+IFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5pbWFnZU1ldGFEYXRhLmxvY2F0aW9uTG9va3VwLmdldChkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9wID0gKDEgLSBsb2NhdGlvbi5pbkJydXNoUGVyY2VudCkgKiAxMDBcbiAgICAgICAgICAgICAgICBjb25zdCBiYXJDb2xvciA9ICcjRURDQUM5JzsgLy8gbGlnaHRlciBmaXJlYnJpY2tcbiAgICAgICAgICAgICAgICByZXR1cm4gYGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBsZWZ0LCByZ2JhKDI1NSwyNTUsMjU1LDApLCByZ2JhKDI1NSwyNTUsMjU1LDApICR7c3RvcH0lLCAke2JhckNvbG9yfSwgJHtzdG9wfSUsICR7YmFyQ29sb3J9KWBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZCA9PiBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xpY2tMb2NhdGlvbihkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHdyYXBlclNlbGVjdGlvbiA9IGxpc3RFbGVtZW50LmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdmcmFtZUxpc3RDb250YWluZXInLCB0cnVlKTtcblxuICAgICAgICAvLyBnZXR0aW5nIHRoZSBmaXJzdCBvbmUsIHRoZXkgc2hvdWxkIGFsbCBiZSB0aGUgc2FtZVxuICAgICAgICBjb25zdCBiYm94ID0gd3JhcGVyU2VsZWN0aW9uLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgbWluaVdpZHRoID0gYmJveC53aWR0aDtcblxuICAgICAgICBjb25zdCBzdmdTZWxlY3Rpb24gPSB3cmFwZXJTZWxlY3Rpb24uYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgbWluaVdpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGQgPT4gZCA9PT0gdGhpcy5zZWxlY3RlZExvY2F0aW9uSWQgPyB0aGlzLmZyYW1lSGVpZ2h0U2VsZWN0ZWQgOiB0aGlzLmZyYW1lSGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgZCA9PiAnZnJhbWVUaWNrc1Zpei0nICsgZClcbiAgICAgICAgICAgIC5hdHRyKCdkYXRhLWxvY0lkJywgZCA9PiBkKVxuICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5faG92ZXJlZExvY0lkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVGcmFtZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUhvdmVyRG90cyhzdmdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSG92ZXJlZExvY2F0aW9uKG51bGwpO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBtYXJnaW5XID0gNDtcbiAgICAgICAgY29uc3QgZnJhbWVFeHRlbnQ6IFtudW1iZXIsIG51bWJlcl0gPSB0aGlzLmRhdGEuZ2V0TWluTWF4KCdGcmFtZSBJRCcpO1xuICAgICAgICB0aGlzLl9mcmFtZVNjYWxlWCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oZnJhbWVFeHRlbnQpXG4gICAgICAgICAgICAucmFuZ2UoW21hcmdpblcsIG1pbmlXaWR0aCAtICBtYXJnaW5XXSk7XG5cbiAgICAgICAgY29uc3Qgc2NhbGVMaW5lV2lkdGggPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFswLCAxXSlcbiAgICAgICAgICAgIC5yYW5nZShbMS4wLCAzLjBdKTtcblxuICAgICAgICB0aGlzLl9mcmFtZVNjYWxlSGVpZ2h0ID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihbMCwgMV0pXG4gICAgICAgICAgICAucmFuZ2UoWzEsIHRoaXMuZnJhbWVIZWlnaHQgLSAyICogdGhpcy5mcmFtZU1hcmdpblRvcEJvdF0pO1xuXG4gICAgICAgIHN2Z1NlbGVjdGlvbi5zZWxlY3RBbGwoJ2xpbmUnKVxuICAgICAgICAgICAgLmRhdGEoZCA9PiB0aGlzLmdldEZyYW1lTGlzdChkKSlcbiAgICAgICAgICAgIC5qb2luKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4gdGhpcy5mcmFtZVNjYWxlWChkLmZyYW1lSWQpKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB0aGlzLmZyYW1lU2NhbGVYKGQuZnJhbWVJZCkpXG4gICAgICAgICAgICAuYXR0cigneTEnLCBkID0+ICh0aGlzLmZyYW1lSGVpZ2h0IC0gdGhpcy5mcmFtZVNjYWxlSGVpZ2h0KGQuaW5CcnVzaFBlcmNlbnQpKSAvIDIpXG4gICAgICAgICAgICAuYXR0cigneTInLCBkID0+IHRoaXMuZnJhbWVIZWlnaHQgLSAodGhpcy5mcmFtZUhlaWdodCAtIHRoaXMuZnJhbWVTY2FsZUhlaWdodChkLmluQnJ1c2hQZXJjZW50KSkgLyAyKVxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIGQgPT4gc2NhbGVMaW5lV2lkdGgoZC5pbkJydXNoUGVyY2VudCkpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZCA9PiBkLmluQnJ1c2ggPyAnZmlyZWJyaWNrJyA6ICdibGFjaycpXG4gICAgICAgICAgICAuY2xhc3NlZCgndGlja01hcmsnLCB0cnVlKTtcbiAgICBcbiAgICAgICAgbGV0IHN2Z0xpc3QgPSBzdmdTZWxlY3Rpb24ubm9kZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdmdMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gc3ZnTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGxvY0lkID0gK3N2Z0VsZW1lbnQuZGF0YXNldFsnbG9jSWQnXTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRMb2NJZCA9IGxvY0lkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlWCA9IGV2ZW50Lm9mZnNldFg7XG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lSWQgPSB0aGlzLmZyYW1lU2NhbGVYLmludmVydChtb3VzZVgpO1xuICAgICAgICAgICAgICAgIGZyYW1lSWQgPSBEZXZsaWJNYXRoLmNsYW1wKE1hdGgucm91bmQoZnJhbWVJZCksIGZyYW1lRXh0ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSG92ZXJMb2NhdGlvbkZyYW1lKGxvY0lkLCBmcmFtZUlkLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3ZnRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudDogTW91c2VFdmVudCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZVggPSBldmVudC5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUlkID0gdGhpcy5mcmFtZVNjYWxlWC5pbnZlcnQobW91c2VYKTtcbiAgICAgICAgICAgICAgICBmcmFtZUlkID0gRGV2bGliTWF0aC5jbGFtcChNYXRoLnJvdW5kKGZyYW1lSWQpLCBmcmFtZUV4dGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrTG9jYXRpb25GcmFtZShsb2NJZCwgZnJhbWVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXHRwcml2YXRlIGhhbmRsZUtleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkXG5cdHtcbiAgICAgICAgbGV0IG5ld0luZGV4OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IFtsb2NJZCwgZnJhbWVJZF0gPSB0aGlzLmhvdmVyZWRMb2NGcmFtZTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KGxvY0lkKTtcbiAgICAgICAgbGV0IG5leHRGcmFtZUlkOiBudW1iZXI7XG5cdFx0c3dpdGNoIChldmVudC5rZXlDb2RlKVxuXHRcdHtcbiAgICAgICAgICAgIGNhc2UgMzc6IC8vIGxlZnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ob3ZlcmVkTG9jSWQgIT09IGxvY0lkKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkZyYW1lSWQgPSBsb2NhdGlvbi5mcmFtZUxpc3RbMF0uZnJhbWVJZDtcbiAgICAgICAgICAgICAgICBuZXh0RnJhbWVJZCA9IE1hdGgubWF4KGZyYW1lSWQgLSAxLCBtaW5GcmFtZUlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSG92ZXJMb2NhdGlvbkZyYW1lKGxvY0lkLCBuZXh0RnJhbWVJZCwgbnVsbCwgdHJ1ZSlcblx0XHRcdFx0YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyByaWdodFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyZWRMb2NJZCAhPT0gbG9jSWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4RnJhbWVJZCA9IGxvY2F0aW9uLmZyYW1lTGlzdFtsb2NhdGlvbi5mcmFtZUxpc3QubGVuZ3RoIC0gMV0uZnJhbWVJZDtcbiAgICAgICAgICAgICAgICBuZXh0RnJhbWVJZCA9IE1hdGgubWluKGZyYW1lSWQgKyAxLCBtYXhGcmFtZUlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSG92ZXJMb2NhdGlvbkZyYW1lKGxvY0lkLCBuZXh0RnJhbWVJZCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEzOiAvLyBlbnRlclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyZWRMb2NJZCAhPT0gbG9jSWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgdGhpcy5zd2l0Y2hUb0hvdmVyZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblx0XHR9XG5cdH1cblxuICAgIHByaXZhdGUgb25Ib3ZlckxvY2F0aW9uRnJhbWUobG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIgfCBudWxsLCBjZWxsSWQ6IHN0cmluZyB8IG51bGwsIHNob3dUb29sdGlwOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5faG92ZXJlZExvY0ZyYW1lID0gW2xvY2F0aW9uSWQsIGZyYW1lSWRdO1xuICAgICAgICBjb25zdCBsYXN0U3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5ob3ZlcmVkTG9jYXRpb25JZCkgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyRG90cyhsYXN0U3ZnQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3ZlckJhcihsYXN0U3ZnQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgbG9jYXRpb25JZCkgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmNoYW5nZUhvdmVyZWRMb2NhdGlvbihsb2NhdGlvbklkKTtcblxuICAgICAgICB0aGlzLmZyYW1lVG9vbHRpcC5IaWRlKCk7XG4gICAgICAgIGlmIChmcmFtZUlkID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dUb29sdGlwKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBiYm94ID0gc3ZnQ29udGFpbmVyLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHhQb3MgPSBiYm94LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3QgeVBvcyA9IGJib3gudG9wICsgYmJveC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3QgaHRtbFN0cmluZyA9IHRoaXMuY3JlYXRlVG9vbHRpcENvbnRlbnQobG9jYXRpb25JZCwgZnJhbWVJZCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lVG9vbHRpcC5TaG93KGh0bWxTdHJpbmcsIHhQb3MsIHlQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0hvdmVyRG90cyhzdmdDb250YWluZXIsIGxvY2F0aW9uSWQsIGZyYW1lSWQpO1xuICAgICAgICB0aGlzLmRyYXdGcmFtZVJhbmdlKHN2Z0NvbnRhaW5lciwgY2VsbElkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN3aXRjaFRvSG92ZXJlZCgpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBbbG9jSWQsIGZyYW1lSWRdID0gdGhpcy5ob3ZlcmVkTG9jRnJhbWU7XG4gICAgICAgIHRoaXMub25DbGlja0xvY2F0aW9uRnJhbWUobG9jSWQsIGZyYW1lSWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0ZyYW1lUmFuZ2Uoc3ZnQ29udGFpbmVyOiBTdmdTZWxlY3Rpb24sIGNlbGxJZDogc3RyaW5nIHwgbnVsbCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChjZWxsSWQgPT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSG92ZXJCYXIoc3ZnQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJ2ZSA9IHRoaXMuZGF0YS5jdXJ2ZUxvb2t1cC5nZXQoY2VsbElkKTtcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IGN1cnZlLnBvaW50TGlzdFswXTtcbiAgICAgICAgY29uc3QgbG93RnJhbWVJZCA9IGZpcnN0UG9pbnQuZ2V0KFwiRnJhbWUgSURcIik7XG4gICAgICAgIGNvbnN0IGxvY0lkID0gZmlyc3RQb2ludC5nZXQoJ0xvY2F0aW9uIElEJylcbiAgICAgICAgY29uc3QgbG9jYXRpb246IEltYWdlTG9jYXRpb24gPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KGxvY0lkKTtcbiAgICAgICAgY29uc3QgZnJhbWVMb3c6IEltYWdlRnJhbWUgPSBsb2NhdGlvbi5mcmFtZUxvb2t1cC5nZXQobG93RnJhbWVJZCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBjdXJ2ZS5wb2ludExpc3RbY3VydmUucG9pbnRMaXN0Lmxlbmd0aCAtIDFdXG4gICAgICAgIGNvbnN0IGhpZ2hGcmFtZUlkID0gbGFzdFBvaW50LmdldChcIkZyYW1lIElEXCIpO1xuICAgICAgICBjb25zdCBmcmFtZUhpZ2g6IEltYWdlRnJhbWUgPSBsb2NhdGlvbi5mcmFtZUxvb2t1cC5nZXQoaGlnaEZyYW1lSWQpO1xuXG4gICAgICAgIGNvbnN0IHhMb3cgPSB0aGlzLmZyYW1lU2NhbGVYKGxvd0ZyYW1lSWQpO1xuICAgICAgICBjb25zdCB4SGlnaCA9IHRoaXMuZnJhbWVTY2FsZVgoaGlnaEZyYW1lSWQpO1xuXG4gICAgICAgIGNvbnN0IGgxID0gKHRoaXMuZnJhbWVTY2FsZUhlaWdodChmcmFtZUxvdy5pbkJydXNoUGVyY2VudCkgKyB0aGlzLmZyYW1lSGVpZ2h0KSAvIDI7XG4gICAgICAgIGNvbnN0IGgyID0gKHRoaXMuZnJhbWVTY2FsZUhlaWdodChmcmFtZUhpZ2guaW5CcnVzaFBlcmNlbnQpICsgdGhpcy5mcmFtZUhlaWdodCkgLyAyO1xuXG4gICAgICAgIGNvbnN0IGJldHdlZW5UaWNrTWFyZ2luID0gMjtcbiAgICAgICAgY29uc3QgZnJvbUJvdHRvbU1hcmdpbiA9IDY7XG5cbiAgICAgICAgY29uc3QgeTEgPSBoMSArIGJldHdlZW5UaWNrTWFyZ2luO1xuICAgICAgICBjb25zdCB5MiA9IHRoaXMuZnJhbWVIZWlnaHRTZWxlY3RlZCAtIGZyb21Cb3R0b21NYXJnaW47XG4gICAgICAgIGNvbnN0IHkzID0gaDIgKyBiZXR3ZWVuVGlja01hcmdpbjtcblxuICAgICAgICBjb25zdCBwb2ludExpc3Q6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgICAgICAgICAgIFt4TG93LCB5MV0sXG4gICAgICAgICAgICBbeExvdywgeTJdLFxuICAgICAgICAgICAgW3hIaWdoLCB5Ml0sXG4gICAgICAgICAgICBbeEhpZ2gsIHkzXVxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IGxpbmVGdW5jdGlvbiA9IGQzLmxpbmU8W251bWJlciwgbnVtYmVyXT4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAueChkID0+IGRbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC55KGQgPT4gZFsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmN1cnZlKGQzLmN1cnZlQmFzaXMpO1xuXG4gICAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IGxpbmVGdW5jdGlvbihwb2ludExpc3QpO1xuICAgICAgICBcbiAgICAgICAgc3ZnQ29udGFpbmVyLnNlbGVjdEFsbCgnLmhvdmVyQmFyJylcbiAgICAgICAgICAgIC5kYXRhKFtwYXRoXSlcbiAgICAgICAgICAgIC5qb2luKCdwYXRoJylcbiAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aClcbiAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlckJhcicsIHRydWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlSG92ZXJCYXIoc3ZnQ29udGFpbmVyOiBTdmdTZWxlY3Rpb24pOiB2b2lkXG4gICAge1xuICAgICAgICBzdmdDb250YWluZXIuc2VsZWN0QWxsKCcuaG92ZXJCYXInKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdIb3ZlckRvdHMoc3ZnQ29udGFpbmVyOiBTdmdTZWxlY3Rpb24sIGxvY2F0aW9uSWQ6IG51bWJlciwgZnJhbWVJZDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgeHlQb3NpdGlvbnM6IFtudW1iZXIsIG51bWJlcl1bXSA9dGhpcy5nZXREb3RDZW50ZXJzKGxvY2F0aW9uSWQsIGZyYW1lSWQpO1xuICAgICAgICBjb25zdCBkb3RSID0gMjtcbiAgICAgICAgc3ZnQ29udGFpbmVyLnNlbGVjdEFsbCgnLmhvdmVyRG90JylcbiAgICAgICAgICAgIC5kYXRhKHh5UG9zaXRpb25zKVxuICAgICAgICAgICAgLmpvaW4oJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXJEb3QnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiBkWzBdKVxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBkWzFdKVxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnI0VDRUNFQycpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZG90UilcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd1NlbGVjdGVkRG90cygpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBbbG9jYXRpb25JZCwgZnJhbWVJZF0gPSB0aGlzLnNlbGVjdGVkTG9jRnJhbWU7XG4gICAgICAgIGNvbnN0IHh5UG9zaXRpb25zOiBbbnVtYmVyLCBudW1iZXJdW10gPXRoaXMuZ2V0RG90Q2VudGVycyhsb2NhdGlvbklkLCBmcmFtZUlkKTtcbiAgICAgICAgY29uc3QgZG90UiA9IDM7XG5cbiAgICAgICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgbG9jYXRpb25JZCkgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICBzdmdDb250YWluZXIuc2VsZWN0QWxsKCcuc2VsZWN0ZWREb3QnKVxuICAgICAgICAgICAgLmRhdGEoeHlQb3NpdGlvbnMpXG4gICAgICAgICAgICAuam9pbignY2lyY2xlJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZERvdCcsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IGRbMF0pXG4gICAgICAgICAgICAuYXR0cignY3knLCBkID0+IGRbMV0pXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZG90UilcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0RG90Q2VudGVycyhsb2NhdGlvbklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl1bXVxuICAgIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KGxvY2F0aW9uSWQpLmZyYW1lTG9va3VwLmdldChmcmFtZUlkKTtcbiAgICAgICAgY29uc3QgeFBvcyA9IHRoaXMuZnJhbWVTY2FsZVgoZnJhbWVJZCk7XG4gICAgICAgIGNvbnN0IHRpY2tIZWlnaHQgPSB0aGlzLmZyYW1lU2NhbGVIZWlnaHQoZnJhbWUuaW5CcnVzaFBlcmNlbnQpO1xuICAgICAgICBjb25zdCBkb3RSID0gMjtcbiAgICAgICAgY29uc3QgZG90TWFyZ2luID0gMztcbiAgICAgICAgY29uc3QgbWFyZ2luID0gKHRoaXMuZnJhbWVIZWlnaHQgLSB0aWNrSGVpZ2h0KSAvIDJcbiAgICAgICAgY29uc3QgeVBvczEgPSBtYXJnaW4gLSBkb3RSIC0gZG90TWFyZ2luO1xuICAgICAgICBjb25zdCB5UG9zMiA9IG1hcmdpbiArIHRpY2tIZWlnaHQgKyBkb3RSICsgZG90TWFyZ2luO1xuICAgICAgICByZXR1cm4gW1t4UG9zLCB5UG9zMV0sIFt4UG9zLCB5UG9zMl1dO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlSG92ZXJEb3RzKHN2Z0NvbnRhaW5lcjogU3ZnU2VsZWN0aW9uKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3ZnQ29udGFpbmVyLnNlbGVjdEFsbCgnLmhvdmVyRG90JykucmVtb3ZlKCk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgcmVtb3ZlQ3VycmVudFNlbGVjdGVkRG90cygpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBzdmdDb250YWluZXIgPSBkMy5zZWxlY3QoJyNmcmFtZVRpY2tzVml6LScgKyB0aGlzLnNlbGVjdGVkTG9jRnJhbWVbMF0pIGFzIFN2Z1NlbGVjdGlvbjtcbiAgICAgICAgc3ZnQ29udGFpbmVyLnNlbGVjdEFsbCgnLnNlbGVjdGVkRG90JykucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrTG9jYXRpb24obG9jYXRpb25JZDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGxvY2F0aW9uSWQgPT09IHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VMb2NhdGlvblNlbGVjdGlvbihsb2NhdGlvbklkKTtcbiAgICAgICAgY29uc3Qgc2tpcEltYWdlVHJhY2tEcmF3ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRJbWFnZVN0YWNrV2lkZ2V0KHNraXBJbWFnZVRyYWNrRHJhdyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrTG9jYXRpb25GcmFtZShsb2NhdGlvbklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBbb2xkTG9jSWQsIG9sZEZyYW1lSWRdID0gdGhpcy5zZWxlY3RlZExvY0ZyYW1lO1xuICAgICAgICBpZiAob2xkTG9jSWQgPT09IGxvY2F0aW9uSWQgJiYgb2xkRnJhbWVJZCA9PT0gZnJhbWVJZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DbGlja0xvY2F0aW9uKGxvY2F0aW9uSWQpO1xuICAgICAgICB0aGlzLmltYWdlU3RhY2tXaWRnZXQuY2hhbmdlU2VsZWN0ZWRJbWFnZShmcmFtZUlkIC0gMSk7IC8vIG1hdGxhYlxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkRG90cyhsb2NhdGlvbklkLCBmcmFtZUlkKTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSB1cGRhdGVTZWxlY3RlZERvdHMobG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRTZWxlY3RlZERvdHMoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRMb2NGcmFtZSA9IFtsb2NhdGlvbklkLCBmcmFtZUlkXTtcbiAgICAgICAgdGhpcy5kcmF3U2VsZWN0ZWREb3RzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVUb29sdGlwQ29udGVudChsb2NhdGlvbklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgY29uc3QgbGFiZWxWYWx1ZUxpc3Q6IFtzdHJpbmcsIHN0cmluZ11bXSA9IFtcbiAgICAgICAgICAgIFsnTG9jYXRpb24nLCBsb2NhdGlvbklkLnRvU3RyaW5nKCldLFxuXHRcdFx0WydGcmFtZScsIGZyYW1lSWQudG9TdHJpbmcoKV0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBSaWNoVG9vbHRpcC5jcmVhdGVMYWJlbFZhbHVlTGlzdENvbnRlbnQobGFiZWxWYWx1ZUxpc3QpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZUZyYW1lVG9vbHRpcCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmZyYW1lVG9vbHRpcC5IaWRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGcmFtZUxpc3QobG9jYXRpb25JZDogbnVtYmVyKTogSW1hZ2VGcmFtZVtdXG4gICAge1xuICAgICAgICBjb25zdCBpbWFnZUxvY2F0aW9uID0gdGhpcy5pbWFnZU1ldGFEYXRhLmxvY2F0aW9uTG9va3VwLmdldChsb2NhdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGltYWdlTG9jYXRpb24uZnJhbWVMaXN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hhbmdlTG9jYXRpb25TZWxlY3Rpb24obmV3SWQ6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBsYXN0U2VsZWN0ZWQgPSBkMy5zZWxlY3QoXCIjaW1hZ2VMb2NhdGlvbi1cIiArIHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKTtcbiAgICAgICAgbGFzdFNlbGVjdGVkLmNsYXNzZWQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICBsZXQgbGFzdFNlbGVjdGVkRnJhbWVUaWNrVml6ID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5zZWxlY3RlZExvY2F0aW9uSWQpO1xuICAgICAgICBsYXN0U2VsZWN0ZWRGcmFtZVRpY2tWaXouYXR0cignaGVpZ2h0JywgdGhpcy5mcmFtZUhlaWdodCk7XG5cblxuICAgICAgICB0aGlzLl9zZWxlY3RlZExvY2F0aW9uSWQgPSBuZXdJZDtcblxuICAgICAgICBsZXQgbmV3U2VsZWN0ZWQgPSBkMy5zZWxlY3QoXCIjaW1hZ2VMb2NhdGlvbi1cIiArIHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKTtcbiAgICAgICAgbmV3U2VsZWN0ZWQuY2xhc3NlZCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgbGV0IG5ld1NlbGVjdGVkRnJhbWVUaWNrVml6ID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5zZWxlY3RlZExvY2F0aW9uSWQpO1xuICAgICAgICBuZXdTZWxlY3RlZEZyYW1lVGlja1Zpei5hdHRyKCdoZWlnaHQnLCB0aGlzLmZyYW1lSGVpZ2h0U2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hhbmdlSG92ZXJlZExvY2F0aW9uKG5ld0lkOiBudW1iZXIgfCBudWxsKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJlZExvY2F0aW9uSWQgIT09IG51bGwpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgbGV0IGxhc3RTZWxlY3RlZCA9IGQzLnNlbGVjdChcIiNpbWFnZUxvY2F0aW9uLVwiICsgdGhpcy5ob3ZlcmVkTG9jYXRpb25JZCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0ZWQuY2xhc3NlZCgnaG92ZXJlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyZWRMb2NhdGlvbklkICE9PSB0aGlzLnNlbGVjdGVkTG9jYXRpb25JZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFNlbGVjdGVkRnJhbWVUaWNrVml6ID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5ob3ZlcmVkTG9jYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkRnJhbWVUaWNrVml6LmF0dHIoJ2hlaWdodCcsIHRoaXMuZnJhbWVIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faG92ZXJlZExvY2F0aW9uSWQgPSBuZXdJZDtcblxuICAgICAgICBpZiAodGhpcy5ob3ZlcmVkTG9jYXRpb25JZCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IG5ld1NlbGVjdGVkID0gZDMuc2VsZWN0KFwiI2ltYWdlTG9jYXRpb24tXCIgKyB0aGlzLmhvdmVyZWRMb2NhdGlvbklkKTtcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkLmNsYXNzZWQoJ2hvdmVyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuZXdTZWxlY3RlZEZyYW1lVGlja1ZpeiA9IGQzLnNlbGVjdCgnI2ZyYW1lVGlja3NWaXotJyArIHRoaXMuaG92ZXJlZExvY2F0aW9uSWQpO1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRGcmFtZVRpY2tWaXouYXR0cignaGVpZ2h0JywgdGhpcy5mcmFtZUhlaWdodFNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgKiBhcyBxdWlja1NlbGVjdCBmcm9tICdxdWlja3NlbGVjdC5qcyc7XG5pbXBvcnQge0h0bWxTZWxlY3Rpb24sIFN2Z1NlbGVjdGlvbn0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJztcbmltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRORCc7XG5pbXBvcnQgeyBJbWFnZUxvY2F0aW9uIH0gZnJvbSAnLi4vRGF0YU1vZGVsL0ltYWdlTG9jYXRpb24nO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5pbXBvcnQgeyBSaWNoVG9vbHRpcCB9IGZyb20gJy4uL0NvbXBvbmVudHMvUmljaFRvb2x0aXAnO1xuaW1wb3J0IHsgSW1hZ2VTdGFja01ldGFEYXRhIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgSW1hZ2VUcmFja1dpZGdldCB9IGZyb20gJy4vSW1hZ2VUcmFja1dpZGdldCc7XG5pbXBvcnQgeyBDdXJ2ZU5EIH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTkQnO1xuaW1wb3J0IHsgSW1hZ2VMYWJlbHMsIEltYWdlU3RhY2tEYXRhUmVxdWVzdCwgUm93IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0ltYWdlU3RhY2tEYXRhUmVxdWVzdCc7XG5pbXBvcnQgeyBEZXZsaWJUU1V0aWwgfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVFNVdGlsJztcblxuZXhwb3J0IGNsYXNzIEltYWdlU3RhY2tXaWRnZXQge1xuXHRcblx0Y29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgaW1hZ2VUcmFja0NvbnRhaW5lcjogSFRNTEVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKVxuXHR7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdHRoaXMuX2ltYWdlVHJhY2tXaWRnZXQgPSBuZXcgSW1hZ2VUcmFja1dpZGdldChpbWFnZVRyYWNrQ29udGFpbmVyLCB0aGlzKTtcblx0XHR0aGlzLl9tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0dGhpcy5pbml0KCk7XG5cdFx0dGhpcy5fY2VsbEhvdmVyZWQgPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkSW1nSW5kZXggPSAwO1xuXHRcdGNvbnNvbGUubG9nKGQzKTtcblx0XHRjb25zb2xlLmxvZyh0aGlzKTtcblx0XHR0aGlzLl90b29sdGlwID0gbmV3IFJpY2hUb29sdGlwKCk7XG5cdFx0dGhpcy5fZXhlbXBsYXJBdHRyaWJ1dGUgPSAnQXZnIE1hc3MnOyAvLyBUT0RPIGNoYW5nZSBkZWZhdWx0XG5cdFx0dGhpcy5faW5FeGVtcGxhck1vZGUgPSB0cnVlOyAvLyBUT0RPXG5cdFx0dGhpcy5faW5Db25kZW5zZWRNb2RlID0gdHJ1ZTsgLy8gVE9ETyBtb2RlXG5cdFx0dGhpcy5fY29uZGVuc2VkTW9kZUNvdW50ID0gNztcblx0XHR0aGlzLl9leGVtcGxhckxvY2F0aW9ucyA9IG5ldyBTZXQoKTtcblx0fVxuXHRcdFxuXHRwcml2YXRlIF9jb250YWluZXIgOiBIVE1MRWxlbWVudDtcblx0cHVibGljIGdldCBjb250YWluZXIoKSA6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9pbWFnZVRyYWNrV2lkZ2V0IDogSW1hZ2VUcmFja1dpZGdldDtcblx0cHVibGljIGdldCBpbWFnZVRyYWNrV2lkZ2V0KCkgOiBJbWFnZVRyYWNrV2lkZ2V0IHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VUcmFja1dpZGdldDtcblx0fVx0XG5cblx0cHJpdmF0ZSBfbWF4SGVpZ2h0IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IG1heEhlaWdodCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4SGVpZ2h0O1xuXHR9XG5cdFxuXHRwcml2YXRlIF9pbWFnZUxvY2F0aW9uIDogSW1hZ2VMb2NhdGlvbjtcblx0cHVibGljIGdldCBpbWFnZUxvY2F0aW9uKCkgOiBJbWFnZUxvY2F0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VMb2NhdGlvbjtcblx0fVxuXHRcblx0cHJpdmF0ZSBfaW1hZ2VTdGFja0Jsb2IgOiBCbG9iO1xuXHRwdWJsaWMgZ2V0IGltYWdlU3RhY2tCbG9iKCkgOiBCbG9iIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VTdGFja0Jsb2I7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IG51bVBpeGVsc0luVGlsZSgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVXaWR0aCAqIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0O1xuXHR9XG5cblx0cHVibGljIGdldCBmaXJzdEluZGV4KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLm51bVBpeGVsc0luVGlsZSAqIHRoaXMuc2VsZWN0ZWRJbWdJbmRleDtcblx0fVxuXG5cdHByaXZhdGUgX2ltYWdlU3RhY2tMYWJlbFVybCA6IHN0cmluZztcblx0cHVibGljIGdldCBpbWFnZVN0YWNrTGFiZWxVcmwoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlU3RhY2tMYWJlbFVybDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfaW1hZ2VTdGFja1dpZHRoIDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGltYWdlU3RhY2tXaWR0aCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VTdGFja1dpZHRoO1xuXHR9XG5cblx0cHJpdmF0ZSBfaW1hZ2VTdGFja0hlaWdodCA6IG51bWJlcjtcblx0cHVibGljIGdldCBpbWFnZVN0YWNrSGVpZ2h0KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZVN0YWNrSGVpZ2h0O1xuXHR9XG5cdFxuXHRwcml2YXRlIF9zZWxlY3RlZEltZ0luZGV4IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IHNlbGVjdGVkSW1nSW5kZXgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkSW1nSW5kZXg7XG5cdH1cblxuXHRwcml2YXRlIF9pbm5lckNvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgaW5uZXJDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9pbm5lckNvbnRhaW5lcjtcblx0fVxuXG5cdHByaXZhdGUgX2xvY2F0aW9uTGFiZWwgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGxvY2F0aW9uTGFiZWwoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9sb2NhdGlvbkxhYmVsO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9mcmFtZUxhYmVsIDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBmcmFtZUxhYmVsKCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fZnJhbWVMYWJlbDtcblx0fVx0XG5cblx0cHJpdmF0ZSBfc2VsZWN0ZWRJbWFnZUNvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgc2VsZWN0ZWRJbWFnZUNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkSW1hZ2VDb250YWluZXI7XG5cdH1cdFxuXG5cdHByaXZhdGUgX3NlbGVjdGVkSW1hZ2VDYW52YXMgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHNlbGVjdGVkSW1hZ2VDYW52YXMoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZEltYWdlQ2FudmFzO1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FudmFzQ29udGV4dCA6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblx0cHVibGljIGdldCBjYW52YXNDb250ZXh0KCkgOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXNDb250ZXh0O1xuXHR9XG5cdFxuXHRwcml2YXRlIF9kYXRhIDogQ3VydmVMaXN0O1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IEN1cnZlTGlzdCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH1cblx0XG5cdHByaXZhdGUgX2ltYWdlU3RhY2tEYXRhUmVxdWVzdCA6IEltYWdlU3RhY2tEYXRhUmVxdWVzdDtcblx0cHVibGljIGdldCBpbWFnZVN0YWNrRGF0YVJlcXVlc3QoKSA6IEltYWdlU3RhY2tEYXRhUmVxdWVzdCB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlU3RhY2tEYXRhUmVxdWVzdDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfZGVmYXVsdENhbnZhc1N0YXRlIDogSW1hZ2VEYXRhO1xuXHRwdWJsaWMgZ2V0IGRlZmF1bHRDYW52YXNTdGF0ZSgpIDogSW1hZ2VEYXRhIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmYXVsdENhbnZhc1N0YXRlO1xuXHR9XG5cblx0cHJpdmF0ZSBfY2VsbEhvdmVyZWQgOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgY2VsbEhvdmVyZWQoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2NlbGxIb3ZlcmVkO1xuXHR9XG5cblx0cHJpdmF0ZSBfdG9vbHRpcCA6IFJpY2hUb29sdGlwO1xuXHRwdWJsaWMgZ2V0IHRvb2x0aXAoKSA6IFJpY2hUb29sdGlwIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbHRpcDtcblx0fVxuXG5cdHByaXZhdGUgX2V4ZW1wbGFyQXR0cmlidXRlIDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGV4ZW1wbGFyQXR0cmlidXRlKCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9leGVtcGxhckF0dHJpYnV0ZTtcblx0fVx0XG5cdFxuXHRwcml2YXRlIF9pbkV4ZW1wbGFyTW9kZSA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaW5FeGVtcGxhck1vZGUoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pbkV4ZW1wbGFyTW9kZTtcblx0fVxuXHRcdFxuXHRwcml2YXRlIF9pbkNvbmRlbnNlZE1vZGUgOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGluQ29uZGVuc2VkTW9kZSgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luQ29uZGVuc2VkTW9kZTtcblx0fVxuXG5cdHByaXZhdGUgX2NvbmRlbnNlZE1vZGVDb3VudCA6IG51bWJlcjtcblx0cHVibGljIGdldCBjb25kZW5zZWRNb2RlQ291bnQoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbmRlbnNlZE1vZGVDb3VudDtcblx0fVxuXG5cdHByaXZhdGUgX2V4ZW1wbGFyTG9jYXRpb25zIDogU2V0PG51bWJlcj47XG5cdHB1YmxpYyBnZXQgZXhlbXBsYXJMb2NhdGlvbnMoKSA6IFNldDxudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fZXhlbXBsYXJMb2NhdGlvbnM7XG5cdH1cdFxuXG5cdHB1YmxpYyBpbml0KCk6IHZvaWRcblx0e1xuXHRcdGNvbnN0IGNvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzLmNvbnRhaW5lcik7XG5cdFx0dGhpcy5faW5uZXJDb250YWluZXIgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKCdkaXYnKVxuXHRcdFx0LmNsYXNzZWQoJ2lubmVyQ29udGFpbmVyJywgdHJ1ZSk7XG5cblx0XHRjb25zdCBsb2NhdGlvbkZyYW1lTGFiZWxDb250YWluZXIgPSB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCdsb2NhdGlvbkZyYW1lTGFiZWxDb250YWluZXInLCB0cnVlKTtcblxuXHRcdGNvbnN0IGxvY2F0aW9uRnJhbWVMYWJlbCA9IGxvY2F0aW9uRnJhbWVMYWJlbENvbnRhaW5lci5hcHBlbmQoJ2gzJylcblx0XHRcdC5jbGFzc2VkKCdsb2NhdGlvbkZyYW1lTGFiZWwnLCB0cnVlKTtcblx0XHRcblx0XHRsb2NhdGlvbkZyYW1lTGFiZWwubm9kZSgpLmFwcGVuZCgnTG9jYXRpb246ICcpO1xuXHRcdHRoaXMuX2xvY2F0aW9uTGFiZWwgPSBsb2NhdGlvbkZyYW1lTGFiZWwuYXBwZW5kKCdzcGFuJylcblx0XHRcdC5jbGFzc2VkKCdsb2NhdGlvbkZyYW1lTGFiZWxWYWx1ZScsIHRydWUpO1xuXG5cdFx0bG9jYXRpb25GcmFtZUxhYmVsLm5vZGUoKS5hcHBlbmQoJ0ZyYW1lOiAnKTtcblx0XHR0aGlzLl9mcmFtZUxhYmVsID0gbG9jYXRpb25GcmFtZUxhYmVsLmFwcGVuZCgnc3BhbicpXG5cdFx0XHQuY2xhc3NlZCgnbG9jYXRpb25GcmFtZUxhYmVsVmFsdWUnLCB0cnVlKTtcblxuXHRcdHRoaXMuX3NlbGVjdGVkSW1hZ2VDb250YWluZXIgPSB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCdub1NocmluaycsIHRydWUpO1xuXG5cdFx0dGhpcy5fc2VsZWN0ZWRJbWFnZUNhbnZhcyA9IHRoaXMuc2VsZWN0ZWRJbWFnZUNvbnRhaW5lci5hcHBlbmQoJ2NhbnZhcycpXG5cdFx0XHQuc3R5bGUoJ29wYWNpdHknLCAwKTtcblxuXHRcdHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5ub2RlKCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGU6IE1vdXNlRXZlbnQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMub25DYW52YXNNb3VzZU1vdmUoZSlcblx0XHRcdH0pO1xuXHRcdFx0ICBcblx0XHR0aGlzLl9jYW52YXNDb250ZXh0ID0gKHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5ub2RlKCkgYXMgSFRNTENhbnZhc0VsZW1lbnQpLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHR0aGlzLnNlbGVjdGVkSW1hZ2VDb250YWluZXJcblx0XHRcdC5vbignbW91c2VlbnRlcicsICgpID0+IHRoaXMuYnJpZ2h0ZW5DYW52YXMoKSlcblx0XHRcdC5vbignbW91c2VsZWF2ZScsICgpID0+IHtcblx0XHRcdFx0dGhpcy5oaWRlU2VnbWVudEhvdmVyKCk7XG5cdFx0XHRcdHRoaXMuZGltQ2FudmFzKCk7XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMuaW1hZ2VUcmFja1dpZGdldC5pbml0KCk7XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdsYXVuY2hFeGVtcGxhckN1cnZlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcblx0XHR7XG5cdFx0XHR0aGlzLl9leGVtcGxhckF0dHJpYnV0ZSA9IGUuZGV0YWlsO1xuXG5cdFx0XHRsZXQgYnV0dG9uQ2hhbmdlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NoYW5nZU1vZGVTZWxlY3QnLCB7ZGV0YWlsOiAwfSk7XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGJ1dHRvbkNoYW5nZUV2ZW50KTtcblxuXHRcdFx0bGV0IG1vZGVDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbW9kZUNoYW5nZScsIHtkZXRhaWw6IHtcblx0XHRcdFx0aW5Db25kZW5zZWRNb2RlOiB0cnVlLFxuXHRcdFx0XHRpbkV4ZW1wbGFyTW9kZTogdHJ1ZVxuXHRcdFx0fX0pO1xuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChtb2RlQ2hhbmdlRXZlbnQpO1xuXHRcdH0pO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW9kZUNoYW5nZScsIChlOiBDdXN0b21FdmVudCkgPT5cblx0XHR7XG5cdFx0XHR0aGlzLl9pbkV4ZW1wbGFyTW9kZSA9IGUuZGV0YWlsLmluRXhlbXBsYXJNb2RlO1xuXHRcdFx0dGhpcy5faW5Db25kZW5zZWRNb2RlID0gZS5kZXRhaWwuaW5Db25kZW5zZWRNb2RlO1xuXHRcdFx0dGhpcy51cGRhdGVUcmFja3NDYW52YXMoKTtcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdtb2RlQ2hhbmdlUmVkcmF3JykpO1xuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2V4ZW1wbGFyQXR0cmlidXRlQ2hhbmdlJywge2RldGFpbDogdGhpcy5pbkV4ZW1wbGFyTW9kZSA/IHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUgOiBudWxsfSkpO1xuXHRcdH0pO1xuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdleGVtcGxhckF0dHJpYnV0ZUNoYW5nZScsIHtkZXRhaWw6IHRoaXMuaW5FeGVtcGxhck1vZGUgPyB0aGlzLmV4ZW1wbGFyQXR0cmlidXRlIDogbnVsbH0pKTtcblx0fVxuXG5cdHB1YmxpYyBkaW1DYW52YXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5zZWxlY3RlZEltYWdlQ2FudmFzLnN0eWxlKCdvcGFjaXR5JywgMC42KTtcblx0fVxuXG5cdHB1YmxpYyBicmlnaHRlbkNhbnZhcygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnNlbGVjdGVkSW1hZ2VDYW52YXMuc3R5bGUoJ29wYWNpdHknLCAxKTtcblx0fVxuXG5cdHB1YmxpYyBTZXREYXRhKGRhdGE6IEN1cnZlTGlzdCwgaW1hZ2VMb2NhdGlvbjogSW1hZ2VMb2NhdGlvbiwgaW1hZ2VTdGFja0RhdGFSZXF1ZXN0OiBJbWFnZVN0YWNrRGF0YVJlcXVlc3QsIHNraXBJbWFnZVRyYWNrRHJhdyA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy5faW1hZ2VTdGFja0RhdGFSZXF1ZXN0ID0gaW1hZ2VTdGFja0RhdGFSZXF1ZXN0O1xuXHRcdHRoaXMuX3NlbGVjdGVkSW1nSW5kZXggPSAwO1xuXHRcdHRoaXMuX2ltYWdlTG9jYXRpb24gPSBpbWFnZUxvY2F0aW9uO1xuXHRcdHRoaXMuU2V0SW1hZ2VQcm9wZXJ0aWVzKHNraXBJbWFnZVRyYWNrRHJhdyk7IC8vIGRlZmF1bHQgdmFsdWVzIGJlZm9yZSBpbWFnZSBsb2FkXG5cdFx0dGhpcy5kcmF3KHNraXBJbWFnZVRyYWNrRHJhdyk7XG5cdH1cblxuXHRwdWJsaWMgU2V0SW1hZ2VQcm9wZXJ0aWVzKHNraXBJbWFnZVRyYWNrRHJhdzogYm9vbGVhbiwgYmxvYj86IEJsb2IsIGltYWdlV2lkdGg/OiBudW1iZXIsIGltYWdlSGVpZ2h0PzogbnVtYmVyLCBudW1Db2x1bW5zPzogbnVtYmVyLCBzY2FsZUZhY3Rvcj86IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdC8vIGRlZmF1bHQgdmFsdWVzIGZvciB3aGVuIGxvYWRpbmcsIG9yIGlmIGltYWdlIGlzbid0IGZvdW5kXG5cdFx0aWYgKCFpbWFnZVdpZHRoKSAgeyBpbWFnZVdpZHRoICA9IDI1NjsgfVxuXHRcdGlmICghaW1hZ2VIZWlnaHQpIHsgaW1hZ2VIZWlnaHQgPSAyNTY7IH1cblx0XHRpZiAoIW51bUNvbHVtbnMpICB7IG51bUNvbHVtbnMgID0gMTA7IH1cblx0XHR0aGlzLl9pbWFnZVN0YWNrQmxvYiA9IGJsb2I7XG5cdFx0dGhpcy5kcmF3KHNraXBJbWFnZVRyYWNrRHJhdyk7XG5cdH1cblxuXHRwdWJsaWMgZHJhdyhza2lwSW1hZ2VUcmFja0RyYXcgPSBmYWxzZSk6IHZvaWRcblx0e1xuXHRcdHRoaXMuZHJhd1NlbGVjdGVkSW1hZ2Uoc2tpcEltYWdlVHJhY2tEcmF3KTtcblx0XHR0aGlzLnVwZGF0ZUxvY2F0aW9uRnJhbWVMYWJlbCgpO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5kcmF3KHRydWUpO1xuXHRcdHRoaXMuaW1hZ2VUcmFja1dpZGdldC5PbkJydXNoQ2hhbmdlKCk7XG5cdH1cblxuXHRwdWJsaWMgZHJhd1VwZGF0ZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnVwZGF0ZUJhY2tncm91bmRQb3NpdGlvbih0aGlzLnNlbGVjdGVkSW1nSW5kZXgpO1xuXHRcdHRoaXMudXBkYXRlQ2FudmFzKHRoaXMuaW5FeGVtcGxhck1vZGUpO1xuXHRcdHRoaXMudXBkYXRlTG9jYXRpb25GcmFtZUxhYmVsKCk7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdTZWxlY3RlZEltYWdlKHNraXBJbWFnZVRyYWNrRHJhdyA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5zZXRJbWFnZUlubGluZVN0eWxlKHRoaXMuc2VsZWN0ZWRJbWdJbmRleCk7XG5cdFx0Ly8gdGhpcy5zZWxlY3RlZEltYWdlQ29udGFpbmVyLmF0dHIoXCJzdHlsZVwiLCBzdHlsZVN0cmluZyk7XG5cdFx0dGhpcy51cGRhdGVDYW52YXMoc2tpcEltYWdlVHJhY2tEcmF3KTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlTG9jYXRpb25GcmFtZUxhYmVsKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMubG9jYXRpb25MYWJlbC50ZXh0KHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSk7XG5cdFx0dGhpcy5mcmFtZUxhYmVsLnRleHQodGhpcy5nZXRDdXJyZW50RnJhbWVJZCgpKTtcblx0fVxuXG5cdHB1YmxpYyBnZXRDdXJyZW50TG9jYXRpb25JZCgpOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiB0aGlzLmltYWdlTG9jYXRpb24ubG9jYXRpb25JZDtcblx0fVxuXG5cdHB1YmxpYyBnZXRDdXJyZW50RnJhbWVJZCgpOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiB0aGlzLnNlbGVjdGVkSW1nSW5kZXggKyAxO1xuXHRcdC8vIHJldHVybiB0aGlzLmltYWdlTG9jYXRpb24uZnJhbWVMaXN0W3RoaXMuc2VsZWN0ZWRJbWdJbmRleF0uZnJhbWVJZDtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlQ2FudmFzKHNraXBJbWFnZVRyYWNrRHJhdyA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0aWYgKCF0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdClcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhc1xuXHRcdFx0LmF0dHIoJ3dpZHRoJywgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVXaWR0aClcblx0XHRcdC5hdHRyKCdoZWlnaHQnLCB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZUhlaWdodCk7XG5cblx0XHR0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8uZ2V0TGFiZWwodGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpLCB0aGlzLnNlbGVjdGVkSW1nSW5kZXgsXG5cdFx0XHQoZGF0YTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcikgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jcmVhdGVPdXRsaW5lSW1hZ2UoZGF0YSwgZmlyc3RJbmRleCk7XG5cdFx0XHRcdHRoaXMuZHJhd0RlZmF1bHRDYW52YXMoKTtcblx0XHRcdH0pO1xuXG5cdFx0bGV0IGxvY0lkID0gdGhpcy5pbWFnZUxvY2F0aW9uLmxvY2F0aW9uSWQ7XG5cdFx0aWYgKCFza2lwSW1hZ2VUcmFja0RyYXcpXG5cdFx0e1xuXHRcdFx0dGhpcy51cGRhdGVUcmFja3NDYW52YXMoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVRyYWNrc0NhbnZhcygpOiB2b2lkXG5cdHtcblx0XHRsZXQgY3VydmVMaXN0OiBDdXJ2ZU5EW107XG5cdFx0aWYgKHRoaXMuaW5FeGVtcGxhck1vZGUpXG5cdFx0e1xuXHRcdFx0Y3VydmVMaXN0ID0gdGhpcy5nZXRFeGVtcGxhckN1cnZlcygpO1xuXHRcdFx0dGhpcy5leGVtcGxhckxvY2F0aW9ucy5jbGVhcigpO1xuXHRcdFx0Zm9yIChsZXQgY3VydmUgb2YgY3VydmVMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBmaXJzdFBvaW50ID0gY3VydmUucG9pbnRMaXN0WzBdO1xuXHRcdFx0XHR0aGlzLmV4ZW1wbGFyTG9jYXRpb25zLmFkZChmaXJzdFBvaW50LmdldCgnTG9jYXRpb24gSUQnKSk7XG5cdFx0XHR9XHRcdFxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Y3VydmVMaXN0ID0gdGhpcy5nZXRDdXJ2ZXNCYXNlZE9uUG9pbnRzQXRDdXJyZW50RnJhbWUoKTtcblx0XHRcdHRoaXMuZXhlbXBsYXJMb2NhdGlvbnMuY2xlYXIoKTtcblx0XHR9XG5cdFx0dGhpcy5pbWFnZVRyYWNrV2lkZ2V0LmRyYXcoY3VydmVMaXN0KTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0RXhlbXBsYXJDdXJ2ZXMoKTogQ3VydmVORFtdXG5cdHtcblx0XHRsZXQgY3VydmVMaXN0OiBDdXJ2ZU5EW10gPSBbXTtcblx0XHRsZXQgZmFjZXRPcHRpb25zID0gdGhpcy5kYXRhLkdldEZhY2V0T3B0aW9ucygpO1xuXHRcdGNvbnN0IGZpcnN0RmFjZXRPcHRpb24gPSBmYWNldE9wdGlvbnNbMF07XG5cdFx0Y29uc3QgZmFjZXROYW1lID0gZmlyc3RGYWNldE9wdGlvbi5uYW1lO1xuXHRcdGxldCBmYWNldHMgPSBmaXJzdEZhY2V0T3B0aW9uLkdldEZhY2V0cygpO1xuXHRcdGNvbnN0IHRyYWNrTGVuZ3RoS2V5ID0gJ1RyYWNrIExlbmd0aCc7XG5cdFx0Zm9yIChsZXQgZmFjZXQgb2YgZmFjZXRzKVxuXHRcdHtcblx0XHRcdGxldCBmYWNldERhdGE6IEN1cnZlTGlzdCA9IGZhY2V0LmRhdGE7XG5cdFx0XHRsZXQgbWF4TGVuZ3RoID0gZmFjZXREYXRhLmN1cnZlQ29sbGVjdGlvbi5nZXRNaW5NYXgodHJhY2tMZW5ndGhLZXkpWzFdO1xuXHRcdFx0bGV0IGxvbmdUcmFja3MgPSBmYWNldERhdGEuY3VydmVMaXN0LmZpbHRlcih4ID0+IHguZ2V0KHRyYWNrTGVuZ3RoS2V5KSA+IChtYXhMZW5ndGggLyAyLjApKTtcblx0XHRcdGxldCBudW1DdXJ2ZXMgPSBsb25nVHJhY2tzLmxlbmd0aDtcblx0XHRcdGxldCBsb3dDdXJ2ZSA9IHF1aWNrU2VsZWN0KGxvbmdUcmFja3MsIDEsIChjdXJ2ZTogQ3VydmVORCkgPT4gY3VydmUuZ2V0KHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUpKTtcblx0XHRcdGxldCBtZWRpYW5DdXJ2ZSA9IHF1aWNrU2VsZWN0KGxvbmdUcmFja3MsIE1hdGguZmxvb3IobnVtQ3VydmVzIC8gMiksIChjdXJ2ZTogQ3VydmVORCkgPT4gY3VydmUuZ2V0KHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUpKTtcblx0XHRcdGxldCBoaWdoQ3VydmUgPSBxdWlja1NlbGVjdChsb25nVHJhY2tzLCBudW1DdXJ2ZXMgLSAxLCAoY3VydmU6IEN1cnZlTkQpID0+IGN1cnZlLmdldCh0aGlzLmV4ZW1wbGFyQXR0cmlidXRlKSk7XG5cdFx0XHRjdXJ2ZUxpc3QucHVzaChsb3dDdXJ2ZSk7XG5cdFx0XHRjdXJ2ZUxpc3QucHVzaChtZWRpYW5DdXJ2ZSk7XG5cdFx0XHRjdXJ2ZUxpc3QucHVzaChoaWdoQ3VydmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjdXJ2ZUxpc3Rcblx0fVxuXG5cdHByaXZhdGUgZ2V0Q3VydmVzQmFzZWRPblBvaW50c0F0Q3VycmVudEZyYW1lKCk6IEN1cnZlTkRbXVxuXHR7XG5cdFx0bGV0IGN1cnZlTGlzdDogQ3VydmVORFtdID0gW107XG5cdFx0Y29uc3QgcG9pbnRzQXRGcmFtZSA9IHRoaXMuZGF0YS5HZXRDZWxsc0F0RnJhbWUodGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpLCB0aGlzLmdldEN1cnJlbnRGcmFtZUlkKCkpXG5cdFx0Zm9yIChsZXQgcG9pbnQgb2YgcG9pbnRzQXRGcmFtZSlcblx0XHR7XG5cdFx0XHRjdXJ2ZUxpc3QucHVzaChwb2ludC5wYXJlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVMaXN0XG5cdH1cblxuXHRwcml2YXRlIGNyZWF0ZU91dGxpbmVJbWFnZShyb3dBcnJheTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdGlmICghdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QpXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgbXlJbWFnZURhdGEgPSB0aGlzLmNhbnZhc0NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVXaWR0aCwgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QudGlsZUhlaWdodCk7XG5cblx0XHRmb3IgKGxldCByb3dJZHggPSBmaXJzdEluZGV4OyByb3dJZHggPCBmaXJzdEluZGV4ICsgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QudGlsZUhlaWdodDsgcm93SWR4KyspXG5cdFx0e1xuXHRcdFx0bGV0IHJvdzogUm93ID0gcm93QXJyYXkucm93TGlzdFtyb3dJZHhdO1xuXHRcdFx0Zm9yIChsZXQgbGFiZWxSdW4gb2Ygcm93LnJvdylcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgY29sSWR4ID0gbGFiZWxSdW4uc3RhcnQ7IGNvbElkeCA8IGxhYmVsUnVuLnN0YXJ0ICsgbGFiZWxSdW4ubGVuZ3RoOyBjb2xJZHgrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmICh0aGlzLmlzQm9yZGVyKGxhYmVsUnVuLmxhYmVsLCByb3dJZHgsIGNvbElkeCwgcm93QXJyYXkpKVxuXHRcdFx0XHRcdHtcblxuXHRcdFx0XHRcdFx0bGV0IGZsYXRJZHggPSAocm93SWR4IC0gZmlyc3RJbmRleCkgKiB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC50aWxlV2lkdGggKyBjb2xJZHg7XG5cdFx0XHRcdFx0XHRmbGF0SWR4ICo9IDQ7XG5cdFx0XHRcdFx0XHRsZXQgW2NlbGwsIF9pbmRleF0gPSB0aGlzLmdldENlbGwobGFiZWxSdW4ubGFiZWwpXG5cdFx0XHRcdFx0XHRsZXQgW3IsIGcsIGJdID0gdGhpcy5nZXRDZWxsQ29sb3IoY2VsbCk7XG5cdFx0XHRcdFx0XHRteUltYWdlRGF0YS5kYXRhW2ZsYXRJZHhdID0gcjtcblx0XHRcdFx0XHRcdG15SW1hZ2VEYXRhLmRhdGFbZmxhdElkeCArIDFdID0gZztcblx0XHRcdFx0XHRcdG15SW1hZ2VEYXRhLmRhdGFbZmxhdElkeCArIDJdID0gYjtcblx0XHRcdFx0XHRcdG15SW1hZ2VEYXRhLmRhdGFbZmxhdElkeCArIDNdID0gMjU1O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2RlZmF1bHRDYW52YXNTdGF0ZSA9IG15SW1hZ2VEYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3RGVmYXVsdENhbnZhcygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmNhbnZhc0NvbnRleHQucHV0SW1hZ2VEYXRhKHRoaXMuZGVmYXVsdENhbnZhc1N0YXRlLCAwLCAwKTtcblx0fVxuXG5cdHB1YmxpYyBpc0JvcmRlcihsYWJlbDogbnVtYmVyLCByb3dJZHg6IG51bWJlciwgY29sSWR4OiBudW1iZXIsIHJvd0FycmF5OiBJbWFnZUxhYmVscyk6IGJvb2xlYW5cblx0e1xuXHRcdGxldCBuZWlnaGJvckluZGljZXM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtdO1xuXHRcdC8vIDQtbmVpZ2hib3Jcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4IC0gMSwgY29sSWR4XSk7XG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCArIDEsIGNvbElkeF0pO1xuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHgsIGNvbElkeCAtIDFdKTtcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4LCBjb2xJZHggKyAxXSk7XG5cdFx0Ly8gOC1uZWlnaGJvclxuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHggLSAxLCBjb2xJZHggLSAxXSk7XG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCArIDEsIGNvbElkeCAtIDFdKTtcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4ICsgMSwgY29sSWR4IC0gMV0pO1xuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHggLSAxLCBjb2xJZHggKyAxXSk7XG5cdFx0Ly8gMTItbmVpZ2hib3Jcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4IC0gMiwgY29sSWR4XSk7XG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCArIDIsIGNvbElkeF0pO1xuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHgsIGNvbElkeCAtIDJdKTtcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4LCBjb2xJZHggKyAyXSk7XG5cblxuXHRcdGZvciAobGV0IFtySSwgY0ldIG9mIG5laWdoYm9ySW5kaWNlcylcblx0XHR7XG5cdFx0XHRpZiAockkgPCAwXG5cdFx0XHRcdHx8IHJJID49IHJvd0FycmF5LnJvd0xpc3QubGVuZ3RoXG5cdFx0XHRcdHx8IGNJIDwgMFxuXHRcdFx0XHR8fCBjSSA+PSB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC50aWxlV2lkdGgpXG5cdFx0XHR7XG5cdFx0XHRcdC8vIG5laWdoYm9yIG91dCBvZiBib3VuZHMgb2YgdGlsZVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGxldCBuVmFsID0gSW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsVmFsdWUockksIGNJLCByb3dBcnJheSk7XG5cdFx0XHRpZiAoblZhbCAhPT0gbGFiZWwpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHByaXZhdGUgb25DYW52YXNNb3VzZU1vdmUoZTogTW91c2VFdmVudCk6IHZvaWRcblx0e1xuXHRcdGlmICghdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QgfHwgIXRoaXMuZGVmYXVsdENhbnZhc1N0YXRlKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0TGFiZWwodGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpLCB0aGlzLnNlbGVjdGVkSW1nSW5kZXgsXG5cdFx0XHQocm93QXJyYXk6IEltYWdlTGFiZWxzLCBmaXJzdEluZGV4OiBudW1iZXIpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHJvd0lkeCA9IGUub2Zmc2V0WSArIGZpcnN0SW5kZXg7XG5cdFx0XHRcdGNvbnN0IGNvbElkeCA9IGUub2Zmc2V0WDtcblx0XHRcdFx0Y29uc3QgbGFiZWwgPSBJbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0TGFiZWxWYWx1ZShyb3dJZHgsIGNvbElkeCwgcm93QXJyYXkpO1xuXHRcdFx0XHRpZiAobGFiZWwgPT09IHRoaXMuY2VsbEhvdmVyZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2VsbEhvdmVyZWQgPSBsYWJlbDtcblx0XHRcdFx0aWYgKGxhYmVsID09PSAwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5kcmF3RGVmYXVsdENhbnZhcygpO1xuXHRcdFx0XHRcdHRoaXMudG9vbHRpcC5IaWRlKCk7XG5cdFx0XHRcdFx0Y29uc3QgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZyYW1lSG92ZXJDaGFuZ2UnLCB7IGRldGFpbDpcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb25JZDogdGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpLFxuXHRcdFx0XHRcdFx0XHRmcmFtZUlkOiB0aGlzLmdldEN1cnJlbnRGcmFtZUlkKCksXG5cdFx0XHRcdFx0XHRcdGNlbGxJZDogbnVsbFxuXHRcdFx0XHRcdFx0fX0pO1xuXHRcdFx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc2hvd1NlZ21lbnRIb3Zlcihyb3dBcnJheSwgbGFiZWwsIGZpcnN0SW5kZXgsIGZhbHNlLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgaGlkZVNlZ21lbnRIb3ZlcihoaWRlVG9vbHRpcEltbWVkaWF0ZWx5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmRyYXdEZWZhdWx0Q2FudmFzKCk7XG5cdFx0bGV0IGRlbGF5T3ZlcnJpZGU6IG51bWJlcjtcblx0XHRpZiAoaGlkZVRvb2x0aXBJbW1lZGlhdGVseSlcblx0XHR7XG5cdFx0XHRkZWxheU92ZXJyaWRlID0gMDtcblx0XHR9XG5cdFx0dGhpcy50b29sdGlwLkhpZGUoZGVsYXlPdmVycmlkZSk7XG5cdH1cblxuXHRwdWJsaWMgc2hvd1NlZ21lbnRIb3Zlcihyb3dBcnJheTogSW1hZ2VMYWJlbHMsIHNlZ21lbnRJZDogbnVtYmVyLCBmaXJzdEluZGV4OiBudW1iZXIsIHNob3dUb29sdGlwSW1tZWRpYXRlbHk6IGJvb2xlYW4gPSBmYWxzZSwgZXZlbnQ/OiBNb3VzZUV2ZW50KTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fY2VsbEhvdmVyZWQgPSBzZWdtZW50SWQ7XG5cdFx0bGV0IFtjZWxsLCBpbmRleF0gPSB0aGlzLmdldENlbGwoc2VnbWVudElkKTtcblxuXHRcdGxldCBjZWxsWCA9IDA7XG5cdFx0bGV0IGNlbGxZID0gMDtcblx0XHRsZXQgcGFnZVggPSAwO1xuXHRcdGxldCBwYWdlWSA9IDA7XG5cdFx0aWYgKGNlbGwpXG5cdFx0e1xuXHRcdFx0bGV0IGNhbnZhc0JvdW5kUmVjdCA9IHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHRjZWxsWCA9IChjZWxsLmdldCgnWCcpICsgY2VsbC5nZXQoJ3hTaGlmdCcpKSAvIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnNjYWxlRmFjdG9yO1xuXHRcdFx0Y2VsbFkgPSAoY2VsbC5nZXQoJ1knKSArIGNlbGwuZ2V0KCd5U2hpZnQnKSkgLyB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC5zY2FsZUZhY3Rvcjtcblx0XHRcdHBhZ2VYID0gY2FudmFzQm91bmRSZWN0LnggKyBjZWxsWDtcblx0XHRcdHBhZ2VZID0gY2FudmFzQm91bmRSZWN0LnkgKyBjZWxsWTtcblxuXHRcdFx0Y29uc3QgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZyYW1lSG92ZXJDaGFuZ2UnLCB7IGRldGFpbDpcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxvY2F0aW9uSWQ6IHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSxcblx0XHRcdFx0XHRmcmFtZUlkOiB0aGlzLmdldEN1cnJlbnRGcmFtZUlkKCksXG5cdFx0XHRcdFx0Y2VsbElkOiBjZWxsLnBhcmVudC5pZFxuXHRcdFx0XHR9fSk7XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZXZlbnQpXG5cdFx0e1xuXHRcdFx0cGFnZVggPSBldmVudC5wYWdlWDtcblx0XHRcdHBhZ2VZID0gZXZlbnQucGFnZVk7XG5cdFx0fVxuXG5cdFx0bGV0IG15SW1hZ2VEYXRhID0gdGhpcy5jYW52YXNDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZVdpZHRoLCB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZUhlaWdodCk7XG5cdFx0bXlJbWFnZURhdGEuZGF0YS5zZXQodGhpcy5kZWZhdWx0Q2FudmFzU3RhdGUuZGF0YSk7XG5cdFx0Zm9yIChsZXQgcm93SWR4ID0gZmlyc3RJbmRleDsgcm93SWR4IDwgZmlyc3RJbmRleCArIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVIZWlnaHQ7IHJvd0lkeCsrKVxuXHRcdHtcblx0XHRcdGxldCByb3c6IFJvdyA9IHJvd0FycmF5LnJvd0xpc3Rbcm93SWR4XTtcblx0XHRcdGZvciAobGV0IGxhYmVsUnVuIG9mIHJvdy5yb3cpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChsYWJlbFJ1bi5sYWJlbCA9PT0gdGhpcy5jZWxsSG92ZXJlZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAobGV0IGNvbElkeCA9IGxhYmVsUnVuLnN0YXJ0OyBjb2xJZHggPCBsYWJlbFJ1bi5zdGFydCArIGxhYmVsUnVuLmxlbmd0aDsgY29sSWR4KyspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRsZXQgZmxhdElkeCA9IChyb3dJZHggLSBmaXJzdEluZGV4KSAqIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVXaWR0aCArIGNvbElkeDtcblx0XHRcdFx0XHRcdFx0ZmxhdElkeCAqPSA0O1xuXHRcdFx0XHRcdFx0XHRsZXQgW2NlbGwsIF9pbmRleF0gPSB0aGlzLmdldENlbGwobGFiZWxSdW4ubGFiZWwpXG5cdFx0XHRcdFx0XHRcdGxldCBbciwgZywgYl0gPSB0aGlzLmdldENlbGxDb2xvcihjZWxsKTtcblx0XHRcdFx0XHRcdFx0bXlJbWFnZURhdGEuZGF0YVtmbGF0SWR4XSA9IHI7XG5cdFx0XHRcdFx0XHRcdG15SW1hZ2VEYXRhLmRhdGFbZmxhdElkeCArIDFdID0gZztcblx0XHRcdFx0XHRcdFx0bXlJbWFnZURhdGEuZGF0YVtmbGF0SWR4ICsgMl0gPSBiO1xuXHRcdFx0XHRcdFx0XHRteUltYWdlRGF0YS5kYXRhW2ZsYXRJZHggKyAzXSA9IDIwMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuY2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEobXlJbWFnZURhdGEsIDAsIDApO1xuXHRcdGlmIChjZWxsKVxuXHRcdHtcblx0XHRcdHRoaXMuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcblx0XHRcdHRoaXMuY2FudmFzQ29udGV4dC5hcmMoY2VsbFgsIGNlbGxZLCA1LCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHR0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXHRcdFx0dGhpcy5jYW52YXNDb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0dGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICcjRkYwMEZGJztcblx0XHRcdHRoaXMuY2FudmFzQ29udGV4dC5maWxsKCk7XG5cdFx0fVxuXG5cdFx0bGV0IHRvb2x0aXBDb250ZW50OiBzdHJpbmcgPSB0aGlzLmdldFRvb2x0aXBDb250ZW50KHNlZ21lbnRJZCwgY2VsbCwgaW5kZXgpO1xuXHRcdGxldCBkZWxheU92ZXJyaWRlOiBudW1iZXI7XG5cdFx0aWYgKHNob3dUb29sdGlwSW1tZWRpYXRlbHkpXG5cdFx0e1xuXHRcdFx0ZGVsYXlPdmVycmlkZSA9IDA7XG5cdFx0fVxuXHRcdHRoaXMudG9vbHRpcC5TaG93KHRvb2x0aXBDb250ZW50LCBwYWdlWCwgcGFnZVksIGRlbGF5T3ZlcnJpZGUpO1xuXHR9XG5cblx0cHVibGljIGdldExhYmVsSW5kZXhGcm9tQmlnSW1nUGl4ZWxYWShmcmFtZUluZGV4OiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXVxuXHR7XG5cdFx0eCA9IE1hdGgucm91bmQoeCk7XG5cdFx0eSA9IE1hdGgucm91bmQoeSk7XG5cblx0XHRsZXQgY29sSWR4ID0geCAlIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGg7XG5cdFx0bGV0IHJvd0lkeCA9ICh5ICUgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVIZWlnaHQpICsgKGZyYW1lSW5kZXggJSB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZXNQZXJGaWxlKSAqIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0O1xuXG5cdFx0cmV0dXJuIFtyb3dJZHgsIGNvbElkeF07XG5cdH1cblxuXHRwdWJsaWMgZ2V0VGlsZUluZGV4RnJvbUJpZ0ltZ1BpeGVsWFkoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdGxldCBjb2xJbmRleCA9IE1hdGguZmxvb3IoeCAvIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGgpO1xuXHRcdGxldCByb3dJbmRleCA9IE1hdGguZmxvb3IoeSAvIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0KTtcblx0XHRyZXR1cm4gcm93SW5kZXggKiB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8ubnVtYmVyT2ZDb2x1bW5zICsgY29sSW5kZXg7XG5cdH1cblxuXHRwcml2YXRlIGdldFRvb2x0aXBDb250ZW50KGxhYmVsOiBudW1iZXIsIGNlbGw6IFBvaW50TkQgfCBudWxsLCBpbmRleDogbnVtYmVyIHwgbnVsbCk6IHN0cmluZ1xuXHR7XG5cdFx0bGV0IGxhYmVsVmFsdWVQYWlyczogW3N0cmluZywgc3RyaW5nIHwgbnVsbF1bXSA9IFtcblx0XHRcdFsnTG9jYXRpb24nLCB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbklkKCkudG9TdHJpbmcoKV0sXG5cdFx0XHRbJ0ZyYW1lJywgdGhpcy5nZXRDdXJyZW50RnJhbWVJZCgpLnRvU3RyaW5nKCldLFxuXHRcdFx0WydTZWdtZW50JywgbGFiZWwudG9TdHJpbmcoKV1cblx0XHRdO1xuXHRcdGxldCBjZWxsSWQgPSBjZWxsPy5wYXJlbnQ/LmlkO1xuXHRcdGlmIChjZWxsSWQpXG5cdFx0e1xuXHRcdFx0bGFiZWxWYWx1ZVBhaXJzLnB1c2goWydDZWxsJywgY2VsbElkXSk7XG5cdFx0XHRsYWJlbFZhbHVlUGFpcnMucHVzaChbJ1JvdycsIGluZGV4LnRvU3RyaW5nKCldKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGxhYmVsVmFsdWVQYWlycy5wdXNoKFsnTm8gY2VsbCBsaW5rZWQnLCBudWxsXSlcblx0XHR9XG5cdFx0cmV0dXJuIFJpY2hUb29sdGlwLmNyZWF0ZUxhYmVsVmFsdWVMaXN0Q29udGVudChsYWJlbFZhbHVlUGFpcnMpO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRDZWxsKGxhYmVsOiBudW1iZXIpOiBbUG9pbnRORCwgbnVtYmVyXSB8IFtudWxsLCBudWxsXVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5HZXRDZWxsRnJvbUxhYmVsKHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSwgdGhpcy5nZXRDdXJyZW50RnJhbWVJZCgpLCBsYWJlbCk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0Q2VsbENvbG9yKGNlbGw6IFBvaW50TkQgfCBudWxsKTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG5cdHtcblx0XHRsZXQgY29sb3I6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IFswLCAwLCAwXTtcblx0XHRpZiAoIWNlbGwpXG5cdFx0e1xuXHRcdFx0Ly8gU3ByaW5nR3JlZW5cblx0XHRcdGNvbG9yID0gWzE1NCwgMjA1LCA1MF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNlbGwuaW5CcnVzaClcblx0XHR7XG5cdFx0XHQvLyBGaXJlQnJpY2tcblx0XHRcdGNvbG9yID0gWzE3OCwgMzQsIDM0XTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdC8vIFN0ZWVsQmx1ZVxuXHRcdFx0Y29sb3IgPSBbNzAsIDEzMCwgMTgwXTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbG9yXG5cdH1cblxuXHRwdWJsaWMgY2hhbmdlU2VsZWN0ZWRJbWFnZShuZXdJbmRleDogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fc2VsZWN0ZWRJbWdJbmRleCA9IG5ld0luZGV4O1xuXHRcdHRoaXMuZHJhd1VwZGF0ZSgpO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRJbWFnZUlubGluZVN0eWxlKGluZGV4OiBudW1iZXIsIGluY2x1ZGVGYWxsYmFjayA9IHRydWUpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8uZ2V0SW1hZ2UodGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpLCBpbmRleCxcblx0XHRcdCh0b3AsIGxlZnQsIF9ibG9iLCBpbWFnZVVybCkgPT5cblx0XHRcdHtcblx0XHRcdFx0bGV0IHN0eWxlU3RyaW5nOiBzdHJpbmcgPVxuXHRcdFx0XHRcdGBcblx0XHRcdFx0XHRiYWNrZ3JvdW5kLXBvc2l0aW9uLXg6ICR7LWxlZnR9cHg7XG5cdFx0XHRcdFx0YmFja2dyb3VuZC1wb3NpdGlvbi15OiAkey10b3B9cHg7XG5cdFx0XHRcdFx0d2lkdGg6ICR7dGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVXaWR0aH1weDtcblx0XHRcdFx0XHRoZWlnaHQ6ICR7dGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVIZWlnaHR9cHg7XG5cdFx0XHRcdFx0YDtcblx0XHRcdFx0aWYgKGltYWdlVXJsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3R5bGVTdHJpbmcgKz0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgke2ltYWdlVXJsfSk7YDtcblx0XHRcdFx0fVxuXHRcdFxuXHRcdFx0XHRpZiAoaW5jbHVkZUZhbGxiYWNrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c3R5bGVTdHJpbmcgKz0gJ2JhY2tncm91bmQtY29sb3I6ICNlYmViZWI7Jztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNlbGVjdGVkSW1hZ2VDb250YWluZXIuYXR0cihcInN0eWxlXCIsIHN0eWxlU3RyaW5nKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVCYWNrZ3JvdW5kUG9zaXRpb24oaW5kZXg6IG51bWJlcilcblx0e1xuXHRcdHRoaXMuc2V0SW1hZ2VJbmxpbmVTdHlsZShpbmRleCk7XG5cdFx0cmV0dXJuO1xuXHRcdGNvbnN0IFt0b3AsIGxlZnRdID0gdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LmdldFRpbGVUb3BMZWZ0KGluZGV4KTtcblx0XHR0aGlzLnNlbGVjdGVkSW1hZ2VDb250YWluZXIubm9kZSgpLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvblggPSAgLWxlZnQgKyAncHgnO1xuXHRcdHRoaXMuc2VsZWN0ZWRJbWFnZUNvbnRhaW5lci5ub2RlKCkuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uWSA9IC10b3AgKyAncHgnO1xuXHR9XG5cdFxuXHRwdWJsaWMgT25SZXNpemUobmV3TWF4SGVpZ2h0OiBudW1iZXIsIGltYWdlVHJhY2tNYXhIZWlnaHQ6IG51bWJlciwgbmV3V2lkdGg6IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdHRoaXMuX21heEhlaWdodCA9IG5ld01heEhlaWdodDtcblx0XHR0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJyxgbWF4LWhlaWdodDogJHt0aGlzLm1heEhlaWdodH1weDtgKTtcblx0XHR0aGlzLmltYWdlVHJhY2tXaWRnZXQuT25SZXNpemUobmV3V2lkdGgsIGltYWdlVHJhY2tNYXhIZWlnaHQpO1xuXHR9XG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBIdG1sU2VsZWN0aW9uLCBTdmdTZWxlY3Rpb24sIE1hcmdpbiB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUeXBlcyc7XG5pbXBvcnQgeyBJbWFnZVN0YWNrV2lkZ2V0IH0gZnJvbSAnLi9JbWFnZVN0YWNrV2lkZ2V0JztcbmltcG9ydCB7IEN1cnZlTkQgfSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVORCc7XG5pbXBvcnQgeyBQb2ludE5EIH0gZnJvbSAnLi4vRGF0YU1vZGVsL1BvaW50TkQnO1xuaW1wb3J0IHsgUmVjdCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IERldmxpYk1hdGggfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliTWF0aCc7XG5pbXBvcnQgeyBEZXZsaWJBbGdvIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYkFsZ28nO1xuaW1wb3J0IHsgSW1hZ2VMYWJlbHMsIEltYWdlU3RhY2tEYXRhUmVxdWVzdCwgUm93IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0ltYWdlU3RhY2tEYXRhUmVxdWVzdCc7XG5pbXBvcnQgeyBEZXZsaWJUU1V0aWwgfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVFNVdGlsJztcblxuZXhwb3J0IGNsYXNzIEltYWdlVHJhY2tXaWRnZXRcbntcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCBwYXJlbnQ6IEltYWdlU3RhY2tXaWRnZXQpXG4gICAge1xuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuX3BhcmVudFdpZGdldCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5fdmVydGljYWxQYWQgPSAxNjtcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbFBhZCA9IDg7XG4gICAgICAgIHRoaXMuX2ZyYW1lTGFiZWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2VsbExhYmVsUG9zaXRpb25zID0gW107XG5cbiAgICAgICAgLy8gaGFyZGNvZGVkIGZyb20gY3NzXG4gICAgICAgIHRoaXMuX2NlbGxUaW1lbGluZU1hcmdpbiA9IHtcbiAgICAgICAgICAgIHRvcDogMzYsXG4gICAgICAgICAgICByaWdodDogNCxcbiAgICAgICAgICAgIGJvdHRvbTogNCxcbiAgICAgICAgICAgIGxlZnQ6IDcyXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGF0ZXN0U2Nyb2xsID0gWzAsMF07XG4gICAgICAgIHRoaXMuX3Njcm9sbENoYW5nZVRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc291cmNlRGVzdENlbGwgPSBbXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jb250YWluZXIgOiBIVE1MRWxlbWVudDtcbiAgICBwdWJsaWMgZ2V0IGNvbnRhaW5lcigpIDogSFRNTEVsZW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3BhcmVudFdpZGdldCA6IEltYWdlU3RhY2tXaWRnZXQ7XG4gICAgcHVibGljIGdldCBwYXJlbnRXaWRnZXQoKSA6IEltYWdlU3RhY2tXaWRnZXQge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50V2lkZ2V0O1xuICAgIH0gICAgXG4gICAgXG4gICAgcHJpdmF0ZSBfaW5uZXJDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgaW5uZXJDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJDb250YWluZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5uZXJDb250YWluZXJXIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgaW5uZXJDb250YWluZXJXKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJDb250YWluZXJXO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9pbm5lckNvbnRhaW5lckggOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBpbm5lckNvbnRhaW5lckgoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lckNvbnRhaW5lckg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdGl0bGVDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgdGl0bGVDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGVDb250YWluZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc3ZnQ29udGFpbmVyIDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgc3ZnQ29udGFpbmVyKCkgOiBTdmdTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ZnQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NlbGxMYWJlbEdyb3VwIDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgY2VsbExhYmVsR3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZWxsTGFiZWxHcm91cDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mcmFtZUxhYmVsR3JvdXAgOiBTdmdTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBmcmFtZUxhYmVsR3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUxhYmVsR3JvdXA7XG4gICAgfVxuXG5cdHByaXZhdGUgX3NlbGVjdGVkSW1hZ2VDYW52YXMgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHNlbGVjdGVkSW1hZ2VDYW52YXMoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZEltYWdlQ2FudmFzO1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FudmFzQ29udGV4dCA6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblx0cHVibGljIGdldCBjYW52YXNDb250ZXh0KCkgOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXNDb250ZXh0O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF90cmFja0xpc3QgOiBDdXJ2ZU5EW107XG4gICAgcHVibGljIGdldCB0cmFja0xpc3QoKSA6IEN1cnZlTkRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja0xpc3Q7XG4gICAgfVxuXG4gICAgXG4gICAgcHJpdmF0ZSBfdmVydGljYWxQYWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCB2ZXJ0aWNhbFBhZCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsUGFkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hvcml6b250YWxQYWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBob3Jpem9udGFsUGFkKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbFBhZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mcmFtZUxhYmVsUG9zaXRpb25zIDogW3N0cmluZywgbnVtYmVyXVtdO1xuICAgIHB1YmxpYyBnZXQgZnJhbWVMYWJlbFBvc2l0aW9ucygpIDogW3N0cmluZywgbnVtYmVyXVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lTGFiZWxQb3NpdGlvbnM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2VsbExhYmVsUG9zaXRpb25zIDogW3N0cmluZywgbnVtYmVyXVtdO1xuICAgIHB1YmxpYyBnZXQgY2VsbExhYmVsUG9zaXRpb25zKCkgOiBbc3RyaW5nLCBudW1iZXJdW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2VsbExhYmVsUG9zaXRpb25zO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NlbGxUaW1lbGluZU1hcmdpbiA6IE1hcmdpbjtcbiAgICBwdWJsaWMgZ2V0IGNlbGxUaW1lbGluZU1hcmdpbigpIDogTWFyZ2luIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbGxUaW1lbGluZU1hcmdpbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zY3JvbGxDaGFuZ2VUaWNraW5nIDogYm9vbGVhbjtcbiAgICBwdWJsaWMgZ2V0IHNjcm9sbENoYW5nZVRpY2tpbmcoKSA6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQ2hhbmdlVGlja2luZztcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfbGF0ZXN0U2Nyb2xsIDogW251bWJlciwgbnVtYmVyXTtcbiAgICBwdWJsaWMgZ2V0IGxhdGVzdFNjcm9sbCgpIDogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RTY3JvbGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbGF0ZXN0TW91c2VDYW52YXNPZmZzZXQgOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIHB1YmxpYyBnZXQgbGF0ZXN0TW91c2VDYW52YXNPZmZzZXQoKSA6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0TW91c2VDYW52YXNPZmZzZXQ7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX3NvdXJjZURlc3RDZWxsIDogW1JlY3QsIFtudW1iZXIsIG51bWJlcl0sIFBvaW50TkRdW107XG4gICAgcHVibGljIGdldCBzb3VyY2VEZXN0Q2VsbCgpIDogW1JlY3QsIFtudW1iZXIsIG51bWJlcl0sIFBvaW50TkRdW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlRGVzdENlbGw7XG4gICAgfVxuXG4gICAgXG4gICAgcHVibGljIGluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fdGl0bGVDb250YWluZXIgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3RyYWNrTW9kZVRpdGxlQ29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdtZWRpdW1UZXh0JywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fc3ZnQ29udGFpbmVyID0gY29udGFpbmVyU2VsZWN0LmFwcGVuZCgnc3ZnJyk7XG4gICAgICAgIHRoaXMuX2NlbGxMYWJlbEdyb3VwID0gdGhpcy5zdmdDb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3B9KWApO1xuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuX2ZyYW1lTGFiZWxHcm91cCA9IHRoaXMuc3ZnQ29udGFpbmVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKCR7dGhpcy5jZWxsVGltZWxpbmVNYXJnaW4ubGVmdH0sIDApYCk7XG5cbiAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2NlbGxUaW1lbGluZUlubmVyQ29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdmVyZmxvdy1zY3JvbGwnLCB0cnVlKTtcblxuICAgICAgICB0aGlzLmlubmVyQ29udGFpbmVyLm5vZGUoKS5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoZTogV2hlZWxFdmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNlbGxUaW1lbGluZVNjcm9sbChlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbWFnZUNhbnZhcyA9IHRoaXMuaW5uZXJDb250YWluZXIuYXBwZW5kKCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY2FudmFzRWxlbWVudDogSFRNTENhbnZhc0VsZW1lbnQgPSB0aGlzLnNlbGVjdGVkSW1hZ2VDYW52YXMubm9kZSgpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgICBjYW52YXNFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlOiBNb3VzZUV2ZW50KSA9PiB0aGlzLm9uQ2FudmFzTW91c2VNb3ZlKGUpICk7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZTogTW91c2VFdmVudCkgPT4gdGhpcy5vbkNhbnZhc0NsaWNrKGUpKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZEltYWdlQ2FudmFzLm9uKCdtb3VzZWxlYXZlJywgKCkgPT4gdGhpcy5vbkNhbnZhc01vdXNlTGVhdmUoKSApO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnJhbWVIb3ZlckNoYW5nZScsIChlOiBDdXN0b21FdmVudCkgPT4gXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lSWQgPSBlLmRldGFpbC5mcmFtZUlkO1xuICAgICAgICAgICAgY29uc3QgY2VsbElkID0gZS5kZXRhaWwuY2VsbElkO1xuICAgICAgICAgICAgaWYgKGZyYW1lSWQgIT09IG51bGwgJiYgY2VsbElkICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUluZGV4OiBudW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJ2ZTogQ3VydmVORCA9IHRoaXMucGFyZW50V2lkZ2V0LmRhdGEuY3VydmVMb29rdXAuZ2V0KGNlbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludEluZGV4ID0gY3VydmUucG9pbnRMaXN0LmZpbmRJbmRleChwb2ludCA9PiBwb2ludC5nZXQoJ0ZyYW1lIElEJykgPT09IGZyYW1lSWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IHBvaW50SW5kZXggLyAoY3VydmUucG9pbnRMaXN0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gcGVyY2VudCAqICh0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYW1lSW5kZXhSb3VuZGVkID0gTWF0aC5yb3VuZChmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXBzaWxvbiA9ICgxIC8gKGN1cnZlLnBvaW50TGlzdC5sZW5ndGggKyAxKSkgKiAodGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhmcmFtZUluZGV4IC0gZnJhbWVJbmRleFJvdW5kZWQpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IGZyYW1lSW5kZXhSb3VuZGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSBmcmFtZUlkIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYWJlbHNPbk1vdXNlTW92ZShjZWxsSWQsIGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxzT25Nb3VzZU1vdmUoJycsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGRyYXcodHJhY2tzOiBDdXJ2ZU5EW10pOiBQcm9taXNlPHZvaWQ+XG4gICAge1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tzID09PSB0aGlzLnRyYWNrTGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERldmxpYlRTVXRpbC5sYXVuY2hTcGlubmVyKCk7XG4gICAgICAgIHRoaXMuX3RyYWNrTGlzdCA9IHRyYWNrcztcbiAgICAgICAgdGhpcy51cGRhdGVUaXRsZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLmRyYXdUcmFja0xpc3QoKTtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUaXRsZSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5FeGVtcGxhck1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGVDb250YWluZXIudGV4dCgnRXhlbXBsYXJzIG9mICcgKyB0aGlzLnBhcmVudFdpZGdldC5leGVtcGxhckF0dHJpYnV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlQ29udGFpbmVyLnRleHQoJ0ZyYW1lIEV4dHJhY3Rpb24gTW9kZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHJhd091dGxpbmVzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBkcmF3VHJhY2tMaXN0KCk6IFByb21pc2U8dm9pZD5cbiAgICB7XG4gICAgICAgIHRoaXMuX3NvdXJjZURlc3RDZWxsID0gW107XG4gICAgICAgIGxldCBsaXN0T2ZCb3VuZGluZ0JveExpc3RzID0gYXdhaXQgdGhpcy5nZXRCb3VuZGluZ0JveExpc3RzKHRoaXMudHJhY2tMaXN0KTtcbiAgICAgICAgbGV0IG1heEhlaWdodExpc3Q6IG51bWJlcltdID0gW107XG4gICAgICAgIGxldCBtYXhXaWR0aDogbnVtYmVyID0gZDMubWF4KGxpc3RPZkJvdW5kaW5nQm94TGlzdHMsIFxuICAgICAgICAgICAgKHJlY3RMaXN0OiBSZWN0W10pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLm1heChyZWN0TGlzdCwgciA9PiBJbWFnZVRyYWNrV2lkZ2V0LnJlY3RXaWR0aChyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGZvciAobGV0IHJlY3RMaXN0IG9mIGxpc3RPZkJvdW5kaW5nQm94TGlzdHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB0aGlzSGVpZ2h0ID0gZDMubWF4KHJlY3RMaXN0LCByID0+IEltYWdlVHJhY2tXaWRnZXQucmVjdEhlaWdodChyKSk7XG4gICAgICAgICAgICBtYXhIZWlnaHRMaXN0LnB1c2godGhpc0hlaWdodCk7IFxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG1pbkZyYW1lSWQgPSBkMy5taW4odGhpcy50cmFja0xpc3QsIFxuICAgICAgICAgICAgKHRyYWNrOiBDdXJ2ZU5EKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBkMy5taW4odHJhY2sucG9pbnRMaXN0LCBwb2ludCA9PiBwb2ludC5nZXQoJ0ZyYW1lIElEJykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IG1heEZyYW1lSWQgPSBkMy5tYXgodGhpcy50cmFja0xpc3QsIFxuICAgICAgICAgICAgKHRyYWNrOiBDdXJ2ZU5EKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBkMy5tYXgodHJhY2sucG9pbnRMaXN0LCBwb2ludCA9PiBwb2ludC5nZXQoJ0ZyYW1lIElEJykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IG51bUZyYW1lczogbnVtYmVyO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBudW1GcmFtZXMgPSB0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBudW1GcmFtZXMgPSBtYXhGcmFtZUlkIC0gbWluRnJhbWVJZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBudW1GcmFtZXMgKiBtYXhXaWR0aCArIHRoaXMuaG9yaXpvbnRhbFBhZCAqIChudW1GcmFtZXMgKyAxKTtcbiAgICAgICAgY29uc3QgdG90YWxIZWlnaHQgPSBkMy5zdW0obWF4SGVpZ2h0TGlzdCkgKyB0aGlzLnZlcnRpY2FsUGFkICogKHRoaXMudHJhY2tMaXN0Lmxlbmd0aCArIDEpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW1hZ2VDYW52YXNcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNhbnZhc1dpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRvdGFsSGVpZ2h0KTtcblxuICAgICAgICBsZXQgdmVydGljYWxPZmZzZXQ6IG51bWJlciA9IHRoaXMudmVydGljYWxQYWQ7XG4gICAgICAgIHRoaXMuX2NlbGxMYWJlbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgZHJhd1RyYWNrUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy50cmFja0xpc3RbaV07XG4gICAgICAgICAgICBsZXQgYm91bmRpbmdCb3hMaXN0ID0gbGlzdE9mQm91bmRpbmdCb3hMaXN0c1tpXTtcbiAgICAgICAgICAgIGxldCB0cmFja0hlaWdodCA9IG1heEhlaWdodExpc3RbaV07XG4gICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuZHJhd1RyYWNrKHRyYWNrLCBib3VuZGluZ0JveExpc3QsIG1heFdpZHRoLCB0cmFja0hlaWdodCwgbWluRnJhbWVJZCwgdmVydGljYWxPZmZzZXQpO1xuICAgICAgICAgICAgZHJhd1RyYWNrUHJvbWlzZXMucHVzaChkb25lKTtcbiAgICAgICAgICAgIHRoaXMuX2NlbGxMYWJlbFBvc2l0aW9ucy5wdXNoKFt0cmFjay5pZCwgdmVydGljYWxPZmZzZXQgKyB0cmFja0hlaWdodCAvIDJdKTtcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ICs9IHRyYWNrSGVpZ2h0ICsgdGhpcy52ZXJ0aWNhbFBhZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcmFtZUxhYmVsUG9zaXRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRnJhbWVzOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBmcmFtZUlkOiBzdHJpbmcgPSAoaSArIG1pbkZyYW1lSWQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5ob3Jpem9udGFsUGFkXG4gICAgICAgICAgICBvZmZzZXQgKz0gaSAqIChtYXhXaWR0aCArIHRoaXMuaG9yaXpvbnRhbFBhZCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbWF4V2lkdGggLyAyO1xuICAgICAgICAgICAgdGhpcy5fZnJhbWVMYWJlbFBvc2l0aW9ucy5wdXNoKFtmcmFtZUlkLCBvZmZzZXRdKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoZHJhd1RyYWNrUHJvbWlzZXMpO1xuICAgICAgICBEZXZsaWJUU1V0aWwuc3RvcFNwaW5uZXIoKTtcbiAgICAgICAgLy8gdGhpcy5kcmF3T3V0bGluZXMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGdldEJvdW5kaW5nQm94TGlzdHModHJhY2tMaXN0OiBDdXJ2ZU5EW10pOiBQcm9taXNlPFJlY3RbXVtdPlxuICAgIHtcbiAgICAgICAgbGV0IGxpc3RPZkxpc3RzOiBSZWN0W11bXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0cmFjayBvZiB0cmFja0xpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB0aGlzTGlzdDogUmVjdFtdID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnQ6IFBvaW50TkQgPSB0aGlzLmdldFBvaW50SW5Db25kZW5zZWRNb2RlKHRyYWNrLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBhd2FpdCB0aGlzLmdldENlbGxCb3VuZGluZ0JveChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNMaXN0LnB1c2goYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb2ludCBvZiB0cmFjay5wb2ludExpc3QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGF3YWl0IHRoaXMuZ2V0Q2VsbEJvdW5kaW5nQm94KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0xpc3QucHVzaChib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdE9mTGlzdHMucHVzaCh0aGlzTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RPZkxpc3RzO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUodHJhY2s6IEN1cnZlTkQsIGluZGV4OiBudW1iZXIpOiBQb2ludE5EXG4gICAge1xuICAgICAgICBsZXQgcGVyY2VudCA9IGluZGV4IC8gKHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudCAtIDEpO1xuICAgICAgICBsZXQgdHJhY2tJbmRleCA9IE1hdGgubWluKE1hdGgucm91bmQocGVyY2VudCAqIHRyYWNrLnBvaW50TGlzdC5sZW5ndGgpLCB0cmFjay5wb2ludExpc3QubGVuZ3RoLTEpO1xuICAgICAgICByZXR1cm4gdHJhY2sucG9pbnRMaXN0W3RyYWNrSW5kZXhdO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZHJhd1RyYWNrKFxuICAgICAgICB0cmFja0RhdGE6IEN1cnZlTkQsXG4gICAgICAgIGJvdW5kaW5nQm94TGlzdDogUmVjdFtdLFxuICAgICAgICBtYXhXaWR0aDogbnVtYmVyLCBtYXhIZWlnaHQ6IG51bWJlcixcbiAgICAgICAgbWluRnJhbWU6IG51bWJlcixcbiAgICAgICAgdmVydGljYWxPZmZzZXQ6IG51bWJlcik6IFByb21pc2U8dm9pZD5cbiAgICB7XG4gICAgICAgIC8vIGRyYXcgdHJhY2sgYmFja2dyb3VuZFxuICAgICAgICB0aGlzLmRyYXdUcmFja0JhY2tncm91bmQodHJhY2tEYXRhLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtaW5GcmFtZSwgdmVydGljYWxPZmZzZXQpO1xuXG5cbiAgICAgICAgbGV0IGFzeW5jRnVuY3Rpb25MaXN0ID0gW107XG4gICAgICAgIGxldCBibG9iUmVxdWVzdHMgPSBbXTtcbiAgICAgICAgbGV0IG9mZnNldEFycmF5OiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGluZ0JveExpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBiaXQgcGFpbmZ1bC4gVGhlIGJpZ2dlc3QgYWRkaXRpb24gdG8gdGhlIGNvbXBsZXhpdHlcbiAgICAgICAgICAgIC8vIGlzIGFjY291bnRpbmcgZm9yIGVkZ2UgY2FzZXMgaW4gdGhlIHRpbGUgb2YgdGhlIHRpbGVkIGltYWdlLlxuICAgICAgICAgICAgLy8gaWYgaXQgZ2V0cyB0byBhbiBlZGdlIG9ubHkgb25seSBjb3BpZXMgd2hhdCBpdCBjYW4sIHRoZW4gY2VudGVycyBpblxuICAgICAgICAgICAgLy8gYSByZWN0IG9mIHRoZSBzYW1lIHNpemUgYXMgb3RoZXJzIGluIHRoZSBjZWxsLlxuICAgICAgICAgICAgbGV0IHBvaW50OiBQb2ludE5EO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUodHJhY2tEYXRhLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHRyYWNrRGF0YS5wb2ludExpc3RbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpO1xuXG4gICAgICAgICAgICAvLyBjb25zdCBvZmZzZXRJbmRleCA9IGZyYW1lSWQgLSBtaW5GcmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lSW5kZXggPSBmcmFtZUlkIC0gMTtcblxuICAgICAgICAgICAgbGV0IGJsb2JSZXF1ZXN0ID0gdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldEltYWdlUHJvbWlzZShwb2ludC5nZXQoJ0xvY2F0aW9uIElEJyksIGZyYW1lSW5kZXgpO1xuXG4gICAgICAgICAgICBibG9iUmVxdWVzdHMucHVzaChibG9iUmVxdWVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGJsb2JSZXF1ZXN0cyk7XG4gICAgICAgICAgICAvLyAudGhlbigocmVzdWx0czogW251bWJlciwgbnVtYmVyLCBCbG9iLCBzdHJpbmddW10pID0+XG4gICAgICAgICAgICAvLyB7XG4gICAgICAgIGxldCBzb3VyY2VEZXN0Q2VsbCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCB3b3JrZXJEYXRhID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHdlYldvcmtlciA9IG5ldyBXb3JrZXIoJy9zdGF0aWMvc2NyaXB0L2Rpc3QvSW1hZ2VXb3JrZXIuanMnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlc3VsdHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgW3RpbGVUb3AsIHRpbGVMZWZ0LCBibG9iLCBfdXJsXSA9IHJlc3VsdHNbal07XG4gICAgICAgICAgICAgICAgICAgIGxldCBiYm94ID0gYm91bmRpbmdCb3hMaXN0W2pdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbc1gsIHNZXSA9IGJib3hbMF07XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aWR0aCA9IEltYWdlVHJhY2tXaWRnZXQucmVjdFdpZHRoKGJib3gpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGVpZ2h0ID0gSW1hZ2VUcmFja1dpZGdldC5yZWN0SGVpZ2h0KGJib3gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYVggPSBNYXRoLnJvdW5kKChtYXhXaWR0aCAtIHdpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYVkgPSBNYXRoLnJvdW5kKChtYXhIZWlnaHQgLSBoZWlnaHQpIC8gMik7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50OiBQb2ludE5EO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUodHJhY2tEYXRhLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gdHJhY2tEYXRhLnBvaW50TGlzdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldEluZGV4OiBudW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEluZGV4ID0gajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEluZGV4ID0gZnJhbWVJZCAtIG1pbkZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlsZUJvdCA9IHRpbGVUb3AgKyB0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVSaWdodCA9IHRpbGVMZWZ0ICsgdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGg7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5VG9wID0gRGV2bGliTWF0aC5jbGFtcChzWSAtIGV4dHJhWSwgW3RpbGVUb3AsIHRpbGVCb3RdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weUxlZnQgPSBEZXZsaWJNYXRoLmNsYW1wKHNYIC0gZXh0cmFYLCBbdGlsZUxlZnQsIHRpbGVSaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weVdpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIHRpbGVSaWdodCAtIGNvcHlMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weUhlaWdodCA9IE1hdGgubWluKG1heEhlaWdodCwgdGlsZUJvdCAtIGNvcHlUb3ApO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQodGhpcy5ob3Jpem9udGFsUGFkICsgb2Zmc2V0SW5kZXggKiAobWF4V2lkdGggKyB0aGlzLmhvcml6b250YWxQYWQpICsgKG1heFdpZHRoIC0gY29weVdpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5yb3VuZCh2ZXJ0aWNhbE9mZnNldCArIChtYXhIZWlnaHQgLSBjb3B5SGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0T2Zmc2V0OiBbbnVtYmVyLCBudW1iZXJdID0gW29mZnNldFgsIG9mZnNldFldO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRBcnJheS5wdXNoKGRlc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc291cmNlUmVjdDogUmVjdCA9IFtbY29weUxlZnQsIGNvcHlUb3BdLCBbY29weUxlZnQgKyBjb3B5V2lkdGgsIGNvcHlUb3AgKyBjb3B5SGVpZ2h0XV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGVzdENlbGwucHVzaChbc291cmNlUmVjdCwgZGVzdE9mZnNldCwgcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRGVzdENlbGwucHVzaChbc291cmNlUmVjdCwgZGVzdE9mZnNldCwgcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyRGF0YS5wdXNoKFtibG9iLCBjb3B5TGVmdCwgY29weVRvcCwgY29weVdpZHRoLCBjb3B5SGVpZ2h0XSk7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2ViV29ya2VyLnBvc3RNZXNzYWdlKHdvcmtlckRhdGEpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB3ZWJXb3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJpdE1hcExpc3Q6IHtzdGF0dXM6IHN0cmluZywgdmFsdWU6SW1hZ2VCaXRtYXB9W10gPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpdE1hcExpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ0JpdG1hcCA9IGJpdE1hcExpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gdHJhY2tEYXRhLnBvaW50TGlzdFtpXS5nZXQoJ0ZyYW1lIElEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RnJhbWU6IGJvb2xlYW4gPSBmcmFtZUlkID09PSB0aGlzLnBhcmVudFdpZGdldC5nZXRDdXJyZW50RnJhbWVJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldEluZGV4OiBudW1iZXIgPSBmcmFtZUlkIC0gbWluRnJhbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRJbmRleCA9IGZyYW1lSWQgLSBtaW5GcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lWCA9IHRoaXMuaG9yaXpvbnRhbFBhZCArIG9mZnNldEluZGV4ICogKG1heFdpZHRoICsgdGhpcy5ob3Jpem9udGFsUGFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lWSA9IHZlcnRpY2FsT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gb2Zmc2V0QXJyYXlbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KGZyYW1lWCwgZnJhbWVZLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgJiYgIXRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9ICdNZWRpdW1TZWFHcmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmxpbmVXaWR0aCA9IDg7IFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlID0gJ2dyZXknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSAxOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltZ0JpdG1hcC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoaW1nQml0bWFwLnZhbHVlLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd091dGxpbmVzKHNvdXJjZURlc3RDZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgd2ViV29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd1RyYWNrQmFja2dyb3VuZChcbiAgICAgICAgdHJhY2tEYXRhOiBDdXJ2ZU5ELFxuICAgICAgICBtYXhXaWR0aDogbnVtYmVyLCBtYXhIZWlnaHQ6IG51bWJlcixcbiAgICAgICAgbWluRnJhbWU6IG51bWJlcixcbiAgICAgICAgdmVydGljYWxPZmZzZXQ6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgdHJhY2sgYmFja2dyb3VuZFxuICAgICAgICBsZXQgb2Zmc2V0SW5kZXg6IG51bWJlcjtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSB0cmFja0RhdGEucG9pbnRMaXN0WzBdLmdldCgnRnJhbWUgSUQnKSAtIG1pbkZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbkRlc3RYID0gdGhpcy5ob3Jpem9udGFsUGFkICsgb2Zmc2V0SW5kZXggKiAobWF4V2lkdGggKyB0aGlzLmhvcml6b250YWxQYWQpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBvZmZzZXRJbmRleCA9IHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRyYWNrRGF0YS5wb2ludExpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIG9mZnNldEluZGV4ID0gdHJhY2tEYXRhLnBvaW50TGlzdFtsYXN0SW5kZXhdLmdldCgnRnJhbWUgSUQnKSAtIG1pbkZyYW1lICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhEZXN0WCA9IG9mZnNldEluZGV4ICogKG1heFdpZHRoICsgdGhpcy5ob3Jpem9udGFsUGFkKTtcbiAgICAgICAgY29uc3QgbWluRGVzdFkgPSB2ZXJ0aWNhbE9mZnNldDtcblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IG1hcmdpblggPSA0O1xuICAgICAgICBjb25zdCBtYXJnaW5ZID0gNDtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlY3QoXG4gICAgICAgICAgICBtaW5EZXN0WCAtIG1hcmdpblgsXG4gICAgICAgICAgICBtaW5EZXN0WSAtIG1hcmdpblksXG4gICAgICAgICAgICBtYXhEZXN0WCAtIG1pbkRlc3RYICsgMSArIDIgKiBtYXJnaW5YLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ICsgMiAqIG1hcmdpblkpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ3JnYigyNDAsMjQwLDI0MCknO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5maWxsKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyByZWN0V2lkdGgocmVjdDogUmVjdCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgcmV0dXJuIHJlY3RbMV1bMF0gLSByZWN0WzBdWzBdICsgMTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBzdGF0aWMgcmVjdEhlaWdodChyZWN0OiBSZWN0KTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gcmVjdFsxXVsxXSAtIHJlY3RbMF1bMV0gKyAxO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZ2V0Q2VsbEJvdW5kaW5nQm94KHBvaW50OiBQb2ludE5EKTogUHJvbWlzZTxSZWN0PlxuICAgIHtcbiAgICAgICAgY29uc3QgbG9jSWQgPSBwb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG4gICAgICAgIGNvbnN0IGZyYW1lSWQgPSBwb2ludC5nZXQoJ0ZyYW1lIElEJyk7XG4gICAgICAgIGNvbnN0IGZyYW1lSW5kZXggPSBmcmFtZUlkIC0gMTsgLy8gTWF0TGFiLi4gICAgICAgIFxuICAgICAgICBjb25zdCBzZWdtZW50SWQgPSBwb2ludC5nZXQoJ3NlZ21lbnRMYWJlbCcpO1xuICAgICAgICBjb25zdCBudW1QaXhlbHNJblRpbGUgPSB0aGlzLnBhcmVudFdpZGdldC5udW1QaXhlbHNJblRpbGU7XG4gICAgICAgIC8vIGNvbnN0IGZpcnN0SW5kZXggPSBmcmFtZUluZGV4ICogbnVtUGl4ZWxzSW5UaWxlO1xuICAgICAgICBsZXQgZXh0ZW50OiBSZWN0ID0gW1tJbmZpbml0eSwgSW5maW5pdHldLCBbLUluZmluaXR5LCAtSW5maW5pdHldXVxuICAgICAgICBsZXQgW3Jvd0FycmF5LCBmaXJzdEluZGV4XSA9IGF3YWl0IHRoaXMucGFyZW50V2lkZ2V0LmltYWdlU3RhY2tEYXRhUmVxdWVzdC5nZXRMYWJlbFByb21pc2UobG9jSWQsIGZyYW1lSW5kZXgpO1xuICAgICAgICBmb3IgKGxldCByb3dJZHggPSBmaXJzdEluZGV4OyByb3dJZHggPCBmaXJzdEluZGV4ICsgdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVIZWlnaHQ7IHJvd0lkeCsrKVxuICAgICAgICB7XG5cdFx0XHRsZXQgcm93OiBSb3cgPSByb3dBcnJheS5yb3dMaXN0W3Jvd0lkeF07XG5cdFx0XHRmb3IgKGxldCBsYWJlbFJ1biBvZiByb3cucm93KVxuXHRcdFx0e1xuICAgICAgICAgICAgICAgIGxldCBbdG9wLCBsZWZ0XSA9IHRoaXMucGFyZW50V2lkZ2V0LmltYWdlU3RhY2tEYXRhUmVxdWVzdC5nZXRUaWxlVG9wTGVmdChmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICBsZXQgYmlnSW1nWE1pbiA9IGxlZnQgKyBsYWJlbFJ1bi5zdGFydDtcbiAgICAgICAgICAgICAgICBsZXQgYmlnSW1nWE1heCA9IGxlZnQgKyBsYWJlbFJ1bi5zdGFydCArIGxhYmVsUnVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgYmlnSW1nWSA9IHRvcCArIChyb3dJZHggJSB0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QudGlsZUhlaWdodCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGFiZWxSdW4ubGFiZWwgPT09IHNlZ21lbnRJZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBbW21pblgsIG1pblldLCBbbWF4WCwgbWF4WV1dID0gZXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgYmlnSW1nWE1pbik7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBiaWdJbWdZKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIGJpZ0ltZ1hNYXgpO1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgYmlnSW1nWSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVudCA9IFtbbWluWCwgbWluWV0sIFttYXhYLCBtYXhZXV07XG4gICAgICAgICAgICAgICAgfVxuXHRcdFx0fVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZXh0ZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgb25DZWxsVGltZWxpbmVTY3JvbGwoZXZlbnQ6IEV2ZW50KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy5pbm5lckNvbnRhaW5lci5ub2RlKCk7XG4gICAgICAgIHRoaXMuX2xhdGVzdFNjcm9sbCA9IFtlbC5zY3JvbGxMZWZ0LCBlbC5zY3JvbGxUb3BdO1xuICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ2hhbmdlVGlja2luZylcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscygpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQ2hhbmdlVGlja2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxDaGFuZ2VUaWNraW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgb25DYW52YXNDbGljayhlOiBNb3VzZUV2ZW50KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeFBvcyA9IGUub2Zmc2V0WDtcbiAgICAgICAgbGV0IHlQb3MgPSBlLm9mZnNldFk7XG4gICAgICAgIGNvbnN0IGNlbGxJZDogc3RyaW5nID0gSW1hZ2VUcmFja1dpZGdldC5nZXRDbG9zZXN0TGFiZWwodGhpcy5jZWxsTGFiZWxQb3NpdGlvbnMsIHlQb3MpO1xuICAgICAgICBsZXQgY3VydmU6IEN1cnZlTkQgPSB0aGlzLnBhcmVudFdpZGdldC5kYXRhLmN1cnZlTG9va3VwLmdldChjZWxsSWQpO1xuXG4gICAgICAgIGxldCBmcmFtZUlkOiBudW1iZXJcbiAgICAgICAgY29uc3QgZnJhbWVJbmRleCA9ICtJbWFnZVRyYWNrV2lkZ2V0LmdldENsb3Nlc3RMYWJlbCh0aGlzLmZyYW1lTGFiZWxQb3NpdGlvbnMsIHhQb3MpIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5nZXRQb2ludEluQ29uZGVuc2VkTW9kZShjdXJ2ZSwgZnJhbWVJbmRleCk7XG4gICAgICAgICAgICBmcmFtZUlkID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZnJhbWVJZCA9IGZyYW1lSW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZpcnN0UG9pbnQgPSBjdXJ2ZS5wb2ludExpc3RbMF07XG4gICAgICAgIGNvbnN0IHRyYWNrTG9jYXRpb24gPSBmaXJzdFBvaW50LmdldCgnTG9jYXRpb24gSUQnKTtcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdsb2NGcmFtZUNsaWNrZWQnLCB7IGRldGFpbDpcbiAgICAgICAge1xuICAgICAgICAgICAgbG9jYXRpb25JZDogdHJhY2tMb2NhdGlvbixcbiAgICAgICAgICAgIGZyYW1lSWQ6IGZyYW1lSWRcbiAgICAgICAgfX0pO1xuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25DYW52YXNNb3VzZU1vdmUoZTogTW91c2VFdmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHhQb3MgPSBlLm9mZnNldFg7XG4gICAgICAgIGxldCB5UG9zID0gZS5vZmZzZXRZO1xuICAgICAgICBjb25zdCBjZWxsSWQ6IHN0cmluZyA9IEltYWdlVHJhY2tXaWRnZXQuZ2V0Q2xvc2VzdExhYmVsKHRoaXMuY2VsbExhYmVsUG9zaXRpb25zLCB5UG9zKTtcbiAgICAgICAgbGV0IGN1cnZlOiBDdXJ2ZU5EID0gdGhpcy5wYXJlbnRXaWRnZXQuZGF0YS5jdXJ2ZUxvb2t1cC5nZXQoY2VsbElkKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBmcmFtZUlkOiBudW1iZXJcbiAgICAgICAgY29uc3QgZnJhbWVJbmRleCA9ICtJbWFnZVRyYWNrV2lkZ2V0LmdldENsb3Nlc3RMYWJlbCh0aGlzLmZyYW1lTGFiZWxQb3NpdGlvbnMsIHhQb3MpIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHBvaW50ID0gdGhpcy5nZXRQb2ludEluQ29uZGVuc2VkTW9kZShjdXJ2ZSwgZnJhbWVJbmRleCk7XG4gICAgICAgICAgICBmcmFtZUlkID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZnJhbWVJZCA9IGZyYW1lSW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuc2VsZWN0ZWRJbWdJbmRleDtcbiAgICAgICAgY29uc3QgZGlzcGxheWVkRnJhbWVJZCA9IHRoaXMucGFyZW50V2lkZ2V0LmdldEN1cnJlbnRGcmFtZUlkKCk7XG4gICAgICAgIGxldCBmaXJzdFBvaW50ID0gY3VydmUucG9pbnRMaXN0WzBdO1xuICAgICAgICBjb25zdCB0cmFja0xvY2F0aW9uID0gZmlyc3RQb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRMb2NhdGlvbiA9IHRoaXMucGFyZW50V2lkZ2V0LmdldEN1cnJlbnRMb2NhdGlvbklkKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodHJhY2tMb2NhdGlvbiA9PSBjdXJyZW50TG9jYXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBkaXNwbGF5ZWRQb2ludCA9IGN1cnZlLnBvaW50TGlzdC5maW5kKHBvaW50ID0+IHBvaW50LmdldCgnRnJhbWUgSUQnKSA9PT0gZGlzcGxheWVkRnJhbWVJZCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0TGFiZWwoZGlzcGxheWVkUG9pbnQuZ2V0KCdMb2NhdGlvbiBJRCcpLCBkaXNwbGF5ZWRQb2ludC5nZXQoJ0ZyYW1lIElEJykgLSAxLFxuICAgICAgICAgICAgKHJvd0FycmF5OiBJbWFnZUxhYmVscywgZmlyc3RJbmRleDogbnVtYmVyKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50V2lkZ2V0LnNob3dTZWdtZW50SG92ZXIocm93QXJyYXksIGRpc3BsYXllZFBvaW50LmdldCgnc2VnbWVudExhYmVsJyksIGZpcnN0SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudFdpZGdldC5icmlnaHRlbkNhbnZhcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuaGlkZVNlZ21lbnRIb3Zlcih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50V2lkZ2V0LmRpbUNhbnZhcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbHNPbk1vdXNlTW92ZShjZWxsSWQsIGZyYW1lSW5kZXgpO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZyYW1lSG92ZXJDaGFuZ2UnLCB7IGRldGFpbDpcbiAgICAgICAge1xuICAgICAgICAgICAgbG9jYXRpb25JZDogdHJhY2tMb2NhdGlvbixcbiAgICAgICAgICAgIGZyYW1lSWQ6IGZyYW1lSWQsXG4gICAgICAgICAgICBjZWxsSWQ6IGNlbGxJZFxuICAgICAgICB9fSk7XG5cdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNhbnZhc01vdXNlTGVhdmUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuaGlkZVNlZ21lbnRIb3Zlcih0cnVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuZGltQ2FudmFzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxzT25Nb3VzZU1vdmUoJycsIC0xKTtcbiAgICAgICAgY29uc3QgbG9jSWQgPSB0aGlzLnBhcmVudFdpZGdldC5nZXRDdXJyZW50TG9jYXRpb25JZCgpO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZyYW1lSG92ZXJDaGFuZ2UnLCB7IGRldGFpbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbklkOiBsb2NJZCxcbiAgICAgICAgICAgICAgICBmcmFtZUlkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNlbGxJZDogbnVsbFxuICAgICAgICAgICAgfX0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q2xvc2VzdExhYmVsKGxhYmVsUG9zaXRpb25zOiBbc3RyaW5nLCBudW1iZXJdW10sIHBvczogbnVtYmVyKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgY29tcGFyZUZ1bmN0aW9uID0gRGV2bGliQWxnby5jb21wYXJlUHJvcGVydHk8W3N0cmluZywgbnVtYmVyXT4ocG9zLCBsYWJlbFBvcyA9PiAgbGFiZWxQb3NbMV0pO1xuICAgICAgICBsZXQgaW5kaWNlcyA9IERldmxpYkFsZ28uQmluYXJ5U2VhcmNoSW5kZXgobGFiZWxQb3NpdGlvbnMsIGNvbXBhcmVGdW5jdGlvbik7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kaWNlcyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHBvcyk7XG4gICAgICAgICAgICByZXR1cm4gJy0xJzsgLy8gdG9kb1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbEluZGV4OiBudW1iZXI7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kaWNlcyA9PT0gJ251bWJlcicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsSW5kZXggPSBpbmRpY2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IFtpbmRleExvdywgaW5kZXhIaWdoXSA9IGluZGljZXM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4TG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbEluZGV4ID0gaW5kZXhIaWdoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGluZGV4SGlnaCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWxJbmRleCA9IGluZGV4TG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgWyBfbGFiZWxMb3csIGxhYmVsUG9zTG93XSA9IGxhYmVsUG9zaXRpb25zW2luZGV4TG93XTtcbiAgICAgICAgICAgICAgICBjb25zdCBbIF9sYWJlbEhlaWdoLCBsYWJlbFBvc0hpZ2hdID0gbGFiZWxQb3NpdGlvbnNbaW5kZXhIaWdoXTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0VG9Mb3cgPSBwb3MgLSBsYWJlbFBvc0xvdztcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0VG9IaWdoID0gbGFiZWxQb3NIaWdoIC0gcG9zO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0VG9Mb3cgPCBkaXN0VG9IaWdoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxJbmRleCA9IGluZGV4TG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbEluZGV4ID0gaW5kZXhIaWdoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxQb3NpdGlvbnNbbGFiZWxJbmRleF1bMF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBkcmF3T3V0bGluZXMoc291cmNlRGVzdENlbGw/OiBbUmVjdCwgW251bWJlciwgbnVtYmVyXSwgUG9pbnRORF1bXSk6IFByb21pc2U8dm9pZD5cbiAgICB7XG4gICAgICAgIGlmICghc291cmNlRGVzdENlbGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNvdXJjZURlc3RDZWxsID0gdGhpcy5zb3VyY2VEZXN0Q2VsbFxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtzb3VyY2VSZWN0LCBbZFgsIGRZXSwgcG9pbnRdIG9mIHNvdXJjZURlc3RDZWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgd2lkdGggPSBJbWFnZVRyYWNrV2lkZ2V0LnJlY3RXaWR0aChzb3VyY2VSZWN0KTtcbiAgICAgICAgICAgIGxldCBoZWlnaHQgPSBJbWFnZVRyYWNrV2lkZ2V0LnJlY3RIZWlnaHQoc291cmNlUmVjdCk7XG4gICAgICAgICAgICBsZXQgW1tzTGVmdCwgc1RvcF0sIFtzUmlnaHQsIHNCb3RdXSA9IHNvdXJjZVJlY3Q7XG4gICAgICAgICAgICBsZXQgb3V0bGluZVRpbGVEYXRhID0gdGhpcy5jYW52YXNDb250ZXh0LmdldEltYWdlRGF0YShkWCwgZFksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgbGV0IGxhYmVsVG9NYXRjaCA9IHBvaW50LmdldCgnc2VnbWVudExhYmVsJyk7XG4gICAgICAgICAgICBsZXQgZnJhbWVJbmRleCA9IHBvaW50LmdldCgnRnJhbWUgSUQnKSAtIDE7XG4gICAgICAgICAgICBsZXQgcklkeCA9IDA7XG4gICAgICAgICAgICBsZXQgW2xhYmVsQXJyYXksIGZpcnN0SW5kZXhdID0gYXdhaXQgdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsUHJvbWlzZShwb2ludC5nZXQoJ0xvY2F0aW9uIElEJyksIGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHNUb3A7IHkgPD0gc0JvdDsgeSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSBzTGVmdDsgeCA8PSBzUmlnaHQ7IHgrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBbcm93SWR4LCBjb2xJZHhdID0gdGhpcy5wYXJlbnRXaWRnZXQuZ2V0TGFiZWxJbmRleEZyb21CaWdJbWdQaXhlbFhZKGZyYW1lSW5kZXgsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gSW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsVmFsdWUocm93SWR4LCBjb2xJZHgsIGxhYmVsQXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbCA9PSBsYWJlbFRvTWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pc0JvcmRlcihsYWJlbCwgcm93SWR4LCBjb2xJZHgsIGxhYmVsQXJyYXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBbciwgZywgYl0gPSB0aGlzLnBhcmVudFdpZGdldC5nZXRDZWxsQ29sb3IocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVUaWxlRGF0YS5kYXRhW3JJZHhdID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lVGlsZURhdGEuZGF0YVtySWR4ICsgMV0gPSBnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVUaWxlRGF0YS5kYXRhW3JJZHggKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0bGluZVRpbGVEYXRhLmRhdGFbcklkeCArIDNdID0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJJZHggKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQucHV0SW1hZ2VEYXRhKG91dGxpbmVUaWxlRGF0YSwgZFgsIGRZKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0xhYmVscygpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjZWxsIGxhYmVsc1xuICAgICAgICBsZXQgcGFkID0gMTA7XG4gICAgICAgIGNvbnN0IHhBbmNob3IgPSB0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi5sZWZ0IC0gcGFkO1xuICAgICAgICBsZXQgbGFiZWxzSW5WaWV3ID0gdGhpcy5jZWxsTGFiZWxQb3NpdGlvbnMuZmlsdGVyKChsYWJlbFBvczogW3N0cmluZywgbnVtYmVyXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcG9zOiBudW1iZXIgPSBsYWJlbFBvc1sxXSAtIHRoaXMubGF0ZXN0U2Nyb2xsWzFdO1xuICAgICAgICAgICAgcmV0dXJuIDAgPD0gcG9zICYmIHBvcyA8PSB0aGlzLmlubmVyQ29udGFpbmVySDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2VsbExhYmVsR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JylcbiAgICAgICAgICAgIC5kYXRhKGxhYmVsc0luVmlldylcbiAgICAgICAgICAgIC5qb2luKCd0ZXh0JylcbiAgICAgICAgICAgIC50ZXh0KGQgPT4gZFswXSlcbiAgICAgICAgICAgIC5hdHRyKCd4JywgeEFuY2hvcilcbiAgICAgICAgICAgIC5hdHRyKCd5JywgZCA9PiBkWzFdIC0gdGhpcy5sYXRlc3RTY3JvbGxbMV0pXG4gICAgICAgICAgICAuY2xhc3NlZCgnY2VsbEF4aXNMYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbGVmdCcsIHRydWUpO1xuXG4gICAgICAgIC8vIGZyYW1lIGxhYmVsc1xuICAgICAgICBwYWQgPSA2O1xuICAgICAgICBjb25zdCB5QW5jaG9yID0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4udG9wIC0gcGFkO1xuICAgICAgICBsYWJlbHNJblZpZXcgPSB0aGlzLmZyYW1lTGFiZWxQb3NpdGlvbnMuZmlsdGVyKChsYWJlbFBvczogW3N0cmluZywgbnVtYmVyXSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcG9zOiBudW1iZXIgPSBsYWJlbFBvc1sxXSAtIHRoaXMubGF0ZXN0U2Nyb2xsWzBdO1xuICAgICAgICAgICAgcmV0dXJuIDAgPD0gcG9zICYmIHBvcyA8PSB0aGlzLmlubmVyQ29udGFpbmVyVztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsc0luVmlldyA9IGxhYmVsc0luVmlldy5tYXAoKGxhYmVsUG9zOiBbc3RyaW5nLCBudW1iZXJdKSA9PiBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSArbGFiZWxQb3NbMF0gLSAxO1xuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50ID0gaW5kZXggLyAodGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtwZXJjZW50LnRvRml4ZWQoMiksIGxhYmVsUG9zWzFdXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lICA9IHRoaXMucGFyZW50V2lkZ2V0LmdldEN1cnJlbnRGcmFtZUlkKCk7XG4gICAgICAgIHRoaXMuZnJhbWVMYWJlbEdyb3VwLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAgICAgICAuZGF0YShsYWJlbHNJblZpZXcpXG4gICAgICAgICAgICAuam9pbigndGV4dCcpXG4gICAgICAgICAgICAudGV4dChkID0+IGRbMF0pXG4gICAgICAgICAgICAuYXR0cigneCcsIGQgPT4gZFsxXSAtIHRoaXMubGF0ZXN0U2Nyb2xsWzBdKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCB5QW5jaG9yKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2N1cnJlbnRGcmFtZScsIGQgPT4gK2RbMF0gPT09IGN1cnJlbnRGcmFtZSAmJiAhdGhpcy5wYXJlbnRXaWRnZXQuaW5FeGVtcGxhck1vZGUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnY2VsbEF4aXNMYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgncmlnaHQnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUxhYmVsc09uTW91c2VNb3ZlKGNlbGxJZDogc3RyaW5nLCBmcmFtZUluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgc3ZnU2VsZWN0aW9uID0gdGhpcy5jZWxsTGFiZWxHcm91cC5zZWxlY3RBbGwoJ3RleHQnKSBhcyBTdmdTZWxlY3Rpb247XG4gICAgICAgIGxldCBmb3VuZE1hdGNoID0gdGhpcy5ob3Zlck5vZGVXaXRoVGV4dChzdmdTZWxlY3Rpb24ubm9kZXMoKSwgY2VsbElkKTtcbiAgICAgICAgc3ZnU2VsZWN0aW9uID0gdGhpcy5mcmFtZUxhYmVsR3JvdXAuc2VsZWN0QWxsKCd0ZXh0JykgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICBpZiAoIWZvdW5kTWF0Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJOb2RlV2l0aFRleHQoc3ZnU2VsZWN0aW9uLm5vZGVzKCksICcnKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGxldCBmcmFtZVRleHQ6IHN0cmluZztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHBlcmNlbnQgPSBmcmFtZUluZGV4IC8gKHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgZnJhbWVUZXh0ID0gcGVyY2VudC50b0ZpeGVkKDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZnJhbWVUZXh0ID0gKGZyYW1lSW5kZXggKyAxKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaG92ZXJOb2RlV2l0aFRleHQoc3ZnU2VsZWN0aW9uLm5vZGVzKCksIGZyYW1lVGV4dCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBob3Zlck5vZGVXaXRoVGV4dChzdmdFbGVtZW50TGlzdDogU1ZHRWxlbWVudFtdLCB0ZXh0OiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgZm91bnRNYXRjaCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBub2RlICBvZiBzdmdFbGVtZW50TGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IG5vZGVFbCA9IChub2RlIGFzIFNWR0VsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKG5vZGVFbC50ZXh0Q29udGVudCA9PT0gdGV4dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub2RlRWwuY2xhc3NMaXN0LmFkZCgnaG92ZXJlZCcpO1xuICAgICAgICAgICAgICAgIGZvdW50TWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVFbC5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW50TWF0Y2g7XG4gICAgfVxuXG4gICAgcHVibGljIE9uUmVzaXplKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgaGVpZ2h0IC09IDMwOyAvLyBoYWNreSwgYnV0IHNlZSAuY2VsbFRpbWVsaW5lSW5uZXJDb250YWluZXIudG9wIGZvciBleHBsYW5hdGlvblxuICAgICAgICB0aGlzLnN2Z0NvbnRhaW5lclxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCAtIDMwKVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpO1xuXG4gICAgICAgIGNvbnN0IGlubmVyVyA9IHdpZHRoIC0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4ubGVmdCAtIHRoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLnJpZ2h0O1xuICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lclcgPSBpbm5lclc7XG4gICAgICAgIGNvbnN0IGlubmVySCA9IGhlaWdodCAtIHRoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLnRvcCAtIHRoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXJIID0gaW5uZXJIO1xuICAgICAgICB0aGlzLmlubmVyQ29udGFpbmVyXG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLFxuICAgICAgICAgICAgYG1heC13aWR0aDogJHtpbm5lcld9cHg7XG4gICAgICAgICAgICBtYXgtaGVpZ2h0OiAke2lubmVySH1weDtcbiAgICAgICAgICAgIHdpZHRoOiAke2lubmVyV31weDtcbiAgICAgICAgICAgIGhlaWdodDogJHtpbm5lckh9cHg7YClcbiAgICB9XG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHtIdG1sU2VsZWN0aW9ufSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHtEZXZsaWJUU1V0aWx9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUU1V0aWwnO1xuaW1wb3J0IHtCYXNlV2lkZ2V0fSBmcm9tICcuL0Jhc2VXaWRnZXQnO1xuaW1wb3J0IHtQb2ludENvbGxlY3Rpb259IGZyb20gJy4uL0RhdGFNb2RlbC9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHtDdXJ2ZUxpc3R9IGZyb20gJy4uL0RhdGFNb2RlbC9DdXJ2ZUxpc3QnO1xuaW1wb3J0IHtMYXlvdXRGcmFtZXdvcmt9IGZyb20gJy4uL0xheW91dEZyYW1ld29yayc7XG5pbXBvcnQge0hpc3RvZ3JhbVdpZGdldH0gZnJvbSAnLi9IaXN0b2dyYW1XaWRnZXQnO1xuaW1wb3J0IHtTY2F0dGVyUGxvdFdpZGdldH0gZnJvbSAnLi9TY2F0dGVyUGxvdFdpZGdldCc7XG5pbXBvcnQge0ZyYW1lLCBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcywgRGlyZWN0aW9uLCBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwsIERhdGFzZXRTcGVjfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBib29sV2l0aEluZGV4IHtcblx0dmFsdWU6IGJvb2xlYW4sXG5cdGluZGV4OiBbbnVtYmVyLCBudW1iZXJdLFxufVxuXG5cbmV4cG9ydCBjbGFzcyBNZXRyaWNEaXN0cmlidXRpb25XaWRnZXQgZXh0ZW5kcyBCYXNlV2lkZ2V0PEN1cnZlTGlzdCwgRGF0YXNldFNwZWM+IHtcblx0XG5cblx0Y29uc3RydWN0b3IoY29udGFpbmVyOiBFbGVtZW50LCBtZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw6IE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbClcblx0e1xuXHRcdHN1cGVyKGNvbnRhaW5lcik7XG5cdFx0dGhpcy5fbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsID0gbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsO1xuXHR9XG5cbiAgICBwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz5cbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0KGNvbnRhaW5lciwgdGhpcy5tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwpO1xuICAgIH1cblxuXHRwcml2YXRlIF93cmFwcGVyQ29udGFpbmVyIDogSFRNTERpdkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgd3JhcHBlckNvbnRhaW5lcigpIDogSFRNTERpdkVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl93cmFwcGVyQ29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfbGF5b3V0RnJhbWV3b3JrIDogTGF5b3V0RnJhbWV3b3JrO1xuXHRwdWJsaWMgZ2V0IGxheW91dEZyYW1ld29yaygpIDogTGF5b3V0RnJhbWV3b3JrIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF5b3V0RnJhbWV3b3JrO1xuXHR9XG5cblx0cHJpdmF0ZSBfc3ViQ29tcG9uZW50TG9va3VwIDogTWFwPEhUTUxFbGVtZW50LCBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcz47XG5cdHB1YmxpYyBnZXQgc3ViQ29tcG9uZW50TG9va3VwKCkgOiBNYXA8SFRNTEVsZW1lbnQsIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YkNvbXBvbmVudExvb2t1cDtcblx0fVxuXG5cdHByaXZhdGUgX2Jhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uIDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBiYXNpc1NlbGVjdENvbnRhaW5lclNlbGVjdGlvbigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2Jhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uO1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24gOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHNjYXR0ZXJQbG90U2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uKCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb247XG5cdH1cblxuXHRwcml2YXRlIF95QXhpc01hdHJpeFNlbGVjdCA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgeUF4aXNNYXRyaXhTZWxlY3QoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl95QXhpc01hdHJpeFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3hBeGlzTWF0cml4U2VsZWN0IDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCB4QXhpc01hdHJpeFNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3hBeGlzTWF0cml4U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbiA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RyaWJ1dGlvblBsb3RDb250YWluZXJTZWxlY3Rpb247XG5cdH1cblxuXHRwcml2YXRlIF9zY2F0dGVyUGxvdENvbnRhaW5lclNlbGVjdGlvbiA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24oKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zY2F0dGVyUGxvdENvbnRhaW5lclNlbGVjdGlvbjtcblx0fVxuXG5cdHByaXZhdGUgX2NvbGxhcHNlQnV0dG9uU2VsZWN0IDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBjb2xsYXBzZUJ1dHRvblNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbGxhcHNlQnV0dG9uU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfZXhwYW5kQnV0dG9uU2VsZWN0IDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBleHBhbmRCdXR0b25TZWxlY3QoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9leHBhbmRCdXR0b25TZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9hdHRyaWJ1dGVUb0luZGV4IDogTWFwPHN0cmluZywgbnVtYmVyPjtcblx0cHVibGljIGdldCBhdHRyaWJ1dGVUb0luZGV4KCkgOiBNYXA8c3RyaW5nLCBudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlVG9JbmRleDtcblx0fVxuXG5cdHByaXZhdGUgX2Jhc2lzU2VsZWN0aW9uQm9vbGVhbnMgOiBib29sZWFuW107XG5cdHB1YmxpYyBnZXQgYmFzaXNTZWxlY3Rpb25Cb29sZWFucygpIDogYm9vbGVhbltdIHtcblx0XHRyZXR1cm4gdGhpcy5fYmFzaXNTZWxlY3Rpb25Cb29sZWFucztcblx0fVxuXG5cdHByaXZhdGUgX3NjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMgOiBib29sV2l0aEluZGV4W11bXTtcblx0cHVibGljIGdldCBzY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zKCkgOiBib29sV2l0aEluZGV4W11bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnM7XG5cdH1cblxuXHRwcml2YXRlIF9oaXN0b2dyYW1XaWRnZXRzIDogSGlzdG9ncmFtV2lkZ2V0W107XG5cdHB1YmxpYyBnZXQgaGlzdG9ncmFtV2lkZ2V0cygpIDogSGlzdG9ncmFtV2lkZ2V0W10ge1xuXHRcdHJldHVybiB0aGlzLl9oaXN0b2dyYW1XaWRnZXRzO1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhdHRlclBsb3RXaWRnZXRzIDogU2NhdHRlclBsb3RXaWRnZXRbXTtcblx0cHVibGljIGdldCBzY2F0dGVyUGxvdFdpZGdldHMoKSA6IFNjYXR0ZXJQbG90V2lkZ2V0W10ge1xuXHRcdHJldHVybiB0aGlzLl9zY2F0dGVyUGxvdFdpZGdldHM7XG5cdH1cblxuXHRwcml2YXRlIF9wb2ludENvbGxlY3Rpb24gOiBQb2ludENvbGxlY3Rpb247XG5cdHB1YmxpYyBnZXQgcG9pbnRDb2xsZWN0aW9uKCkgOiBQb2ludENvbGxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludENvbGxlY3Rpb247XG5cdH1cblxuXHRwcml2YXRlIF9tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwgOiBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw7XG5cdHB1YmxpYyBnZXQgbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsKCkgOiBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwge1xuXHRcdHJldHVybiB0aGlzLl9tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw7XG5cdH1cblx0XG5cdHByaXZhdGUgX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbigpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uO1xuXHR9XG5cblx0cHJvdGVjdGVkIGluaXQoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fd3JhcHBlckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0dGhpcy53cmFwcGVyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmFtZVwiLCBcImRpci1yb3dcIiwgXCJ3cmFwcGVyQ29udGFpbmVyXCIpO1xuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlckNvbnRhaW5lcik7XG5cblx0XHR0aGlzLl9sYXlvdXRGcmFtZXdvcmsgPSBuZXcgTGF5b3V0RnJhbWV3b3JrKHRoaXMud3JhcHBlckNvbnRhaW5lciwgZmFsc2UpO1xuXHRcdGxldCBsYXlvdXQ6IEZyYW1lPE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzPiA9IHtcblx0XHRcdGRpcmVjdGlvbjogRGlyZWN0aW9uLnJvdyxcblx0XHRcdGluc2lkZTogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBEaXJlY3Rpb24uY29sdW1uLFxuXHRcdFx0XHRcdG1pblNpemU6IDgwLFxuXHRcdFx0XHRcdG1heFNpemU6IDgwLFxuXHRcdFx0XHRcdGluc2lkZTogTWV0cmljRGlzdHJpYnV0aW9uU3ViQ29tcG9uZW50VHlwZXMuQmFzaXNTZWxlY3Rcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRpcmVjdGlvbjogRGlyZWN0aW9uLmNvbHVtbixcblx0XHRcdFx0XHRpbnNpZGU6IE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLlNjYXR0ZXJwbG90U2VsZWN0XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkaXJlY3Rpb246IERpcmVjdGlvbi5jb2x1bW4sXG5cdFx0XHRcdFx0aW5zaWRlOiBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5EaXN0cmlidXRpb25QbG90XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkaXJlY3Rpb246IERpcmVjdGlvbi5jb2x1bW4sXG5cdFx0XHRcdFx0aW5zaWRlOiBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5TY2F0dGVycGxvdFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fTtcblx0XHR0aGlzLl9zdWJDb21wb25lbnRMb29rdXAgPSB0aGlzLmxheW91dEZyYW1ld29yay5Jbml0aWFsaXplTGF5b3V0PE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzPihsYXlvdXQpXG5cdFx0dGhpcy5pbml0U3ViQ29tcG9uZW50cygpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0U3ViQ29tcG9uZW50cygpOiB2b2lkXG5cdHtcblx0XHRmb3IgKGxldCBbY29udGFpbmVyLCBzdWJDb21wb25lbnRdIG9mIHRoaXMuc3ViQ29tcG9uZW50TG9va3VwKVxuXHRcdHtcblx0XHRcdHN3aXRjaCAoc3ViQ29tcG9uZW50KSB7XG5cdFx0XHRcdGNhc2UgTWV0cmljRGlzdHJpYnV0aW9uU3ViQ29tcG9uZW50VHlwZXMuQmFzaXNTZWxlY3Q6XG5cdFx0XHRcdFx0dGhpcy5fYmFzaXNTZWxlY3RDb250YWluZXJTZWxlY3Rpb24gPSB0aGlzLmluaXRTdWJDb21wb25lbnQoY29udGFpbmVyLCBcInRvZ2dsZUJ1dHRvbkNvbnRhaW5lclwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5TY2F0dGVycGxvdFNlbGVjdDpcblx0XHRcdFx0XHRsZXQgd3JhcHBlciA9IGQzLnNlbGVjdChjb250YWluZXIpLmFwcGVuZCgnZGl2Jylcblx0XHRcdFx0XHRcdC5jbGFzc2VkKFwibWF0cml4V3JhcHBlckNvbnRhaW5lclwiLCB0cnVlKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJpZFwiLCBcIm1hdHJpeFdyYXBwZXJDb250YWluZXJcIik7XG5cblx0XHRcdFx0XHR0aGlzLl95QXhpc01hdHJpeFNlbGVjdCA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudCh3cmFwcGVyLm5vZGUoKSwgXCJ5QXhpc01hdHJpeENvbnRhaW5lclwiKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGxldCByaWdodFdyYXBwZXIgPSB3cmFwcGVyLmFwcGVuZCgnZGl2Jylcblx0XHRcdFx0XHRcdC5jbGFzc2VkKFwibWF0cml4UmlnaHRXcmFwcGVyQ29udGFpbmVyXCIsIHRydWUpO1xuXG5cdFx0XHRcdFx0dGhpcy5fc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24gPSB0aGlzLmluaXRTdWJDb21wb25lbnQocmlnaHRXcmFwcGVyLm5vZGUoKSwgXCJtYXRyaXhDb250YWluZXJcIik7XG5cdFx0XHRcdFx0dGhpcy5feEF4aXNNYXRyaXhTZWxlY3QgPSB0aGlzLmluaXRTdWJDb21wb25lbnQocmlnaHRXcmFwcGVyLm5vZGUoKSwgXCJ4QXhpc01hdHJpeENvbnRhaW5lclwiKTtcblx0XHRcdFx0XHRsZXQgY29sbGFwc2VFeHBhbmRMaXN0OiBIVE1MRWxlbWVudFtdID0gW1xuXHRcdFx0XHRcdFx0dGhpcy5iYXNpc1NlbGVjdENvbnRhaW5lclNlbGVjdGlvbi5ub2RlKCkucGFyZW50RWxlbWVudCxcblx0XHRcdFx0XHRcdHdyYXBwZXIubm9kZSgpLnBhcmVudEVsZW1lbnRcblx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdHRoaXMuaGlkZUVsZW1lbnRzKGNvbGxhcHNlRXhwYW5kTGlzdCk7IC8vIGNvbGxhcHNlZCBieSBkZWZhdWx0XG5cdFx0XHRcdFx0dGhpcy5pbml0Q29sbGFwc2VCdXR0b24ocmlnaHRXcmFwcGVyLCBjb2xsYXBzZUV4cGFuZExpc3QpO1xuXHRcdFx0XHRcdHRoaXMuaW5pdEV4cGFuZEJ1dHRvbihjb2xsYXBzZUV4cGFuZExpc3QpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLkRpc3RyaWJ1dGlvblBsb3Q6XG5cdFx0XHRcdFx0dGhpcy5fZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbiA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChjb250YWluZXIsIFwiZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5TY2F0dGVycGxvdDpcblx0XHRcdFx0XHR0aGlzLl9zY2F0dGVyUGxvdENvbnRhaW5lclNlbGVjdGlvbiA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChjb250YWluZXIsIFwic2NhdHRlclBsb3RPdXRlckNvbnRhaW5lclwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5yZXNpemVTdWJDb21wb25lbnRzKCk7XG5cdH1cblxuXHRwcml2YXRlIGluaXRTdWJDb21wb25lbnQoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcpOiBIdG1sU2VsZWN0aW9uXG5cdHtcblx0XHRyZXR1cm4gZDMuc2VsZWN0KGNvbnRhaW5lcilcdFx0XHRcblx0XHRcdC5hcHBlbmQoXCJkaXZcIilcblx0XHRcdC5jbGFzc2VkKGNsYXNzTmFtZSwgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKFwib3ZlcmZsb3ctc2Nyb2xsXCIsIHRydWUpXG5cdFx0XHQuYXR0cihcImlkXCIsIGNsYXNzTmFtZSk7XG5cdH1cblxuXHRwcml2YXRlIGluaXRDb2xsYXBzZUJ1dHRvbihjb250YWluZXJTZWxlY3Q6IEh0bWxTZWxlY3Rpb24sIHRvSGlkZTogSFRNTEVsZW1lbnRbXSk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX2NvbGxhcHNlQnV0dG9uU2VsZWN0ID0gXG5cdFx0Y29udGFpbmVyU2VsZWN0LmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCdjb2xsYXBzZUNvbnRhaW5lcicsIHRydWUpXG5cdFx0ICAuYXBwZW5kKCdidXR0b24nKVxuXHRcdFx0LmNsYXNzZWQoJ2NvbGxhcHNlQnV0dG9uJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdkZXZsaWJCdXR0b24nLCB0cnVlKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBcIk1ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldC1jb2xsYXBzZUJ1dHRvblwiKVxuXHRcdFx0LnRleHQoJ0NvbGxhcHNlJylcblx0XHRcdC5vbignY2xpY2snLCAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmhpZGVFbGVtZW50cyh0b0hpZGUpO1xuXHRcdFx0XHR0aGlzLmV4cGFuZEJ1dHRvblNlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdtb3VzZWVudGVyJywgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgZWxlbWVudCBvZiB0b0hpZGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJob3ZlcmVkQXJlYVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VsZWF2ZScsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IGVsZW1lbnQgb2YgdG9IaWRlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiaG92ZXJlZEFyZWFcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBoaWRlRWxlbWVudHModG9IaWRlOiBIVE1MRWxlbWVudFtdKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgZWxlbWVudCBvZiB0b0hpZGUpXG5cdFx0e1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibm9EaXNwXCIpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaW5pdEV4cGFuZEJ1dHRvbih0b1Nob3c6IEhUTUxFbGVtZW50W10pOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9leHBhbmRCdXR0b25TZWxlY3QgPSBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpLmFwcGVuZChcImJ1dHRvblwiKVxuXHRcdFx0LmNsYXNzZWQoJ2V4cGFuZEJ1dHRvbicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnZGV2bGliQnV0dG9uJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKVxuXHRcdFx0LmF0dHIoJ2lkJywgJ01ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldC1leHBhbmRCdXR0b24nKVxuXHRcdFx0LmF0dHIoXCJ0aXRsZVwiLCBcIk9wZW4gZGlzdHJpYnV0aW9uIHNlbGVjdGlvbiB3aWRnZXQuXCIpXG5cdFx0XHQub24oJ2NsaWNrJywgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy5leHBhbmRCdXR0b25TZWxlY3QuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG5cdFx0XHRcdGZvciAobGV0IGVsZW1lbnQgb2YgdG9TaG93KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdub0Rpc3AnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRsZXQgaWNvbiA9IERldmxpYlRTVXRpbC5nZXRGb250QXdlc29tZUljb24oJ3RoJyk7XG5cdFx0dGhpcy5leHBhbmRCdXR0b25TZWxlY3Qubm9kZSgpLmFwcGVuZENoaWxkKGljb24pO1xuXHR9XG5cblx0cHVibGljIE9uRGF0YUNoYW5nZSgpOiB2b2lkXG5cdHtcblx0XHRzd2l0Y2ggKHRoaXMubWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsKVxuXHRcdHtcblx0XHRcdGNhc2UgTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLlBvaW50OlxuXHRcdFx0XHR0aGlzLl9wb2ludENvbGxlY3Rpb24gPSB0aGlzLmRhdGEgYXMgUG9pbnRDb2xsZWN0aW9uO1xuXHRcdFx0XHR0aGlzLl9pbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbiA9IGZhbHNlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLkN1cnZlOlxuXHRcdFx0XHR0aGlzLl9wb2ludENvbGxlY3Rpb24gPSB0aGlzLmRhdGEuY3VydmVDb2xsZWN0aW9uIGFzIFBvaW50Q29sbGVjdGlvbjtcblx0XHRcdFx0dGhpcy5faW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24gPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRoaXMuX3BvaW50Q29sbGVjdGlvbiA9IG51bGw7XG5cdFx0XHRcdHRoaXMuX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uID0gZmFsc2U7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsIG5vdCBzZXQuJylcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYXR0cmlidXRlVG9JbmRleCA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cdFx0Zm9yIChsZXQgW2luZGV4LCBhdHRyXSBvZiB0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0LmVudHJpZXMoKSlcblx0XHR7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZVRvSW5kZXguc2V0KGF0dHIsIGluZGV4KTtcblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZVVJRGF0YSgpO1xuXHRcdHRoaXMuZHJhd0Jhc2lzU2VsZWN0KCk7XG5cdFx0dGhpcy5kcmF3U2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24oKTtcblx0XHR0aGlzLmRyYXdNYXRyaXhBeGlzKCk7XG5cdFx0dGhpcy5leHBhbmRCdXR0b25TZWxlY3QuY2xhc3NlZCgnbm9EaXNwJywgZmFsc2UpO1xuXHRcdHRoaXMuZHJhd0hpc3RvZ3JhbXMoKTtcblx0XHR0aGlzLmRyYXdTY2F0dGVyUGxvdHModGhpcy5nZXRTY2F0dGVyT3B0aW9uc01hdHJpeCgpKTtcblx0fVxuXG5cdHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdGZvciAobGV0IGhpc3Qgb2YgdGhpcy5oaXN0b2dyYW1XaWRnZXRzKVxuXHRcdHtcblx0XHRcdGhpc3QuT25CcnVzaENoYW5nZSgpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IHNjYXR0ZXIgb2YgdGhpcy5zY2F0dGVyUGxvdFdpZGdldHMpXG5cdFx0e1xuXHRcdFx0c2NhdHRlci5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVVSURhdGEoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fYmFzaXNTZWxlY3Rpb25Cb29sZWFucyA9IFtdO1xuXHRcdC8vIFRvZG8gLSBpdCB3b3VsZCBiZSBuaWNlIGlmIHRoaXMgd2FzIGNvbmZpZ3VyYWJsZS5cblx0XHRjb25zdCBkZWZhdWx0SW5jbHVkZWQgPSBuZXcgU2V0KFsnTWFzcyAocGcpJywgJ1RpbWUgKGgpJywgJ01hc3Nfbm9ybScsICdUcmFjayBMZW5ndGgnLCAnQXZnIE1hc3MnLCAnR3Jvd3RoIFJhdGUnLCAnRXhwb25lbnRpYWwgR3Jvd3RoIENvbnN0YW50J10pO1xuXG5cdFx0Y29uc3QgbWF4RGVmYXVsdE1hdHJpeFNpemUgPSAxNVxuXHRcdHRoaXMuX3NjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMgPSBbXTtcblx0XHRmb3IgKGxldCBbcm93SW5kZXgsIGF0dHIxXSBvZiB0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0LmVudHJpZXMoKSlcblx0XHR7XG5cdFx0XHR0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnMucHVzaChyb3dJbmRleCA8IG1heERlZmF1bHRNYXRyaXhTaXplICYmIGRlZmF1bHRJbmNsdWRlZC5oYXMoYXR0cjEpKTtcblx0XHRcdGxldCByb3c6IGJvb2xXaXRoSW5kZXhbXSA9IFtdO1xuXHRcdFx0Zm9yIChsZXQgW2NvbEluZGV4LCBhdHRyMl0gb2YgdGhpcy5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdC5lbnRyaWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdHJvdy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogYXR0cjEgPT09IGF0dHIyLFxuXHRcdFx0XHRcdGluZGV4OiBbcm93SW5kZXgsIGNvbEluZGV4XVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zLnB1c2gocm93KTtcblx0XHR9XG5cdFx0dGhpcy5kcmF3QmFzaXNTZWxlY3QoKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0Jhc2lzU2VsZWN0KCk6IHZvaWRcblx0e1xuXHRcdGxldCB0aGlzV2lkZ2V0ID0gdGhpcztcblx0XHRsZXQgZmxhdERhdGEgPSB0aGlzLmdldFNjYXR0ZXJPcHRpb25zTWF0cml4KCk7XG5cdFx0dGhpcy5iYXNpc1NlbGVjdENvbnRhaW5lclNlbGVjdGlvblxuXHRcdFx0LnNlbGVjdEFsbChcImJ1dHRvblwiKVxuXHRcdFx0LmRhdGEodGhpcy5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdClcblx0XHRcdC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0XHQudGV4dChkID0+IGQpXG5cdFx0XHQuYXR0cigndGl0bGUnLCBkID0+IGQpXG5cdFx0XHQuY2xhc3NlZChcInRvZ2dsZUJ1dHRvblwiLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoXCJvblwiLCAoZCwgaSkgPT4gdGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2ldKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBkID0+IFwiTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0LXZhclNlbGVjdC1cIiArIGQpXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24oZCwgaSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IGJ1dHRvblNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzKTtcblx0XHRcdFx0bGV0IHR1cm5PbiA9ICF0aGlzV2lkZ2V0LmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbaV07XG5cdFx0XHRcdGJ1dHRvblNlbGVjdC5jbGFzc2VkKFwib25cIiwgdHVybk9uKTtcblx0XHRcdFx0dGhpc1dpZGdldC5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2ldID0gdHVybk9uO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LmRyYXdTY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvbigpO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LmRyYXdNYXRyaXhBeGlzKCk7XG5cdFx0XHRcdHRoaXNXaWRnZXQudXBkYXRlSGlzdG9ncmFtcygpO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LnVwZGF0ZVNjYXR0ZXJQbG90cyhmbGF0RGF0YSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd01hdHJpeEF4aXMoKTogdm9pZFxuXHR7XG5cdFx0Y29uc3QgYnV0dG9uV2lkdGggPSA4MDtcblx0XHRjb25zdCBidXR0b25IZWlnaHQgPSAxODtcblx0XHRsZXQgb3B0aW9ucyA9IHRoaXMuZ2V0Q3VycmVudE9wdGlvbnMoKTtcblx0XHR0aGlzLnlBeGlzTWF0cml4U2VsZWN0LnNlbGVjdEFsbChcImJ1dHRvblwiKVxuXHRcdFx0LmRhdGEob3B0aW9ucylcblx0XHQgIC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0J1dHRvbicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgneScsIHRydWUpXG5cdFx0XHQuYXR0cihcInN0eWxlXCIsIChkLCBpKSA9PiBgXG5cdFx0XHRcdHdpZHRoOiAke2J1dHRvbldpZHRofXB4O1xuXHRcdFx0XHRoZWlnaHQ6ICR7YnV0dG9uSGVpZ2h0fXB4O2ApXG5cdFx0XHQudGV4dChkID0+IGQpXG5cdFx0XHQuYXR0cigndGl0bGUnLCBkID0+IGQpXG5cdFx0XHQub24oXCJjbGlja1wiLCAoZCkgPT4ge1xuXHRcdFx0XHRsZXQgcm93SW5kZXggPSB0aGlzLmF0dHJpYnV0ZVRvSW5kZXguZ2V0KGQpO1xuXHRcdFx0XHRsZXQgcm93OiBib29sV2l0aEluZGV4W10gPSB0aGlzLnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnNbcm93SW5kZXhdO1xuXHRcdFx0XHRsZXQgYWxsVHJ1ZSA9IHRydWU7XG5cdFx0XHRcdGZvciAobGV0IGNlbGwgb2Ygcm93KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKHRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tjZWxsLmluZGV4WzFdXSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoIWNlbGwudmFsdWUpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGFsbFRydWUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNlbGwudmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWxsVHJ1ZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAobGV0IGNlbGwgb2Ygcm93KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbY2VsbC5pbmRleFsxXV0pXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNlbGwudmFsdWUgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmFmdGVyTXVsdGlwbGVNYXRyaXhDaGFuZ2VzKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbihkKVxuXHRcdFx0e1xuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZChcImhvdmVyZWRcIiwgdHJ1ZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbihkKVxuXHRcdFx0e1xuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZChcImhvdmVyZWRcIiwgZmFsc2UpO1xuXHRcdFx0fSk7XG5cblxuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGJ1dHRvbldpZHRoIC8gMjsgXG5cdFx0Y29uc3Qgcm90YXRlID0gLTkwO1xuXHRcdGNvbnN0IHRoZXRhID0gTWF0aC5QSSAqIHJvdGF0ZSAvIDE4MDtcblx0XHRjb25zdCB4T2Zmc2V0ID0gLTAuNSAqIChidXR0b25XaWR0aCArIGJ1dHRvbldpZHRoICogTWF0aC5jb3MoLXRoZXRhKSArIGJ1dHRvbkhlaWdodCAqIE1hdGguc2luKC10aGV0YSkpO1xuXHRcdGNvbnN0IHlPZmZzZXQgPSAwLjUgKiAoYnV0dG9uV2lkdGggKiBNYXRoLnNpbigtdGhldGEpICsgYnV0dG9uSGVpZ2h0ICogTWF0aC5jb3MoLXRoZXRhKSAtIGJ1dHRvbkhlaWdodCk7XG5cblx0XHRsZXQgdGhldGEyID0gOTAgKyByb3RhdGU7XG5cdFx0dGhldGEyID0gTWF0aC5QSSAqIHRoZXRhMiAvIDE4MDtcblx0XHRjb25zdCBob3Jpem9udGFsUGFkZGluZyA9IDI7XG5cdFx0bGV0IHN0ZXBTaXplID0gaG9yaXpvbnRhbFBhZGRpbmcgKyBidXR0b25IZWlnaHQgLyBNYXRoLmNvcyh0aGV0YTIpO1xuXG5cblx0XHR0aGlzLnhBeGlzTWF0cml4U2VsZWN0LnNlbGVjdEFsbChcImJ1dHRvblwiKVxuXHRcdFx0LmRhdGEob3B0aW9ucylcblx0XHQgIC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0J1dHRvbicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgneCcsIHRydWUpXG5cdFx0XHQuYXR0cihcInN0eWxlXCIsIChkLCBpKSA9PiBgXG5cdFx0XHRcdHdpZHRoOiAke2J1dHRvbldpZHRofXB4O1xuXHRcdFx0XHRoZWlnaHQ6ICR7YnV0dG9uSGVpZ2h0fXB4O1xuXHRcdFx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZSggJHtzdGVwU2l6ZSAqIChpICsgMSkgKyB4T2Zmc2V0fXB4LCAke3lPZmZzZXR9cHgpIHJvdGF0ZSgke3JvdGF0ZX1kZWcpO2ApXG5cdFx0XHQudGV4dChkID0+IGQpXG5cdFx0XHQuYXR0cigndGl0bGUnLCBkID0+IGQpXG5cdFx0XHQub24oXCJjbGlja1wiLCAoZCkgPT4ge1xuXHRcdFx0XHRsZXQgY29sSW5kZXggPSB0aGlzLmF0dHJpYnV0ZVRvSW5kZXguZ2V0KGQpO1xuXHRcdFx0XHRsZXQgYWxsVHJ1ZSA9IHRydWU7XG5cdFx0XHRcdGZvciAobGV0IHJvdyBvZiB0aGlzLnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGxldCBjZWxsIG9mIHJvdylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRsZXQgY2VsbFJvd0luZGV4ID0gY2VsbC5pbmRleFswXTtcblx0XHRcdFx0XHRcdGxldCBjZWxsQ29sSW5kZXggPSBjZWxsLmluZGV4WzFdO1xuXG5cdFx0XHRcdFx0XHRpZiAoY29sSW5kZXggPT09IGNlbGxDb2xJbmRleCAmJiB0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbY2VsbFJvd0luZGV4XSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKCFjZWxsLnZhbHVlKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0YWxsVHJ1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNlbGwudmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChhbGxUcnVlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChsZXQgcm93IG9mIHRoaXMuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3IgKGxldCBjZWxsIG9mIHJvdylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bGV0IGNlbGxSb3dJbmRleCA9IGNlbGwuaW5kZXhbMF07XG5cdFx0XHRcdFx0XHRcdGxldCBjZWxsQ29sSW5kZXggPSBjZWxsLmluZGV4WzFdO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChjb2xJbmRleCA9PT0gY2VsbENvbEluZGV4ICYmIHRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tjZWxsUm93SW5kZXhdKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y2VsbC52YWx1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmFmdGVyTXVsdGlwbGVNYXRyaXhDaGFuZ2VzKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbihkKVxuXHRcdFx0e1xuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZChcImhvdmVyZWRcIiwgdHJ1ZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbihkKVxuXHRcdFx0e1xuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZChcImhvdmVyZWRcIiwgZmFsc2UpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGdldEN1cnJlbnRPcHRpb25zKCk6IHN0cmluZ1tdXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdC5maWx0ZXIoKGQsIGkpID0+IHRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tpXSk7XG5cdH1cblxuXHRwcml2YXRlIGFmdGVyTXVsdGlwbGVNYXRyaXhDaGFuZ2VzKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMudXBkYXRlTWF0cml4Q2VsbFNlbGVjdGlvbnMoKTtcblx0XHRsZXQgZmxhdERhdGEgPSB0aGlzLmdldFNjYXR0ZXJPcHRpb25zTWF0cml4KClcblx0XHR0aGlzLnVwZGF0ZUhpc3RvZ3JhbXMoKTtcblx0XHR0aGlzLnVwZGF0ZVNjYXR0ZXJQbG90cyhmbGF0RGF0YSk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZU1hdHJpeENlbGxTZWxlY3Rpb25zKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb25cblx0XHRcdC5zZWxlY3RBbGwoXCJkaXZcIilcblx0XHRcdC5kYXRhKHRoaXMuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucylcblx0XHQgIC5qb2luKFwiZGl2XCIpXG5cdFx0XHQuc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHQuZGF0YShkID0+IGQpXG5cdFx0ICAuam9pbihcImJ1dHRvblwiKVxuXHRcdCAgXHQuY2xhc3NlZChcIm9uXCIsIGQ9PiBkLnZhbHVlKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd1NjYXR0ZXJQbG90U2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uKCk6IHZvaWRcblx0e1xuXHRcdGxldCB0aGlzV2lkZ2V0ID0gdGhpcztcblx0XHRsZXQgZmxhdERhdGEgPSB0aGlzLmdldFNjYXR0ZXJPcHRpb25zTWF0cml4KCk7XG5cdFx0dGhpcy5zY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvblxuXHRcdFx0LnNlbGVjdEFsbChcImRpdlwiKVxuXHRcdFx0LmRhdGEodGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zKVxuXHRcdCAgLmpvaW4oXCJkaXZcIilcblx0XHRcdC5jbGFzc2VkKFwicm93Q29udGFpbmVyXCIsIHRydWUpXG5cdFx0XHQuY2xhc3NlZChcIm5vRGlzcFwiLCAoZCwgaSkgPT4gIXRoaXNXaWRnZXQuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tpXSApXG5cdFx0XHQuc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHQuZGF0YShkID0+IGQpXG5cdFx0ICAuam9pbihcImJ1dHRvblwiKVxuXHRcdCAgXHQuY2xhc3NlZChcInNxdWFyZUJ1dHRvblwiLCB0cnVlKVxuXHRcdCAgXHQuY2xhc3NlZChcIm9uXCIsIGQ9PiBkLnZhbHVlKVxuXHRcdCAgXHQuY2xhc3NlZChcIm5vRGlzcFwiLCAoZCwgaSkgPT4gIXRoaXNXaWRnZXQuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tpXSlcblx0XHRcdC5hdHRyKFwiaWRcIiwgZCA9PiBcIk1ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldC1zY2F0dGVyU2VsZWN0LVwiICsgZC5pbmRleFswXSArIFwiLVwiICsgZC5pbmRleFsxXSlcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBidXR0b25TZWxlY3QgPSBkMy5zZWxlY3QodGhpcyk7XG5cdFx0XHRcdGxldCB0dXJuT24gPSAhZC52YWx1ZTtcblx0XHRcdFx0YnV0dG9uU2VsZWN0LmNsYXNzZWQoXCJvblwiLCB0dXJuT24pO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnNbZC5pbmRleFswXV1baV0udmFsdWUgPSB0dXJuT247XG5cdFx0XHRcdGlmIChpID09PSBkLmluZGV4WzBdKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpc1dpZGdldC51cGRhdGVIaXN0b2dyYW1zKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpc1dpZGdldC51cGRhdGVTY2F0dGVyUGxvdHMoZmxhdERhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwibW91c2VlbnRlclwiLCBmdW5jdGlvbiAoZClcblx0XHRcdHtcblx0XHRcdFx0bGV0IFtyb3dJZHgsIGNvbElkeF0gPSBkLmluZGV4O1xuXHRcdFx0XHRsZXQgYnV0dG9uU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRidXR0b25TZWxlY3QuY2xhc3NlZChcImhvdmVyZWRcIiwgdHJ1ZSk7XG5cdFx0XHRcdGxldCBvcHRpb25zID0gdGhpc1dpZGdldC5nZXRDdXJyZW50T3B0aW9ucygpO1xuXHRcdFx0XHRsZXQgcm93TmFtZSA9IHRoaXNXaWRnZXQucG9pbnRDb2xsZWN0aW9uLmF0dHJpYnV0ZUxpc3Rbcm93SWR4XTtcblx0XHRcdFx0bGV0IGNvbE5hbWUgPSB0aGlzV2lkZ2V0LnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0W2NvbElkeF07XG5cdFx0XHRcdHRoaXNXaWRnZXQueUF4aXNNYXRyaXhTZWxlY3Quc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHRcdFx0LmRhdGEob3B0aW9ucylcblx0XHRcdFx0XHQuY2xhc3NlZChcImhvdmVyZWRcIiwgZCA9PiBkID09PSByb3dOYW1lKTtcblxuXHRcdFx0XHR0aGlzV2lkZ2V0LnhBeGlzTWF0cml4U2VsZWN0LnNlbGVjdEFsbChcImJ1dHRvblwiKVxuXHRcdFx0XHRcdC5kYXRhKG9wdGlvbnMpXG5cdFx0XHRcdFx0LmNsYXNzZWQoXCJob3ZlcmVkXCIsIGQgPT4gZCA9PT0gY29sTmFtZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoZClcblx0XHRcdHtcblx0XHRcdFx0bGV0IGJ1dHRvblNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzKTtcblx0XHRcdFx0YnV0dG9uU2VsZWN0LmNsYXNzZWQoXCJob3ZlcmVkXCIsIGZhbHNlKTtcblxuXHRcdFx0XHRsZXQgb3B0aW9ucyA9IHRoaXNXaWRnZXQuZ2V0Q3VycmVudE9wdGlvbnMoKTtcblx0XHRcdFx0dGhpc1dpZGdldC55QXhpc01hdHJpeFNlbGVjdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdFx0XHQuZGF0YShvcHRpb25zKVxuXHRcdFx0XHRcdC5jbGFzc2VkKFwiaG92ZXJlZFwiLCBmYWxzZSk7XG5cblx0XHRcdFx0dGhpc1dpZGdldC54QXhpc01hdHJpeFNlbGVjdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdFx0XHQuZGF0YShvcHRpb25zKVxuXHRcdFx0XHRcdC5jbGFzc2VkKFwiaG92ZXJlZFwiLCBmYWxzZSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0hpc3RvZ3JhbXMoKTogdm9pZFxuXHR7XG5cdFx0bGV0IHRoaXNXaWRnZXQgPSB0aGlzO1xuXHRcdHRoaXMuX2hpc3RvZ3JhbVdpZGdldHMgPSBbXTtcblxuXHRcdGxldCBwYXJlbnRFbGVtZW50ID0gdGhpcy5kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5wYXJlbnRFbGVtZW50O1xuXHRcdHBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm5vRGlzcFwiKTtcblxuXG5cdFx0dGhpcy5kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uLmh0bWwobnVsbClcblx0XHRcdC5jbGFzc2VkKFwibm9EaXNwXCIsIGZhbHNlKVxuXHRcdFx0LnNlbGVjdEFsbChcImRpdlwiKVxuXHRcdFx0LmRhdGEodGhpcy5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdClcblx0XHQgIC5qb2luKFwiZGl2XCIpXG5cdFx0XHQuY2xhc3NlZChcImhpc3RvZ3JhbUNvbnRhaW5lclwiLCB0cnVlKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBkID0+IFwiTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0LWhpc3RvZ3JhbUNvbnRhaW5lci1cIiArIGQpXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgY29udGFpbmVyID0gdGhpcyBhcyBIVE1MRGl2RWxlbWVudDtcblx0XHRcdFx0Y29uc3QgY2FuQnJ1c2ggPSB0cnVlO1xuXHRcdFx0XHRsZXQgbmV3V2lkZ2V0ID0gbmV3IEhpc3RvZ3JhbVdpZGdldChjb250YWluZXIsIGQsIGNhbkJydXNoLCB0aGlzV2lkZ2V0LmluY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uKTtcblx0XHRcdFx0dGhpc1dpZGdldC5oaXN0b2dyYW1XaWRnZXRzLnB1c2gobmV3V2lkZ2V0KTtcblx0XHRcdH0pO1xuXHRcdHRoaXMudXBkYXRlSGlzdG9ncmFtcygpO1xuXHR9XG5cblx0XG5cdHByaXZhdGUgdXBkYXRlSGlzdG9ncmFtcygpOiB2b2lkXG5cdHtcblx0XHRsZXQgdGhpc1dpZGdldCA9IHRoaXM7XG5cdFx0bGV0IGFsbEhpZGRlbiA9IHRydWU7XG5cdFx0dGhpcy5kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uXG5cdFx0XHQuc2VsZWN0QWxsKFwiLmhpc3RvZ3JhbUNvbnRhaW5lclwiKVxuXHRcdFx0LmRhdGEodGhpcy5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdClcblx0XHRcdC5jbGFzc2VkKFwibm9EaXNwXCIsIChkLCBpKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0bGV0IHNob3VsZEhpZGUgPSB0aGlzLnNob3VsZEhpZGUoaSk7XG5cdFx0XHRcdGlmICghc2hvdWxkSGlkZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbEhpZGRlbiA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzaG91bGRIaWRlO1xuXHRcdFx0fSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBjb250YWluZXIgPSB0aGlzIGFzIEhUTUxEaXZFbGVtZW50O1xuXHRcdFx0XHRsZXQgaGlzdG9ncmFtV2lkZ2V0ID0gdGhpc1dpZGdldC5oaXN0b2dyYW1XaWRnZXRzW2ldO1xuXHRcdFx0XHRpZiAoIXRoaXNXaWRnZXQuc2hvdWxkSGlkZShpKSAmJiAhaGlzdG9ncmFtV2lkZ2V0LmRhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRoaXN0b2dyYW1XaWRnZXQuU2V0RGF0YSh0aGlzV2lkZ2V0LnBvaW50Q29sbGVjdGlvbilcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRsZXQgcGFyZW50RWxlbWVudCA9IHRoaXMuZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbi5ub2RlKCkucGFyZW50RWxlbWVudDtcblx0XHRpZiAoYWxsSGlkZGVuKVxuXHRcdHtcblx0XHRcdHBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm5vRGlzcFwiKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm5vRGlzcFwiKTtcblx0XHR9XG5cdH1cblxuXG5cblx0cHJpdmF0ZSBnZXRTY2F0dGVyT3B0aW9uc01hdHJpeCgpOiBib29sV2l0aEluZGV4W11cblx0e1xuXHRcdGxldCBmbGF0RGF0YSA9IHRoaXMuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucy5mbGF0KCk7XG5cdFx0ZmxhdERhdGEgPSBmbGF0RGF0YS5maWx0ZXIoZCA9PiBkLmluZGV4WzBdICE9PSBkLmluZGV4WzFdKTtcblx0XHRyZXR1cm4gZmxhdERhdGE7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdTY2F0dGVyUGxvdHMoZmxhdERhdGE6IGJvb2xXaXRoSW5kZXhbXSk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3NjYXR0ZXJQbG90V2lkZ2V0cyA9IFtdO1xuXHRcdGxldCB0aGlzV2lkZ2V0ID0gdGhpcztcblxuXHRcdGxldCBwYXJlbnRFbGVtZW50ID0gdGhpcy5zY2F0dGVyUGxvdENvbnRhaW5lclNlbGVjdGlvbi5ub2RlKCkucGFyZW50RWxlbWVudDtcblx0XHRwYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJub0Rpc3BcIik7XG5cblx0XHR0aGlzLnNjYXR0ZXJQbG90Q29udGFpbmVyU2VsZWN0aW9uLmh0bWwobnVsbClcblx0XHRcdC5zZWxlY3RBbGwoXCJkaXZcIilcblx0XHRcdC5kYXRhKGZsYXREYXRhKVxuXHRcdFx0LmpvaW4oXCJkaXZcIilcblx0XHRcdC5jbGFzc2VkKFwic2NhdHRlclBsb3RDb250YWluZXJcIiwgdHJ1ZSlcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBjb250YWluZXIgPSB0aGlzIGFzIEhUTUxEaXZFbGVtZW50O1xuXHRcdFx0XHRsZXQgeEtleSA9IHRoaXNXaWRnZXQucG9pbnRDb2xsZWN0aW9uLmF0dHJpYnV0ZUxpc3RbZC5pbmRleFsxXV07XG5cdFx0XHRcdGxldCB5S2V5ID0gdGhpc1dpZGdldC5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdFtkLmluZGV4WzBdXTtcblx0XHRcdFx0bGV0IG5ld1dpZGdldCA9IG5ldyBTY2F0dGVyUGxvdFdpZGdldChjb250YWluZXIsIHhLZXksIHlLZXkpO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LnNjYXR0ZXJQbG90V2lkZ2V0cy5wdXNoKG5ld1dpZGdldCk7XG5cdFx0XHR9KTtcblx0XHR0aGlzLnVwZGF0ZVNjYXR0ZXJQbG90cyhmbGF0RGF0YSk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVNjYXR0ZXJQbG90cyhmbGF0RGF0YTogYm9vbFdpdGhJbmRleFtdKTogdm9pZFxuXHR7XG5cdFx0bGV0IHRoaXNXaWRnZXQgPSB0aGlzO1xuXG5cdFx0bGV0IGFsbEhpZGRlbiA9IHRydWU7XG5cblx0XHR0aGlzLnNjYXR0ZXJQbG90Q29udGFpbmVyU2VsZWN0aW9uXG5cdFx0XHQuc2VsZWN0QWxsKFwiLnNjYXR0ZXJQbG90Q29udGFpbmVyXCIpXG5cdFx0XHQuZGF0YShmbGF0RGF0YSlcblx0XHRcdC5jbGFzc2VkKFwibm9EaXNwXCIsIChkKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgc2hvdWxkSGlkZSA9IHRoaXMuc2hvdWxkSGlkZShkKTtcblx0XHRcdFx0aWYgKCFzaG91bGRIaWRlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YWxsSGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNob3VsZEhpZGU7XG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IHNjYXR0ZXJXaWRnZXQgPSB0aGlzV2lkZ2V0LnNjYXR0ZXJQbG90V2lkZ2V0c1tpXTtcblx0XHRcdFx0aWYgKCF0aGlzV2lkZ2V0LnNob3VsZEhpZGUoZCkgJiYgIXNjYXR0ZXJXaWRnZXQuZGF0YSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHNjYXR0ZXJXaWRnZXQuU2V0RGF0YSh0aGlzV2lkZ2V0LnBvaW50Q29sbGVjdGlvbilcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0bGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLnNjYXR0ZXJQbG90Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5wYXJlbnRFbGVtZW50O1xuXHRcdGlmIChhbGxIaWRkZW4pXG5cdFx0e1xuXHRcdFx0cGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibm9EaXNwXCIpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0cGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibm9EaXNwXCIpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc2hvdWxkSGlkZShkOiBib29sV2l0aEluZGV4IHwgbnVtYmVyKTogYm9vbGVhblxuXHR7XG5cdFx0aWYgKHR5cGVvZiBkID09PSBcIm51bWJlclwiKVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2RdKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhdGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zW2RdW2RdLnZhbHVlO1xuXG5cdFx0fVxuXHRcdGlmICghdGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2QuaW5kZXhbMF1dIHx8ICF0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbZC5pbmRleFsxXV0pXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAhZC52YWx1ZTtcblx0fVxuXG5cdHByb3RlY3RlZCBPblJlc2l6ZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnJlc2l6ZVN1YkNvbXBvbmVudHMoKTtcblx0fVxuXG5cdHByaXZhdGUgcmVzaXplU3ViQ29tcG9uZW50cygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmJhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIlxuXHRcdHRoaXMuc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1heEhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiXG5cdFx0dGhpcy5kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIlxuXHRcdHRoaXMuc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1heEhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiXG5cdH1cblxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IEJ1dHRvblByb3BzLCBIdG1sU2VsZWN0aW9uIH0gZnJvbSAnLi4vZGV2bGliL0RldkxpYlR5cGVzJztcblxuZW51bSBPcHRpb25Nb2RlIHtcblx0QnV0dG9uTGlzdCxcblx0RHJvcGRvd25cbn1cblxuZXhwb3J0IGNsYXNzIE9wdGlvblNlbGVjdCB7XG5cdFxuXHRjb25zdHJ1Y3RvcihodG1sQ29udGFpbmVySWQ6IHN0cmluZywgbGFiZWw/OiBzdHJpbmcsIGRlZmF1bHRTZWxlY3Rpb25JbmRleD86IG51bWJlcilcblx0e1xuXHRcdHRoaXMuX2NvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdChcIiNcIiArIGh0bWxDb250YWluZXJJZCk7XG5cdFx0dGhpcy5fbGFiZWwgPSBsYWJlbDtcblx0XHR0aGlzLl91bmlxdWVJZCA9ICdPcHRpb25TZWxlY3REcm9wZG93bl8nICsgT3B0aW9uU2VsZWN0Ll9pbnN0YW5jZUNvdW50Kys7XG5cdFx0dGhpcy5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gbnVsbDtcblx0XHRpZiAodHlwZW9mIGRlZmF1bHRTZWxlY3Rpb25JbmRleCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gZGVmYXVsdFNlbGVjdGlvbkluZGV4O1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgX2RhdGEgOiBCdXR0b25Qcm9wc1tdO1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IEJ1dHRvblByb3BzW10ge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29udGFpbmVyU2VsZWN0IDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBjb250YWluZXJTZWxlY3QoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXJTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9sYWJlbCA6IHN0cmluZztcblx0cHVibGljIGdldCBsYWJlbCgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWw7XG5cdH1cblxuXHRwcml2YXRlIF9tb2RlIDogT3B0aW9uTW9kZTtcblx0cHVibGljIGdldCBtb2RlKCkgOiBPcHRpb25Nb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5fbW9kZTtcblx0fVxuXG5cdHByaXZhdGUgX3VuaXF1ZUlkIDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHVuaXF1ZUlkKCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl91bmlxdWVJZDtcblx0fVxuXG5cdFxuXHRwcml2YXRlIF9jdXJyZW50U2VsZWN0aW9uSW5kZXggOiBudW1iZXIgfCBudWxsO1xuXHRwdWJsaWMgZ2V0IGN1cnJlbnRTZWxlY3Rpb25JbmRleCgpIDogbnVtYmVyIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRTZWxlY3Rpb25JbmRleDtcblx0fVxuXHRcblx0cHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlQ291bnQ6IG51bWJlciA9IDA7XG5cblx0cHJpdmF0ZSBjbGVhclNlbGVjdGVkQnV0dG9uKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuY29udGFpbmVyU2VsZWN0LnNlbGVjdEFsbChcIi5vblwiKVxuXHRcdFx0LmNsYXNzZWQoXCJvblwiLCBmYWxzZSk7XG5cdH1cblxuXHRwdWJsaWMgb25EYXRhQ2hhbmdlKGRhdGE6IEJ1dHRvblByb3BzW10sIGRlZmF1bHRTZWxlY3Rpb24/OiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0XHRjb25zb2xlLmxvZyhkYXRhKTtcblx0XHR0aGlzLmNvbnRhaW5lclNlbGVjdC5odG1sKG51bGwpO1xuXG5cdFx0aWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDEpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMubGFiZWwpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyU2VsZWN0XG5cdFx0XHRcdFx0LmFwcGVuZCgnc3BhbicpXG5cdFx0XHRcdFx0LmNsYXNzZWQoJ29wdGlvblNlbGVjdExhYmVsJywgdHJ1ZSlcblx0XHRcdFx0XHQudGV4dCh0aGlzLmxhYmVsKTtcblx0XHRcdH1cblx0XG5cblx0XHRcdHRoaXMuY29udGFpbmVyU2VsZWN0XG5cdFx0XHRcdC5hcHBlbmQoXCJzcGFuXCIpXG5cdFx0XHRcdC5jbGFzc2VkKFwidmFsdWVIZWFkZXJcIiwgdHJ1ZSlcblx0XHRcdFx0LnRleHQodGhpcy5kYXRhWzBdLmRpc3BsYXlOYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZUJ1dHRvbnMoZGVmYXVsdFNlbGVjdGlvbik7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUJ1dHRvbnMoZGVmYXVsdFNlbGVjdGlvbj86IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdGlmICh0eXBlb2YgZGVmYXVsdFNlbGVjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gZGVmYXVsdFNlbGVjdGlvbjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kYXRhLmxlbmd0aCA8IDQpXG5cdFx0e1xuXHRcdFx0dGhpcy5kcmF3UXVpY2tTZWxlY3RCdXR0b25zKHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4KTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuZHJhd0Ryb3BEb3duQnV0dG9ucyh0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBkcmF3UXVpY2tTZWxlY3RCdXR0b25zKGRlZmF1bHRTZWxlY3Rpb24/OiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tb2RlID0gT3B0aW9uTW9kZS5CdXR0b25MaXN0O1xuXHRcdGxldCB0aGlzT3B0aW9uU2VsZWN0OiBPcHRpb25TZWxlY3QgPSB0aGlzO1xuXHRcdHRoaXMuY29udGFpbmVyU2VsZWN0Lmh0bWwobnVsbCk7XG5cblx0XHRpZiAodGhpcy5sYWJlbClcblx0XHR7XG5cdFx0XHR0aGlzLmNvbnRhaW5lclNlbGVjdFxuXHRcdFx0XHQuYXBwZW5kKCdzcGFuJylcblx0XHRcdFx0LmNsYXNzZWQoJ29wdGlvblNlbGVjdExhYmVsJywgdHJ1ZSlcblx0XHRcdFx0LnRleHQodGhpcy5sYWJlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb250YWluZXJTZWxlY3Rcblx0XHRcdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdC5kYXRhKHRoaXMuZGF0YSlcblx0XHRcdC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0XHQudGV4dChkID0+IGQuZGlzcGxheU5hbWUpXG5cdFx0XHQuY2xhc3NlZChcInRvZ2dsZUJ1dHRvblwiLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoXCJvblwiLCAoZCwgaSkgPT4gZGVmYXVsdFNlbGVjdGlvbiA9PT0gaSlcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGJ1dHRvblByb3BzOiBCdXR0b25Qcm9wcywgaW5kZXg6IG51bWJlcilcblx0XHRcdHtcblx0XHRcdFx0aWYgKCh0aGlzIGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoXCJvblwiKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzT3B0aW9uU2VsZWN0Ll9jdXJyZW50U2VsZWN0aW9uSW5kZXggPSBpbmRleDtcblx0XHRcdFx0dGhpc09wdGlvblNlbGVjdC5jbGVhclNlbGVjdGVkQnV0dG9uKCk7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwib25cIiwgdHJ1ZSk7XG5cdFx0XHRcdGJ1dHRvblByb3BzLmNhbGxiYWNrKCk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0Ryb3BEb3duQnV0dG9ucyhkZWZhdWx0U2VsZWN0aW9uPzogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fbW9kZSA9IE9wdGlvbk1vZGUuRHJvcGRvd247XG5cdFx0bGV0IHRoaXNPcHRpb25TZWxlY3Q6IE9wdGlvblNlbGVjdCA9IHRoaXM7XG5cdFx0dGhpcy5jb250YWluZXJTZWxlY3QuaHRtbChudWxsKTtcblxuXHRcdGlmICh0aGlzLmxhYmVsKVxuXHRcdHtcblx0XHRcdHRoaXMuY29udGFpbmVyU2VsZWN0LmFwcGVuZCgnbGFiZWwnKVxuXHRcdFx0XHQudGV4dCh0aGlzLmxhYmVsKVxuXHRcdFx0XHQuY2xhc3NlZCgnb3B0aW9uU2VsZWN0TGFiZWwnLCB0cnVlKVxuXHRcdFx0XHQuYXR0cignZm9yJywgdGhpcy51bmlxdWVJZCk7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuY29udGFpbmVyU2VsZWN0XG5cdFx0XHQuYXBwZW5kKCdzZWxlY3QnKVxuXHRcdFx0LmF0dHIoJ2lkJywgdGhpcy51bmlxdWVJZCkgXG5cdFx0XHQuY2xhc3NlZCgnb3B0aW9uU2VsZWN0U2VsZWN0JywgdHJ1ZSlcblx0XHRcdC5vbignY2hhbmdlJywgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0bGV0IG9wdGlvblNlbGVjdCA9IHRoaXMuY29udGFpbmVyU2VsZWN0LnNlbGVjdCgnIycgKyB0aGlzLnVuaXF1ZUlkKVxuXHRcdFx0XHRsZXQgbmV3SW5kZXg6IG51bWJlciA9ICtvcHRpb25TZWxlY3QucHJvcGVydHkoJ3ZhbHVlJyk7XG5cdFx0XHRcdHRoaXMuZGF0YVtuZXdJbmRleF0uY2FsbGJhY2soKTtcblx0XHRcdFx0dGhpc09wdGlvblNlbGVjdC5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gbmV3SW5kZXg7XG5cdFx0XHR9KVxuXHRcdFx0LnNlbGVjdEFsbCgnb3B0aW9uJylcblx0XHRcdC5kYXRhKHRoaXMuZGF0YSlcblx0XHRcdC5qb2luKCdvcHRpb24nKVxuXHRcdFx0LmF0dHIoJ3ZhbHVlJywgKGQsIGkpID0+IGkpXG5cdFx0XHQucHJvcGVydHkoJ3NlbGVjdGVkJywgKGQsIGkpID0+IGRlZmF1bHRTZWxlY3Rpb24gPT09IGkpXG5cdFx0XHQudGV4dChkID0+IGQuZGlzcGxheU5hbWUpO1xuXHR9XG5cdFxuXHRwdWJsaWMgYWRkQnV0dG9uKGJ1dHRvblByb3BzOiBCdXR0b25Qcm9wcywgc2VsZWN0SW5kZXg/OiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmRhdGEucHVzaChidXR0b25Qcm9wcyk7XG5cdFx0dGhpcy51cGRhdGVCdXR0b25zKHNlbGVjdEluZGV4KTtcblx0fVxuXG5cdHB1YmxpYyByZW1vdmVCdXR0b24oZGlzcGxheU5hbWU6IHN0cmluZywgY2FsbERlZmF1bHRDYWxsYmFjayA9IHRydWUpOiB2b2lkXG5cdHtcblx0XHRpZiAoIXRoaXMuZGF0YSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCByZW1vdmVJbmRleCA9IHRoaXMuZGF0YS5maW5kSW5kZXgoKGJ1dHRvbjogQnV0dG9uUHJvcHMpID0+IGJ1dHRvbi5kaXNwbGF5TmFtZSA9PT0gZGlzcGxheU5hbWUpO1xuXHRcdGlmIChyZW1vdmVJbmRleCA9PT0gLTEpXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmRhdGEuc3BsaWNlKHJlbW92ZUluZGV4KTtcblx0XHRsZXQgc2VsZWN0aW9uSW5kZXg6IG51bWJlcjtcblx0XHRpZiAoY2FsbERlZmF1bHRDYWxsYmFjayAmJiB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleCA9PT0gcmVtb3ZlSW5kZXgpXG5cdFx0e1xuXHRcdFx0c2VsZWN0aW9uSW5kZXggPSAwO1xuXHRcdFx0dGhpcy5kYXRhWzBdLmNhbGxiYWNrKCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRzZWxlY3Rpb25JbmRleCA9IHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4O1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUJ1dHRvbnMoc2VsZWN0aW9uSW5kZXgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHB1YmxpYyByZXBsYWNlQnV0dG9uKG9sZEJ1dHRvbk5hbWU6IHN0cmluZywgbmV3QnV0dG9uUHJvcHM6IEJ1dHRvblByb3BzKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5yZW1vdmVCdXR0b24ob2xkQnV0dG9uTmFtZSwgZmFsc2UpO1xuXHRcdHRoaXMuYWRkQnV0dG9uKG5ld0J1dHRvblByb3BzLCB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleCk7XG5cdFx0aWYgKHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4ID09PSB0aGlzLmRhdGEubGVuZ3RoIC0gMSlcblx0XHR7XG5cdFx0XHR0aGlzLmRhdGFbdGhpcy5jdXJyZW50U2VsZWN0aW9uSW5kZXhdLmNhbGxiYWNrKCk7XG5cdFx0fVxuXHR9XG5cdFxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7QmFzZVdpZGdldH0gZnJvbSAnLi9CYXNlV2lkZ2V0JztcbmltcG9ydCB7Q3VydmVMaXN0fSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVMaXN0JztcbmltcG9ydCB7UG9pbnRORH0gZnJvbSAnLi4vRGF0YU1vZGVsL1BvaW50TkQnO1xuaW1wb3J0IHtTdmdTZWxlY3Rpb24sIEh0bWxTZWxlY3Rpb24sIEJ1dHRvblByb3BzfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHsgdmFsdWVGaWx0ZXIgfSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IE9wdGlvblNlbGVjdCB9IGZyb20gJy4vT3B0aW9uU2VsZWN0JztcbmltcG9ydCB7IERhdGFzZXRTcGVjIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyB9IGZyb20gJ2QzJztcblxuaW50ZXJmYWNlIHF1aWNrUGlja09wdGlvbiB7XG5cdHhLZXk6IHN0cmluZyxcblx0eUtleTogc3RyaW5nLFxuXHRzcXVhcmVBc3BlY3RSYXRpbzogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgUGxvdDJkUGF0aHNXaWRnZXQgZXh0ZW5kcyBCYXNlV2lkZ2V0PEN1cnZlTGlzdCwgRGF0YXNldFNwZWM+IHtcblx0XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogRWxlbWVudCwgcXVpY2tQaWNrT3B0aW9uczogcXVpY2tQaWNrT3B0aW9uW10sIGluaXRpYWxRdWlja1BpY2tPcHRpb25JbmRleDogbnVtYmVyID0gMCwgc3F1YXJlQXNwZWN0UmF0aW86IGJvb2xlYW4gPSB0cnVlLCBjYW5CcnVzaDogYm9vbGVhbiA9IHRydWUpXG5cdHtcblx0XHRzdXBlcihjb250YWluZXIsIHRydWUsIHF1aWNrUGlja09wdGlvbnMsIGluaXRpYWxRdWlja1BpY2tPcHRpb25JbmRleCwgY2FuQnJ1c2gpO1xuXHRcdHRoaXMuX3NxdWFyZUFzcGVjdFJhdGlvID0gc3F1YXJlQXNwZWN0UmF0aW87XG5cdFx0dGhpcy5hZGRMYWJlbCgpO1xuXHR9XG5cdFxuXHRwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz5cbiAgICB7XG5cdFx0Y29uc3QgY2FuQnJ1c2ggPSBmYWxzZTtcblx0XHRyZXR1cm4gbmV3IFBsb3QyZFBhdGhzV2lkZ2V0KGNvbnRhaW5lciwgdGhpcy5xdWlja1BpY2tPcHRpb25zLCB0aGlzLnF1aWNrUGlja09wdGlvblNlbGVjdC5jdXJyZW50U2VsZWN0aW9uSW5kZXgsIHRoaXMuc3F1YXJlQXNwZWN0UmF0aW8sIGNhbkJydXNoKTtcblx0fVxuXG5cdHByb3RlY3RlZCBpbml0UHJvcHMocHJvcHM/OiBhbnlbXSk6IHZvaWRcblx0e1xuXHRcdHN1cGVyLmluaXRQcm9wcygpO1xuXHRcdHRoaXMuX3F1aWNrUGlja09wdGlvbnMgPSBwcm9wc1swXTtcblx0XHR0aGlzLl9pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXggPSBwcm9wc1sxXTtcblx0XHR0aGlzLl9jYW5CcnVzaCA9IHByb3BzWzJdO1xuXHRcdHRoaXMuX3hLZXkgPSB0aGlzLnF1aWNrUGlja09wdGlvbnNbdGhpcy5pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXhdLnhLZXk7XG5cdFx0dGhpcy5feUtleSA9IHRoaXMucXVpY2tQaWNrT3B0aW9uc1t0aGlzLmluaXRpYWxRdWlja1BpY2tPcHRpb25JbmRleF0ueUtleTtcblx0fVxuXG5cdHByaXZhdGUgX3N2Z1NlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBzdmdTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N2Z1NlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX21haW5Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBtYWluR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX21haW5Hcm91cFNlbGVjdDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfY2FudmFzQ29udGFpbmVyIDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGNhbnZhc0NvbnRhaW5lcigpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzQ29udGFpbmVyO1xuXHR9XHRcblxuXHRwcml2YXRlIF9jYW52YXNFbGVtZW50IDogSFRNTENhbnZhc0VsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY2FudmFzRWxlbWVudCgpIDogSFRNTENhbnZhc0VsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXNFbGVtZW50O1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FuQnJ1c2ggOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGNhbkJydXNoKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FuQnJ1c2g7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaEdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGJydXNoR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF94QXhpc0dyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHhBeGlzR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3hBeGlzR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF94TGFiZWxUZXh0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHhMYWJlbFRleHRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3hMYWJlbFRleHRTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF95QXhpc0dyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHlBeGlzR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lBeGlzR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF95TGFiZWxUZXh0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHlMYWJlbFRleHRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lMYWJlbFRleHRTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9xdWlja1BpY2tDb250YWluZXJTZWxlY3QgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHF1aWNrUGlja0NvbnRhaW5lclNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3F1aWNrUGlja0NvbnRhaW5lclNlbGVjdDtcblx0fVxuXHRwdWJsaWMgc2V0IHF1aWNrUGlja0NvbnRhaW5lclNlbGVjdCh2IDogSHRtbFNlbGVjdGlvbikge1xuXHRcdHRoaXMuX3F1aWNrUGlja0NvbnRhaW5lclNlbGVjdCA9IHY7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVggOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVYKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVg7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVZKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVk7XG5cdH1cblxuXHRwcml2YXRlIF94S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHhLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3hLZXk7XG5cdH1cblxuXHRwcml2YXRlIF95S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHlLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3lLZXk7XG5cdH1cblxuXHRwcml2YXRlIF9xdWlja1BpY2tPcHRpb25zIDogcXVpY2tQaWNrT3B0aW9uW107XG5cdHB1YmxpYyBnZXQgcXVpY2tQaWNrT3B0aW9ucygpIDogcXVpY2tQaWNrT3B0aW9uW10ge1xuXHRcdHJldHVybiB0aGlzLl9xdWlja1BpY2tPcHRpb25zO1xuXHR9XHRcblxuXHRwcml2YXRlIF9pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgaW5pdGlhbFF1aWNrUGlja09wdGlvbkluZGV4KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXg7XG5cdH1cblx0XG5cdHByaXZhdGUgX3F1aWNrUGlja09wdGlvblNlbGVjdCA6IE9wdGlvblNlbGVjdDtcblx0cHVibGljIGdldCBxdWlja1BpY2tPcHRpb25TZWxlY3QoKSA6IE9wdGlvblNlbGVjdCB7XG5cdFx0cmV0dXJuIHRoaXMuX3F1aWNrUGlja09wdGlvblNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3NxdWFyZUFzcGVjdFJhdGlvIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBzcXVhcmVBc3BlY3RSYXRpbygpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NxdWFyZUFzcGVjdFJhdGlvO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2ggOiBkMy5CcnVzaEJlaGF2aW9yPGFueT47XG5cdHB1YmxpYyBnZXQgYnJ1c2goKSA6IGQzLkJydXNoQmVoYXZpb3I8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9sYXN0WFZhbHVlQnJ1c2hCb3VuZCA6IFtudW1iZXIsIG51bWJlcl07XG5cdHB1YmxpYyBnZXQgbGFzdFhWYWx1ZUJydXNoQm91bmQoKSA6IFtudW1iZXIsIG51bWJlcl0ge1xuXHRcdHJldHVybiB0aGlzLl9sYXN0WFZhbHVlQnJ1c2hCb3VuZDtcblx0fVxuXG5cdHByaXZhdGUgX2xhc3RZVmFsdWVCcnVzaEJvdW5kIDogW251bWJlciwgbnVtYmVyXTtcblx0cHVibGljIGdldCBsYXN0WVZhbHVlQnJ1c2hCb3VuZCgpIDogW251bWJlciwgbnVtYmVyXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhc3RZVmFsdWVCcnVzaEJvdW5kO1xuXHR9XG5cdFxuXG5cdHByb3RlY3RlZCBzZXRNYXJnaW4oKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fbWFyZ2luID0ge1xuXHRcdFx0dG9wOiAyMCxcblx0XHRcdHJpZ2h0OiA4LFxuXHRcdFx0Ym90dG9tOiA0Mixcblx0XHRcdGxlZnQ6IDY0XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIGluaXQoKTogdm9pZFxuXHR7XG5cdFx0Y29uc3QgY29udGFpbmVyU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMuY29udGFpbmVyKTtcblx0XHRjb250YWluZXJTZWxlY3Rcblx0XHRcdC5vbignbW91c2VlbnRlcicsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmRhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnNob3dRdWlja1BpY2tDb250YWluZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VsZWF2ZScsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuaGlkZVF1aWNrUGlja0NvbnRhaW5lcigpO1xuXHRcdFx0fSlcblx0XHR0aGlzLl9zdmdTZWxlY3QgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKFwic3ZnXCIpXG5cdFx0dGhpcy5fbWFpbkdyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApO1xuXG5cdFx0dGhpcy5fY2FudmFzQ29udGFpbmVyID0gdGhpcy5tYWluR3JvdXBTZWxlY3Rcblx0XHRcdC5hcHBlbmQoJ2ZvcmVpZ25PYmplY3QnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQpO1xuXG5cdFx0dGhpcy5fY2FudmFzRWxlbWVudCA9IHRoaXMuY2FudmFzQ29udGFpbmVyLmFwcGVuZCgneGh0bWw6Y2FudmFzJylcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgdGhpcy52aXpXaWR0aClcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHRoaXMudml6SGVpZ2h0KVxuXHRcdFx0Lm5vZGUoKSBhcyBIVE1MQ2FudmFzRWxlbWVudDtcblxuXHRcdGlmICh0aGlzLmNhbkJydXNoKVxuXHRcdHtcblx0XHRcdHRoaXMuX2JydXNoR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoXCJnXCIpXG5cdFx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuXHRcdFx0XHQuY2xhc3NlZChcImJydXNoQ29udGFpbmVyXCIsIHRydWUpO1xuXHRcdFx0dGhpcy5pbml0QnJ1c2goKTtcblx0XHR9XG5cblx0XHQvLyB0aGlzLnN2Z1NlbGVjdC5hdHRyKFwic3R5bGVcIiwgJ3dpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7Jyk7XG5cdFx0dGhpcy5zdmdTZWxlY3QuYXR0cignd2lkdGgnLCB0aGlzLndpZHRoKTtcblx0XHR0aGlzLnN2Z1NlbGVjdC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG5cblx0XHR0aGlzLl94QXhpc0dyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCdnJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHR9KWApXG5cdFx0XHQuY2xhc3NlZChcImxhYmVsQ29sb3JcIiwgdHJ1ZSk7XG5cblx0XHR0aGlzLl95QXhpc0dyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCdnJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuXHRcdFx0LmNsYXNzZWQoXCJsYWJlbENvbG9yXCIsIHRydWUpO1xuXG5cdFx0dGhpcy5pbml0UXVpY2tQaWNrT3B0aW9ucygpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0UXVpY2tQaWNrT3B0aW9ucygpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBjb250YWluZXJJZCA9IHRoaXMuQ29tcG9uZW50SWQgKyAnLXF1aWNrUGlja0NvbnRhaW5lcic7XG5cdFx0dGhpcy5fcXVpY2tQaWNrQ29udGFpbmVyU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMuY29udGFpbmVyKS5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgncXVpY2tQaWNrQ29udGFpbmVyJywgdHJ1ZSlcblx0XHRcdC5hdHRyKCdpZCcsIGNvbnRhaW5lcklkKTtcblxuXHRcdHRoaXMuX3F1aWNrUGlja09wdGlvblNlbGVjdCA9IG5ldyBPcHRpb25TZWxlY3QoY29udGFpbmVySWQsIFwiT3B0aW9uXCIpO1xuXHRcdGxldCBidXR0b25Qcm9wTGlzdDogQnV0dG9uUHJvcHNbXSA9IFtdO1xuXHRcdGZvciAobGV0IHF1aWNrUGlja09wdGlvbiBvZiB0aGlzLnF1aWNrUGlja09wdGlvbnMpXG5cdFx0e1xuXHRcdFx0bGV0IGJ1dHRvblByb3A6IEJ1dHRvblByb3BzID0ge1xuXHRcdFx0XHRkaXNwbGF5TmFtZTogcXVpY2tQaWNrT3B0aW9uLnlLZXkgKyBcIiB2LiBcIiArIHF1aWNrUGlja09wdGlvbi54S2V5LFxuXHRcdFx0XHRjYWxsYmFjazogKCkgPT4gdGhpcy5jaGFuZ2VBeGVzKHF1aWNrUGlja09wdGlvbi54S2V5LCBxdWlja1BpY2tPcHRpb24ueUtleSwgcXVpY2tQaWNrT3B0aW9uLnNxdWFyZUFzcGVjdFJhdGlvKVxuXHRcdFx0fVxuXHRcdFx0YnV0dG9uUHJvcExpc3QucHVzaChidXR0b25Qcm9wKTtcblx0XHR9XG5cdFx0dGhpcy5oaWRlUXVpY2tQaWNrQ29udGFpbmVyKCk7XG5cdFx0dGhpcy5xdWlja1BpY2tPcHRpb25TZWxlY3Qub25EYXRhQ2hhbmdlKGJ1dHRvblByb3BMaXN0LCB0aGlzLmluaXRpYWxRdWlja1BpY2tPcHRpb25JbmRleCk7XG5cdH1cblxuXHRwcml2YXRlIGluaXRCcnVzaCgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9icnVzaCA9IGQzLmJydXNoKClcblx0XHQuZXh0ZW50KFtbMCwgMF0sIFt0aGlzLnZpeldpZHRoLCB0aGlzLnZpekhlaWdodF1dKVxuXHRcdC5vbihcImVuZFwiLCAoKSA9PiB7IHRoaXMuYnJ1c2hIYW5kbGVyKCkgfSk7XG5cblx0XHR0aGlzLmJydXNoR3JvdXBTZWxlY3QuY2FsbCh0aGlzLmJydXNoKTtcblx0fVxuXG5cdHByaXZhdGUgYWRkTGFiZWwoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5feExhYmVsVGV4dFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgndGV4dCcpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKTtcblxuXHRcdHRoaXMuX3lMYWJlbFRleHRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmNsYXNzZWQoJ2F4aXNMYWJlbCcsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnbGFiZWxDb2xvcicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG5cblx0XHR0aGlzLnBvc2l0aW9uTGFiZWxzKCk7XG5cdH1cblxuXHRwcml2YXRlIHBvc2l0aW9uTGFiZWxzKCk6IHZvaWRcblx0e1xuXHRcdC8vIFgtQXhpc1xuXHRcdGxldCBidWZmZXJGb3JBeGlzID0gMzI7XG5cdFx0dGhpcy54TGFiZWxUZXh0U2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnQgKyB0aGlzLnZpeldpZHRoIC8gMn0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgKyBidWZmZXJGb3JBeGlzfSlgKTtcblxuXHRcdGJ1ZmZlckZvckF4aXMgPSA0MDtcblx0XHQvLyBZLUF4aXNcblx0XHRsZXQgdHJhbnNYID0gdGhpcy5tYXJnaW4ubGVmdCAtIGJ1ZmZlckZvckF4aXM7XG5cdFx0bGV0IHRyYW5zWSA9IHRoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0IC8gMjtcblx0XHRsZXQgdHJhbnNmb3JtVGV4dDogc3RyaW5nO1xuXHRcdHRyYW5zZm9ybVRleHQgPSBgcm90YXRlKC05MCkgdHJhbnNsYXRlKCR7LXRyYW5zWX0sICR7dHJhbnNYfSlgO1xuXHRcdHRoaXMueUxhYmVsVGV4dFNlbGVjdC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1UZXh0KTtcblx0fVxuXG5cdHByaXZhdGUgc2hvd1F1aWNrUGlja0NvbnRhaW5lcigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnF1aWNrUGlja0NvbnRhaW5lclNlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG5cdH1cblxuXHRwcml2YXRlIGhpZGVRdWlja1BpY2tDb250YWluZXIoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5xdWlja1BpY2tDb250YWluZXJTZWxlY3QuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG5cdH1cblxuXHRwdWJsaWMgT25EYXRhQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMudXBkYXRlU2NhbGVzKCk7XG5cdFx0dGhpcy51cGRhdGVQYXRocygpO1xuXHRcdHRoaXMuZHJhd0F4aXMoKTtcbiAgICAgICAgdGhpcy5zaG93TGFiZWwoKTtcblx0fVxuXG5cdHByaXZhdGUgY2hhbmdlQXhlcyh4S2V5OiBzdHJpbmcsIHlLZXk6IHN0cmluZywgc3F1YXJlQXNwZWN0UmF0aW86IGJvb2xlYW4pOiB2b2lkXG5cdHtcblx0XHR0aGlzLl94S2V5ID0geEtleTtcblx0XHR0aGlzLl95S2V5ID0geUtleTtcblx0XHR0aGlzLl9zcXVhcmVBc3BlY3RSYXRpbyA9IHNxdWFyZUFzcGVjdFJhdGlvO1xuXHRcdHRoaXMucmVtb3ZlQnJ1c2goKTtcblx0XHR0aGlzLk9uRGF0YUNoYW5nZSgpO1xuXHR9XG5cdFxuXHRwcml2YXRlIHJlbW92ZUJydXNoKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuYnJ1c2hHcm91cFNlbGVjdC5jYWxsKHRoaXMuYnJ1c2gubW92ZSwgbnVsbCk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVNjYWxlcygpOiB2b2lkXG5cdHtcblx0XHRsZXQgW21pblgsIG1heFhdID0gdGhpcy5mdWxsRGF0YS5taW5NYXhNYXAuZ2V0KHRoaXMueEtleSk7XG5cdFx0bGV0IFttaW5ZLCBtYXhZXSA9IHRoaXMuZnVsbERhdGEubWluTWF4TWFwLmdldCh0aGlzLnlLZXkpO1xuXHRcdGlmICh0aGlzLnNxdWFyZUFzcGVjdFJhdGlvKVxuXHRcdHtcblx0XHRcdHRoaXMubWFrZVNxdWFyZUFzcGVjdFJhdGlvU2NhbGVzKG1pblgsIG1heFgsIG1pblksIG1heFkpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5tYWtlU3RyZXRjaGVkQXNwZWN0UmF0aW9TY2FsZXMobWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG5cdFx0fVxuXG5cdFxuXHR9XG5cblx0cHJpdmF0ZSBtYWtlU3F1YXJlQXNwZWN0UmF0aW9TY2FsZXMobWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0Ly8gdGhpcyBjb2RlIGtlZXBzIHRoZSBkYXRhIGFzcGVjdCByYXRpbyBzcXVhcmUgYW5kIGtlZXBzIGl0IGNlbnRlcmVkIGFuZCBhcyBsYXJnZVxuXHRcdC8vIGFzIHBvc3NpYmxlIGluIGl0J3MgY29udGFpbmVyXG5cdFx0bGV0IGNvbnRhaW5lclJhdGlvID0gdGhpcy52aXpIZWlnaHQgLyB0aGlzLnZpeldpZHRoO1xuXHRcdGxldCBkYXRhUmF0aW8gPSAobWF4WSAtIG1pblkpIC8gKG1heFggLSBtaW5YKTtcblx0XHRpZiAoY29udGFpbmVyUmF0aW8gPiBkYXRhUmF0aW8pXG5cdFx0e1xuXHRcdFx0dGhpcy5fc2NhbGVYID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0XHQuZG9tYWluKFttaW5YLCBtYXhYXSlcblx0XHRcdFx0LnJhbmdlKFswLCB0aGlzLnZpeldpZHRoXSk7XG5cblx0XHRcdGxldCBbc2NhbGVkTWluWSwgc2NhbGVkTWF4WV0gPSBbdGhpcy5zY2FsZVgobWluWSksIHRoaXMuc2NhbGVYKG1heFkpXTsgXG5cdFx0XHRsZXQgZGF0YUxlbmd0aCA9IHNjYWxlZE1heFkgLSBzY2FsZWRNaW5ZO1xuXHRcdFx0bGV0IG9mZnNldCA9ICh0aGlzLnZpekhlaWdodCAtIGRhdGFMZW5ndGgpIC8gMi4wIC0gc2NhbGVkTWluWTtcblxuXHRcdFx0dGhpcy5fc2NhbGVZID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0XHQuZG9tYWluKFttaW5ZLCBtYXhZXSlcblx0XHRcdFx0LnJhbmdlKFtzY2FsZWRNYXhZICsgb2Zmc2V0LCBzY2FsZWRNaW5ZICsgb2Zmc2V0XSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLl9zY2FsZVkgPSBkMy5zY2FsZUxpbmVhcigpXG5cdFx0XHRcdC5kb21haW4oW21pblksIG1heFldKVxuXHRcdFx0XHQucmFuZ2UoW3RoaXMudml6SGVpZ2h0LCAwXSk7XG5cblxuXHRcdFx0bGV0IFtzY2FsZWRNaW5YLCBzY2FsZWRNYXhYXSA9IFt0aGlzLnNjYWxlWShtaW5YKSwgdGhpcy5zY2FsZVkobWF4WCldOyBcblx0XHRcdGxldCBkYXRhTGVuZ3RoID0gc2NhbGVkTWF4WCAtIHNjYWxlZE1pblg7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gKHRoaXMudml6V2lkdGggLSBkYXRhTGVuZ3RoKSAvIDIuMCAtIHNjYWxlZE1pblg7XG5cblx0XHRcdHRoaXMuX3NjYWxlWCA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdFx0LmRvbWFpbihbbWluWCwgbWF4WF0pXG5cdFx0XHRcdC5yYW5nZShbc2NhbGVkTWF4WCArIG9mZnNldCwgc2NhbGVkTWluWCArIG9mZnNldF0pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgbWFrZVN0cmV0Y2hlZEFzcGVjdFJhdGlvU2NhbGVzKG1pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3NjYWxlWCA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4oW21pblgsIG1heFhdKVxuXHRcdFx0LnJhbmdlKFswLCB0aGlzLnZpeldpZHRoXSk7XG5cblx0XHR0aGlzLl9zY2FsZVkgPSBkMy5zY2FsZUxpbmVhcigpXG5cdFx0XHQuZG9tYWluKFttaW5ZLCBtYXhZXSlcblx0XHRcdC5yYW5nZShbdGhpcy52aXpIZWlnaHQsIDBdKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlUGF0aHMoKTogdm9pZFxuXHR7XG5cdFx0bGV0IGxpbmUgPSBkMy5saW5lPFBvaW50TkQ+KClcblx0XHRcdC54KChkLCBpKSA9PiB7IHJldHVybiB0aGlzLnNjYWxlWChkLmdldCh0aGlzLnhLZXkpKSB9KVxuXHRcdFx0LnkoKGQpID0+IHsgcmV0dXJuIHRoaXMuc2NhbGVZKGQuZ2V0KHRoaXMueUtleSkpIH0pXG5cdFx0XHQuZGVmaW5lZChkID0+IGQuaW5CcnVzaCk7XG5cdFx0XG5cdFx0Y29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsMCwgdGhpcy52aXpXaWR0aCwgdGhpcy52aXpIZWlnaHQpO1xuXHRcdGNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXHRcdGNhbnZhc0NvbnRleHQubGluZVdpZHRoID0gMTtcblx0XHRjYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhID0gMC4yNTtcblx0XHRjYW52YXNDb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcblxuXHRcdGZvciAobGV0IGN1cnZlIG9mIHRoaXMuZGF0YS5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y29uc3QgcGF0aCA9IG5ldyBQYXRoMkQobGluZShjdXJ2ZS5wb2ludExpc3QpKTtcblx0XHRcdGNhbnZhc0NvbnRleHQuc3Ryb2tlKHBhdGgpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgZHJhd0F4aXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy54QXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0fSlgKVxuXHRcdFx0LmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlWCkudGlja3MoNSkpO1xuXG5cdFx0dGhpcy55QXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYClcblx0XHRcdC5jYWxsKGQzLmF4aXNMZWZ0KHRoaXMuc2NhbGVZKS50aWNrcyg1KSk7XG5cdH1cblxuICAgIHByaXZhdGUgc2hvd0xhYmVsKCk6IHZvaWRcbiAgICB7XG5cdFx0dGhpcy54TGFiZWxUZXh0U2VsZWN0XG5cdFx0XHQudGV4dCh0aGlzLnhLZXkpXG5cdFx0XHQuY2xhc3NlZCgnbm9EaXNwJywgZmFsc2UpO1xuXG5cdFx0dGhpcy55TGFiZWxUZXh0U2VsZWN0XG5cdFx0XHQudGV4dCh0aGlzLnlLZXkpXG5cdFx0XHQuY2xhc3NlZCgnbm9EaXNwJywgZmFsc2UpO1xuXHRcdFxuICAgIH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMuZGF0YSlcblx0XHR7XG5cdFx0XHR0aGlzLnN2Z1NlbGVjdC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuXHRcdFx0dGhpcy5zdmdTZWxlY3QuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuXHRcdFx0dGhpcy5jYW52YXNDb250YWluZXJcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgdGhpcy52aXpXaWR0aClcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHRoaXMudml6SGVpZ2h0KTtcblxuXHRcdFx0ZDMuc2VsZWN0KHRoaXMuY2FudmFzRWxlbWVudClcblx0XHRcdFx0LmF0dHIoJ3dpZHRoJywgdGhpcy52aXpXaWR0aClcblx0XHRcdFx0LmF0dHIoJ2hlaWdodCcsIHRoaXMudml6SGVpZ2h0KTtcblx0XHRcdFx0XG5cdFx0XHR0aGlzLnVwZGF0ZVNjYWxlcygpO1xuXHRcdFx0dGhpcy51cGRhdGVQYXRocygpO1xuXHRcdFx0dGhpcy5wb3NpdGlvbkxhYmVscygpO1xuXHRcdFx0dGhpcy5kcmF3QXhpcygpO1xuXHRcdH1cblx0XHR0aGlzLnJlc2l6ZUJydXNoKCk7XG5cdH1cblxuXHRwcml2YXRlIHJlc2l6ZUJydXNoKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuaW5pdEJydXNoKCk7XG5cdFx0aWYgKHRoaXMubGFzdFlWYWx1ZUJydXNoQm91bmQgPT0gbnVsbCB8fCB0aGlzLmxhc3RYVmFsdWVCcnVzaEJvdW5kID09IG51bGwpXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgbGVmdCA9IHRoaXMuc2NhbGVYKHRoaXMubGFzdFhWYWx1ZUJydXNoQm91bmRbMF0pO1xuXHRcdGxldCByaWdodCA9IHRoaXMuc2NhbGVYKHRoaXMubGFzdFhWYWx1ZUJydXNoQm91bmRbMV0pO1xuXHRcdGxldCB0b3AgPSB0aGlzLnNjYWxlWSh0aGlzLmxhc3RZVmFsdWVCcnVzaEJvdW5kWzFdKTtcblx0XHRsZXQgYm90dG9tID0gdGhpcy5zY2FsZVkodGhpcy5sYXN0WVZhbHVlQnJ1c2hCb3VuZFswXSk7XG5cdFx0dGhpcy5icnVzaEdyb3VwU2VsZWN0LmNhbGwodGhpcy5icnVzaC5tb3ZlLCBbW2xlZnQsIHRvcF0sIFtyaWdodCwgYm90dG9tXV0pO1xuXHR9XG5cblx0cHJpdmF0ZSBicnVzaEhhbmRsZXIoKTogdm9pZFxuXHR7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uOiBbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV0gfCBudWxsICB8IHVuZGVmaW5lZCA9IGQzLmV2ZW50LnNlbGVjdGlvbjtcblx0XHRpZiAodHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJ1bmRlZmluZWRcIiB8fCBzZWxlY3Rpb24gPT09IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhpcy5kYXRhLnJlbW92ZUN1cnZlQnJ1c2godGhpcy5Db21wb25lbnRJZCk7XG5cdFx0XHR0aGlzLl9sYXN0WFZhbHVlQnJ1c2hCb3VuZCA9IG51bGw7XG5cdFx0XHR0aGlzLl9sYXN0WVZhbHVlQnJ1c2hCb3VuZCA9IG51bGw7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IFtbbGVmdCwgdG9wXSwgW3JpZ2h0LCBib3R0b21dXSA9IHNlbGVjdGlvbjtcblxuXHRcdGxldCBtaW5YID0gdGhpcy5zY2FsZVguaW52ZXJ0KGxlZnQpO1xuXHRcdGxldCBtYXhYID0gdGhpcy5zY2FsZVguaW52ZXJ0KHJpZ2h0KTtcblx0XHR0aGlzLl9sYXN0WFZhbHVlQnJ1c2hCb3VuZCA9IFttaW5YLCBtYXhYXTtcblx0XHRsZXQgeFZhbHVlRmlsdGVyOiB2YWx1ZUZpbHRlciA9IHtcblx0XHRcdGtleTogdGhpcy54S2V5LFxuXHRcdFx0Ym91bmQ6IHRoaXMubGFzdFhWYWx1ZUJydXNoQm91bmRcblx0XHR9XG5cblx0XHRsZXQgbWluWSA9IHRoaXMuc2NhbGVZLmludmVydChib3R0b20pO1xuXHRcdGxldCBtYXhZID0gdGhpcy5zY2FsZVkuaW52ZXJ0KHRvcCk7XG5cdFx0dGhpcy5fbGFzdFlWYWx1ZUJydXNoQm91bmQgPSBbbWluWSwgbWF4WV07XG5cdFx0bGV0IHlWYWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRoaXMueUtleSxcblx0XHRcdGJvdW5kOiB0aGlzLmxhc3RZVmFsdWVCcnVzaEJvdW5kXG5cdFx0fVxuXHRcdHRoaXMuZGF0YS5hZGRDdXJ2ZUJydXNoKHRoaXMuQ29tcG9uZW50SWQsIFt4VmFsdWVGaWx0ZXIsIHlWYWx1ZUZpbHRlcl0pO1xuXG5cdH1cblx0XG5cdHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMudXBkYXRlUGF0aHMoKTtcblx0fVxuXG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSBcIi4uL2RldmxpYi9EZXZsaWJUU1V0aWxcIjtcblxuZXhwb3J0IGNsYXNzIFJpY2hUb29sdGlwXG57XG5cbiAgICBjb25zdHJ1Y3Rvcih3YWl0VG9TaG93OiBudW1iZXIgPSAzNTAsIHdhaXRUb0hpZGU6IG51bWJlciA9IDIwMClcbiAgICB7XG4gICAgICAgIHRoaXMuX3dhaXRUb1Nob3cgPSB3YWl0VG9TaG93O1xuICAgICAgICB0aGlzLl93YWl0VG9IaWRlID0gd2FpdFRvSGlkZTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIERldmxpYlRTVXRpbC5oaWRlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3JpY2hUb29sdGlwJyk7XG4gICAgICAgIHRoaXMuX3Nob3dUaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5IaWRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZVRpbWVyICYmIHRoaXMuaGlkZVRpbWVyUnVubmluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVUaW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaG93VGltZXJSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faGlkZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgRGV2bGliVFNVdGlsLmhpZGUodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgIC8vIHNob3VsZG4ndCBuZWVkIHRoaXMsIGJ1dCBJIHdhcyBydW5uaW5nIGludG8gYSBwcm9ibGVtIHdoZXJlIHN0b3AgdGltZXIgd2FzIGdldHRpbmcgc3R1Y2sgaW4gYSBsb29wLlxuICAgICAgICAgICAgIC8vIHRoaXMgYXBwZWFycyB0byBmaXggaXQuXG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICB9XG5cbiAgICBcbiAgICBwcml2YXRlIF93YWl0VG9TaG93IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgd2FpdFRvU2hvdygpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRUb1Nob3c7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd2FpdFRvSGlkZSA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHdhaXRUb0hpZGUoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWl0VG9IaWRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NvbnRhaW5lciA6IEhUTUxEaXZFbGVtZW50O1xuICAgIHB1YmxpYyBnZXQgY29udGFpbmVyKCkgOiBIVE1MRGl2RWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX3Nob3dUaW1lclJ1bm5pbmcgOiBib29sZWFuO1xuICAgIHB1YmxpYyBnZXQgc2hvd1RpbWVyUnVubmluZygpIDogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93VGltZXJSdW5uaW5nO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zaG93VGltZXIgOiBkMy5UaW1lcjtcbiAgICBwdWJsaWMgZ2V0IHNob3dUaW1lcigpIDogZDMuVGltZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1RpbWVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hpZGVUaW1lciA6IGQzLlRpbWVyO1xuICAgIHB1YmxpYyBnZXQgaGlkZVRpbWVyKCkgOiBkMy5UaW1lciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlVGltZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaGlkZVRpbWVyUnVubmluZyA6IGJvb2xlYW47XG4gICAgcHVibGljIGdldCBoaWRlVGltZXJSdW5uaW5nKCkgOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGVUaW1lclJ1bm5pbmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaGlkZUNhbGxiYWNrIDogKGVsYXBzZWQ6IG51bWJlcikgPT4gdm9pZDtcbiAgICBwdWJsaWMgZ2V0IGhpZGVDYWxsYmFjaygpIDogKGVsYXBzZWQ6IG51bWJlcikgPT4gdm9pZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlQ2FsbGJhY2s7XG4gICAgfVxuXG4gICAgcHVibGljIFNob3coaHRtbFN0cmluZzogc3RyaW5nLCBwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCB3YWl0T3ZlcnJpZGU/OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBjYWxsYmFja0Z1bmMgPSAoKSA9PiB0aGlzLmRyYXdUb29sdGlwKGh0bWxTdHJpbmcsIHBhZ2VYLCBwYWdlWSlcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWVyUnVubmluZylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zaG93VGltZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWxheTogbnVtYmVyXG4gICAgICAgIGlmICh0eXBlb2Ygd2FpdE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsYXkgPSB3YWl0T3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxheSA9IHRoaXMud2FpdFRvU2hvdztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaG93VGltZXIgPSBkMy50aW1lb3V0KGNhbGxiYWNrRnVuYywgZGVsYXkpO1xuICAgICAgICB0aGlzLl9zaG93VGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaGlkZVRpbWVyUnVubmluZylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oaWRlVGltZXIuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3VG9vbHRpcChodG1sU3RyaW5nOiBzdHJpbmcsIHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9zaG93VGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxTdHJpbmc7XG5cbiAgICAgICAgLy8gbmVlZCB0byBkaXNwbGF5IGFzIGhpZGRlbiB0byBnZXQgd2lkdGhcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICBEZXZsaWJUU1V0aWwuc2hvdyh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIGxldCBib3VuZFJlY3QgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGNvbnRhaW5lclJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIFByaW9yaXR5IGZvciBwbGFjZW1lbnQgaXMgcmlnaHQsIGJlbG93LCBsZWZ0LCBhYm92ZVxuICAgICAgICBjb25zdCBvZmZzZXQgPSAyMDsgLy8gc3BhY2UgYmV0d2VlbiBsYWJlbCBhbmQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgZWRnZU1hcmdpbiA9IDEwOyAvLyB3aGl0ZXNwYWNlIHJlcXVpcmVkIGJldHdlZW4gbGFiZWwgYW5kIGVkZ2Ugb2YgZG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IHBhZCA9IG9mZnNldCAgKyBlZGdlTWFyZ2luO1xuICAgICAgICBsZXQgc3BhY2VSaWdodCA9IGNvbnRhaW5lclJlY3QucmlnaHQgLSBwYWdlWDtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBjb250YWluZXJSZWN0LmJvdHRvbSAtIHBhZ2VZO1xuICAgICAgICBsZXQgc3BhY2VMZWZ0ID0gY29udGFpbmVyUmVjdC53aWR0aCAtIHNwYWNlUmlnaHQ7XG4gICAgICAgIGxldCBzcGFjZUFib3ZlID0gY29udGFpbmVyUmVjdC5oZWlnaHQgLSBzcGFjZUJlbG93O1xuICAgICAgICBsZXQgdyA9IGJvdW5kUmVjdC53aWR0aDtcbiAgICAgICAgbGV0IGggPSBib3VuZFJlY3QuaGVpZ2h0O1xuICAgICAgICBsZXQgdzIgPSB3IC8gMi4wO1xuICAgICAgICBsZXQgaDIgPSBoIC8gMi4wO1xuICAgICAgICBsZXQgW3RvcCwgbGVmdF06IFtudW1iZXIsIG51bWJlcl0gPSBbMCwgMF07XG4gICAgICAgIGlmIChzcGFjZVJpZ2h0ID49IHcgKyBwYWQgJiYgc3BhY2VBYm92ZSA+PSBoMiArIGVkZ2VNYXJnaW4gJiYgc3BhY2VCZWxvdyA+PSBoMiArIGVkZ2VNYXJnaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIFt0b3AsIGxlZnRdID0gdGhpcy5wb3NpdGlvblJpZ2h0KHBhZ2VYLCBwYWdlWSwgYm91bmRSZWN0LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYWNlQmVsb3cgPj0gaCArIHBhZCAmJiBzcGFjZVJpZ2h0ID49IGgyICsgZWRnZU1hcmdpbiAmJiBzcGFjZUxlZnQgPj0gaDIgKyBlZGdlTWFyZ2luKVxuICAgICAgICB7XG4gICAgICAgICAgICBbdG9wLCBsZWZ0XSA9IHRoaXMucG9zaXRpb25CZWxvdyhwYWdlWCwgcGFnZVksIGJvdW5kUmVjdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcGFjZUxlZnQgPj0gdyArIHBhZCAmJiBzcGFjZUFib3ZlID49IGgyICsgZWRnZU1hcmdpbiAmJiBzcGFjZUJlbG93ID49IGgyICsgZWRnZU1hcmdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgW3RvcCwgbGVmdF0gPSB0aGlzLnBvc2l0aW9uTGVmdChwYWdlWCwgcGFnZVksIGJvdW5kUmVjdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIFt0b3AsIGxlZnRdID0gdGhpcy5wb3NpdGlvbkFib3ZlKHBhZ2VYLCBwYWdlWSwgYm91bmRSZWN0LCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gVE9ETyBUaGlzIGNhbiBzdGlsbCBydW4gaW50byBwcm9ibGVtcyBpZiB0aGUgeCBhbmQgeSBhcmUgYXQgY29ybmVycywgYW5kIHRoaXMgcG9pbnQgZ2V0J3MgcmVhY2hlZC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvblJpZ2h0KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIGJvdW5kUmVjdDogRE9NUmVjdCwgb2Zmc2V0OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdXG4gICAge1xuICAgICAgICBsZXQgdG9wID0gcGFnZVkgLSBib3VuZFJlY3QuaGVpZ2h0IC8gMi4wO1xuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIHByaXZhdGUgcG9zaXRpb25CZWxvdyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBib3VuZFJlY3Q6IERPTVJlY3QsIG9mZnNldDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXVxuICAgIHtcbiAgICAgICAgbGV0IHRvcCA9IHBhZ2VZICsgb2Zmc2V0O1xuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYIC0gYm91bmRSZWN0LndpZHRoIC8gMi4wO1xuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIHByaXZhdGUgcG9zaXRpb25MZWZ0KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIGJvdW5kUmVjdDogRE9NUmVjdCwgb2Zmc2V0OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdXG4gICAge1xuICAgICAgICBsZXQgdG9wID0gcGFnZVkgLSBib3VuZFJlY3QuaGVpZ2h0IC8gMi4wO1xuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYIC0gb2Zmc2V0IC0gYm91bmRSZWN0LndpZHRoO1xuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIHByaXZhdGUgcG9zaXRpb25BYm92ZShwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBib3VuZFJlY3Q6IERPTVJlY3QsIG9mZnNldDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXVxuICAgIHtcbiAgICAgICAgbGV0IHRvcCA9IHBhZ2VZIC0gb2Zmc2V0IC0gYm91bmRSZWN0LmhlaWdodDtcbiAgICAgICAgbGV0IGxlZnQgPSBwYWdlWCAtIGJvdW5kUmVjdC53aWR0aCAvIDIuMDtcbiAgICAgICAgcmV0dXJuIFt0b3AsIGxlZnRdO1xuICAgIH1cblxuICAgIHB1YmxpYyBIaWRlKHdhaXRPdmVycmlkZT86IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnNob3dUaW1lclJ1bm5pbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpbWVyLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhpZGVUaW1lciAmJiB0aGlzLmhpZGVUaW1lclJ1bm5pbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGRlbGF5OiBudW1iZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdhaXRPdmVycmlkZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSB3YWl0T3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSB0aGlzLndhaXRUb0hpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXIgPSBkMy50aW1lb3V0KHRoaXMuaGlkZUNhbGxiYWNrLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVMYWJlbFZhbHVlTGlzdENvbnRlbnQobGFiZWxWYWx1ZUxpc3Q6IFtzdHJpbmcsIHN0cmluZyB8IG51bGxdW10pOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBpbm5lckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpbm5lckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd0b29sdGlwSW5uZXJDb250YWluZXInKVxuICAgICAgICBcbiAgICAgICAgZDMuc2VsZWN0KGlubmVyQ29udGFpbmVyKS5zZWxlY3RBbGwoJ3AnKVxuICAgICAgICAuZGF0YShsYWJlbFZhbHVlTGlzdClcbiAgICAgICAgLmpvaW4oJ3AnKVxuICAgICAgICAuaHRtbChkID0+IHtcbiAgICAgICAgICAgIGlmIChkWzFdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdICsgJzogPGI+JyArIGRbMV0gKyAnPC9iPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJzxpPicgKyBkWzBdICsgJzwvaT4nO1xuICAgICAgICB9KVxuICAgICAgICAuY2xhc3NlZCgndG9vbHRpcERpc3BsYXlSb3cnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlubmVyQ29udGFpbmVyLm91dGVySFRNTDtcbiAgICB9XG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHtTdmdTZWxlY3Rpb259IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcyc7XG5pbXBvcnQge0Jhc2VXaWRnZXR9IGZyb20gJy4vQmFzZVdpZGdldCc7XG5pbXBvcnQgeyBORGltIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJztcbmltcG9ydCB7dmFsdWVGaWx0ZXIsIFBvaW50Q29sbGVjdGlvbn0gZnJvbSAnLi4vRGF0YU1vZGVsL1BvaW50Q29sbGVjdGlvbic7XG5pbXBvcnQgeyBEYXRhc2V0U3BlYyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIFNjYXR0ZXJQbG90V2lkZ2V0IGV4dGVuZHMgQmFzZVdpZGdldDxQb2ludENvbGxlY3Rpb24sIERhdGFzZXRTcGVjPiB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCB4S2V5OiBzdHJpbmcsIHlLZXk6IHN0cmluZywgY2FuQnJ1c2g6IGJvb2xlYW4gPSB0cnVlKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCB0cnVlLCBjYW5CcnVzaCk7XG5cdFx0dGhpcy5feEtleSA9IHhLZXk7XG5cdFx0dGhpcy5feUtleSA9IHlLZXk7XG5cdFx0dGhpcy5zZXRMYWJlbCgpO1xuXHR9XG5cblx0cHJvdGVjdGVkIENsb25lKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiBCYXNlV2lkZ2V0PFBvaW50Q29sbGVjdGlvbiwgRGF0YXNldFNwZWM+XG4gICAge1xuXHRcdGNvbnN0IGNhbkJydXNoID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgU2NhdHRlclBsb3RXaWRnZXQoY29udGFpbmVyLCB0aGlzLnhLZXksICB0aGlzLnlLZXksIGNhbkJydXNoKTtcblx0fVxuXHRcblx0cHJvdGVjdGVkIGluaXRQcm9wcyhwcm9wcz86IGFueVtdKTogdm9pZFxuXHR7XG5cdFx0c3VwZXIuaW5pdFByb3BzKCk7XG5cdFx0dGhpcy5fY2FuQnJ1c2ggPSBwcm9wc1swXTtcblx0fVxuXG5cdHByaXZhdGUgX3hLZXkgOiBzdHJpbmc7XG5cdHB1YmxpYyBnZXQgeEtleSgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5feEtleTtcblx0fVxuXG5cdHByaXZhdGUgX3lLZXkgOiBzdHJpbmc7XG5cdHB1YmxpYyBnZXQgeUtleSgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5feUtleTtcblx0fVxuXG5cdHByaXZhdGUgX3N2Z1NlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBzdmdTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N2Z1NlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX21haW5Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBtYWluR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX21haW5Hcm91cFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX2NhbnZhc0VsZW1lbnQgOiBIVE1MQ2FudmFzRWxlbWVudDtcblx0cHVibGljIGdldCBjYW52YXNFbGVtZW50KCkgOiBIVE1MQ2FudmFzRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhc0VsZW1lbnQ7XG5cdH1cblxuXHRwcml2YXRlIF9jYW5CcnVzaCA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgY2FuQnJ1c2goKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9jYW5CcnVzaDtcblx0fVxuXG5cdHByaXZhdGUgX2JydXNoR3JvdXBTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgYnJ1c2hHcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fYnJ1c2hHcm91cFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3hBeGlzR3JvdXBTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgeEF4aXNHcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5feEF4aXNHcm91cFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3hMYWJlbFRleHRTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgeExhYmVsVGV4dFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5feExhYmVsVGV4dFNlbGVjdDtcblx0fVxuXG5cblx0cHJpdmF0ZSBfeUF4aXNHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB5QXhpc0dyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl95QXhpc0dyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeUxhYmVsVGV4dFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB5TGFiZWxUZXh0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl95TGFiZWxUZXh0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhbGVYIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IHNjYWxlWCgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGVYO1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhbGVZIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IHNjYWxlWSgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGVZO1xuXHR9XG5cblx0cHJpdmF0ZSBfYXhpc1BhZGRpbmcgOiAgbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGF4aXNQYWRkaW5nKCkgOiAgbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fYXhpc1BhZGRpbmc7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaCA6IGQzLkJydXNoQmVoYXZpb3I8YW55Pjtcblx0cHVibGljIGdldCBicnVzaCgpIDogZDMuQnJ1c2hCZWhhdmlvcjxhbnk+IHtcblx0XHRyZXR1cm4gdGhpcy5fYnJ1c2g7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0TWFyZ2luKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX21hcmdpbiA9IHtcblx0XHRcdHRvcDogOCxcblx0XHRcdHJpZ2h0OiA4LFxuXHRcdFx0Ym90dG9tOiA1Nixcblx0XHRcdGxlZnQ6IDU2XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGluaXQoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fc3ZnU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMuY29udGFpbmVyKS5hcHBlbmQoXCJzdmdcIilcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgdGhpcy53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdHRoaXMuX21haW5Hcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKTtcblx0XHRcblx0XHR0aGlzLl9jYW52YXNFbGVtZW50ID0gdGhpcy5tYWluR3JvdXBTZWxlY3Rcblx0XHRcdC5hcHBlbmQoJ2ZvcmVpZ25PYmplY3QnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQpXG5cdFx0XHQuYXBwZW5kKCd4aHRtbDpjYW52YXMnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQpXG5cdFx0XHQubm9kZSgpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuXG5cdFx0aWYgKHRoaXMuY2FuQnJ1c2gpXG5cdFx0e1xuXHRcdFx0dGhpcy5fYnJ1c2hHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApXG5cdFx0XHRcdC5jbGFzc2VkKFwiYnJ1c2hDb250YWluZXJcIiwgdHJ1ZSk7XG5cblx0XHRcdHRoaXMuX2JydXNoID0gZDMuYnJ1c2goKVxuXHRcdFx0XHQuZXh0ZW50KFtbMCwgMF0sIFt0aGlzLnZpeldpZHRoLCB0aGlzLnZpekhlaWdodF1dKVxuXHRcdFx0XHQub24oXCJlbmRcIiwgKCkgPT4geyB0aGlzLmJydXNoSGFuZGxlcigpIH0pO1xuXHRcdFxuXHRcdFx0dGhpcy5icnVzaEdyb3VwU2VsZWN0LmNhbGwodGhpcy5icnVzaCk7XG5cdFx0fVxuXHRcdFx0XG5cdFx0dGhpcy5fYXhpc1BhZGRpbmcgPSAwO1xuXHRcdFx0XG5cdFx0dGhpcy5feEF4aXNHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgnZycpXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0ICsgdGhpcy5heGlzUGFkZGluZ30pYClcblx0XHRcdC5jbGFzc2VkKFwibGFiZWxDb2xvclwiLCB0cnVlKTtcblx0XHRcdFxuXHRcdHRoaXMuX3lBeGlzR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5heGlzUGFkZGluZ30sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuXHRcdFx0LmNsYXNzZWQoXCJsYWJlbENvbG9yXCIsIHRydWUpO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRMYWJlbCgpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBidWZmZXJGb3JBeGlzID0gMzIgKyB0aGlzLmF4aXNQYWRkaW5nO1xuXHRcdHRoaXMuX3hMYWJlbFRleHRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0ICsgdGhpcy52aXpXaWR0aCAvIDJ9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0ICsgYnVmZmVyRm9yQXhpc30pYClcblx0XHRcdC5jbGFzc2VkKCdheGlzTGFiZWwnLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ2xhYmVsQ29sb3InLCB0cnVlKVxuXHRcdFx0LnRleHQodGhpcy54S2V5KTtcblxuXHRcdGxldCB0cmFuc1ggPSB0aGlzLm1hcmdpbi5sZWZ0IC0gYnVmZmVyRm9yQXhpcztcblx0XHRsZXQgdHJhbnNZID0gdGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgLyAyO1xuXHRcdGxldCB0cmFuc2Zvcm1UZXh0OiBzdHJpbmc7XG5cdFx0aWYgKHRoaXMueUtleS5sZW5ndGggPT09IDEpXG5cdFx0e1xuXHRcdFx0dHJhbnNmb3JtVGV4dCA9IGB0cmFuc2xhdGUoJHt0cmFuc1h9LCAke3RyYW5zWX0pYDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRyYW5zZm9ybVRleHQgPSBgcm90YXRlKC05MCkgdHJhbnNsYXRlKCR7LXRyYW5zWX0sICR7dHJhbnNYfSlgO1xuXHRcdH1cblxuXHRcdHRoaXMuX3lMYWJlbFRleHRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybVRleHQpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcblx0XHRcdC50ZXh0KHRoaXMueUtleSk7XG5cdH1cblxuXHRwdWJsaWMgT25EYXRhQ2hhbmdlKClcblx0e1xuXHRcdHRoaXMudXBkYXRlU2NhbGVzKCk7XG5cdFx0dGhpcy5kcmF3UG9pbnRzKCk7XG5cdFx0dGhpcy5kcmF3QXhpcygpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3UG9pbnRzKCk6IHZvaWRcblx0e1xuXHRcdGxldCB2YWxpZFBvaW50cyA9IHRoaXMuZGF0YS5BcnJheS5maWx0ZXIoKHBvaW50OiBORGltKSA9PiBcblx0XHRcdHtcblxuXHRcdFx0XHRyZXR1cm4gIWlzTmFOKHBvaW50LmdldCh0aGlzLnhLZXkpKVxuXHRcdFx0XHRcdCYmICFpc05hTihwb2ludC5nZXQodGhpcy55S2V5KSlcblx0XHRcdFx0XHQmJiBwb2ludC5pbkJydXNoO1xuXHRcdFx0fSk7XG5cblx0XHRjb25zdCBjYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwwLCB0aGlzLnZpeldpZHRoLCB0aGlzLnZpekhlaWdodCk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkUG9pbnRzLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdGxldCBwb2ludCA9IHZhbGlkUG9pbnRzW2ldO1xuXHRcdFx0bGV0IHggPSB0aGlzLnNjYWxlWChwb2ludC5nZXQodGhpcy54S2V5KSk7XG5cdFx0XHRsZXQgeSA9IHRoaXMuc2NhbGVZKHBvaW50LmdldCh0aGlzLnlLZXkpKTtcblx0XHRcdGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRjb25zdCByYWRpdXMgPSAwLjU7XG5cdFx0XHRjYW52YXNDb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHRcdGNhbnZhc0NvbnRleHQuZmlsbCgpO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCBkcmF3RmFjZXRlZERhdGEoZmFjZXRPcHRpb25JbmRleExpc3Q6IG51bWJlcltdKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5kcmF3RmFjZXRlZERhdGFEZWZhdWx0UmVjdXJzZShmYWNldE9wdGlvbkluZGV4TGlzdCwgXCIzMDBweFwiLCBcIjMwMHB4XCIpO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVTY2FsZXMoKTogdm9pZFxuXHR7XG5cdFx0bGV0IG1pbk1heFggPSB0aGlzLmZ1bGxEYXRhLmdldE1pbk1heCh0aGlzLnhLZXkpO1xuXHRcdHRoaXMuX3NjYWxlWCA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4obWluTWF4WClcblx0XHRcdC5yYW5nZShbMCwgdGhpcy52aXpXaWR0aF0pO1xuXG5cdFx0bGV0IG1pbk1heFkgPSB0aGlzLmZ1bGxEYXRhLmdldE1pbk1heCh0aGlzLnlLZXkpO1xuXHRcdHRoaXMuX3NjYWxlWSA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4obWluTWF4WSlcblx0XHRcdC5yYW5nZShbdGhpcy52aXpIZWlnaHQsIDBdKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0F4aXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy54QXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuY2FsbChkMy5heGlzQm90dG9tKHRoaXMuc2NhbGVYKS50aWNrcyg1KSk7XG5cblx0XHR0aGlzLnlBeGlzR3JvdXBTZWxlY3Rcblx0XHRcdC5jYWxsKGQzLmF4aXNMZWZ0KHRoaXMuc2NhbGVZKS50aWNrcyg1KSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0Ly8gcmVzaXplIGlzIGhhbmRsZWQgYnkgY3NzIC8gSFRNTFxuXHR9XG5cblx0cHJpdmF0ZSBicnVzaEhhbmRsZXIoKTogIHZvaWRcblx0e1xuXHRcdGNvbnN0IHNlbGVjdGlvbjogW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dIHwgbnVsbCAgfCB1bmRlZmluZWQgPSBkMy5ldmVudC5zZWxlY3Rpb247XG5cdFx0aWYgKHR5cGVvZiBzZWxlY3Rpb24gPT09IFwidW5kZWZpbmVkXCIgfHwgc2VsZWN0aW9uID09PSBudWxsKVxuXHRcdHtcblx0XHRcdHRoaXMuZGF0YS5yZW1vdmVCcnVzaCh0aGlzLkNvbXBvbmVudElkKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IFtbbGVmdCwgdG9wXSwgW3JpZ2h0LCBib3R0b21dXSA9IHNlbGVjdGlvbjtcblx0XHRcblx0XHRsZXQgbWluWCA9IHRoaXMuc2NhbGVYLmludmVydChsZWZ0KTtcblx0XHRsZXQgbWF4WCA9IHRoaXMuc2NhbGVYLmludmVydChyaWdodCk7XG5cdFx0bGV0IHhWYWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRoaXMueEtleSxcblx0XHRcdGJvdW5kOiBbbWluWCwgbWF4WF1cblx0XHR9XG5cblx0XHRsZXQgbWluWSA9IHRoaXMuc2NhbGVZLmludmVydChib3R0b20pO1xuXHRcdGxldCBtYXhZID0gdGhpcy5zY2FsZVkuaW52ZXJ0KHRvcCk7XG5cdFx0bGV0IHlWYWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRoaXMueUtleSxcblx0XHRcdGJvdW5kOiBbbWluWSwgbWF4WV1cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYWRkQnJ1c2godGhpcy5Db21wb25lbnRJZCwgeFZhbHVlRmlsdGVyLCB5VmFsdWVGaWx0ZXIpO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcIm5vRGlzcFwiKSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gaGlkZSBkeW5hbWljYWxseVxuXHRcdHRoaXMuZHJhd1BvaW50cygpO1xuXHR9XG5cbn0iLCJpbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQge1Rvb2xiYXJFbGVtZW50fSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlRTVXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBUb29sYmFyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEVsZW1lbnQpXG5cdHtcblx0XHRzdXBlcihjb250YWluZXIpO1xuXHR9XG5cblx0cHJpdmF0ZSBfdXBsb2FkRmlsZUJ1dHRvbldyYXBwZXIgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCB1cGxvYWRGaWxlQnV0dG9uV3JhcHBlcigpIDogSFRNTERpdkVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl91cGxvYWRGaWxlQnV0dG9uV3JhcHBlcjtcblx0fVxuXHRcblx0cHJpdmF0ZSBfdG9vbGJhckVsZW1lbnRzIDogVG9vbGJhckVsZW1lbnRbXTtcblx0cHVibGljIGdldCB0b29sYmFyRWxlbWVudHMoKSA6IFRvb2xiYXJFbGVtZW50W10ge1xuXHRcdHJldHVybiB0aGlzLl90b29sYmFyRWxlbWVudHM7XG5cdH1cblxuXHRwcml2YXRlIF93cmFwcGVyRGl2IDogSFRNTERpdkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgd3JhcHBlckRpdigpIDogSFRNTERpdkVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl93cmFwcGVyRGl2O1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0VG9vbGJhckVsZW1lbnRzKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3Rvb2xiYXJFbGVtZW50cyA9IFtcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogJ3NpbmdsZScsXG5cdFx0XHRcdGljb25LZXk6ICdob21lJyxcblx0XHRcdFx0Y2FsbGJhY2s6ICgpID0+IGxvY2F0aW9uLmhyZWYgPSAnL292ZXJ2aWV3Jyxcblx0XHRcdFx0dG9vbHRpcDogJ1JldHVybiB0byBvdmVydmlldyBzY3JlZW4nXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiAndG9nZ2xlQnV0dG9uJyxcblx0XHRcdFx0aWNvbktleXM6IFsnZXllLXNsYXNoJywgJ2V5ZSddLFxuXHRcdFx0XHRjYWxsYmFjazogKHN0YXRlOiBib29sZWFuKSA9PiBjb25zb2xlLmxvZygndG9nZ2xlJywgc3RhdGUpLFxuXHRcdFx0XHR0b29sdGlwczogWydPbmx5IHNob3dpbmcgbG9uZ2VyIHRyYWNrcywgY2xpY2sgdG8gc2hvdyBhbGwgY2VsbHMuJywgJ1Nob3dpbmcgYWxsIGNlbGxzLCBjbGljayB0byBzaG93IG9ubHkgbG9uZyB0cmFja3MuJ11cblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6ICdvcHRpb25TZWxlY3QnLFxuXHRcdFx0XHRpY29uS2V5czogWydiYXJzJywgJ3N0cmVhbScsICdjbG9uZSddLFxuXHRcdFx0XHRkZWZhdWx0SW5kZXg6IDAsXG5cdFx0XHRcdGNhbGxiYWNrOiBhc3luYyAoc3RhdGU6IG51bWJlcikgPT4ge1xuXHRcdFx0XHRcdGxldCBtb2RlQ2hhbmdlRXZlbnQ6IEN1c3RvbUV2ZW50O1xuXHRcdFx0XHRcdHN3aXRjaCAoc3RhdGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0XHRtb2RlQ2hhbmdlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vZGVDaGFuZ2UnLCB7ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRcdFx0aW5Db25kZW5zZWRNb2RlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH19KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdG1vZGVDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbW9kZUNoYW5nZScsIHtkZXRhaWw6IHtcblx0XHRcdFx0XHRcdFx0XHRpbkNvbmRlbnNlZE1vZGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH19KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRcdG1vZGVDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbW9kZUNoYW5nZScsIHtkZXRhaWw6IHtcblx0XHRcdFx0XHRcdFx0XHRpbkNvbmRlbnNlZE1vZGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHR9fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdERldmxpYlRTVXRpbC5sYXVuY2hTcGlubmVyKCk7XG5cdFx0XHRcdFx0YXdhaXQgRGV2bGliVFNVdGlsLm1ha2VBc3luYygoKSA9PiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG1vZGVDaGFuZ2VFdmVudCkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b29sdGlwczogWydDb25kZW5zZWQgTW9kZScsICdFeHBhbmRlZCBNb2RlJywgJ0ZyYW1lIE1vZGUnXVxuXHRcdFx0fVxuXHRcdF1cblx0fVxuXG5cdHByb3RlY3RlZCBpbml0KCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3dyYXBwZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdHRoaXMud3JhcHBlckRpdi5jbGFzc0xpc3QuYWRkKFwid3JhcHBlckRpdlwiKTtcblxuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlckRpdik7XG5cdFx0dGhpcy5pbml0VG9vbGJhckVsZW1lbnRzKCk7XG5cdFx0dGhpcy5kcmF3VG9vbGJhckVsZW1lbnRzKCk7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdUb29sYmFyRWxlbWVudHMoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgdG9vbGJhckVsZW1lbnQgb2YgdGhpcy50b29sYmFyRWxlbWVudHMpXG5cdFx0e1xuXHRcdFx0aWYgKHRvb2xiYXJFbGVtZW50LnR5cGUgPT09ICdzaW5nbGUnKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24odG9vbGJhckVsZW1lbnQuaWNvbktleSwgdG9vbGJhckVsZW1lbnQuY2FsbGJhY2spO1xuXHRcdFx0XHRidXR0b24uY2xhc3NMaXN0LmFkZCgnYmlnJyk7XG5cdFx0XHRcdHRoaXMud3JhcHBlckRpdi5hcHBlbmQoYnV0dG9uKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRvb2xiYXJFbGVtZW50LnR5cGUgPT09ICd0b2dnbGVCdXR0b24nKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYnV0dG9uVHJ1ZSA9IERldmxpYlRTVXRpbC5nZXRJY29uQnV0dG9uKHRvb2xiYXJFbGVtZW50Lmljb25LZXlzWzBdLCBudWxsKTtcblx0XHRcdFx0YnV0dG9uVHJ1ZS5jbGFzc0xpc3QuYWRkKCdiaWcnKTtcblx0XHRcdFx0dGhpcy53cmFwcGVyRGl2LmFwcGVuZChidXR0b25UcnVlKTtcblxuXHRcdFx0XHRsZXQgYnV0dG9uRmFsc2UgPSBEZXZsaWJUU1V0aWwuZ2V0SWNvbkJ1dHRvbih0b29sYmFyRWxlbWVudC5pY29uS2V5c1sxXSwgbnVsbCk7XG5cdFx0XHRcdGJ1dHRvbkZhbHNlLmNsYXNzTGlzdC5hZGQoJ2JpZycpO1xuXHRcdFx0XHR0aGlzLndyYXBwZXJEaXYuYXBwZW5kKGJ1dHRvbkZhbHNlKTtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUoYnV0dG9uRmFsc2UpO1xuXG5cdFx0XHRcdGJ1dHRvblRydWUub25jbGljayA9ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZShidXR0b25UcnVlKTtcblx0XHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyhidXR0b25GYWxzZSk7XG5cdFx0XHRcdFx0dG9vbGJhckVsZW1lbnQuY2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRidXR0b25GYWxzZS5vbmNsaWNrID0gKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KGJ1dHRvblRydWUpO1xuXHRcdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKGJ1dHRvbkZhbHNlKTtcblx0XHRcdFx0XHR0b29sYmFyRWxlbWVudC5jYWxsYmFjayhmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodG9vbGJhckVsZW1lbnQudHlwZSA9PT0gJ29wdGlvblNlbGVjdCcpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBncm91cGVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdGdyb3VwZXJEaXYuY2xhc3NMaXN0LmFkZCgnb3B0aW9uU2VsZWN0R3JvdXBlckRpdicpO1xuXHRcdFx0XHRsZXQgYnV0dG9uTGlzdDogSFRNTEJ1dHRvbkVsZW1lbnRbXSA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRvb2xiYXJFbGVtZW50Lmljb25LZXlzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGV0IGljb25LZXkgPSB0b29sYmFyRWxlbWVudC5pY29uS2V5c1tpXTtcblx0XHRcdFx0XHRsZXQgYnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24oaWNvbktleSwgbnVsbCk7XG5cdFx0XHRcdFx0YnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2JpZycpO1xuXHRcdFx0XHRcdGlmIChpID09PSB0b29sYmFyRWxlbWVudC5kZWZhdWx0SW5kZXgpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJ1dHRvbkxpc3QucHVzaChidXR0b24pO1xuXHRcdFx0XHRcdGdyb3VwZXJEaXYuYXBwZW5kKGJ1dHRvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCByZW1vdmVTZWxlY3RlZCA9ICgpID0+IHtcblx0XHRcdFx0XHRmb3IgKGxldCBidXR0b24gb2YgYnV0dG9uTGlzdClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25MaXN0Lmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGV0IGJ1dHRvbiA9IGJ1dHRvbkxpc3RbaV07XG5cdFx0XHRcdFx0YnV0dG9uLm9uY2xpY2sgPSAoKSA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHJlbW92ZVNlbGVjdGVkKCk7XG5cdFx0XHRcdFx0XHRidXR0b24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0XHRcdHRvb2xiYXJFbGVtZW50LmNhbGxiYWNrKGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2VNb2RlU2VsZWN0JywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlbW92ZVNlbGVjdGVkKCk7XG5cdFx0XHRcdFx0YnV0dG9uTGlzdFtlLmRldGFpbF0uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMud3JhcHBlckRpdi5hcHBlbmQoZ3JvdXBlckRpdik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJvdGVjdGVkIE9uUmVzaXplKCk6IHZvaWRcblx0e1xuXHRcdC8vIGRvIG5vdGhpbmdcblx0fVxufSIsImltcG9ydCB7IE5EaW0gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVHlwZXMnXG5pbXBvcnQgeyBDdXJ2ZUNvbGxlY3Rpb25JdGVyYXRvciB9IGZyb20gJy4vQ3VydmVDb2xsZWN0aW9uSXRlcmF0b3InO1xuaW1wb3J0IHsgUG9pbnRDb2xsZWN0aW9uIH0gZnJvbSAnLi9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi9DdXJ2ZUxpc3QnO1xuaW1wb3J0IHsgRmFjZXQsIExvY2F0aW9uTWFwTGlzdCwgTG9jYXRpb25NYXBUZW1wbGF0ZSwgRGF0YXNldFNwZWMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3RGYWN0b3J5IH0gZnJvbSAnLi9DdXJ2ZUxpc3RGYWN0b3J5JztcblxuZXhwb3J0IGNsYXNzIEN1cnZlQ29sbGVjdGlvbiBleHRlbmRzIFBvaW50Q29sbGVjdGlvblxue1xuICAgIGNvbnN0cnVjdG9yKGN1cnZlTGlzdDogQ3VydmVMaXN0LCBzcGVjOiBEYXRhc2V0U3BlYylcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGN1cnZlTGlzdC5jdXJ2ZUxpc3QubGVuZ3RoO1xuXHRcdHRoaXMuX2N1cnZlTGlzdCA9IGN1cnZlTGlzdDtcblx0XHR0aGlzLlNwZWNpZmljYXRpb24gPSBzcGVjO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9jdXJ2ZUxpc3QgOiBDdXJ2ZUxpc3Q7XG4gICAgcHVibGljIGdldCBjdXJ2ZUxpc3QoKSA6IEN1cnZlTGlzdCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZUxpc3Q7XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWQgeyB9XG5cblx0cHJvdGVjdGVkIGdldEZhY2V0TGlzdChsb2NhdGlvbk1hcDogTG9jYXRpb25NYXBMaXN0IHwgTG9jYXRpb25NYXBUZW1wbGF0ZSk6IEZhY2V0W11cblx0e1xuICAgICAgICBsZXQgZmFjZXRMaXN0ID0gQ3VydmVMaXN0RmFjdG9yeS5DcmVhdGVGYWNldGVkRGF0YXNldHModGhpcy5jdXJ2ZUxpc3QsIGxvY2F0aW9uTWFwKTtcbiAgICAgICAgZm9yIChsZXQgZmFjZXQgb2YgZmFjZXRMaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBmYWNldC5kYXRhID0gZmFjZXQuZGF0YS5jdXJ2ZUNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhY2V0TGlzdDtcblx0fVxuXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmF0b3I8TkRpbT5cblx0e1xuXHRcdHJldHVybiBuZXcgQ3VydmVDb2xsZWN0aW9uSXRlcmF0b3IodGhpcy5jdXJ2ZUxpc3QpO1xuXHR9XG5cbn0iLCJpbXBvcnQgeyBORGltIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJztcbmltcG9ydCB7IEN1cnZlTGlzdCB9IGZyb20gJy4vQ3VydmVMaXN0JztcblxuZXhwb3J0IGNsYXNzIEN1cnZlQ29sbGVjdGlvbkl0ZXJhdG9yIGltcGxlbWVudHMgSXRlcmF0b3I8TkRpbT4ge1xuXHRcblx0Y29uc3RydWN0b3IoY3VydmVMaXN0OiBDdXJ2ZUxpc3QpXG5cdHtcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuXHRcdHRoaXMuX2N1cnZlTGlzdCA9IGN1cnZlTGlzdDtcblx0fVxuXG5cdHByaXZhdGUgX2luZGV4IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGluZGV4KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxuXG5cdHByaXZhdGUgX2N1cnZlTGlzdCA6IEN1cnZlTGlzdDtcblx0cHVibGljIGdldCBjdXJ2ZUxpc3QoKSA6IEN1cnZlTGlzdCB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnZlTGlzdDtcblx0fVxuXG5cdHB1YmxpYyBuZXh0KCk6IEl0ZXJhdG9yUmVzdWx0PE5EaW0+XG5cdHtcblx0XHRsZXQgY3VydmUgPSB0aGlzLmN1cnZlTGlzdC5jdXJ2ZUxpc3RbdGhpcy5pbmRleF07XG5cdFx0bGV0IGlzRG9uZTogYm9vbGVhbiA9ICB0aGlzLmluZGV4ID49IHRoaXMuY3VydmVMaXN0LmN1cnZlTGlzdC5sZW5ndGg7XG5cdFx0Kyt0aGlzLl9pbmRleDtcblx0XHRsZXQgaXRlclJlc3VsdDogSXRlcmF0b3JSZXN1bHQ8TkRpbT4gPSB7XG5cdFx0XHR2YWx1ZTogY3VydmUsXG5cdFx0XHRkb25lOiBpc0RvbmVcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZXJSZXN1bHQ7XG5cdH1cblxufSIsImltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuL1BvaW50TkQnO1xuXG5leHBvcnQgY2xhc3MgQ3VydmVJdGVyYXRvciBpbXBsZW1lbnRzIEl0ZXJhdG9yPFBvaW50TkQ+IHtcblx0XG5cdGNvbnN0cnVjdG9yKHBvaW50TGlzdDogUG9pbnRORFtdKVxuXHR7XG5cdFx0dGhpcy5faW5kZXggPSAwO1xuXHRcdHRoaXMuX3BvaW50TGlzdCA9IHBvaW50TGlzdDtcblx0fVxuXG5cdHByaXZhdGUgX2luZGV4IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGluZGV4KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxuXG5cdHByaXZhdGUgX3BvaW50TGlzdCA6IFBvaW50TkRbXTtcblx0cHVibGljIGdldCBwb2ludExpc3QoKSA6IFBvaW50TkRbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50TGlzdDtcblx0fVxuXG5cdHB1YmxpYyBuZXh0KCk6IEl0ZXJhdG9yUmVzdWx0PFBvaW50TkQ+XG5cdHtcblx0XHRsZXQgcG9pbnQ6IFBvaW50TkQgPSB0aGlzLnBvaW50TGlzdFt0aGlzLmluZGV4XTtcblx0XHRsZXQgaXNEb25lOiBib29sZWFuID0gIHRoaXMuaW5kZXggPj0gdGhpcy5wb2ludExpc3QubGVuZ3RoO1xuXHRcdCsrdGhpcy5faW5kZXg7XG5cdFx0bGV0IGl0ZXJSZXN1bHQ6IEl0ZXJhdG9yUmVzdWx0PFBvaW50TkQ+ID0ge1xuXHRcdFx0dmFsdWU6IHBvaW50LFxuXHRcdFx0ZG9uZTogaXNEb25lXG5cdFx0fVxuXHRcdHJldHVybiBpdGVyUmVzdWx0O1xuXHR9XG5cbn0iLCJpbXBvcnQgeyBEZXZsaWJNYXRoIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYk1hdGgnO1xuaW1wb3J0IHsgRGV2bGliQWxnbyB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJBbGdvJztcbmltcG9ydCB7IEN1cnZlTkQgfSBmcm9tICcuL0N1cnZlTkQnO1xuaW1wb3J0IHsgUG9pbnRORCB9IGZyb20gJy4vUG9pbnRORCc7XG5pbXBvcnQgeyBQb2ludENvbGxlY3Rpb24sIHZhbHVlRmlsdGVyIH0gZnJvbSAnLi9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQ3VydmVMaXN0SXRlcmF0b3IgfSBmcm9tICcuL0N1cnZlTGlzdEl0ZXJhdG9yJztcbmltcG9ydCB7IEN1cnZlQ29sbGVjdGlvbiB9IGZyb20gJy4vQ3VydmVDb2xsZWN0aW9uJztcbmltcG9ydCB7IERhdGFzZXRTcGVjLCBGYWNldE9wdGlvbiwgRmFjZXQsIEFwcERhdGEsIExvY2F0aW9uTWFwTGlzdCwgTG9jYXRpb25NYXBUZW1wbGF0ZSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEN1cnZlTGlzdEZhY3RvcnkgfSBmcm9tICcuL0N1cnZlTGlzdEZhY3RvcnknO1xuXG5leHBvcnQgY2xhc3MgQ3VydmVMaXN0IGV4dGVuZHMgUG9pbnRDb2xsZWN0aW9uIGltcGxlbWVudHMgQXBwRGF0YTxEYXRhc2V0U3BlYz5cbntcblxuXHRjb25zdHJ1Y3RvcihjdXJ2ZUxpc3Q6IEN1cnZlTkRbXSwgc3BlYzogRGF0YXNldFNwZWMpXG5cdHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMuX2N1cnZlTGlzdCA9IGN1cnZlTGlzdDtcblx0XHR0aGlzLl9sZW5ndGggPSAwO1xuXHRcdGxldCBpID0gMDtcblx0XHR0aGlzLl9jdXJ2ZUxvb2t1cCA9IG5ldyBNYXA8c3RyaW5nLCBDdXJ2ZU5EPigpO1xuXHRcdGZvciAobGV0IGN1cnZlIG9mIHRoaXMuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdHRoaXMuY3VydmVMb29rdXAuc2V0KGN1cnZlLmlkLCBjdXJ2ZSk7XG5cdFx0XHR0aGlzLl9sZW5ndGggKz0gY3VydmUubGVuZ3RoO1xuXHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgY3VydmUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXNbaV0gPSBwb2ludDtcblx0XHRcdFx0KytpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9taW5NYXhNYXAgPSBuZXcgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4oKTtcblx0XHR0aGlzLl9sb2NhdGlvbkZyYW1lU2VnbWVudExvb2t1cCA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBbUG9pbnRORCwgbnVtYmVyXT4+PigpO1xuXHRcdC8vIHRoaXMuX2xvY2F0aW9uRnJhbWVTZWdtZW50TG9va3VwID0gbmV3IE1hcDxzdHJpbmcsIFtQb2ludE5ELCBudW1iZXJdPigpO1xuXHRcdGNvbnN0IGxvY2F0aW9uU2V0ID0gbmV3IFNldDxudW1iZXI+KCk7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdGxldCBwb2ludCA9IHRoaXNbaV0gYXMgUG9pbnRORDtcblx0XHRcdGxldCBsb2MgPSBwb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG5cdFx0XHRsb2NhdGlvblNldC5hZGQobG9jKTtcblx0XHRcdGlmICghdGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAuaGFzKGxvYykpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2xvY2F0aW9uRnJhbWVTZWdtZW50TG9va3VwLnNldChsb2MsIG5ldyBNYXAoKSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBsb2NNYXAgPSB0aGlzLl9sb2NhdGlvbkZyYW1lU2VnbWVudExvb2t1cC5nZXQobG9jKTtcblx0XHRcdGxldCBmcmFtZSA9IHBvaW50LmdldCgnRnJhbWUgSUQnKTtcblx0XHRcdGlmICghbG9jTWFwLmhhcyhmcmFtZSkpXG5cdFx0XHR7XG5cdFx0XHRcdGxvY01hcC5zZXQoZnJhbWUsIG5ldyBNYXAoKSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBzZWdNYXAgPSBsb2NNYXAuZ2V0KGZyYW1lKTtcblx0XHRcdGxldCBzZWdtZW50TGFiZWwgPSBwb2ludC5nZXQoJ3NlZ21lbnRMYWJlbCcpO1xuXHRcdFx0c2VnTWFwLnNldChzZWdtZW50TGFiZWwsIFtwb2ludCwgaSArIDFdKTtcblx0XHR9XG5cdFx0dGhpcy5fbG9jYXRpb25MaXN0ID0gQXJyYXkuZnJvbShsb2NhdGlvblNldCk7XG5cdFx0dGhpcy5sb2NhdGlvbkxpc3Quc29ydChEZXZsaWJBbGdvLnNvcnRBc2NlbmQpO1xuXHRcdHRoaXMuX2N1cnZlQ29sbGVjdGlvbiA9IG5ldyBDdXJ2ZUNvbGxlY3Rpb24odGhpcywgc3BlYyk7XG5cdFx0dGhpcy5fY3VydmVCcnVzaExpc3QgPSBuZXcgTWFwPHN0cmluZywgdmFsdWVGaWx0ZXJbXT4oKTtcblx0XHR0aGlzLlNwZWNpZmljYXRpb24gPSBzcGVjO1xuXHR9XG5cblxuXG5cdHByaXZhdGUgX2N1cnZlTGlzdCA6IEN1cnZlTkRbXTtcblx0cHVibGljIGdldCBjdXJ2ZUxpc3QoKSA6IEN1cnZlTkRbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnZlTGlzdDtcblx0fVxuXG5cdHByaXZhdGUgX2N1cnZlTG9va3VwIDogTWFwPHN0cmluZywgQ3VydmVORD47XG5cdHB1YmxpYyBnZXQgY3VydmVMb29rdXAoKSA6IE1hcDxzdHJpbmcsIEN1cnZlTkQ+IHtcblx0XHRyZXR1cm4gdGhpcy5fY3VydmVMb29rdXA7XG5cdH1cblxuXHRwcml2YXRlIF9jdXJ2ZUNvbGxlY3Rpb24gOiBDdXJ2ZUNvbGxlY3Rpb247XG5cdHB1YmxpYyBnZXQgY3VydmVDb2xsZWN0aW9uKCkgOiBDdXJ2ZUNvbGxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9jdXJ2ZUNvbGxlY3Rpb247XG5cdH1cblx0cHVibGljIHNldCBjdXJ2ZUNvbGxlY3Rpb24odiA6IEN1cnZlQ29sbGVjdGlvbikge1xuXHRcdHRoaXMuX2N1cnZlQ29sbGVjdGlvbiA9IHY7XG5cdH1cdFxuXG5cdHByaXZhdGUgX2lucHV0S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGlucHV0S2V5KCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9pbnB1dEtleTtcblx0fVxuXG5cdHByaXZhdGUgX21pbk1heE1hcCA6IE1hcDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl0+O1xuXHRwdWJsaWMgZ2V0IG1pbk1heE1hcCgpIDogTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4ge1xuXHRcdGlmICh0aGlzLl9taW5NYXhNYXAuc2l6ZSA9PT0gMClcblx0XHR7XG5cdFx0XHR0aGlzLnVwZGF0ZU1pbk1heE1hcCgpXG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taW5NYXhNYXA7XG5cdH1cblxuXHQvLyBwcml2YXRlIF9sb2NhdGlvbkZyYW1lU2VnbWVudExvb2t1cCA6IE1hcDxzdHJpbmcsIFtQb2ludE5ELCBudW1iZXJdPjtcblx0cHJpdmF0ZSBfbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAgOiBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBbUG9pbnRORCwgbnVtYmVyXT4+PjtcblxuXHRwcml2YXRlIF9sb2NhdGlvbkxpc3QgOiBudW1iZXJbXTtcblx0cHVibGljIGdldCBsb2NhdGlvbkxpc3QoKSA6IG51bWJlcltdIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9jYXRpb25MaXN0O1xuXHR9XHRcblxuXHRwdWJsaWMgR2V0Q2VsbHNBdEZyYW1lKGxvY2F0aW9uSWQ6IG51bWJlciwgZnJhbWVJZDogbnVtYmVyKTogUG9pbnRORFtdXG5cdHtcblx0XHRpZiAodGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAuaGFzKGxvY2F0aW9uSWQpKVxuXHRcdHtcblx0XHRcdGNvbnN0IGZyYW1lTWFwID0gdGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAuZ2V0KGxvY2F0aW9uSWQpO1xuXHRcdFx0aWYgKGZyYW1lTWFwLmhhcyhmcmFtZUlkKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc2VnTWFwID0gZnJhbWVNYXAuZ2V0KGZyYW1lSWQpO1xuXHRcdFx0XHRjb25zdCB0dXBsZWxpc3QgPSBzZWdNYXAudmFsdWVzKCk7XG5cdFx0XHRcdGxldCBwb2ludExpc3Q6IFBvaW50TkRbXSA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBbcG9pbnQsIF9dIG9mIHR1cGxlbGlzdClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBvaW50TGlzdC5wdXNoKHBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcG9pbnRMaXN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRwdWJsaWMgR2V0Q2VsbEZyb21MYWJlbChsb2NhdGlvbklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlciwgc2VnbWVudExhYmVsOiBudW1iZXIpOiBbUG9pbnRORCwgbnVtYmVyXSB8IFtudWxsLCBudWxsXVxuXHR7XG5cdFx0aWYgKHRoaXMuX2xvY2F0aW9uRnJhbWVTZWdtZW50TG9va3VwLmhhcyhsb2NhdGlvbklkKSlcblx0XHR7XG5cdFx0XHRjb25zdCBmcmFtZU1hcCA9IHRoaXMuX2xvY2F0aW9uRnJhbWVTZWdtZW50TG9va3VwLmdldChsb2NhdGlvbklkKTtcblx0XHRcdGlmIChmcmFtZU1hcC5oYXMoZnJhbWVJZCkpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHNlZ01hcCA9IGZyYW1lTWFwLmdldChmcmFtZUlkKTtcblx0XHRcdFx0aWYgKHNlZ01hcC5oYXMoc2VnbWVudExhYmVsKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBzZWdNYXAuZ2V0KHNlZ21lbnRMYWJlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFtudWxsLCBudWxsXTtcblx0fVxuXHRcblxuXHRwcml2YXRlIF9icnVzaEFwcGxpZWQgOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGJydXNoQXBwbGllZCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoQXBwbGllZDtcblx0fVxuXHRwdWJsaWMgc2V0IGJydXNoQXBwbGllZCh2IDogYm9vbGVhbikge1xuXHRcdHRoaXMuX2JydXNoQXBwbGllZCA9IHY7XG5cdH1cblx0XG5cdHByaXZhdGUgX2N1cnZlQnJ1c2hMaXN0IDogTWFwPHN0cmluZywgdmFsdWVGaWx0ZXJbXT47XG5cdHB1YmxpYyBnZXQgY3VydmVCcnVzaExpc3QoKSA6IE1hcDxzdHJpbmcsIHZhbHVlRmlsdGVyW10+IHtcblx0XHRyZXR1cm4gdGhpcy5fY3VydmVCcnVzaExpc3Q7XG5cdH1cdFxuXG5cdHByb3RlY3RlZCBnZXRGYWNldExpc3QobG9jYXRpb25NYXA6IExvY2F0aW9uTWFwTGlzdCB8IExvY2F0aW9uTWFwVGVtcGxhdGUpOiBGYWNldFtdXG5cdHtcblx0XHRyZXR1cm4gQ3VydmVMaXN0RmFjdG9yeS5DcmVhdGVGYWNldGVkRGF0YXNldHModGhpcywgbG9jYXRpb25NYXApO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y3VydmUuaW5CcnVzaCA9IHRydWU7XG5cdFx0XHRmb3IgKGxldCBwb2ludCBvZiBjdXJ2ZS5wb2ludExpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdHBvaW50LmluQnJ1c2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBzZXRzIGZpbHRlciB2YWx1ZXMgYXQgcG9pbnQgbGV2ZWxcblx0XHRjb25zdCBwb2ludEJydXNoQXBwbGllZDogYm9vbGVhbiA9IHRoaXMuU2V0QnJ1c2hWYWx1ZXMoKTtcblxuXHRcdC8vIHNldCB0cmFjayB0byBmYWxzZSBpZiBhbGwgdGhlIHBvaW50cyBpbiBhIHRyYWNrIGFyZSBhbHNvIGZhbHNlXG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0bGV0IGFsbFBvaW50c0hpZGRlbiA9IHRydWU7XG5cdFx0XHRmb3IgKGxldCBwb2ludCBvZiBjdXJ2ZS5wb2ludExpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChwb2ludC5pbkJydXNoKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YWxsUG9pbnRzSGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhbGxQb2ludHNIaWRkZW4pXG5cdFx0XHR7XG5cdFx0XHRcdGN1cnZlLmluQnJ1c2ggPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzZXRzIGZpbHRlciB2YWx1ZXMgYXQgdHJhY2sgbGV2ZWxcblx0XHRjb25zdCBjdXJ2ZUNvbGxlY3Rpb25CcnVzaEFwcGxpZWQ6IGJvb2xlYW4gPSB0aGlzLmN1cnZlQ29sbGVjdGlvbi5TZXRCcnVzaFZhbHVlcygpO1xuXHRcdGNvbnN0IGN1cnZlQnJ1c2hBcHBsaWVkOiBib29sZWFuID0gdGhpcy5zZXRDdXJ2ZUJydXNoVmFsdWVzKCk7XG5cdFx0dGhpcy5fYnJ1c2hBcHBsaWVkID0gcG9pbnRCcnVzaEFwcGxpZWQgfHwgY3VydmVCcnVzaEFwcGxpZWQgfHwgY3VydmVDb2xsZWN0aW9uQnJ1c2hBcHBsaWVkO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRDdXJ2ZUJydXNoVmFsdWVzKCk6IGJvb2xlYW5cblx0e1xuXHRcdGxldCBicnVzaEFwcGxpZWQgPSBmYWxzZTtcblx0XHRmb3IgKGxldCBjdXJ2ZSBvZiB0aGlzLmN1cnZlTGlzdClcblx0XHR7XG5cdFx0XHRsZXQgYWxsUG9pbnRzT3V0T2ZCcnVzaCA9IHRydWU7XG5cdFx0XHRmb3IgKGxldCBwb2ludCBvZiBjdXJ2ZS5wb2ludExpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmlzUG9pbnRJbkN1cnZlQnJ1c2hMaXN0KHBvaW50KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFBvaW50c091dE9mQnJ1c2ggPSBmYWxzZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFsbFBvaW50c091dE9mQnJ1c2gpXG5cdFx0XHR7XG5cdFx0XHRcdGN1cnZlLmluQnJ1c2ggPSBmYWxzZTtcblx0XHRcdFx0YnJ1c2hBcHBsaWVkID0gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYnJ1c2hBcHBsaWVkO1xuXHR9XG5cblx0cHJpdmF0ZSBpc1BvaW50SW5DdXJ2ZUJydXNoTGlzdChwb2ludDogUG9pbnRORCk6IGJvb2xlYW5cblx0e1xuXHRcdGZvciAobGV0IHZhbHVlRmlsdGVyTGlzdCBvZiB0aGlzLmN1cnZlQnJ1c2hMaXN0LnZhbHVlcygpKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IHZhbHVlRmlsdGVyIG9mIHZhbHVlRmlsdGVyTGlzdClcblx0XHRcdHtcblx0XHRcdFx0aWYgKCFQb2ludENvbGxlY3Rpb24uSXNJbkJydXNoKHBvaW50LCB2YWx1ZUZpbHRlcikpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZU1pbk1heE1hcCgpXG5cdHtcblx0XHRmb3IgKGxldCBjdXJ2ZSBvZiB0aGlzLmN1cnZlTGlzdClcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBwb2ludCBvZiBjdXJ2ZS5wb2ludExpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBwb2ludC52YWx1ZU1hcClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBjdXJyZW50VmFsID0gdGhpcy5fbWluTWF4TWFwLmdldChrZXkpO1xuXHRcdFx0XHRcdGxldCBwb2ludFZhbCA9IHBvaW50LmdldChrZXkpO1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3VycmVudFZhbCA9PT0gXCJ1bmRlZmluZWRcIilcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLl9taW5NYXhNYXAuc2V0KGtleSwgW3BvaW50VmFsLCBwb2ludFZhbF0pO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCBbYzEsIGMyXSA9IGN1cnJlbnRWYWw7XG5cdFx0XHRcdFx0bGV0IG5ld1ZhbDogW251bWJlciwgbnVtYmVyXSA9IFtNYXRoLm1pbihjMSwgcG9pbnRWYWwpLCBNYXRoLm1heChjMiwgcG9pbnRWYWwpXTtcblx0XHRcdFx0XHR0aGlzLl9taW5NYXhNYXAuc2V0KGtleSwgbmV3VmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaW5pdFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y3VydmUuYWRkVmFsdWUoa2V5LCB2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBpc0tleVNldChrZXk6IHN0cmluZyk6IGJvb2xlYW5cblx0e1xuXHRcdGZvciAobGV0IGN1cnZlIG9mIHRoaXMuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGxldCB2YWx1ZTogbnVtYmVyIHwgdW5kZWZpbmVkID0gY3VydmUuZ2V0KGtleSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cHVibGljIHNldElucHV0S2V5KGtleTogc3RyaW5nKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5faW5wdXRLZXkgPSBrZXk7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y3VydmUuc29ydChrZXkpO1xuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyByZW1vdmVDdXJ2ZUJydXNoKGJydXNoS2V5OiBzdHJpbmcpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmN1cnZlQnJ1c2hMaXN0LmRlbGV0ZShicnVzaEtleSk7XG5cdFx0dGhpcy51cGRhdGVCcnVzaCgpO1xuXHR9XG5cblx0cHVibGljIGFkZEN1cnZlQnJ1c2goYnJ1c2hLZXk6IHN0cmluZywgZmlsdGVyczogdmFsdWVGaWx0ZXJbXSk6IHZvaWRcblx0e1xuXHRcdHRoaXMuY3VydmVCcnVzaExpc3Quc2V0KGJydXNoS2V5LCBmaWx0ZXJzKTtcblx0XHR0aGlzLnVwZGF0ZUJydXNoKCk7XG5cdH1cblxuXHRwdWJsaWMgc29ydChrZXk6IHN0cmluZywgYXNjZW5kOiBib29sZWFuID0gdHJ1ZSk6IHZvaWRcblx0e1xuXHRcdGxldCBzb3J0RnVuY3Rpb24gPSBEZXZsaWJBbGdvLnNvcnRPblByb3BlcnR5PEN1cnZlTkQ+KChjdXJ2ZTogQ3VydmVORCkgPT4gXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGN1cnZlLmdldChrZXkpO1xuXHRcdH0sIGFzY2VuZCk7XG5cdFx0dGhpcy5jdXJ2ZUxpc3Quc29ydChzb3J0RnVuY3Rpb24pO1xuXHR9XG5cblx0cHVibGljIGdldFBvaW50c0F0SW5wdXQoaW5wdXRWYWx1ZTogbnVtYmVyKTogUG9pbnRORFtdXG5cdHtcblx0XHRsZXQgcG9pbnRMaXN0OiBQb2ludE5EW10gPSBbXTtcblx0XHRmb3IgKGxldCBjdXJ2ZSBvZiB0aGlzLmN1cnZlTGlzdClcblx0XHR7XG5cdFx0XHRsZXQgcG9pbnQgPSBjdXJ2ZS5nZXRQb2ludChpbnB1dFZhbHVlKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKHBvaW50KTtcblx0XHRcdGlmIChwb2ludClcblx0XHRcdHtcblx0XHRcdFx0cG9pbnRMaXN0LnB1c2gocG9pbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwb2ludExpc3Q7XG5cdH1cblxuXHRwdWJsaWMgY2FsY3VsYXRlRGVwdGgoZGVwdGhLZXk6IHN0cmluZywgdmFsdWVLZXk6IHN0cmluZyk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmlzS2V5U2V0KGRlcHRoS2V5KSlcblx0XHR7XG5cdFx0XHQvLyBkZXB0aCBpcyBhbHJlYWR5IHNldFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmluaXRWYWx1ZShkZXB0aEtleSwgMCk7XG5cblx0XHRjb25zdCBhbGxCYW5kcyA9IEN1cnZlTGlzdC5nZXRBbGxQb3NzaWJsZTJCYW5kcyh0aGlzLmN1cnZlTGlzdCkgYXMgW0N1cnZlTkQsIEN1cnZlTkRdW107XG5cdFx0Zm9yIChsZXQgYmFuZCBvZiBhbGxCYW5kcylcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBjdXJ2ZSBvZiB0aGlzLmN1cnZlTGlzdClcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgZGVwdGhDb250cmlidXRpb24gPSB0aGlzLmdldERlcHRoQ29udHJpYnV0aW9uKGN1cnZlLCBiYW5kLCB2YWx1ZUtleSk7XG5cdFx0XHRcdGNvbnN0IG9sZERlcHRoID0gY3VydmUuZ2V0KGRlcHRoS2V5KTtcblx0XHRcdFx0Y3VydmUuYWRkVmFsdWUoZGVwdGhLZXksIG9sZERlcHRoICsgZGVwdGhDb250cmlidXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRvZG8gLSBub3JtYWxpemVcblxuXHR9XG5cblx0cHJpdmF0ZSBnZXREZXB0aENvbnRyaWJ1dGlvbihjdXJ2ZTogQ3VydmVORCwgW2IxLCBiMl06IFtDdXJ2ZU5ELCBDdXJ2ZU5EXSwgdmFsdWVLZXk6IHN0cmluZyk6IG51bWJlclxuXHR7XG5cdFx0bGV0IGRlcHRoID0gMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGN1cnZlLnBvaW50TGlzdC5sZW5ndGg7IGkrKylcblx0XHR7XG5cdFx0XHRsZXQgcG9pbnQ6IFBvaW50TkQgPSBjdXJ2ZS5wb2ludExpc3RbaV07XG5cdFx0XHRjb25zdCB0ID0gcG9pbnQuZ2V0KHRoaXMuaW5wdXRLZXkpO1xuXHRcdFx0bGV0IHRoaXNWYWwgPSBwb2ludC5nZXQodmFsdWVLZXkpO1xuXHRcdFx0bGV0IGIxVmFsID0gYjEuZ2V0UG9pbnRWYWx1ZSh0LCB2YWx1ZUtleSk7XG5cdFx0XHRsZXQgYjJWYWwgPSBiMi5nZXRQb2ludFZhbHVlKHQsIHZhbHVlS2V5KTtcblx0XHRcdGxldCBtaW5WYWwgPSBNYXRoLm1pbihiMVZhbCwgYjJWYWwpO1xuXHRcdFx0bGV0IG1heFZhbCA9IE1hdGgubWF4KGIxVmFsLCBiMlZhbCk7XG5cdFx0XHRpZiAobWluVmFsIDw9IHRoaXNWYWwgJiYgdGhpc1ZhbCA8PSBtYXhWYWwpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHdlaWdodCA9IGN1cnZlLmdldFBvaW50V2VpZ2h0KGkpO1xuXHRcdFx0XHRkZXB0aCArPSB3ZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXB0aDtcblx0fVxuXG5cdHN0YXRpYyBnZXRBbGxQb3NzaWJsZTJCYW5kcyhsaXN0OiBhbnlbXSk6IFthbnksIGFueV1bXVxuXHR7XG5cdFx0Y29uc3QgYmFuZExpc3Q6IFthbnksIGFueV1bXSA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKylcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBqID0gaSArIDE7IGogPCBsaXN0Lmxlbmd0aDsgaisrKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYjogW2FueSwgYW55XSA9IFtsaXN0W2ldLCBsaXN0W2pdXTtcblx0XHRcdFx0YmFuZExpc3QucHVzaChiKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJhbmRMaXN0XG5cdH1cblxuXHRbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYXRvcjxQb2ludE5EPlxuXHR7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxpc3RJdGVyYXRvcih0aGlzLmN1cnZlTGlzdCk7XG5cdH1cblxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IERldmxpYk1hdGggfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliTWF0aCc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3QgfSBmcm9tICcuL0N1cnZlTGlzdCc7XG5pbXBvcnQgeyBDdXJ2ZU5EIH0gZnJvbSAnLi9DdXJ2ZU5EJztcbmltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuL1BvaW50TkQnO1xuaW1wb3J0IHsgU3RyaW5nVG9TdHJpbmdPYmosIFN0cmluZ1RvTnVtYmVyT2JqLCBLZXllZFRyYWNrRGVyaXZhdGlvbkZ1bmN0aW9uLCBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uIH0gZnJvbSAnLi4vZGV2bGliL0RldkxpYlR5cGVzJ1xuaW1wb3J0IHsgRGF0YXNldFNwZWMsIEZhY2V0LCBMb2NhdGlvbk1hcExpc3QsIExvY2F0aW9uTWFwVGVtcGxhdGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBTdHJpbmdUb051bWJlck9yTGlzdCB7XG4gICAgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgU3RyaW5nVG9OdW1iZXJPYmpbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEN1cnZlTGlzdEZhY3Rvcnkge1xuXG5cdHB1YmxpYyBzdGF0aWMgQ3JlYXRlRmFjZXRlZERhdGFzZXRzKGZ1bGxEYXRhOiBDdXJ2ZUxpc3QsIGxvY2F0aW9uTWFwOiBMb2NhdGlvbk1hcExpc3QgfCBMb2NhdGlvbk1hcFRlbXBsYXRlKTogRmFjZXRbXVxuXHR7XG5cdFx0bGV0IGxvY1RvQ2F0OiBNYXA8bnVtYmVyLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXHRcdFxuXHRcdGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhsb2NhdGlvbk1hcCkpXG5cdFx0e1xuXHRcdFx0bGV0IHZhbHVlTGlzdCA9IGxvY2F0aW9uTWFwW2tleV07XG5cdFx0XHRpZiAodmFsdWVMaXN0Lmxlbmd0aCA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdMb2NhdGlvbk1hcCB2YWx1ZUxpc3Qgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5Jylcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgdmFsdWVMaXN0WzBdID09PSAnc3RyaW5nJylcblx0XHRcdHtcblx0XHRcdFx0Ly8gdG9kbyB3b3JrIGZvciBsb2NhdGlvbm1hcHRlbWFwbGF0ZSB0eXBlXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IFtsb3csIGhpZ2hdIG9mIHZhbHVlTGlzdClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSArbG93OyBpIDw9ICtoaWdoOyBpKyspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bG9jVG9DYXQuc2V0KGksIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHBvaW50TWFwOiBNYXA8c3RyaW5nLCBDdXJ2ZU5EW10+ID0gbmV3IE1hcCgpO1xuXG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgZnVsbERhdGEuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGxldCBmaXJzdFBvaW50ID0gY3VydmUucG9pbnRMaXN0WzBdO1xuXHRcdFx0bGV0IGxvY2F0aW9uID0gZmlyc3RQb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG5cdFx0XHRsZXQgY2F0ZWdvcnkgPSBsb2NUb0NhdC5nZXQobG9jYXRpb24pO1xuXHRcdFx0aWYgKCFwb2ludE1hcC5oYXMoY2F0ZWdvcnkpKVxuXHRcdFx0e1xuXHRcdFx0XHRwb2ludE1hcC5zZXQoY2F0ZWdvcnksIFtdKTtcblx0XHRcdH1cblx0XHRcdHBvaW50TWFwLmdldChjYXRlZ29yeSkucHVzaChjdXJ2ZSk7XG5cdFx0fVxuXG5cdFx0bGV0IGZhY2V0TGlzdCA9IFtdO1xuXHRcdGZvciAobGV0IFtjYXQsIGxpc3RPZkN1cnZlc10gb2YgcG9pbnRNYXApXG5cdFx0e1xuXHRcdFx0bGV0IGN1cnZlTGlzdCA9IG5ldyBDdXJ2ZUxpc3QobGlzdE9mQ3VydmVzLCBmdWxsRGF0YS5TcGVjaWZpY2F0aW9uKTtcblx0XHRcdGxldCBmYWNldDogRmFjZXQgPSB7XG5cdFx0XHRcdG5hbWU6IGNhdCxcblx0XHRcdFx0ZGF0YTogY3VydmVMaXN0XG5cdFx0XHR9XG5cdFx0XHRmYWNldExpc3QucHVzaChmYWNldCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWNldExpc3Q7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIENyZWF0ZUN1cnZlTGlzdEZyb21DU1ZPYmplY3QoY3N2T2JqZWN0OiBkMy5EU1ZSb3dBcnJheTxzdHJpbmc+LCBkZXJpdmVkVHJhY2tEYXRhRnVuY3Rpb25zOiBLZXllZFRyYWNrRGVyaXZhdGlvbkZ1bmN0aW9uW10sIGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnM6IEtleWVkUG9pbnREZXJpdmF0aW9uRnVuY3Rpb25bXSwgZGF0YVNwZWM6IERhdGFzZXRTcGVjLCBpZGtleTogc3RyaW5nID0gXCJpZFwiLCB0S2V5T3B0aW9uczogc3RyaW5nW10gPSBbXCJUaW1lIChoKVwiXSk6IEN1cnZlTGlzdFxuXHR7XG5cdFx0Y29uc29sZS5sb2coY3N2T2JqZWN0KTtcblx0XHRjb25zdCBjdXJ2ZUxpc3Q6IEN1cnZlTkRbXSA9IFtdO1xuXHRcdGxldCB0S2V5OiBzdHJpbmcgPSBudWxsO1xuXHRcdGZvciAobGV0IGtleU9wdGlvbiBvZiB0S2V5T3B0aW9ucylcblx0XHR7XG5cdFx0XHRpZiAoY3N2T2JqZWN0LmNvbHVtbnMuaW5jbHVkZXMoa2V5T3B0aW9uKSlcblx0XHRcdHtcblx0XHRcdFx0dEtleSA9IGtleU9wdGlvbjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh0S2V5ID09IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRGF0YXNldCBkb2VzIG5vdCBjb250YWluIGFueSB0S2V5IGNvbHVtbi4gQWxsb3dlZCBLZXlzOiBcIiArIHRLZXlPcHRpb25zLnRvU3RyaW5nKCkpXG5cdFx0fVxuXG5cdFx0bGV0IHBvam9MaXN0ID0gZDMubmVzdDxTdHJpbmdUb1N0cmluZ09iaiwgU3RyaW5nVG9OdW1iZXJPckxpc3Q+KClcblx0XHRcdC5rZXkoZCA9PiBkW2lka2V5XSlcblx0XHRcdC5yb2xsdXAoKHJvd3M6IGFueVtdKSA9PlxuXHRcdFx0eyBcblx0XHRcdFx0Y29uc3QgdmFsdWVzOiBTdHJpbmdUb051bWJlck9yTGlzdCA9IHt9O1xuXHRcdFx0XHRjb25zdCBwb2ludHM6IFN0cmluZ1RvTnVtYmVyT2JqW10gPSBbXTtcblx0XHRcdFx0Zm9yIChsZXQgcm93IG9mIHJvd3MpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB0VmFsdWU6IHN0cmluZyA9IHJvd1t0S2V5XTtcblx0XHRcdFx0XHRpZiAoIURldmxpYk1hdGguaXNOdW1iZXIodFZhbHVlKSlcblx0XHRcdFx0XHR7XG5cblx0XHRcdFx0XHRcdGZvciAobGV0IGtleSBpbiByb3cpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGlmIChrZXkgPT09IGlka2V5IHx8IGtleSA9PT0gdEtleSlcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gcm93W2tleV07XG5cdFx0XHRcdFx0XHRcdGlmICghRGV2bGliTWF0aC5pc051bWJlcilcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1t0VmFsdWVdID0gK3ZhbHVlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBwb2ludDogU3RyaW5nVG9OdW1iZXJPYmogPSB7fTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGtleSBpbiByb3cpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGtleSA9PT0gaWRrZXkpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cG9pbnRba2V5XSA9ICtyb3dba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNvbnN0IHNvcnRGdW5jdGlvbiA9IERldmxpYk1hdGguc29ydE9uUHJvcGVydHk8U3RyaW5nVG9OdW1iZXJPYmo+KG9iaiA9PiBvYmpbdEtleV0pO1xuXHRcdFx0XHQvLyBwb2ludHMuc29ydChzb3J0RnVuY3Rpb24pO1xuXG5cdFx0XHRcdHZhbHVlcy5wb2ludHMgPSBwb2ludHM7XG5cdFx0XHRcdEN1cnZlTGlzdEZhY3RvcnkuY2FsY3VsYXRlRGVyaXZlZFRyYWNrVmFsdWVzKHZhbHVlcywgZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9ucyk7XG5cdFx0XHRcdEN1cnZlTGlzdEZhY3RvcnkuY2FsY3VsYXRlRGVyaXZlZFBvaW50VmFsdWVzKHZhbHVlcywgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9ucyk7XG5cdFx0XHRcdC8vIHRvZG8gYWRkIHBvaW50IGRlcml2ZWQgZnVuY3Rpb25zIC0gYWxzbyBzaG91bGQgcHVsbCB0aGlzIG91dCBpbnRvIGEgZnVuY3Rpb25cblx0XHRcdFx0Ly8gZm9yIChsZXQgW2F0dHJOYW1lTGlzdCwgZnVuY10gb2YgZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9ucylcblx0XHRcdFx0Ly8ge1xuXHRcdFx0XHQvLyBcdGxldCB2YWx1ZUxpc3QgPSBmdW5jKHBvaW50cyk7XG5cdFx0XHRcdC8vIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyTmFtZUxpc3QubGVuZ3RoOyBpKyspXG5cdFx0XHRcdC8vIFx0e1xuXHRcdFx0XHQvLyBcdFx0bGV0IGF0dHJOYW1lID0gYXR0ck5hbWVMaXN0W2ldO1xuXHRcdFx0XHQvLyBcdFx0bGV0IHZhbCA9IHZhbHVlTGlzdFtpXTtcblx0XHRcdFx0Ly8gXHRcdHZhbHVlc1thdHRyTmFtZV0gPSB2YWw7XG5cdFx0XHRcdC8vIFx0fVxuXHRcdFx0XHQvLyB9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9KVxuXHRcdFx0LmVudHJpZXMoY3N2T2JqZWN0KTtcblxuXHRcdGZvciAobGV0IHBsYWluQ3VydmUgb2YgcG9qb0xpc3QpXG5cdFx0e1xuXHRcdFx0bGV0IG51bWVyaWNLZXkgPSArcGxhaW5DdXJ2ZS5rZXk7XG5cdFx0XHQvLyBqcyBmb3JtYXRzIHRoZSBudW1iZXIgYXMgJzEyMy4wJywgSW5zdGVhZCBJIHdhbnQgJzEyMydcblx0XHRcdGNvbnN0IGN1cnZlID0gbmV3IEN1cnZlTkQobnVtZXJpY0tleS50b1N0cmluZygpKTtcblx0XHRcdGZvciAobGV0IGtleSBpbiBwbGFpbkN1cnZlLnZhbHVlKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBwbGFpbkN1cnZlLnZhbHVlW2tleV07XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjdXJ2ZS5hZGRWYWx1ZShrZXksIHZhbHVlKTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGxldCBwb2pvUG9pbnQgb2YgdmFsdWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBwb2ludCA9IG5ldyBQb2ludE5EKHBvam9Qb2ludCk7XG5cdFx0XHRcdFx0Y3VydmUuYWRkUG9pbnQocG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdXJ2ZUxpc3QucHVzaChjdXJ2ZSk7XG5cdFx0fVxuXHRcdC8vIGNvbnNvbGUubG9nKGN1cnZlTGlzdCk7XG5cdFx0Y29uc3QgY3VydmVMaXN0T2JqID0gbmV3IEN1cnZlTGlzdChjdXJ2ZUxpc3QsIGRhdGFTcGVjKTtcblx0XHRjdXJ2ZUxpc3RPYmouc2V0SW5wdXRLZXkodEtleSk7XG5cdFx0cmV0dXJuIGN1cnZlTGlzdE9iajtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGNhbGN1bGF0ZURlcml2ZWRUcmFja1ZhbHVlcyh2YWx1ZXM6IFN0cmluZ1RvTnVtYmVyT3JMaXN0LCBkZXJpdmVkVHJhY2tEYXRhRnVuY3Rpb25zOiBLZXllZFRyYWNrRGVyaXZhdGlvbkZ1bmN0aW9uW10pOiB2b2lkXG5cdHtcblx0XHRsZXQgcG9pbnRzOiBTdHJpbmdUb051bWJlck9ialtdID0gdmFsdWVzLnBvaW50cyBhcyBTdHJpbmdUb051bWJlck9ialtdO1xuXHRcdGZvciAobGV0IFthdHRyTmFtZUxpc3QsIGZ1bmNdIG9mIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnMpXG5cdFx0e1xuXHRcdFx0bGV0IHZhbHVlTGlzdCA9IGZ1bmMocG9pbnRzKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ck5hbWVMaXN0Lmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYXR0ck5hbWUgPSBhdHRyTmFtZUxpc3RbaV07XG5cdFx0XHRcdGxldCB2YWwgPSB2YWx1ZUxpc3RbaV07XG5cdFx0XHRcdHZhbHVlc1thdHRyTmFtZV0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlRGVyaXZlZFBvaW50VmFsdWVzKHZhbHVlczogU3RyaW5nVG9OdW1iZXJPckxpc3QsIGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnM6IEtleWVkUG9pbnREZXJpdmF0aW9uRnVuY3Rpb25bXSk6IHZvaWRcblx0e1xuXHRcdGxldCBwb2ludHM6IFN0cmluZ1RvTnVtYmVyT2JqW10gPSB2YWx1ZXMucG9pbnRzIGFzIFN0cmluZ1RvTnVtYmVyT2JqW107XG5cdFx0Zm9yIChsZXQgW2F0dHJOYW1lTGlzdCwgZnVuY10gb2YgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9ucylcblx0XHR7XG5cdFx0XHRsZXQgdmFsdWVMaXN0T2ZMaXN0cyA9IGZ1bmMocG9pbnRzKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXR0ck5hbWVMaXN0Lmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYXR0ck5hbWUgPSBhdHRyTmFtZUxpc3RbaV07XG5cdFx0XHRcdGxldCB2YWx1ZUxpc3QgPSB2YWx1ZUxpc3RPZkxpc3RzW2ldO1xuXHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGorKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHBvaW50c1tqXVthdHRyTmFtZV0gPSB2YWx1ZUxpc3Rbal07XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSIsImltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuL1BvaW50TkQnO1xuaW1wb3J0IHsgQ3VydmVORCB9IGZyb20gJy4vQ3VydmVORCc7XG5pbXBvcnQgeyBDdXJ2ZUl0ZXJhdG9yIH0gZnJvbSAnLi9DdXJ2ZUl0ZXJhdG9yJztcblxuZXhwb3J0IGNsYXNzIEN1cnZlTGlzdEl0ZXJhdG9yIGltcGxlbWVudHMgSXRlcmF0b3I8UG9pbnRORD4ge1xuXHRcblx0Y29uc3RydWN0b3IoY3VydmVMaXN0OiBDdXJ2ZU5EW10pXG5cdHtcblx0XHR0aGlzLl9jdXJ2ZUxpc3QgPSBjdXJ2ZUxpc3Q7XG5cdFx0dGhpcy51cGRhdGVDdXJ2ZUl0ZXJhdG9yKDApO1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgaW5kZXgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9XG5cblx0cHJpdmF0ZSBfY3VydmVMaXN0IDogQ3VydmVORFtdO1xuXHRwdWJsaWMgZ2V0IGN1cnZlTGlzdCgpIDogQ3VydmVORFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VydmVMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY3VycmVudEN1cnZlSXRlcmF0b3IgOiBDdXJ2ZUl0ZXJhdG9yO1xuXHRwdWJsaWMgZ2V0IGN1cnJlbnRDdXJ2ZUl0ZXJhdG9yKCkgOiBDdXJ2ZUl0ZXJhdG9yIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudEN1cnZlSXRlcmF0b3I7XG5cdH1cblxuXHRwdWJsaWMgbmV4dCgpOiBJdGVyYXRvclJlc3VsdDxQb2ludE5EPlxuXHR7XG5cdFx0bGV0IG5leHRSZXN1bHQgPSB0aGlzLmN1cnJlbnRDdXJ2ZUl0ZXJhdG9yLm5leHQoKTtcblx0XHRpZiAoIW5leHRSZXN1bHQuZG9uZSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV4dFJlc3VsdDtcblx0XHR9XG5cdFx0bGV0IG5ld0luZGV4ID0gdGhpcy5pbmRleCArIDE7XG5cdFx0aWYgKG5ld0luZGV4ID49IHRoaXMuY3VydmVMaXN0Lmxlbmd0aClcblx0XHR7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkb25lOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkXG5cdFx0XHR9O1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUN1cnZlSXRlcmF0b3IobmV3SW5kZXgpO1xuXHRcdHJldHVybiB0aGlzLm5leHQoKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlQ3VydmVJdGVyYXRvcihuZXdJbmRleDogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5faW5kZXggPSBuZXdJbmRleDtcblx0XHRsZXQgbmV4dEN1cnZlID0gdGhpcy5jdXJ2ZUxpc3RbbmV3SW5kZXhdO1xuXHRcdGlmIChuZXh0Q3VydmUpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY3VycmVudEN1cnZlSXRlcmF0b3IgPSBuZXcgQ3VydmVJdGVyYXRvcihuZXh0Q3VydmUucG9pbnRMaXN0KTtcblx0XHR9XG5cdH1cblxuXG59IiwiaW1wb3J0IHsgTkRpbSB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUeXBlcydcbmltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuL1BvaW50TkQnO1xuaW1wb3J0IHsgRGV2bGliQWxnbyB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJBbGdvJztcbmltcG9ydCB7IFBvaW50Q29sbGVjdGlvbiB9IGZyb20gJy4vUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IEN1cnZlSXRlcmF0b3IgfSBmcm9tICcuL0N1cnZlSXRlcmF0b3InO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBDdXJ2ZU5EIGV4dGVuZHMgUG9pbnRDb2xsZWN0aW9uIGltcGxlbWVudHMgTkRpbSB7XG5cdFxuXHRjb25zdHJ1Y3RvcihpZDogc3RyaW5nKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdHRoaXMuX3ZhbHVlTWFwID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblx0XHR0aGlzLl9wb2ludExpc3QgPSBbXTtcblx0XHR0aGlzLl9pbkJydXNoID0gdHJ1ZTtcblx0fVxuXG5cdHByaXZhdGUgX2lkIDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGlkKCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fVxuXG5cdHByaXZhdGUgX2lucHV0S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGlucHV0S2V5KCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9pbnB1dEtleTtcblx0fVxuXG5cdHByaXZhdGUgX3ZhbHVlTWFwIDogTWFwPHN0cmluZywgbnVtYmVyPjtcblx0cHVibGljIGdldCB2YWx1ZU1hcCgpIDogTWFwPHN0cmluZywgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWFwO1xuXHR9XG5cblx0cHJpdmF0ZSBfcG9pbnRMaXN0IDogUG9pbnRORFtdO1xuXHRwdWJsaWMgZ2V0IHBvaW50TGlzdCgpIDogUG9pbnRORFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnRMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5CcnVzaCA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaW5CcnVzaCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luQnJ1c2g7XG5cdH1cblxuXHRwdWJsaWMgc2V0IGluQnJ1c2godjogYm9vbGVhbikge1xuXHRcdHRoaXMuX2luQnJ1c2ggPSB2O1xuXHRcdGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRMaXN0KVxuXHRcdHtcblx0XHRcdHBvaW50LmluQnJ1c2ggPSB2O1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCBnZXRGYWNldExpc3QoKTogRmFjZXRbXVxuXHR7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQuJyk7XG5cdH1cblxuXHRwdWJsaWMgT25CcnVzaENoYW5nZSgpOiB2b2lkIHsgfVxuXG5cdHB1YmxpYyBhZGRWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IG51bWJlcilcblx0e1xuXHRcdHRoaXMudmFsdWVNYXAuc2V0KGtleSwgdmFsdWUpO1xuXHR9XG5cblx0cHVibGljIGdldChrZXk6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZFxuXHR7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVNYXAuZ2V0KGtleSk7XG5cdH1cblxuXHQvLyBmaW5kcyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHdpdGggZ2l2ZW4ga2V5LiBXaWxsIGludGVycG9sYXRlLlxuXHRwdWJsaWMgZ2V0UG9pbnRWYWx1ZShpbnB1dFZhbHVlOiBudW1iZXIsIG91dHB1dEtleTogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkXG5cdHtcblx0XHRsZXQgc29ydEZ1bmN0aW9uID0gRGV2bGliQWxnby5jb21wYXJlUHJvcGVydHk8UG9pbnRORD4oaW5wdXRWYWx1ZSwgKHBvaW50OiBQb2ludE5EKSA9PiBcblx0XHR7XG5cdFx0XHRyZXR1cm4gcG9pbnQuZ2V0KHRoaXMuaW5wdXRLZXkpO1xuXHRcdH0pO1xuXHRcdGxldCBwb2ludEluZGV4OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdO1xuXHRcdHBvaW50SW5kZXggPSBEZXZsaWJBbGdvLkJpbmFyeVNlYXJjaEluZGV4KHRoaXMucG9pbnRMaXN0LCBzb3J0RnVuY3Rpb24pO1xuXG5cdFx0aWYgKHR5cGVvZiBwb2ludEluZGV4ID09PSBcIm51bWJlclwiKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnBvaW50TGlzdFtwb2ludEluZGV4XS5nZXQob3V0cHV0S2V5KTtcblx0XHR9XG5cdFx0Y29uc3QgW2lkeDEsIGlkeDJdID0gcG9pbnRJbmRleDtcblx0XHRpZiAoaWR4MSA9PT0gdW5kZWZpbmVkIHx8IGlkeDIgPT09IHVuZGVmaW5lZClcblx0XHR7XG5cdFx0XHQvLyBvdXQgb2YgYm91bmRzXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRjb25zdCBwb2ludDEgPSB0aGlzLnBvaW50TGlzdFtpZHgxXTtcblx0XHRjb25zdCBwb2ludDIgPSB0aGlzLnBvaW50TGlzdFtpZHgyXTtcblxuXHRcdGNvbnN0IHZhbDEgPSBwb2ludDEuZ2V0KG91dHB1dEtleSk7XG5cdFx0Y29uc3QgdmFsMiA9IHBvaW50Mi5nZXQob3V0cHV0S2V5KTtcblxuXHRcdGNvbnN0IHQxID0gcG9pbnQxLmdldCh0aGlzLmlucHV0S2V5KTtcblx0XHRjb25zdCB0MiA9IHBvaW50Mi5nZXQodGhpcy5pbnB1dEtleSk7XG5cblx0XHRjb25zdCB0RGlmZiA9IHQyIC0gdDE7XG5cdFx0Y29uc3QgcG9ydGlvbiA9IChpbnB1dFZhbHVlIC0gdDEpIC8gdERpZmY7XG5cdFx0Y29uc3QgdmFsRGlmZiA9IHZhbDIgLSB2YWwxO1xuXG5cdFx0cmV0dXJuIHZhbDEgKyB2YWxEaWZmICogcG9ydGlvbjtcblx0fVxuXG5cdC8vIGZpbmRzIHBvaW50IGF0IGdpdmVuIGlucHV0IHRpbWUuIFdpbGwgY29uc3RydWN0IGEgbmV3IHBvaW50IGFuZCBpbnRlcnBvbGF0ZSBhbGwgdmFsdWVzIGlmIGl0IGlzIGJldHdlZW4gcG9pbnRzXG5cdHB1YmxpYyBnZXRQb2ludChpbnB1dFZhbHVlOiBudW1iZXIpOiBQb2ludE5EXG5cdHtcblx0XHRsZXQgc29ydEZ1bmN0aW9uID0gRGV2bGliQWxnby5jb21wYXJlUHJvcGVydHk8UG9pbnRORD4oaW5wdXRWYWx1ZSwgKHBvaW50OiBQb2ludE5EKSA9PiBcblx0XHR7XG5cdFx0XHRyZXR1cm4gcG9pbnQuZ2V0KHRoaXMuaW5wdXRLZXkpO1xuXHRcdH0pO1xuXHRcdGxldCBwb2ludEluZGV4OiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdO1xuXHRcdHBvaW50SW5kZXggPSBEZXZsaWJBbGdvLkJpbmFyeVNlYXJjaEluZGV4KHRoaXMucG9pbnRMaXN0LCBzb3J0RnVuY3Rpb24pO1xuXHRcdGlmICh0eXBlb2YgcG9pbnRJbmRleCA9PT0gXCJudW1iZXJcIilcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5wb2ludExpc3RbcG9pbnRJbmRleF07XG5cdFx0fVxuXHRcdGNvbnN0IFtpZHgxLCBpZHgyXSA9IHBvaW50SW5kZXg7XG5cdFx0aWYgKGlkeDEgPT09IHVuZGVmaW5lZCB8fCBpZHgyID09PSB1bmRlZmluZWQpXG5cdFx0e1xuXHRcdFx0Ly8gb3V0IG9mIGJvdW5kc1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Y29uc3QgcG9pbnQxID0gdGhpcy5wb2ludExpc3RbaWR4MV07XG5cdFx0Y29uc3QgcG9pbnQyID0gdGhpcy5wb2ludExpc3RbaWR4Ml07XG5cblx0XHRjb25zdCB0MSA9IHBvaW50MS5nZXQodGhpcy5pbnB1dEtleSk7XG5cdFx0Y29uc3QgdDIgPSBwb2ludDIuZ2V0KHRoaXMuaW5wdXRLZXkpO1xuXG5cdFx0Y29uc3QgdERpZmYgPSB0MiAtIHQxO1xuXHRcdGNvbnN0IHBvcnRpb24gPSAoaW5wdXRWYWx1ZSAtIHQxKSAvIHREaWZmO1xuXG5cdFx0bGV0IGludGVycG9sYXRlZFBvaW50ID0gbmV3IFBvaW50TkQoKTtcblx0XHRpbnRlcnBvbGF0ZWRQb2ludC5hZGRWYWx1ZSh0aGlzLmlucHV0S2V5LCBpbnB1dFZhbHVlKTtcblxuXHRcdGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBwb2ludDEudmFsdWVNYXApXG5cdFx0e1xuXHRcdFx0bGV0IHZhbDEgPSBwb2ludDEuZ2V0KGtleSk7XG5cdFx0XHRsZXQgdmFsMiA9IHBvaW50Mi5nZXQoa2V5KTtcblx0XHRcdGxldCB2YWxEaWZmID0gdmFsMiAtIHZhbDE7XG5cdFx0XHRpbnRlcnBvbGF0ZWRQb2ludC5hZGRWYWx1ZShrZXksIHZhbDEgKyB2YWxEaWZmICogcG9ydGlvbik7XG5cdFx0fVxuXHRcdGludGVycG9sYXRlZFBvaW50LmluQnJ1c2ggPSBwb2ludDEuaW5CcnVzaCAmJiBwb2ludDIuaW5CcnVzaDtcblx0XHRyZXR1cm4gaW50ZXJwb2xhdGVkUG9pbnQ7XG5cdH1cblxuXHRwdWJsaWMgZ2V0UG9pbnRXZWlnaHQocG9pbnRJbmRleDogbnVtYmVyKTogbnVtYmVyXG5cdHtcblx0XHRjb25zdCBpZHhMZWZ0ID0gTWF0aC5tYXgocG9pbnRJbmRleCAtIDEsIDApO1xuXHRcdGNvbnN0IGlkeFJpZ2h0ID0gTWF0aC5taW4ocG9pbnRJbmRleCArIDEsIHRoaXMucG9pbnRMaXN0Lmxlbmd0aCAtIDEpO1xuXHRcdGNvbnN0IHRMZWZ0ID0gdGhpcy5wb2ludExpc3RbaWR4TGVmdF0uZ2V0KHRoaXMuaW5wdXRLZXkpO1xuXHRcdGNvbnN0IHRSaWdodCA9IHRoaXMucG9pbnRMaXN0W2lkeFJpZ2h0XS5nZXQodGhpcy5pbnB1dEtleSk7XG5cdFx0cmV0dXJuICh0UmlnaHQgLSB0TGVmdCApIC8gMjtcblx0fVxuXG5cdHB1YmxpYyBhZGRQb2ludChwb2ludDogUG9pbnRORCk6IHZvaWRcblx0e1xuXHRcdHBvaW50LnBhcmVudCA9IHRoaXM7XG5cdFx0dGhpcy5fcG9pbnRMaXN0LnB1c2gocG9pbnQpO1xuXHRcdHRoaXNbdGhpcy5sZW5ndGhdID0gcG9pbnQ7XG5cdFx0Kyt0aGlzLl9sZW5ndGg7XG5cdH1cblxuXHRwdWJsaWMgc29ydChrZXk6IHN0cmluZyk6IHZvaWRcblx0e1xuXHRcdGxldCBzb3J0RnVuY3Rpb24gPSBEZXZsaWJBbGdvLnNvcnRPblByb3BlcnR5PFBvaW50TkQ+KChwb2ludDogUG9pbnRORCkgPT4gXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHBvaW50LmdldChrZXkpO1xuXHRcdH0pO1xuXHRcdHRoaXMucG9pbnRMaXN0LnNvcnQoc29ydEZ1bmN0aW9uKTtcblx0XHR0aGlzLl9pbnB1dEtleSA9IGtleTtcblx0fVxuXG5cdFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhdG9yPFBvaW50TkQ+XG5cdHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlSXRlcmF0b3IodGhpcy5wb2ludExpc3QpO1xuXHR9XG5cbn0iLCJleHBvcnQgZW51bSBEYXRhRXZlbnRzIHtcblx0YnJ1c2hDaGFuZ2UgPSBcImJydXNoQ2hhbmdlXCJcbn0iLCJpbXBvcnQgeyBTdHJpbmdUb051bWJlck9iaiwgUG9pbnREZXJpdmF0aW9uRnVuY3Rpb24gfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBEZXJpdmVkUG9pbnRWYWx1ZUZ1bmN0aW9uc1xue1xuICAgIHB1YmxpYyBzdGF0aWMgR2V0RnVuY3Rpb25MaXN0KCk6IFtzdHJpbmdbXSwgUG9pbnREZXJpdmF0aW9uRnVuY3Rpb25dW11cbiAgICB7XG4gICAgICAgIGxldCBmdW5jdGlvbkxpc3QgPSBbXTtcbiAgICAgICAgZnVuY3Rpb25MaXN0LnB1c2goW1snTWFzc19ub3JtJ10sIChwb2ludExpc3Q6IFN0cmluZ1RvTnVtYmVyT2JqW10pID0+IHRoaXMubm9ybUF0dHIoJ01hc3MgKHBnKScsIHBvaW50TGlzdCwgZmFsc2UpXSk7XG4gICAgICAgIGZ1bmN0aW9uTGlzdC5wdXNoKFtbJ1RpbWVfbm9ybSddLCAocG9pbnRMaXN0OiBTdHJpbmdUb051bWJlck9ialtdKSA9PiB0aGlzLm5vcm1BdHRyKCdUaW1lIChoKScsIHBvaW50TGlzdCldKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTGlzdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBub3JtQXR0cihhdHRyS2V5OiBzdHJpbmcsIHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSwgemVyb05vcm0gPSB0cnVlKTogW251bWJlcltdXVxuICAgIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgaWYgKHBvaW50TGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3VmFsdWVzXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdFZhbDogbnVtYmVyID0gcG9pbnRMaXN0WzBdW2F0dHJLZXldO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiBwb2ludExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBvbGRWYWwgPSBwb2ludFthdHRyS2V5XTtcbiAgICAgICAgICAgIGlmICh6ZXJvTm9ybSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZXMucHVzaChvbGRWYWwgLSBmaXJzdFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7ICAgXG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzLnB1c2gob2xkVmFsIC8gZmlyc3RWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3VmFsdWVzXTtcbiAgICB9XG5cbiAgICAvLyBwcml2YXRlIHN0YXRpYyBmdW5jdGlvbk5hbWUocG9pbnRMaXN0OiBTdHJpbmdUb051bWJlck9ialtdKTogbnVtYmVyW11cbiAgICAvLyB7XG4gICAgICAgIFxuICAgIC8vIH1cblxufSIsImltcG9ydCB7IFN0cmluZ1RvTnVtYmVyT2JqLCBUcmFja0Rlcml2YXRpb25GdW5jdGlvbiB9IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcydcblxuZXhwb3J0IGNsYXNzIERlcml2ZWRUcmFja1ZhbHVlRnVuY3Rpb25zXG57XG4gICAgcHVibGljIHN0YXRpYyBHZXRGdW5jdGlvbkxpc3QoKTogW3N0cmluZ1tdLCBUcmFja0Rlcml2YXRpb25GdW5jdGlvbl1bXVxuICAgIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uTGlzdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbkxpc3QucHVzaChbWydUcmFjayBMZW5ndGgnXSwgdGhpcy50cmFja0xlbmd0aF0pO1xuICAgICAgICBmdW5jdGlvbkxpc3QucHVzaChbWydBdmcgTWFzcyddLCB0aGlzLmF2ZXJhZ2VNYXNzXSk7XG4gICAgICAgIGZ1bmN0aW9uTGlzdC5wdXNoKFtbJ0dyb3d0aCBSYXRlJywgJ0ludGVyY2VwdCcsICdJbml0aWFsIE1hc3MnLCAnRXhwb25lbnRpYWwgR3Jvd3RoIENvbnN0YW50JywgJ3Jfc3F1YXJlZCddLCB0aGlzLmdyb3d0aFJhdGVTdGF0c10pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25MaXN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIHRyYWNrTGVuZ3RoKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSk6IFtudW1iZXJdXG4gICAge1xuICAgICAgICBsZXQgZmlyc3RUaW1lID0gcG9pbnRMaXN0WzBdWydUaW1lIChoKSddO1xuICAgICAgICBsZXQgbGFzdFRpbWUgPSBwb2ludExpc3RbcG9pbnRMaXN0Lmxlbmd0aCAtIDFdWydUaW1lIChoKSddO1xuICAgICAgICByZXR1cm4gW2xhc3RUaW1lIC0gZmlyc3RUaW1lXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhdmVyYWdlTWFzcyhwb2ludExpc3Q6IFN0cmluZ1RvTnVtYmVyT2JqW10pOiBbbnVtYmVyXVxuICAgIHtcbiAgICAgICAgbGV0IHRvdGFsTWFzcyA9IDA7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50TGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgdG90YWxNYXNzICs9IHBvaW50WydNYXNzIChwZyknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvdGFsTWFzcyAvIHBvaW50TGlzdC5sZW5ndGhdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGdyb3d0aFJhdGVTdGF0cyhwb2ludExpc3Q6IFN0cmluZ1RvTnVtYmVyT2JqW10pOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gICAge1xuICAgICAgICAvLyBSZWZlcmVuY2VkIG1hdGhcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3JkaW5hcnlfbGVhc3Rfc3F1YXJlcyNTaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb25fbW9kZWxcbiAgICAgICAgbGV0IHN1bVggPSAwO1xuICAgICAgICBsZXQgc3VtWSA9IDA7XG4gICAgICAgIGxldCBzdW1ZWSA9IDA7XG4gICAgICAgIGxldCBzdW1YWSA9IDA7XG4gICAgICAgIGxldCBzdW1YWCA9IDA7XG4gICAgICAgIGxldCBOID0gcG9pbnRMaXN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKE4gPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBbIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOIF07IC8vIGNhbGN1bGF0aW5nIHRoZSBzbG9wZSBvZiBvbmUgcG9pbnQgaXMgYWN0dWFsbHkgcG9pbnQuLi5sZXNzXG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRMaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgeCA9IHBvaW50WydUaW1lIChoKSddO1xuICAgICAgICAgICAgbGV0IHkgPSBwb2ludFsnTWFzcyAocGcpJ107XG4gICAgICAgICAgICBzdW1YICs9IHg7XG4gICAgICAgICAgICBzdW1ZICs9IHk7XG4gICAgICAgICAgICBzdW1ZWSArPSB5Knk7XG4gICAgICAgICAgICBzdW1YWSArPSB4Knk7XG4gICAgICAgICAgICBzdW1YWCArPSB4Kng7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgTl9pbnYgPSAxIC8gTjtcbiAgICAgICAgbGV0IGNvdmFyaWFuY2UgPSBzdW1YWSAtIE5faW52ICogc3VtWCAqIHN1bVk7XG4gICAgICAgIGxldCB2YXJpYW5jZSA9IHN1bVhYIC0gTl9pbnYgKiBzdW1YICogc3VtWDtcbiAgICAgICAgbGV0IHNsb3BlID0gY292YXJpYW5jZSAvIHZhcmlhbmNlO1xuICAgICAgICBsZXQgaW50ZXJjZXB0ID0gTl9pbnYgKiAoc3VtWSAtIHNsb3BlICogc3VtWCk7XG4gICAgICAgIGxldCBpbml0aWFsTWFzcyA9IHBvaW50TGlzdFswXVsnVGltZSAoaCknXSAqIHNsb3BlICsgaW50ZXJjZXB0O1xuICAgICAgICBsZXQgZXhwb25lbnRpYWxHcm93dGhDb25zdGFudCA9IHNsb3BlIC8gaW5pdGlhbE1hc3M7XG5cbiAgICAgICAgLy8gcl9zcXVhcmVkIGVxdWF0aW9uIGZyb20gaGVyZVxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaW1wbGVfbGluZWFyX3JlZ3Jlc3Npb24jRml0dGluZ190aGVfcmVncmVzc2lvbl9saW5lXG4gICAgICAgIGxldCByX3RvcCA9IChOX2ludiAqIHN1bVhZIC0gTl9pbnYgKiBzdW1YICogTl9pbnYgKiBzdW1ZKTtcbiAgICAgICAgbGV0IHJfYm90ID0gTWF0aC5zcXJ0KCAoTl9pbnYgKiBzdW1YWCAtIE5faW52ICogc3VtWCAqIE5faW52ICogc3VtWCkgKiAoTl9pbnYgKiBzdW1ZWSAtIE5faW52ICogc3VtWSAqIE5faW52ICogc3VtWSkgKTtcbiAgICAgICAgbGV0IHJfc3F1YXJlZCA9IE1hdGgucG93KChyX3RvcCAvIHJfYm90KSwgMik7XG4gICAgICAgIHJldHVybiBbIHNsb3BlLCBpbnRlcmNlcHQsIGluaXRpYWxNYXNzLCBleHBvbmVudGlhbEdyb3d0aENvbnN0YW50LCByX3NxdWFyZWQgXTtcbiAgICB9XG5cblxuICAgIC8vIHByaXZhdGUgc3RhdGljIGZ1bmN0aW9uTmFtZShwb2ludExpc3Q6IFN0cmluZ1RvTnVtYmVyT2JqW10pOiBudW1iZXJcbiAgICAvLyB7XG4gICAgICAgIFxuICAgIC8vIH1cblxufSIsImV4cG9ydCBjbGFzcyBJbWFnZUZyYW1lXG57XG4gICAgY29uc3RydWN0b3IoZnJhbWVJZDogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZnJhbWVJZCA9IGZyYW1lSWQ7XG4gICAgICAgIHRoaXMuX2luQnJ1c2ggPSB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2luQnJ1c2ggOiBib29sZWFuO1xuICAgIHB1YmxpYyBnZXQgaW5CcnVzaCgpIDogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbkJydXNoO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGluQnJ1c2godjogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9pbkJydXNoID0gdjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbkJydXNoQ291bnQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBpbkJydXNoQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbkJydXNoQ291bnQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaW5CcnVzaENvdW50KHYgOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5faW5CcnVzaENvdW50ID0gdjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF90b3RhbENvdW50IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgdG90YWxDb3VudCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsQ291bnQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgdG90YWxDb3VudCh2IDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3RvdGFsQ291bnQgPSB2O1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgZ2V0IGluQnJ1c2hQZXJjZW50KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkJydXNoQ291bnQgLyB0aGlzLnRvdGFsQ291bnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnJhbWVJZCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lSWQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUlkO1xuICAgIH1cbiAgICAgICAgXG59IiwiaW1wb3J0IHsgSW1hZ2VGcmFtZSB9IGZyb20gJy4vSW1hZ2VGcmFtZSdcbmltcG9ydCB7IERldmxpYkFsZ28gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliQWxnbyc7XG5cbmV4cG9ydCBjbGFzcyBJbWFnZUxvY2F0aW9uXG57XG4gICAgY29uc3RydWN0b3IobG9jYXRpb25JZDogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9jYXRpb25JZCA9IGxvY2F0aW9uSWQ7XG4gICAgICAgIHRoaXMuX2luQnJ1c2ggPSB0cnVlO1xuICAgICAgICB0aGlzLl9mcmFtZUxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fZnJhbWVMb29rdXAgPSBuZXcgTWFwPG51bWJlciwgSW1hZ2VGcmFtZT4oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbkJydXNoIDogYm9vbGVhbjtcbiAgICBwdWJsaWMgZ2V0IGluQnJ1c2goKSA6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5CcnVzaDtcbiAgICB9XG4gICAgcHVibGljIHNldCBpbkJydXNoKHY6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5faW5CcnVzaCA9IHY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5CcnVzaENvdW50IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgaW5CcnVzaENvdW50KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5CcnVzaENvdW50O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGluQnJ1c2hDb3VudCh2IDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2luQnJ1c2hDb3VudCA9IHY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdG90YWxDb3VudCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHRvdGFsQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbENvdW50O1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IHRvdGFsQ291bnQodiA6IG51bWJlcikge1xuICAgICAgICB0aGlzLl90b3RhbENvdW50ID0gdjtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldCBpbkJydXNoUGVyY2VudCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5CcnVzaENvdW50IC8gdGhpcy50b3RhbENvdW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2xvY2F0aW9uSWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBsb2NhdGlvbklkKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25JZDtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfZnJhbWVMaXN0IDogSW1hZ2VGcmFtZVtdO1xuICAgIHB1YmxpYyBnZXQgZnJhbWVMaXN0KCkgOiBJbWFnZUZyYW1lW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVMaXN0O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9mcmFtZUxvb2t1cCA6IE1hcDxudW1iZXIsIEltYWdlRnJhbWU+O1xuICAgIHB1YmxpYyBnZXQgZnJhbWVMb29rdXAoKSA6IE1hcDxudW1iZXIsIEltYWdlRnJhbWU+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lTG9va3VwO1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgYWRkRnJhbWUoZnJhbWVJZDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVMb29rdXAuaGFzKGZyYW1lSWQpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3RnJhbWUgPSBuZXcgSW1hZ2VGcmFtZShmcmFtZUlkKTtcbiAgICAgICAgdGhpcy5mcmFtZUxpc3QucHVzaChuZXdGcmFtZSk7XG4gICAgICAgIHRoaXMuZnJhbWVMb29rdXAuc2V0KGZyYW1lSWQsIG5ld0ZyYW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc29ydEZyYW1lcygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmZyYW1lTGlzdC5zb3J0KERldmxpYkFsZ28uc29ydE9uUHJvcGVydHkoKGZyYW1lOiBJbWFnZUZyYW1lKSA9PiBmcmFtZS5mcmFtZUlkKSk7XG4gICAgfVxufSIsImltcG9ydCB7IFBvaW50Q29sbGVjdGlvbiB9IGZyb20gJy4vUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IEltYWdlTG9jYXRpb24gfSBmcm9tICcuL0ltYWdlTG9jYXRpb24nO1xuXG5leHBvcnQgY2xhc3MgSW1hZ2VNZXRhRGF0YVxueyAgIFxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fbG9jYXRpb25MaXN0ID0gW107XG4gICAgICAgIHRoaXMuX2xvY2F0aW9uTG9va3VwID0gbmV3IE1hcDxudW1iZXIsIEltYWdlTG9jYXRpb24+KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25MaXN0IDogSW1hZ2VMb2NhdGlvbltdO1xuICAgIHB1YmxpYyBnZXQgbG9jYXRpb25MaXN0KCkgOiBJbWFnZUxvY2F0aW9uW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25MaXN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2xvY2F0aW9uTG9va3VwIDogTWFwPG51bWJlciwgSW1hZ2VMb2NhdGlvbj47XG4gICAgcHVibGljIGdldCBsb2NhdGlvbkxvb2t1cCgpIDogTWFwPG51bWJlciwgSW1hZ2VMb2NhdGlvbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25Mb29rdXA7XG4gICAgfVxuXG4gICAgXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25JZEtleSA6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IGxvY2F0aW9uSWRLZXkoKSA6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbklkS2V5O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ZyYW1lSWRLZXkgOiBzdHJpbmc7XG4gICAgcHVibGljIGdldCBmcmFtZUlkS2V5KCkgOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVJZEtleTtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldEJydXNoZWRMb2NhdGlvbnMoKTogbnVtYmVyW11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2F0aW9uTGlzdC5maWx0ZXIobG9jID0+IGxvYy5pbkJydXNoKS5tYXAobG9jID0+IGxvYy5sb2NhdGlvbklkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0QnJ1c2hlZEltYWdlQ291bnQoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBsb2Mgb2YgdGhpcy5sb2NhdGlvbkxpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvdW50ICs9IGxvYy5mcmFtZUxpc3QuZmlsdGVyKGZyYW1lID0+IGZyYW1lLmluQnJ1c2gpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgdXBkYXRlSW5CcnVzaFByb3AocG9pbnRMaXN0OiBQb2ludENvbGxlY3Rpb24pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJlc2V0QWxsVG9GYWxzZSgpO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiBwb2ludExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBsb2NJZDogbnVtYmVyID0gcG9pbnQuZ2V0KHRoaXMubG9jYXRpb25JZEtleSk7XG4gICAgICAgICAgICBsZXQgZnJhbWVJZDogbnVtYmVyID0gcG9pbnQuZ2V0KHRoaXMuZnJhbWVJZEtleSk7XG4gICAgICAgICAgICBsZXQgbG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uTG9va3VwLmdldChsb2NJZCk7XG4gICAgICAgICAgICBsZXQgZnJhbWUgPSBsb2NhdGlvbi5mcmFtZUxvb2t1cC5nZXQoZnJhbWVJZCk7XG4gICAgICAgICAgICBsb2NhdGlvbi50b3RhbENvdW50Kys7XG4gICAgICAgICAgICBmcmFtZS50b3RhbENvdW50Kys7XG4gICAgICAgICAgICBpZiAocG9pbnQuaW5CcnVzaClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5pbkJydXNoQ291bnQrKztcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5pbkJydXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5pbkJydXNoQ291bnQrKztcbiAgICAgICAgICAgICAgICBmcmFtZS5pbkJydXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzZXRBbGxUb0ZhbHNlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGZvciAobGV0IGxvYyBvZiB0aGlzLmxvY2F0aW9uTGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgbG9jLmluQnJ1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGxvYy5pbkJydXNoQ291bnQgPSAwO1xuICAgICAgICAgICAgbG9jLnRvdGFsQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgZnJhbWUgb2YgbG9jLmZyYW1lTGlzdClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmcmFtZS5pbkJydXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZnJhbWUuaW5CcnVzaENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBmcmFtZS50b3RhbENvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzdGF0aWMgZnJvbVBvaW50Q29sbGVjdGlvbihwb2ludExpc3Q6IFBvaW50Q29sbGVjdGlvbiwgbG9jYXRpb25JZEtleTogc3RyaW5nID0gJ0xvY2F0aW9uIElEJywgZnJhbWVJZEtleTogc3RyaW5nID0gJ0ZyYW1lIElEJyk6IEltYWdlTWV0YURhdGFcbiAgICB7XG4gICAgICAgIGxldCBpbWdNZXRhRGF0YSA9IG5ldyBJbWFnZU1ldGFEYXRhKCk7XG4gICAgICAgIGltZ01ldGFEYXRhLl9sb2NhdGlvbklkS2V5ID0gbG9jYXRpb25JZEtleTtcbiAgICAgICAgaW1nTWV0YURhdGEuX2ZyYW1lSWRLZXkgPSBmcmFtZUlkS2V5O1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiBwb2ludExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBsb2NJZDogbnVtYmVyID0gcG9pbnQuZ2V0KGxvY2F0aW9uSWRLZXkpO1xuICAgICAgICAgICAgbGV0IGZyYW1lSWQ6IG51bWJlciA9IHBvaW50LmdldChmcmFtZUlkS2V5KTtcbiAgICAgICAgICAgIGxldCBpbWFnZUxvY2F0aW9uOiBJbWFnZUxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKGltZ01ldGFEYXRhLmxvY2F0aW9uTG9va3VwLmhhcyhsb2NJZCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW1hZ2VMb2NhdGlvbiA9IGltZ01ldGFEYXRhLmxvY2F0aW9uTG9va3VwLmdldChsb2NJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW1hZ2VMb2NhdGlvbiA9IG5ldyBJbWFnZUxvY2F0aW9uKGxvY0lkKTtcbiAgICAgICAgICAgICAgICBpbWdNZXRhRGF0YS5sb2NhdGlvbkxpc3QucHVzaChpbWFnZUxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBpbWdNZXRhRGF0YS5sb2NhdGlvbkxvb2t1cC5zZXQobG9jSWQsIGltYWdlTG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2VMb2NhdGlvbi5hZGRGcmFtZShmcmFtZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpbWFnZUxvY2F0aW9uIG9mIGltZ01ldGFEYXRhLmxvY2F0aW9uTGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgaW1hZ2VMb2NhdGlvbi5zb3J0RnJhbWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW1nTWV0YURhdGEudXBkYXRlSW5CcnVzaFByb3AocG9pbnRMaXN0KTtcbiAgICAgICAgcmV0dXJuIGltZ01ldGFEYXRhO1xuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBsb2FkIH0gZnJvbSBcInByb3RvYnVmanNcIjtcbmltcG9ydCB7IERldmxpYlRTVXRpbCB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUU1V0aWwnO1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZUxhYmVsc1xue1xuICAgIHJvd0xpc3Q6IFJvd1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm93XG57XG4gICAgcm93OiBMYWJlbFJ1bltdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGFiZWxSdW4ge1xuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgbGVuZ3RoOiBudW1iZXIsXG4gICAgbGFiZWw6IG51bWJlclxufVxuXG5cbmV4cG9ydCBjbGFzcyBJbWFnZVN0YWNrRGF0YVJlcXVlc3RcbntcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoZHJpdmVJZDogc3RyaW5nKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZHJpdmVJZCA9IGRyaXZlSWQ7XG4gICAgICAgIHRoaXMuX21ldGFEYXRhTG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGQzLmpzb24oYC9kYXRhLyR7ZHJpdmVJZH0vaW1hZ2VNZXRhRGF0YS5qc29uYCkudGhlbigoZGF0YTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl90aWxlV2lkdGggPSBkYXRhLnRpbGVXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVIZWlnaHQgPSBkYXRhLnRpbGVIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJPZkNvbHVtbnMgPSBkYXRhLm51bWJlck9mQ29sdW1ucztcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzUGVyRmlsZSA9IGRhdGEudGlsZXNQZXJGaWxlO1xuICAgICAgICAgICAgdGhpcy5fbWV0YURhdGFMb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2NhbGVGYWN0b3IpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBkYXRhLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjYWxlRmFjdG9yID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2Jsb2JBcnJheT0gW107XG4gICAgICAgIHRoaXMuX2xhYmVsQXJyYXk9IFtdO1xuICAgICAgICB0aGlzLl9tYXhCbG9iQ291bnQgPSAxMDA7XG4gICAgICAgIHRoaXMuX25leHRCbG9iSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9uZXh0TGFiZWxJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX21heExhYmVsQ291bnQgPSAxMDA7XG4gICAgfVxuICAgIFxuICAgIFxuICAgIHByaXZhdGUgX21ldGFEYXRhTG9hZGVkIDogYm9vbGVhbjtcbiAgICBwdWJsaWMgZ2V0IG1ldGFEYXRhTG9hZGVkKCkgOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFEYXRhTG9hZGVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RyaXZlSWQgOiBzdHJpbmc7XG4gICAgcHVibGljIGdldCBkcml2ZUlkKCkgOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVJZDtcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfdGlsZVdpZHRoIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgdGlsZVdpZHRoKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RpbGVIZWlnaHQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCB0aWxlSGVpZ2h0KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUhlaWdodDtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfbnVtYmVyT2ZDb2x1bW5zIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgbnVtYmVyT2ZDb2x1bW5zKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZDb2x1bW5zO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RpbGVzUGVyRmlsZSA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHRpbGVzUGVyRmlsZSgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzUGVyRmlsZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXhCbG9iQ291bnQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBtYXhCbG9iQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhCbG9iQ291bnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbWF4TGFiZWxDb3VudCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IG1heExhYmVsQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhMYWJlbENvdW50O1xuICAgIH1cbiBcbiAgICBwcml2YXRlIF9zY2FsZUZhY3RvciA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHNjYWxlRmFjdG9yKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVGYWN0b3I7XG4gICAgfSAgICBcblxuICAgIC8vIGJsb2IsIGtleSwgdXJsXG4gICAgcHJpdmF0ZSBfYmxvYkFycmF5IDogW0Jsb2IsIHN0cmluZywgc3RyaW5nXVtdO1xuICAgIHB1YmxpYyBnZXQgYmxvYkFycmF5KCkgOiBbQmxvYiwgc3RyaW5nLCBzdHJpbmddW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvYkFycmF5O1xuICAgIH1cblxuICAgIHByaXZhdGUgX25leHRCbG9iSW5kZXggOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBuZXh0QmxvYkluZGV4KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEJsb2JJbmRleDtcbiAgICB9XG5cbiAgICAvLyByb3dzLCBrZXlcbiAgICBwcml2YXRlIF9sYWJlbEFycmF5IDogW0ltYWdlTGFiZWxzLCBzdHJpbmddW107XG4gICAgcHVibGljIGdldCBsYWJlbEFycmF5KCkgOiBbSW1hZ2VMYWJlbHMsIHN0cmluZ11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbEFycmF5O1xuICAgIH1cblxuICAgIHByaXZhdGUgX25leHRMYWJlbEluZGV4IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgbmV4dExhYmVsSW5kZXgoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0TGFiZWxJbmRleDtcbiAgICB9XG5cblxuOyBcbiAgICBwdWJsaWMgZ2V0SW1hZ2UobG9jYXRpb246IG51bWJlciwgZnJhbWVJbmRleDogbnVtYmVyLCBjYWxsYmFjazogKHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJsb2I6IEJsb2IsIGltYWdlVXJsOiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMubWV0YURhdGFMb2FkZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKGxvY2F0aW9uLCBmcmFtZUluZGV4LCBjYWxsYmFjaylcbiAgICAgICAgICAgIH0sIDUwKTsgLy8gdG9kbyBmYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbdG9wLCBsZWZ0XSA9IHRoaXMuZ2V0VGlsZVRvcExlZnQoZnJhbWVJbmRleCk7XG4gICAgICAgIGxldCBidW5kbGVJbmRleCA9IE1hdGguZmxvb3IoZnJhbWVJbmRleCAvIHRoaXMudGlsZXNQZXJGaWxlKTtcbiAgICAgICAgbGV0IGtleSA9IFtsb2NhdGlvbiwgYnVuZGxlSW5kZXhdLmpvaW4oJy0nKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBjYWNoZWRFbGVtZW50ID0gdGhpcy5ibG9iQXJyYXkuZmluZChkID0+IGRbMV0gPT09IGtleSk7XG4gICAgICAgIGlmIChjYWNoZWRFbGVtZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJ1bldpdGhDYWNoZWRJbWFnZShrZXksIHRvcCwgbGVmdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltZ1VybCA9IGAvZGF0YS8ke3RoaXMuZHJpdmVJZH0vaW1nXyR7bG9jYXRpb259XyR7YnVuZGxlSW5kZXh9LmpwZ2A7XG4gICAgICAgIGNvbnN0IHRoaXNJbmRleCA9IHRoaXMubmV4dEJsb2JJbmRleDtcbiAgICAgICAgdGhpcy5ibG9iQXJyYXlbdGhpc0luZGV4XSA9IFtudWxsLCBrZXksIG51bGxdO1xuICAgICAgICB0aGlzLl9uZXh0QmxvYkluZGV4ID0gKHRoaXMubmV4dEJsb2JJbmRleCArIDEpICUgdGhpcy5tYXhCbG9iQ291bnQ7XG5cbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICB4aHIub25sb2FkID0gKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGJsb2IgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICB0aGlzLmJsb2JBcnJheVt0aGlzSW5kZXhdID0gW2Jsb2IsIGtleSwgdXJsXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRvcCwgbGVmdCwgYmxvYiwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIub25lcnJvciA9IChlKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIEZldGNoaW5nOiAnICsgaW1nVXJsKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICB9XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBpbWdVcmwpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBydW5XaXRoQ2FjaGVkSW1hZ2Uoa2V5OiBzdHJpbmcsIHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGNhbGxiYWNrOiAodG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYmxvYjogQmxvYiwgaW1hZ2VVcmw6IHN0cmluZykgPT4gdm9pZCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBjYWNoZWRFbGVtZW50ID0gdGhpcy5ibG9iQXJyYXkuZmluZChkID0+IGRbMV0gPT09IGtleSk7XG4gICAgICAgIGlmIChjYWNoZWRFbGVtZW50WzBdKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYWxsYmFjayh0b3AsIGxlZnQsIGNhY2hlZEVsZW1lbnRbMF0sIGNhY2hlZEVsZW1lbnRbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbG9hZGluZywgdHJ5IGFnYWluIGxhdGVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bldpdGhDYWNoZWRJbWFnZShrZXksIHRvcCwgbGVmdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldEltYWdlUHJvbWlzZShsb2NhdGlvbjogbnVtYmVyLCBmcmFtZUluZGV4OiBudW1iZXIpOiBQcm9taXNlPFtudW1iZXIsIG51bWJlciwgQmxvYiwgc3RyaW5nXT5cbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW1hZ2UobG9jYXRpb24sIGZyYW1lSW5kZXgsICh0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBibG9iOiBCbG9iLCBpbWFnZVVybDogc3RyaW5nKSA9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbdG9wLCBsZWZ0LCBibG9iLCBpbWFnZVVybF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBnZXRUaWxlVG9wTGVmdChmcmFtZUluZGV4OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdXG5cdHtcblx0XHRjb25zdCBsZWZ0OiBudW1iZXIgPSAoZnJhbWVJbmRleCAlIHRoaXMubnVtYmVyT2ZDb2x1bW5zKSAqIHRoaXMudGlsZVdpZHRoO1xuICAgICAgICBsZXQgdG9wOiBudW1iZXIgPSBNYXRoLmZsb29yKChmcmFtZUluZGV4ICUgdGhpcy50aWxlc1BlckZpbGUpIC8gdGhpcy5udW1iZXJPZkNvbHVtbnMpICogdGhpcy50aWxlSGVpZ2h0O1xuXHRcdHJldHVybiBbdG9wLCBsZWZ0XTtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIGdldExhYmVsKGxvY2F0aW9uOiBudW1iZXIsIGZyYW1lSW5kZXg6IG51bWJlciwgY2FsbGJhY2s6IChyb3dEYXRhOiBJbWFnZUxhYmVscywgZmlyc3RJbmRleDogbnVtYmVyKSA9PiB2b2lkKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLm1ldGFEYXRhTG9hZGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRMYWJlbChsb2NhdGlvbiwgZnJhbWVJbmRleCwgY2FsbGJhY2spXG4gICAgICAgICAgICB9LCA1MCk7IC8vIHRvZG8gZmFsbGJhY2tcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsZXQgW3RvcCwgbGVmdF0gPSB0aGlzLmdldFRpbGVUb3BMZWZ0KGZyYW1lSW5kZXgpO1xuICAgICAgICBsZXQgZmlyc3RJbmRleDogbnVtYmVyID0gKGZyYW1lSW5kZXggJSB0aGlzLnRpbGVzUGVyRmlsZSkgKiB0aGlzLnRpbGVIZWlnaHQ7XG4gICAgICAgIGxldCBidW5kbGVJbmRleCA9IE1hdGguZmxvb3IoZnJhbWVJbmRleCAvIHRoaXMudGlsZXNQZXJGaWxlKTtcbiAgICAgICAgbGV0IGtleSA9IFtsb2NhdGlvbiwgYnVuZGxlSW5kZXhdLmpvaW4oJy0nKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBjYWNoZWRFbGVtZW50ID0gdGhpcy5sYWJlbEFycmF5LmZpbmQoZCA9PiBkWzFdID09PSBrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkRWxlbWVudClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdG9kbyAtIHNpbWlsYXIgcnVuV2l0aENhY2hlZCBsb2dpY1xuICAgICAgICAgICAgdGhpcy5ydW5XaXRoQ2FjaGVkTGFiZWwoa2V5LCBmaXJzdEluZGV4LCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRoaXNJbmRleCA9IHRoaXMubmV4dExhYmVsSW5kZXg7XG4gICAgICAgIHRoaXMuX25leHRMYWJlbEluZGV4ID0gKHRoaXMubmV4dExhYmVsSW5kZXggKyAxKSAlIHRoaXMubWF4QmxvYkNvdW50O1xuICAgICAgICB0aGlzLmxhYmVsQXJyYXlbdGhpc0luZGV4XSA9IFtudWxsLCBrZXldO1xuXG4gICAgICAgIGNvbnN0IGxhYmVsVXJsID0gYC9kYXRhLyR7dGhpcy5kcml2ZUlkfS9sYWJlbF8ke2xvY2F0aW9ufV8ke2J1bmRsZUluZGV4fS5wYmA7XG4gICAgICAgIGxvYWQoXCIvc3RhdGljL3Byb3RvRGVmcy9STEUucHJvdG9cIiwgYXN5bmMgKGVyciwgcm9vdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPYnRhaW4gYSBtZXNzYWdlIHR5cGVcbiAgICAgICAgICAgIGxldCBJbWFnZUxhYmVsc01lc3NhZ2UgPSByb290Lmxvb2t1cFR5cGUoXCJpbWFnZUxhYmVscy5JbWFnZUxhYmVsc1wiKTtcbiAgICAgICAgICAgIGxldCBidWZmZXIgPSBhd2FpdCBkMy5idWZmZXIobGFiZWxVcmwpO1xuICAgICAgICAgICAgLy8gRGVjb2RlIGFuIFVpbnQ4QXJyYXkgKGJyb3dzZXIpIG9yIEJ1ZmZlciAobm9kZSkgdG8gYSBtZXNzYWdlXG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IEltYWdlTGFiZWxzTWVzc2FnZS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkgYXMgYW55O1xuXG4gICAgICAgICAgICB0aGlzLmxhYmVsQXJyYXlbdGhpc0luZGV4XSA9IFttZXNzYWdlLCBrZXldO1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgICAgICBjYWxsYmFjayhtZXNzYWdlLCBmaXJzdEluZGV4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByaXZhdGUgcnVuV2l0aENhY2hlZExhYmVsKGtleTogc3RyaW5nLCBmaXJzdEluZGV4OiBudW1iZXIsIGNhbGxiYWNrOiAocm93RGF0YTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcikgPT4gdm9pZCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBjYWNoZWRFbGVtZW50ID0gdGhpcy5sYWJlbEFycmF5LmZpbmQoZCA9PiBkWzFdID09PSBrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkRWxlbWVudFswXSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2FsbGJhY2soY2FjaGVkRWxlbWVudFswXSwgZmlyc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBsb2FkaW5nLCB0cnkgYWdhaW4gbGF0ZXJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuV2l0aENhY2hlZExhYmVsKGtleSwgZmlyc3RJbmRleCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldExhYmVsUHJvbWlzZShsb2NhdGlvbjogbnVtYmVyLCBmcmFtZUluZGV4OiBudW1iZXIpOiBQcm9taXNlPFtJbWFnZUxhYmVscywgbnVtYmVyXT5cbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdldExhYmVsKGxvY2F0aW9uLCBmcmFtZUluZGV4LCAocm93RGF0YTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKFtyb3dEYXRhLCBmaXJzdEluZGV4XSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdldExhYmVsVmFsdWUocm93SWR4OiBudW1iZXIsIGNvbElkeDogbnVtYmVyLCByb3dBcnJheTogSW1hZ2VMYWJlbHMpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBib3R0bGVuZWNrLCB0aGlzIGNvdWxkIGJlIGltcHJvdmVkIHdpdGggcXVpY2tzZWFyY2guXG4gICAgICAgIGxldCByb3c6IFJvdyA9IHJvd0FycmF5LnJvd0xpc3Rbcm93SWR4XTtcbiAgICAgICAgZm9yIChsZXQgbGFiZWxSdW4gb2Ygcm93LnJvdylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGxhYmVsUnVuLnN0YXJ0IDw9IGNvbElkeCAmJiBjb2xJZHggPCBsYWJlbFJ1bi5zdGFydCArIGxhYmVsUnVuLmxlbmd0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxSdW4ubGFiZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufSIsIi8vIGltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuL1BvaW50TkQnO1xuaW1wb3J0IHsgTkRpbSB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUeXBlcydcbmltcG9ydCB7IERhdGFFdmVudHMgfSBmcm9tICcuL0RhdGFFdmVudHMnO1xuaW1wb3J0IHsgQXBwRGF0YSwgRmFjZXRPcHRpb24sIEZhY2V0LCBEYXRhc2V0U3BlYywgTG9jYXRpb25NYXBMaXN0LCBMb2NhdGlvbk1hcFRlbXBsYXRlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIHZhbHVlRmlsdGVyIHtcblx0a2V5OiBzdHJpbmcsXG5cdGJvdW5kOiBbbnVtYmVyLCBudW1iZXJdXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2ludENvbGxlY3Rpb24gaW1wbGVtZW50cyBJdGVyYWJsZTxORGltPiwgQXJyYXlMaWtlPE5EaW0+LCBBcHBEYXRhPERhdGFzZXRTcGVjPiB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihwb2ludExpc3Q6IE5EaW1bXSA9IFtdKVxuXHR7XG5cdFx0dGhpcy5fYXR0cmlidXRlTGlzdCA9IFtdO1xuXHRcdHRoaXMuX2xlbmd0aCA9IHBvaW50TGlzdC5sZW5ndGg7XG5cdFx0dGhpcy5fQXJyYXkgPSBwb2ludExpc3Q7XG5cdFx0dGhpcy5fbWluTWF4Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4oKTtcblx0XHR0aGlzLl9icnVzaExpc3QgPSBuZXcgTWFwPHN0cmluZywgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4+KCk7XG5cdH1cblx0XG5cdGFic3RyYWN0IFtTeW1ib2wuaXRlcmF0b3JdKCk6IEl0ZXJhdG9yPE5EaW0+O1xuXG5cdHByaXZhdGUgX1NwZWNpZmljYXRpb24gOiBEYXRhc2V0U3BlYztcblx0cHVibGljIGdldCBTcGVjaWZpY2F0aW9uKCkgOiBEYXRhc2V0U3BlYyB7XG5cdFx0cmV0dXJuIHRoaXMuX1NwZWNpZmljYXRpb247XG5cdH1cblx0cHVibGljIHNldCBTcGVjaWZpY2F0aW9uKHYgOiBEYXRhc2V0U3BlYykge1xuXHRcdHRoaXMuX1NwZWNpZmljYXRpb24gPSB2O1xuXHR9XG5cblx0cHJpdmF0ZSBfc291cmNlS2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHNvdXJjZUtleSgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fc291cmNlS2V5O1xuXHR9XG5cdHB1YmxpYyBzZXQgc291cmNlS2V5KHY6IHN0cmluZykge1xuXHRcdHRoaXMuX3NvdXJjZUtleSA9IHY7XG5cdH1cblx0XG5cdHByaXZhdGUgX3Bvc3RmaXhLZXkgOiBzdHJpbmc7XG5cdHB1YmxpYyBnZXQgcG9zdGZpeEtleSgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9zdGZpeEtleTtcblx0fVxuXHRwdWJsaWMgc2V0IHBvc3RmaXhLZXkodiA6IHN0cmluZykge1xuXHRcdHRoaXMuX3Bvc3RmaXhLZXkgPSB2O1xuXHR9XG5cblx0cHJvdGVjdGVkIF9sZW5ndGggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgbGVuZ3RoKCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH1cblxuXHRbbjogbnVtYmVyXTogTkRpbTtcblxuXHRwcml2YXRlIF9hdHRyaWJ1dGVMaXN0IDogc3RyaW5nW107XG5cdHB1YmxpYyBnZXQgYXR0cmlidXRlTGlzdCgpIDogc3RyaW5nW10ge1xuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGVMaXN0Lmxlbmd0aCA9PT0gMClcblx0XHR7XG5cdFx0XHR0aGlzLmluaXRBdHRyaWJ1dGVMaXN0KCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9hdHRyaWJ1dGVMaXN0O1xuXHR9XG5cblxuXHRwcml2YXRlIF9BcnJheSA6IE5EaW1bXTtcblx0cHVibGljIGdldCBBcnJheSgpIDogTkRpbVtdIHtcblx0XHRpZiAodGhpcy5fQXJyYXkubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHRoaXMuX0FycmF5ID0gQXJyYXkuZnJvbSh0aGlzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX0FycmF5O1xuXHR9XG5cblx0cHJpdmF0ZSBfbWluTWF4Q2FjaGUgOiBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPjtcblx0cHJpdmF0ZSBnZXQgbWluTWF4Q2FjaGUoKSA6IE1hcDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl0+IHtcblx0XHRyZXR1cm4gdGhpcy5fbWluTWF4Q2FjaGU7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaExpc3QgOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPj4gO1xuXHRwdWJsaWMgZ2V0IGJydXNoTGlzdCgpIDogTWFwPHN0cmluZywgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4+ICB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoTGlzdDtcblx0fVxuXG5cdHB1YmxpYyBhYnN0cmFjdCBPbkJydXNoQ2hhbmdlKCk6IHZvaWQ7XG5cblx0cHVibGljIEdldEZhY2V0T3B0aW9ucygpOiBGYWNldE9wdGlvbltdXG5cdHtcblx0XHRpZiAoIXRoaXMuU3BlY2lmaWNhdGlvbi5sb2NhdGlvbk1hcHMpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0XHRsZXQgZmFjZXRPcHRpb25MaXN0ID0gW107XG5cdFx0Zm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuU3BlY2lmaWNhdGlvbi5sb2NhdGlvbk1hcHMpKVxuXHRcdHtcblx0XHRcdGxldCBsb2NhdGlvbk1hcCA9IHRoaXMuU3BlY2lmaWNhdGlvbi5sb2NhdGlvbk1hcHNba2V5XTtcblx0XHRcdGxldCBmYWNldE9wdGlvbjogRmFjZXRPcHRpb24gPSBcblx0XHRcdHtcblx0XHRcdFx0bmFtZToga2V5LFxuXHRcdFx0XHRHZXRGYWNldHM6ICgpID0+IHtyZXR1cm4gdGhpcy5nZXRGYWNldExpc3QobG9jYXRpb25NYXApfVxuXHRcdFx0fVxuXHRcdFx0ZmFjZXRPcHRpb25MaXN0LnB1c2goZmFjZXRPcHRpb24pXG5cdFx0fVxuXHRcdHJldHVybiBmYWNldE9wdGlvbkxpc3Q7XG5cdH1cblxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0RmFjZXRMaXN0KGxvY2F0aW9uTWFwOiBMb2NhdGlvbk1hcExpc3QgfCBMb2NhdGlvbk1hcFRlbXBsYXRlKTogRmFjZXRbXTtcblxuXHRwcml2YXRlIGluaXRBdHRyaWJ1dGVMaXN0KCk6IHZvaWRcblx0e1xuXHRcdGxldCBwb2ludExpc3QgPSBbLi4udGhpc107XG5cdFx0aWYgKHBvaW50TGlzdC5sZW5ndGggPiAwKVxuXHRcdHtcblx0XHRcdGxldCBwb2ludCA9IHBvaW50TGlzdFswXTtcblx0XHRcdGZvciAobGV0IGtleSBvZiBwb2ludC52YWx1ZU1hcC5rZXlzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuX2F0dHJpYnV0ZUxpc3QucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBnZXRNaW5NYXgoa2V5OiBzdHJpbmcpOiBbbnVtYmVyLCBudW1iZXJdXG5cdHtcblx0XHRpZiAodGhpcy5taW5NYXhDYWNoZS5oYXMoa2V5KSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdGhpcy5taW5NYXhDYWNoZS5nZXQoa2V5KTtcblx0XHR9XG5cdFx0bGV0IG1pbk46IG51bWJlciA9IEluZmluaXR5O1xuXHRcdGxldCBtYXhOOiBudW1iZXIgPSAtSW5maW5pdHk7XG5cblx0XHRmb3IgKGxldCBwb2ludCBvZiB0aGlzKVxuXHRcdHtcblx0XHRcdGxldCB2YWwgPSBwb2ludC52YWx1ZU1hcC5nZXQoa2V5KTtcblx0XHRcdGlmICh2YWwgPCBtaW5OKVxuXHRcdFx0e1xuXHRcdFx0XHRtaW5OID0gdmFsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZhbCA+IG1heE4pXG5cdFx0XHR7XG5cdFx0XHRcdG1heE4gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMubWluTWF4Q2FjaGUuc2V0KGtleSwgW21pbk4sIG1heE5dKTtcblx0XHRyZXR1cm4gW21pbk4sIG1heE5dXG5cdH1cblxuXHRwdWJsaWMgYWRkQnJ1c2goYnJ1c2hLZXk6IHN0cmluZywgLi4uZmlsdGVyczogdmFsdWVGaWx0ZXJbXSk6IHZvaWRcblx0e1xuXHRcdGlmICghdGhpcy5icnVzaExpc3QuaGFzKGJydXNoS2V5KSlcblx0XHR7XG5cdFx0XHR0aGlzLmJydXNoTGlzdC5zZXQoYnJ1c2hLZXksIG5ldyBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPigpKTtcblx0XHR9XG5cdFx0bGV0IHRoaXNNYXAgPSB0aGlzLmJydXNoTGlzdC5nZXQoYnJ1c2hLZXkpO1xuXHRcdGZvciAobGV0IGZpbHRlciBvZiBmaWx0ZXJzKVxuXHRcdHtcblxuXHRcdFx0dGhpc01hcC5zZXQoZmlsdGVyLmtleSwgZmlsdGVyLmJvdW5kKVxuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUJydXNoKCk7XG5cdH1cblxuXHRwdWJsaWMgcmVtb3ZlQnJ1c2goYnJ1c2hLZXk6IGFueSk6IHZvaWRcblx0e1xuXHRcdHRoaXMuYnJ1c2hMaXN0LmRlbGV0ZShicnVzaEtleSk7XG5cdFx0dGhpcy51cGRhdGVCcnVzaCgpO1xuXHR9XG5cblx0cHVibGljIFNldEJydXNoVmFsdWVzKCk6IGJvb2xlYW5cblx0e1xuXHRcdGxldCBicnVzaEFwcGxpZWQgPSBmYWxzZTtcblx0XHRmb3IgKGxldCBwb2ludCBvZiB0aGlzKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IHZhbHVlRmlsdGVyTWFwIG9mIHRoaXMuYnJ1c2hMaXN0LnZhbHVlcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCBba2V5LCBib3VuZF0gb2YgdmFsdWVGaWx0ZXJNYXApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsZXQgdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRcdFx0XHRrZXk6IGtleSxcblx0XHRcdFx0XHRcdGJvdW5kOiBib3VuZFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIVBvaW50Q29sbGVjdGlvbi5Jc0luQnJ1c2gocG9pbnQsIHZhbHVlRmlsdGVyKSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRwb2ludC5pbkJydXNoID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRicnVzaEFwcGxpZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYnJ1c2hBcHBsaWVkO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBJc0luQnJ1c2gocG9pbnQ6IE5EaW0sIHZhbHVlRmlsdGVyOiB2YWx1ZUZpbHRlcik6IGJvb2xlYW5cblx0e1xuXHRcdGxldCB2OiBudW1iZXIgPSBwb2ludC5nZXQodmFsdWVGaWx0ZXIua2V5KTtcblx0XHRsZXQgW2xvdywgaGlnaF0gPSB2YWx1ZUZpbHRlci5ib3VuZDtcblx0XHRyZXR1cm4gbG93IDw9IHYgJiYgdiA8PSBoaWdoICYmICFpc05hTih2KTtcblx0fVxuXG5cdHB1YmxpYyB1cGRhdGVCcnVzaCgpOiB2b2lkXG5cdHtcblx0XHRsZXQgZXZlbnQgPSBuZXcgRXZlbnQoRGF0YUV2ZW50cy5icnVzaENoYW5nZSk7XG5cdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdH1cblxufVxuXG5cbiIsImltcG9ydCB7IFN0cmluZ1RvTnVtYmVyT2JqLCBORGltIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJ1xuaW1wb3J0IHsgQ3VydmVORCB9IGZyb20gJy4vQ3VydmVORCc7XG5cbmV4cG9ydCBjbGFzcyBQb2ludE5EIGltcGxlbWVudHMgTkRpbSB7XG5cblx0Y29uc3RydWN0b3IocG9qbz86IFN0cmluZ1RvTnVtYmVyT2JqKVxuXHR7XG5cdFx0dGhpcy5fdmFsdWVNYXAgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuXHRcdGZvciAobGV0IGtleSBpbiBwb2pvKVxuXHRcdHtcblx0XHRcdGNvbnN0IG06IG51bWJlciA9ICtwb2pvW2tleV07XG5cdFx0XHR0aGlzLl92YWx1ZU1hcC5zZXQoa2V5LCBtKTtcblx0XHR9XG5cdFx0dGhpcy5faW5CcnVzaCA9IHRydWU7XG5cdFx0dGhpcy5fcGFyZW50ID0gbnVsbDtcblx0fVxuXG5cdHByaXZhdGUgX3ZhbHVlTWFwIDogTWFwPHN0cmluZywgbnVtYmVyPjtcblx0cHVibGljIGdldCB2YWx1ZU1hcCgpIDogTWFwPHN0cmluZywgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWFwO1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5CcnVzaCA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaW5CcnVzaCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luQnJ1c2g7XG5cdH1cblx0cHVibGljIHNldCBpbkJydXNoKHY6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9pbkJydXNoID0gdjtcblx0fVxuXHRcblx0cHJpdmF0ZSBfcGFyZW50IDogQ3VydmVORCB8IG51bGw7XG5cdHB1YmxpYyBnZXQgcGFyZW50KCkgOiBDdXJ2ZU5EIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudDtcblx0fVxuXHRwdWJsaWMgc2V0IHBhcmVudCh2IDogQ3VydmVORCB8IG51bGwpIHtcblx0XHR0aGlzLl9wYXJlbnQgPSB2O1xuXHR9XG5cblx0cHVibGljIGFkZFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKVxuXHR7XG5cdFx0dGhpcy52YWx1ZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0KGtleTogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkXG5cdHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZU1hcC5nZXQoa2V5KTtcblx0fVxufSIsImltcG9ydCB7RnJhbWUsIERpcmVjdGlvbn0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBMYXlvdXRGcmFtZXdvcmsge1xuXHRcblx0Y29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgaW5jbHVkZUJvcmRlcnM6IGJvb2xlYW4gPSB0cnVlKVxuXHR7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdHRoaXMuX2luY2x1ZGVCb3JkZXJzID0gaW5jbHVkZUJvcmRlcnM7XG5cdH1cblxuXHRwcml2YXRlIF9jb250YWluZXIgOiBIVE1MRWxlbWVudDtcblx0cHVibGljIGdldCBjb250YWluZXIoKSA6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5jbHVkZUJvcmRlcnMgOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGluY2x1ZGVCb3JkZXJzKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faW5jbHVkZUJvcmRlcnM7XG5cdH1cdFxuXG5cdHB1YmxpYyBJbml0aWFsaXplTGF5b3V0PENvbnRlbnRUeXBlPihmcmFtZTogRnJhbWU8Q29udGVudFR5cGU+KTogTWFwPEhUTUxFbGVtZW50LCBDb250ZW50VHlwZT5cblx0e1xuXHRcdGxldCBlbGVtZW50VG9Db21wb25lbnRUeXBlID0gbmV3IE1hcDxIVE1MRWxlbWVudCwgQ29udGVudFR5cGU+KCk7XG5cdFx0dGhpcy5hZGRGcmFtZTxDb250ZW50VHlwZT4odGhpcy5jb250YWluZXIsIGZyYW1lLCBlbGVtZW50VG9Db21wb25lbnRUeXBlLCB0cnVlKTtcblx0XHRyZXR1cm4gZWxlbWVudFRvQ29tcG9uZW50VHlwZTtcblx0fVxuXG5cdHByaXZhdGUgYWRkRnJhbWU8Q29udGVudFR5cGU+KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGZyYW1lOiBGcmFtZTxDb250ZW50VHlwZT4sIGxvb2t1cDogTWFwPEVsZW1lbnQsIENvbnRlbnRUeXBlPiwgc2tpcFRoaXNCb3JkZXI6IGJvb2xlYW4pOiB2b2lkXG5cdHtcblx0XHRjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZyYW1lXCIpO1xuXHRcdGlmICh0aGlzLmluY2x1ZGVCb3JkZXJzICYmICFza2lwVGhpc0JvcmRlcilcblx0XHR7XG5cdFx0XHRjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnd2l0aC1ib3JkZXInKTtcblx0XHR9XG5cdFx0bGV0IGRpckNsYXNzOiBzdHJpbmc7XG5cdFx0bGV0IGRpclBvc3RGaXg6IHN0cmluZztcblx0XHRpZiAoZnJhbWUuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uY29sdW1uKVxuXHRcdHtcblx0XHRcdGRpckNsYXNzID0gXCJkaXItY29sXCI7XG5cdFx0XHRkaXJQb3N0Rml4ID0gXCJ3aWR0aFwiO1xuXHRcdH1cblx0XHRlbHNlIGlmIChmcmFtZS5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5yb3cpXG5cdFx0e1xuXHRcdFx0ZGlyQ2xhc3MgPSBcImRpci1yb3dcIjtcblx0XHRcdGRpclBvc3RGaXggPSBcImhlaWdodFwiO1xuXHRcdH1cblx0XHRjb250YWluZXIuY2xhc3NMaXN0LmFkZChkaXJDbGFzcyk7XG5cdFx0bGV0IGlubGluZVN0eWxlOiBzdHJpbmcgPSBcIlwiO1xuXHRcdGlmICh0eXBlb2YgZnJhbWUubWluU2l6ZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHR7XG5cdFx0XHRpbmxpbmVTdHlsZSArPSBgbWluLSR7ZGlyUG9zdEZpeH06ICR7ZnJhbWUubWluU2l6ZX1weDsgYDtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBmcmFtZS5tYXhTaXplICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdHtcblx0XHRcdGlubGluZVN0eWxlICs9IGBtYXgtJHtkaXJQb3N0Rml4fTogJHtmcmFtZS5tYXhTaXplfXB4OyBgO1x0XHRcdFxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgZnJhbWUuZnJhY3Rpb24gPT09IFwidW5kZWZpbmVkXCIpXG5cdFx0e1xuXHRcdFx0ZnJhbWUuZnJhY3Rpb24gPSAxO1xuXHRcdH1cblx0XHRpbmxpbmVTdHlsZSArPSBgZmxleC1ncm93OiAke2ZyYW1lLmZyYWN0aW9ufTsgYDtcdFx0XHRcblxuXHRcdGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBpbmxpbmVTdHlsZSk7XG5cblx0XHRpZiAoZnJhbWUuaW5zaWRlIGluc3RhbmNlb2YgQXJyYXkpXG5cdFx0e1xuXHRcdFx0bGV0IGxhc3RDaGlsZEZyYW1lID0gZnJhbWUuaW5zaWRlW2ZyYW1lLmluc2lkZS5sZW5ndGggLSAxXTtcblx0XHRcdGZvciAobGV0IGNoaWxkRnJhbWUgb2YgZnJhbWUuaW5zaWRlKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgY2hpbGRDb250YWluZXI6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkQ29udGFpbmVyKTtcblx0XHRcdFx0bGV0IGlzTGFzdENoaWxkID0gY2hpbGRGcmFtZSA9PT0gbGFzdENoaWxkRnJhbWU7XG5cdFx0XHRcdHRoaXMuYWRkRnJhbWUoY2hpbGRDb250YWluZXIsIGNoaWxkRnJhbWUsIGxvb2t1cCwgaXNMYXN0Q2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0bG9va3VwLnNldChjb250YWluZXIsIGZyYW1lLmluc2lkZSk7XG5cdFx0fVxuXHR9XG59IiwiZXhwb3J0IGNsYXNzIERldmxpYkFsZ28ge1xuXHRcblx0cHVibGljIHN0YXRpYyBCaW5hcnlTZWFyY2hJbmRleDxUPihsaXN0OiBUW10sIGNvbXBhcmVGdW5jdGlvbjogKGVsZW1lbnQ6IFQpID0+IG51bWJlcik6IG51bWJlciB8IFtudW1iZXIgfCB1bmRlZmluZWQsIG51bWJlciB8IHVuZGVmaW5lZF1cblx0e1xuXHRcdGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcblx0XHR7XG5cdFx0XHRyZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcblx0XHR9XG5cdFx0bGV0IGZpcnN0RWxlbWVudDogVCA9IGxpc3RbMF07XG5cdFx0bGV0IGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlRnVuY3Rpb24oZmlyc3RFbGVtZW50KTtcblx0XHRpZiAoY29tcGFyZVJlc3VsdCA+IDApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFt1bmRlZmluZWQsIDBdO1xuXHRcdH1cblx0XHRsZXQgbGFzdEVsZW1lbnQ6IFQgPSBsaXN0W2xpc3QubGVuZ3RoIC0gMV07XG5cdFx0Y29tcGFyZVJlc3VsdCA9IGNvbXBhcmVGdW5jdGlvbihsYXN0RWxlbWVudCk7XG5cdFx0aWYgKGNvbXBhcmVSZXN1bHQgPCAwKVxuXHRcdHtcblx0XHRcdHJldHVybiBbbGlzdC5sZW5ndGggLSAxLCB1bmRlZmluZWRdO1xuXHRcdH1cblx0XHRyZXR1cm4gRGV2bGliQWxnby5CaW5hcnlTZWFyY2hSZWN1cnNlKGxpc3QsIGNvbXBhcmVGdW5jdGlvbiwgMCwgbGlzdC5sZW5ndGggLSAxKTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgQmluYXJ5U2VhcmNoUmVjdXJzZTxUPihsaXN0OiBUW10sIGNvbXBhcmVGdW5jdGlvbjogKGVsZW1lbnQ6IFQpID0+IG51bWJlciwgaWR4MTogbnVtYmVyLCBpZHgyOiBudW1iZXIpOiBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdXG5cdHtcblx0XHRpZiAoTWF0aC5hYnMoaWR4MSAtIGlkeDIpID09PSAxKVxuXHRcdHtcblx0XHRcdHJldHVybiBbaWR4MSwgaWR4Ml07XG5cdFx0fVxuXHRcdC8vIGlmIChpZHgxID09PSBpZHgyKVxuXHRcdC8vIHtcblx0XHQvLyBcdHJldHVybiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG5cdFx0Ly8gfVxuXHRcdGxldCBtaWRJbmRleCA9IE1hdGguZmxvb3IoKGlkeDEgKyBpZHgyKSAvIDIpO1xuXHRcdGxldCBlbGVtZW50OiBUID0gbGlzdFttaWRJbmRleF07XG5cdFx0bGV0IGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlRnVuY3Rpb24oZWxlbWVudCk7XG5cdFx0aWYgKGNvbXBhcmVSZXN1bHQgPT09IDApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG1pZEluZGV4O1xuXHRcdH1cblx0XHRlbHNlIGlmIChjb21wYXJlUmVzdWx0ID4gMClcblx0XHR7XG5cdFx0XHRyZXR1cm4gRGV2bGliQWxnby5CaW5hcnlTZWFyY2hSZWN1cnNlKGxpc3QsIGNvbXBhcmVGdW5jdGlvbiwgaWR4MSwgbWlkSW5kZXgpO1x0XHRcdFxuXHRcdH1cblx0XHRlbHNlIGlmIChjb21wYXJlUmVzdWx0IDwgMClcblx0XHR7XG5cdFx0XHRyZXR1cm4gRGV2bGliQWxnby5CaW5hcnlTZWFyY2hSZWN1cnNlKGxpc3QsIGNvbXBhcmVGdW5jdGlvbiwgbWlkSW5kZXgsIGlkeDIpO1xuXHRcdH1cblx0fVxuXG5cblx0cHVibGljIHN0YXRpYyBjb21wYXJlUHJvcGVydHk8b2JqVHlwZT4obnVtOiBudW1iZXIsIHByb3BlcnR5QWNjZXNzb3I6IChvYmpUeXBlOiBhbnkpID0+IG51bWJlciwpOiAob2JqOiBvYmpUeXBlKSA9PiBudW1iZXJcblx0e1xuXHRcdHJldHVybiAoYTogb2JqVHlwZSkgPT5cblx0XHR7XG5cdFx0XHRjb25zdCBhVmFsID0gcHJvcGVydHlBY2Nlc3NvcihhKTtcblx0XHRcdHJldHVybiBEZXZsaWJBbGdvLmNvbXBhcmVWYWx1ZXMoYVZhbCwgbnVtKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIHNvcnRPblByb3BlcnR5PG9ialR5cGU+KHByb3BlcnR5QWNjZXNzb3I6IChvYmpUeXBlOiBvYmpUeXBlKSA9PiBudW1iZXIsIGFzY2VuZCA9IHRydWUpOiAoYTogb2JqVHlwZSwgYjogb2JqVHlwZSkgPT4gbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gKGE6IG9ialR5cGUsIGI6IG9ialR5cGUpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgYVZhbCA9IHByb3BlcnR5QWNjZXNzb3IoYSk7XG5cdFx0XHRjb25zdCBiVmFsID0gcHJvcGVydHlBY2Nlc3NvcihiKTtcblx0XHRcdGlmIChhc2NlbmQpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBEZXZsaWJBbGdvLnNvcnRBc2NlbmQoYVZhbCwgYlZhbCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBEZXZsaWJBbGdvLnNvcnREZXNjZW5kKGFWYWwsIGJWYWwpO1x0XHRcdFx0XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzb3J0QXNjZW5kKGFWYWw6IG51bWJlciwgYlZhbDogbnVtYmVyKTogbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gRGV2bGliQWxnby5jb21wYXJlVmFsdWVzKGFWYWwsIGJWYWwpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzb3J0RGVzY2VuZChhVmFsOiBudW1iZXIsIGJWYWw6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIERldmxpYkFsZ28uY29tcGFyZVZhbHVlcyhiVmFsLCBhVmFsKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGNvbXBhcmVWYWx1ZXMoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdFx0bGV0IGRpZmYgPSBhIC0gYjtcblx0XHRcdGlmIChNYXRoLmFicyhkaWZmKSA+IDApXG5cdFx0XHR7XG5cdFx0XHRcdGRpZmYgLz0gTWF0aC5hYnMoZGlmZik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG59IiwiZXhwb3J0IGNsYXNzIERldmxpYk1hdGhcbntcblxuXHRwdWJsaWMgc3RhdGljIHN1bU4oLi4ubnVtYmVyczogbnVtYmVyW10pOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiBudW1iZXJzLnJlZHVjZSggKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBhICsgYiApO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzdW0oYXJyOiBudW1iZXJbXSk6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIERldmxpYk1hdGguc3VtTiguLi5hcnIpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBhdmVyYWdlTiguLi5udW1iZXJzOiBudW1iZXJbXSk6IG51bWJlclxuXHR7XG5cdFx0Y29uc3Qgc3VtID0gRGV2bGliTWF0aC5zdW0obnVtYmVycyk7XG5cdFx0cmV0dXJuIHN1bSAvIG51bWJlcnMubGVuZ3RoO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBhdmVyYWdlKGFycjogbnVtYmVyW10pOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiBEZXZsaWJNYXRoLmF2ZXJhZ2VOKC4uLmFycik7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIG1lYW5TcXVhcmVkRXJyb3IobnVtYmVyczogbnVtYmVyW10sIHY6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0Y29uc3Qgc3F1YXJlZEVycm9yczogbnVtYmVyW10gPSBudW1iZXJzLm1hcCggKGE6IG51bWJlcikgPT4gTWF0aC5wb3coYSAtIHYsICAyKSApO1xuXHRcdHJldHVybiBEZXZsaWJNYXRoLmF2ZXJhZ2Uoc3F1YXJlZEVycm9ycyk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIHZhcmlhbmNlTiguLi5udW1iZXJzOiBudW1iZXJbXSk6IG51bWJlclxuXHR7XG5cdFx0bGV0IGF2ZyA9IERldmxpYk1hdGguYXZlcmFnZShudW1iZXJzKTtcblx0XHRyZXR1cm4gRGV2bGliTWF0aC5tZWFuU3F1YXJlZEVycm9yKG51bWJlcnMsIGF2Zyk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIHZhcmlhbmNlKG51bWJlcnM6IG51bWJlcltdKTogbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gRGV2bGliTWF0aC52YXJpYW5jZU4oLi4ubnVtYmVycyk7XG5cdH1cblxuXHQvLyByZXR1cm5zIGEgbnVtYmVyIGluIHRoZSByYW5nZSBbbWluLCBtYXhdIGluY2x1c2l2ZSBvbiBib3RoIGVuZHMuXG5cdHB1YmxpYyBzdGF0aWMgcmFuZG9tSW50KG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggKyAxKSk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBuQ2hvb3NlVHdvKG46IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIG4gKiAobi0xKSAvIDIuMFxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBpc051bWJlcih0ZXh0OiBzdHJpbmcpOiBib29sZWFuXG5cdHtcblx0XHRpZiAodGV4dCA9PT0gXCJcIilcblx0XHR7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiAhaXNOYU4oTnVtYmVyKHRleHQpKVxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBjbGFtcCh2YWw6IG51bWJlciwgW21pblZhbCwgbWF4VmFsXTogW251bWJlciwgbnVtYmVyXSk6IG51bWJlclxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbCwgbWluVmFsKSwgbWF4VmFsKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBpbWFnZSB9IGZyb20gXCJkM1wiO1xuXG5leHBvcnQgY2xhc3MgRGV2bGliVFNVdGlsIHtcblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIGFzeW5jU2V0VGltZW91dChmOiBGdW5jdGlvbiwgbWlsbGlEZWxheTogbnVtYmVyKTogUHJvbWlzZTxhbnk+XG5cdHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG5cdFx0e1xuXHRcdFx0c2V0VGltZW91dChcblx0XHRcdFx0KCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGYoKTtcblx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG1pbGxpRGVsYXlcblx0XHRcdCk7XG5cdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGFzeW5jIG1ha2VBc3luYyhmOiBGdW5jdGlvbik6IFByb21pc2U8YW55PlxuXHR7XG5cdFx0cmV0dXJuIERldmxpYlRTVXRpbC5hc3luY1NldFRpbWVvdXQoZiwgMCk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGdldEljb25CdXR0b24oaWNvbktleTogc3RyaW5nLCBjYWxsYmFjazogKGV2OiBNb3VzZUV2ZW50KSA9PiB2b2lkKTogSFRNTEJ1dHRvbkVsZW1lbnRcblx0e1xuXHRcdGxldCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcblx0XHRidG4uY2xhc3NMaXN0LmFkZCgnYmFzaWNJY29uQnV0dG9uJyk7XG5cdFx0bGV0IGljb24gPSBEZXZsaWJUU1V0aWwuZ2V0Rm9udEF3ZXNvbWVJY29uKGljb25LZXkpO1xuXHRcdGJ0bi5hcHBlbmRDaGlsZChpY29uKTtcblx0XHRidG4ub25jbGljayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiBidG47XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGdldEZvbnRBd2Vzb21lSWNvbihpY29uS2V5OiBzdHJpbmcpOiBIVE1MRWxlbWVudFxuXHR7XG5cdFx0Ly8gPGkgY2xhc3M9XCJmYXMgZmEte2ljb259XCI+PC9pPlxuXHRcdGxldCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XG5cdFx0aWNvbi5jbGFzc0xpc3QuYWRkKCdmYXMnKTtcblx0XHRpY29uLmNsYXNzTGlzdC5hZGQoJ2ZhLScgKyBpY29uS2V5KTtcblx0XHRyZXR1cm4gaWNvbjtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc2hvdyhlbGVtZW50OiBFbGVtZW50KTogdm9pZFxuXHR7XG5cdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdub0Rpc3AnKTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgaGlkZShlbGVtZW50OiBFbGVtZW50KTogdm9pZFxuXHR7XG5cdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdub0Rpc3AnKTtcblx0fVxuXHRwdWJsaWMgc3RhdGljIGxhdW5jaFNwaW5uZXIoKTogdm9pZFxuXHR7XG5cdFx0Y29uc3Qgb3V0ZXJJZCA9ICdsb2FkaW5nU3Bpbm5lckNvbnRhaW5lcic7XG5cdFx0aWYgKCFEZXZsaWJUU1V0aWwuc3Bpbm5lckluRG9tKCkpXG5cdFx0e1xuXHRcdFx0bGV0IG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRvdXRlci5jbGFzc0xpc3QuYWRkKCdzcGlubmVyT3V0ZXInKTtcblx0XHRcdG91dGVyLmlkID0gb3V0ZXJJZDtcblx0XHRcdFxuXHRcdFx0bGV0IGltZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0aW1nRGl2LmNsYXNzTGlzdC5hZGQoJ3NwaW5uZXJXcmFwcGVyJyk7XG5cblx0XHRcdGxldCBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXHRcdFx0aW5uZXIuY2xhc3NMaXN0LmFkZCgnc3Bpbm5lcicpO1xuXHRcdFx0aW5uZXIuc3JjID0gJy9zcGlubmVyLmdpZic7XG5cdFx0XHRpbWdEaXYuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuXHRcdFx0b3V0ZXIuYXBwZW5kQ2hpbGQoaW1nRGl2KTtcblx0XHRcdFxuXHRcdFx0bGV0IGF0dHJpYnV0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdFx0YXR0cmlidXRpb24uY2xhc3NMaXN0LmFkZCgnYXR0cmlidXRpb25MaW5rJyk7XG5cdFx0XHRhdHRyaWJ1dGlvbi5ocmVmID0gJ2h0dHBzOi8vbG9hZGluZy5pby9hc3NldC80NDI0NzMnO1xuXHRcdFx0YXR0cmlidXRpb24uaW5uZXJUZXh0ID0gXCJpY29uICdEb3VibGUgUmluZycgZnJvbSBsb2FkaW5nLmlvXCI7XG5cdFx0XHRcblx0XHRcdG91dGVyLmFwcGVuZENoaWxkKGF0dHJpYnV0aW9uKTtcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXHRcdH1cblx0XHRpZiAoIURldmxpYlRTVXRpbC5zcGlubmVyU3Bpbm5pbmcoKSlcblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuc2hvdyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvdXRlcklkKSk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzdG9wU3Bpbm5lcigpOiB2b2lkXG5cdHtcblx0XHRsZXQgc3Bpbm5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nU3Bpbm5lckNvbnRhaW5lcicpO1xuXHRcdGlmIChzcGlubmVyKVxuXHRcdHtcblx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHNwaW5uZXIpO1xuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc3Bpbm5lckluRG9tKCk6IGJvb2xlYW5cblx0e1xuXHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZ1NwaW5uZXJDb250YWluZXInKSAhPT0gbnVsbFxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzcGlubmVyU3Bpbm5pbmcoKTogYm9vbGVhblxuXHR7XG5cdFx0bGV0IG91dGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmdTcGlubmVyQ29udGFpbmVyJyk7XG5cdFx0aWYgKG91dGVyICYmICFvdXRlci5jbGFzc0xpc3QuY29udGFpbnMoJ25vRGlzcCcpKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IGxvYWQgfSBmcm9tIFwicHJvdG9idWZqc1wiO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vc3JjL0RhdGFNb2RlbC9DdXJ2ZUxpc3QnO1xuaW1wb3J0IHsgQ3VydmVMaXN0RmFjdG9yeSB9IGZyb20gJy4uL3NyYy9EYXRhTW9kZWwvQ3VydmVMaXN0RmFjdG9yeSc7XG5pbXBvcnQgeyBEZXJpdmVkVHJhY2tWYWx1ZUZ1bmN0aW9ucyB9IGZyb20gJy4uL3NyYy9EYXRhTW9kZWwvRGVyaXZlZFRyYWNrVmFsdWVGdW5jdGlvbnMnO1xuaW1wb3J0IHsgRGVyaXZlZFBvaW50VmFsdWVGdW5jdGlvbnMgfSBmcm9tICcuLi9zcmMvRGF0YU1vZGVsL0Rlcml2ZWRQb2ludFZhbHVlRnVuY3Rpb25zJztcbmltcG9ydCB7IEFwcCB9IGZyb20gJy4vQXBwJztcbmltcG9ydCB7IERhdGFzZXRTcGVjIH0gZnJvbSAnLi90eXBlcyc7XG5cbmxldCBtZXRhQ29udGFpbmVyOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZXRhQ29udGFpbmVyJyk7XG5cbmxldCBkZXJpdmVkVHJhY2tEYXRhRnVuY3Rpb25zID0gRGVyaXZlZFRyYWNrVmFsdWVGdW5jdGlvbnMuR2V0RnVuY3Rpb25MaXN0KCk7XG5sZXQgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9ucyA9IERlcml2ZWRQb2ludFZhbHVlRnVuY3Rpb25zLkdldEZ1bmN0aW9uTGlzdCgpO1xubGV0IGFwcDogQXBwPEN1cnZlTGlzdCwgRGF0YXNldFNwZWM+ID0gbmV3IEFwcDxDdXJ2ZUxpc3QsIERhdGFzZXRTcGVjPihtZXRhQ29udGFpbmVyLCBDdXJ2ZUxpc3RGYWN0b3J5LkNyZWF0ZUN1cnZlTGlzdEZyb21DU1ZPYmplY3QsIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnMsIGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnMpO1xud2luZG93Lm9ucmVzaXplID0gKCkgPT4gYXBwLk9uV2luZG93UmVzaXplKCk7XG5cblxuZDMuanNvbignL3N0YXRpYy9sYXlvdXRzL2RlZmF1bHRMYXlvdXQuanNvbicpLnRoZW4oKGRhdGE6IGFueSkgPT5cbntcbiAgICBhcHAuSW5pdGlhbGl6ZUxheW91dChkYXRhKTtcbiAgICBjb25zdCBkYXRhc2V0SWQ6IHN0cmluZyA9IG1ldGFDb250YWluZXIuZGF0YXNldC5kYXRhc2V0O1xuICAgIGFwcC5Mb2FkRGF0YXNldChkYXRhc2V0SWQpO1xufSk7XG4iLCJleHBvcnQgaW50ZXJmYWNlIEZyYW1lPFQ+IHtcblx0ZnJhY3Rpb24/OiBudW1iZXIsIC8vIGlmIG5vIGZyYWN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgYXNzdW1lZCB0byBiZSBlcXVhbCB3ZWlnaHRcblx0bWluU2l6ZT86IG51bWJlcixcblx0bWF4U2l6ZT86IG51bWJlcixcblx0ZGlyZWN0aW9uOiBEaXJlY3Rpb24sXG5cdGluc2lkZTogRnJhbWU8VD5bXSB8IFRcbn1cblxuZXhwb3J0IGVudW0gRGlyZWN0aW9uIHtcblx0cm93ID0gXCJyb3dcIixcblx0Y29sdW1uID0gXCJjb2xcIlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudEluaXRJbmZvIHtcblx0dHlwZTogQ29tcG9uZW50VHlwZSxcblx0aW5pdEFyZ3M6IEFyZ3VtZW50c1xufVxuXG5leHBvcnQgZW51bSBDb21wb25lbnRUeXBlIHtcblx0VG9vbGJhciA9IFwiVG9vbGJhclwiLFxuXHRQbG90MmRQYXRoc1dpZGdldCA9IFwiUGxvdDJkUGF0aHNXaWRnZXRcIixcblx0TWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0ID0gXCJNZXRyaWNEaXN0cmlidXRpb25XaWRnZXRcIixcblx0SW1hZ2VTZWxlY3Rpb25XaWRnZXQgPSBcIkltYWdlU2VsZWN0aW9uV2lkZ2V0XCIsXG5cdEltYWdlU3RhY2tXaWRnZXQgPSBcIkltYWdlU3RhY2tXaWRnZXRcIixcblx0RGV0YWlsZWREaXN0cmlidXRpb24gPSBcIkRldGFpbGVkRGlzdHJpYnV0aW9uXCJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmd1bWVudHMge1xuXHRbYXJnTmFtZTogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBlbnVtIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzIHtcblx0QmFzaXNTZWxlY3QgPSBcIkJhc2lzU2VsZWN0XCIsXG5cdFNjYXR0ZXJwbG90U2VsZWN0ID0gXCJTY2F0dGVycGxvdFNlbGVjdFwiLFxuXHREaXN0cmlidXRpb25QbG90ID0gXCJEaXN0cmlidXRpb25QbG90XCIsXG5cdFNjYXR0ZXJwbG90ID0gXCJTY2F0dGVycGxvdFwiXG59XG5cbmV4cG9ydCBlbnVtIE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCB7XG5cdFBvaW50ID0gXCJQb2ludFwiLFxuXHRDdXJ2ZSA9IFwiQ3VydmVcIlxufVxuZXhwb3J0IGludGVyZmFjZSBBcHBEYXRhPFNwZWNUeXBlPiB7XG5cdEdldEZhY2V0T3B0aW9uczogKCkgPT4gRmFjZXRPcHRpb25bXTtcblx0T25CcnVzaENoYW5nZTogKCkgPT4gdm9pZDtcblx0U3BlY2lmaWNhdGlvbjogU3BlY1R5cGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGYWNldE9wdGlvbiB7XG5cdG5hbWU6IHN0cmluZyxcblx0R2V0RmFjZXRzOiAoKSA9PiBGYWNldFtdXG5cbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmFjZXQge1xuXHRuYW1lOiBzdHJpbmcsXG5cdGRhdGE6IGFueVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFzZXRTcGVjIHtcblx0dW5pcXVlSWQ6IHN0cmluZyxcbiAgICBkaXNwbGF5TmFtZTogc3RyaW5nLFxuICAgIGdvb2dsZURyaXZlSWQ6IHN0cmluZyxcblx0Zm9sZGVyUGF0aDogc3RyaW5nLFxuXHRsb2NhdGlvbk1hcHM6IExvY2F0aW9uTWFwc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uTWFwcyB7XG5cdFttYXBOYW1lOiBzdHJpbmddOiBMb2NhdGlvbk1hcExpc3QgfCBMb2NhdGlvbk1hcFRlbXBsYXRlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb25NYXBMaXN0XG57XG5cdFtjYXRlZ29yeU5hbWU6IHN0cmluZ106IFtudW1iZXIsIG51bWJlcl1bXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uTWFwVGVtcGxhdGVcbntcblx0W3RlbXBsYXRlRmlsZW5hbWU6IHN0cmluZ106IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VTdGFja01ldGFEYXRhXG57XG5cdHVybDogc3RyaW5nLFxuXHR0aWxlV2lkdGg6IG51bWJlcixcblx0dGlsZUhlaWdodDogbnVtYmVyLFxuXHRudW1iZXJPZlRpbGVzOiBudW1iZXIsXG5cdG51bWJlck9mQ29sdW1uczogbnVtYmVyLFxuXHRzY2FsZUZhY3Rvcj86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBSZWN0ID0gW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dO1xuXG4vLyBleHBvcnQgdHlwZSBMb2NhdGlvbk1hcExpc3QgPSBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdW10+XG4vLyBleHBvcnQgdHlwZSBMb2NhdGlvbk1hcFRlbXBsYXRlID0gTWFwPHN0cmluZywgc3RyaW5nW10+Il19
