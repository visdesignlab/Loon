(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = codegen;

/**
 * Begins generating a function.
 * @memberof util
 * @param {string[]} functionParams Function parameter names
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 */
function codegen(functionParams, functionName) {

    /* istanbul ignore if */
    if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = undefined;
    }

    var body = [];

    /**
     * Appends code to the function's body or finishes generation.
     * @typedef Codegen
     * @type {function}
     * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any
     * @param {...*} [formatParams] Format parameters
     * @returns {Codegen|Function} Itself or the generated function if finished
     * @throws {Error} If format parameter counts do not match
     */

    function Codegen(formatStringOrScope) {
        // note that explicit array handling below makes this ~50% faster

        // finish the function
        if (typeof formatStringOrScope !== "string") {
            var source = toString();
            if (codegen.verbose)
                console.log("codegen: " + source); // eslint-disable-line no-console
            source = "return " + source;
            if (formatStringOrScope) {
                var scopeKeys   = Object.keys(formatStringOrScope),
                    scopeParams = new Array(scopeKeys.length + 1),
                    scopeValues = new Array(scopeKeys.length),
                    scopeOffset = 0;
                while (scopeOffset < scopeKeys.length) {
                    scopeParams[scopeOffset] = scopeKeys[scopeOffset];
                    scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
                }
                scopeParams[scopeOffset] = source;
                return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func
            }
            return Function(source)(); // eslint-disable-line no-new-func
        }

        // otherwise append to body
        var formatParams = new Array(arguments.length - 1),
            formatOffset = 0;
        while (formatOffset < formatParams.length)
            formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
            var value = formatParams[formatOffset++];
            switch ($1) {
                case "d": case "f": return String(Number(value));
                case "i": return String(Math.floor(value));
                case "j": return JSON.stringify(value);
                case "s": return String(value);
            }
            return "%";
        });
        if (formatOffset !== formatParams.length)
            throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
    }

    function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
    }

    Codegen.toString = toString;
    return Codegen;
}

/**
 * Begins generating a function.
 * @memberof util
 * @function codegen
 * @param {string} [functionName] Function name if not anonymous
 * @returns {Codegen} Appender that appends code to the function's body
 * @variation 2
 */

/**
 * When set to `true`, codegen will log generated code to console. Useful for debugging.
 * @name util.codegen.verbose
 * @type {boolean}
 */
codegen.verbose = false;

},{}],4:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],5:[function(require,module,exports){
"use strict";
module.exports = fetch;

var asPromise = require("@protobufjs/aspromise"),
    inquire   = require("@protobufjs/inquire");

var fs = inquire("fs");

/**
 * Node-style callback as used by {@link util.fetch}.
 * @typedef FetchCallback
 * @type {function}
 * @param {?Error} error Error, if any, otherwise `null`
 * @param {string} [contents] File contents, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Options as used by {@link util.fetch}.
 * @typedef FetchOptions
 * @type {Object}
 * @property {boolean} [binary=false] Whether expecting a binary response
 * @property {boolean} [xhr=false] If `true`, forces the use of XMLHttpRequest
 */

/**
 * Fetches the contents of a file.
 * @memberof util
 * @param {string} filename File path or url
 * @param {FetchOptions} options Fetch options
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
function fetch(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else if (!options)
        options = {};

    if (!callback)
        return asPromise(fetch, this, filename, options); // eslint-disable-line no-invalid-this

    // if a node-like filesystem is present, try it first but fall back to XHR if nothing is found.
    if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
            return err && typeof XMLHttpRequest !== "undefined"
                ? fetch.xhr(filename, options, callback)
                : err
                ? callback(err)
                : callback(null, options.binary ? contents : contents.toString("utf8"));
        });

    // use the XHR version otherwise.
    return fetch.xhr(filename, options, callback);
}

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */

/**
 * Fetches the contents of a file.
 * @name util.fetch
 * @function
 * @param {string} path File path or url
 * @param {FetchOptions} [options] Fetch options
 * @returns {Promise<string|Uint8Array>} Promise
 * @variation 3
 */

/**/
fetch.xhr = function fetch_xhr(filename, options, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange /* works everywhere */ = function fetchOnReadyStateChange() {

        if (xhr.readyState !== 4)
            return undefined;

        // local cors security errors return status 0 / empty string, too. afaik this cannot be
        // reliably distinguished from an actually empty file for security reasons. feel free
        // to send a pull request if you are aware of a solution.
        if (xhr.status !== 0 && xhr.status !== 200)
            return callback(Error("status " + xhr.status));

        // if binary data is expected, make sure that some sort of array is returned, even if
        // ArrayBuffers are not supported. the binary string fallback, however, is unsafe.
        if (options.binary) {
            var buffer = xhr.response;
            if (!buffer) {
                buffer = [];
                for (var i = 0; i < xhr.responseText.length; ++i)
                    buffer.push(xhr.responseText.charCodeAt(i) & 255);
            }
            return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
    };

    if (options.binary) {
        // ref: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data#Receiving_binary_data_in_older_browsers
        if ("overrideMimeType" in xhr)
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
    }

    xhr.open("GET", filename);
    xhr.send();
};

},{"@protobufjs/aspromise":1,"@protobufjs/inquire":7}],6:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],7:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],8:[function(require,module,exports){
"use strict";

/**
 * A minimal path module to resolve Unix, Windows and URL paths alike.
 * @memberof util
 * @namespace
 */
var path = exports;

var isAbsolute =
/**
 * Tests if the specified path is absolute.
 * @param {string} path Path to test
 * @returns {boolean} `true` if path is absolute
 */
path.isAbsolute = function isAbsolute(path) {
    return /^(?:\/|\w+:)/.test(path);
};

var normalize =
/**
 * Normalizes the specified path.
 * @param {string} path Path to normalize
 * @returns {string} Normalized path
 */
path.normalize = function normalize(path) {
    path = path.replace(/\\/g, "/")
               .replace(/\/{2,}/g, "/");
    var parts    = path.split("/"),
        absolute = isAbsolute(path),
        prefix   = "";
    if (absolute)
        prefix = parts.shift() + "/";
    for (var i = 0; i < parts.length;) {
        if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
                parts.splice(--i, 2);
            else if (absolute)
                parts.splice(i, 1);
            else
                ++i;
        } else if (parts[i] === ".")
            parts.splice(i, 1);
        else
            ++i;
    }
    return prefix + parts.join("/");
};

/**
 * Resolves the specified include path against the specified origin path.
 * @param {string} originPath Path to the origin file
 * @param {string} includePath Include path relative to origin path
 * @param {boolean} [alreadyNormalized=false] `true` if both paths are already known to be normalized
 * @returns {string} Path to the include file
 */
path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
    if (!alreadyNormalized)
        includePath = normalize(includePath);
    if (isAbsolute(includePath))
        return includePath;
    if (!alreadyNormalized)
        originPath = normalize(originPath);
    return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
};

},{}],9:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],10:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],11:[function(require,module,exports){
// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

function pairs(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

function cross(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function number(x) {
  return x === null ? NaN : +x;
}

function variance(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}

function deviation(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
}

function extent(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

function constant(x) {
  return function() {
    return x;
  };
}

function identity(x) {
  return x;
}

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function ticks(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}

function histogram() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
}

function quantile(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

function freedmanDiaconis(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}

function scott(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
}

function max(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}

function mean(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
}

function median(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
}

function merge(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}

function min(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}

function permute(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
}

function scan(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}

function shuffle(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}

function sum(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}

function transpose(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
}

function length(d) {
  return d.length;
}

function zip() {
  return transpose(arguments);
}

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],12:[function(require,module,exports){
// https://d3js.org/d3-axis/ v1.0.12 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = Array.prototype.slice;

function identity(x) {
  return x;
}

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "currentColor"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "currentColor")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "currentColor")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
            : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],13:[function(require,module,exports){
// https://d3js.org/d3-brush/ v1.1.5 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function BrushEvent(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

var MODE_DRAG = {name: "drag"},
    MODE_SPACE = {name: "space"},
    MODE_HANDLE = {name: "handle"},
    MODE_CENTER = {name: "center"};

function number1(e) {
  return [+e[0], +e[1]];
}

function number2(e) {
  return [number1(e[0]), number1(e[1])];
}

function toucher(identifier) {
  return function(target) {
    return d3Selection.touch(target, d3Selection.event.touches, identifier);
  };
}

var X = {
  name: "x",
  handles: ["w", "e"].map(type),
  input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
  input: function(xy) { return xy == null ? null : number2(xy); },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

function brush() {
  return brush$1(XY);
}

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      touchable = defaultTouchable,
      keys = true,
      listeners = d3Dispatch.dispatch("start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          d3Selection.select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .on("mousedown.brush", started)
      .filter(touchable)
        .on("touchstart.brush", started)
        .on("touchmove.brush", touchmoved)
        .on("touchend.brush touchcancel.brush", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = d3Interpolate.interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && selection1 === null ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 !== null && selection1 !== null ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            d3Transition.interrupt(that);
            state.selection = selection1 === null ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  brush.clear = function(group) {
    brush.move(group, null);
  };

  function redraw() {
    var group = d3Selection.select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args, clean) {
    return (!clean && that.__brush.emitter) || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      else this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (touchending && !d3Selection.event.touches) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3Selection.event.target.__data__.type,
        mode = (keys && d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx = 0,
        dy = 0,
        moving,
        shifting = signX && signY && keys && d3Selection.event.shiftKey,
        lockX,
        lockY,
        pointer = d3Selection.event.touches ? toucher(d3Selection.event.changedTouches[0].identifier) : d3Selection.mouse,
        point0 = pointer(that),
        point = point0,
        emit = emitter(that, arguments, true).beforestart();

    if (type === "overlay") {
      if (selection) moving = true;
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = d3Selection.select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3Selection.event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = d3Selection.select(d3Selection.event.view)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);
      if (keys) view
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true);

      d3Drag.dragDisable(d3Selection.event.view);
    }

    nopropagation();
    d3Transition.interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (d3Selection.event.touches) {
        if (d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
      } else {
        d3Drag.dragEnable(d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3Selection.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function touchmoved() {
    emitter(this, arguments).moved();
  }

  function touchended() {
    emitter(this, arguments).ended();
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = number2(extent.apply(this, arguments));
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant(number2(_)), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush) : touchable;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.keyModifiers = function(_) {
    return arguments.length ? (keys = !!_, brush) : keys;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

exports.brush = brush;
exports.brushSelection = brushSelection;
exports.brushX = brushX;
exports.brushY = brushY;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":18,"d3-drag":19,"d3-interpolate":27,"d3-selection":34,"d3-transition":39}],14:[function(require,module,exports){
// https://d3js.org/d3-chord/ v1.0.6 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-path')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Array,d3Path) { 'use strict';

var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

function chord() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = d3Array.range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3Array.range(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max(0, tau - padAngle * n) / k;
    dx = k ? padAngle : tau / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}

var slice = Array.prototype.slice;

function constant(x) {
  return function() {
    return x;
  };
}

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function ribbon() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi,
        sa1 = endAngle.apply(this, argv) - halfPi,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi,
        ta1 = endAngle.apply(this, argv) - halfPi;

    if (!context) context = buffer = d3Path.path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
}

exports.chord = chord;
exports.ribbon = ribbon;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":11,"d3-path":28}],15:[function(require,module,exports){
// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

function nest() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

function keys(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
}

function values(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
}

function entries(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
}

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],16:[function(require,module,exports){
// https://d3js.org/d3-color/ v1.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? new Rgb(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? new Rgb((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.cubehelix = cubehelix;
exports.gray = gray;
exports.hcl = hcl;
exports.hsl = hsl;
exports.lab = lab;
exports.lch = lch;
exports.rgb = rgb;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],17:[function(require,module,exports){
// https://d3js.org/d3-contour/ v1.3.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Array) { 'use strict';

var array = Array.prototype;

var slice = array.slice;

function ascending(a, b) {
  return a - b;
}

function area(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}

function constant(x) {
  return function() {
    return x;
  };
}

function contains(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
}

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function noop() {}

var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

function contours() {
  var dx = 1,
      dy = 1,
      threshold = d3Array.thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
      tz = d3Array.tickStep(start, stop, tz);
      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

function defaultWeight() {
  return 1;
}

function density() {
  var x = defaultX,
      y = defaultY,
      weight = defaultWeight,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = constant(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (+x(d, i, data) + o) >> k,
          yi = (+y(d, i, data) + o) >> k,
          wi = +weight(d, i, data);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });

    // TODO Optimize.
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = d3Array.max(values0);
      tz = d3Array.tickStep(0, stop, tz);
      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
  };

  density.weight = function(_) {
    return arguments.length ? (weight = typeof _ === "function" ? _ : constant(+_), density) : weight;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
}

exports.contours = contours;
exports.contourDensity = density;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":11}],18:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],19:[function(require,module,exports){
// https://d3js.org/d3-drag/ v1.2.5 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-selection')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Selection) { 'use strict';

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

function nodrag(view) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

function constant(x) {
  return function() {
    return x;
  };
}

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function drag() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = d3Dispatch.dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
    if (!gesture) return;
    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(d3Selection.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = d3Selection.event.clientX;
    mousedowny = d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(d3Selection.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

exports.drag = drag;
exports.dragDisable = nodrag;
exports.dragEnable = yesdrag;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":18,"d3-selection":34}],20:[function(require,module,exports){
// https://d3js.org/d3-dsv/ v1.2.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear()) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

function dsv(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

function autoType(object) {
  for (var key in object) {
    var value = object[key].trim(), number, m;
    if (!value) value = null;
    else if (value === "true") value = true;
    else if (value === "false") value = false;
    else if (value === "NaN") value = NaN;
    else if (!isNaN(number = +value)) value = number;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    }
    else continue;
    object[key] = value;
  }
  return object;
}

// https://github.com/d3/d3-dsv/issues/45
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

exports.autoType = autoType;
exports.csvFormat = csvFormat;
exports.csvFormatBody = csvFormatBody;
exports.csvFormatRow = csvFormatRow;
exports.csvFormatRows = csvFormatRows;
exports.csvFormatValue = csvFormatValue;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.dsvFormat = dsv;
exports.tsvFormat = tsvFormat;
exports.tsvFormatBody = tsvFormatBody;
exports.tsvFormatRow = tsvFormatRow;
exports.tsvFormatRows = tsvFormatRows;
exports.tsvFormatValue = tsvFormatValue;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],21:[function(require,module,exports){
// https://d3js.org/d3-ease/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackInOut = backInOut;
exports.easeBackOut = backOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceInOut = bounceInOut;
exports.easeBounceOut = bounceOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleInOut = circleInOut;
exports.easeCircleOut = circleOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicInOut = cubicInOut;
exports.easeCubicOut = cubicOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticInOut = elasticInOut;
exports.easeElasticOut = elasticOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpInOut = expInOut;
exports.easeExpOut = expOut;
exports.easeLinear = linear;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyInOut = polyInOut;
exports.easePolyOut = polyOut;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadInOut = quadInOut;
exports.easeQuadOut = quadOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinInOut = sinInOut;
exports.easeSinOut = sinOut;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],22:[function(require,module,exports){
// https://d3js.org/d3-fetch/ v1.1.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dsv')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dsv'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Dsv) { 'use strict';

function responseBlob(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.blob();
}

function blob(input, init) {
  return fetch(input, init).then(responseBlob);
}

function responseArrayBuffer(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}

function buffer(input, init) {
  return fetch(input, init).then(responseArrayBuffer);
}

function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

function text(input, init) {
  return fetch(input, init).then(responseText);
}

function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return text(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = d3Dsv.dsvFormat(delimiter);
  return text(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3Dsv.csvParse);
var tsv = dsvParse(d3Dsv.tsvParse);

function image(input, init) {
  return new Promise(function(resolve, reject) {
    var image = new Image;
    for (var key in init) image[key] = init[key];
    image.onerror = reject;
    image.onload = function() { resolve(image); };
    image.src = input;
  });
}

function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.json();
}

function json(input, init) {
  return fetch(input, init).then(responseJson);
}

function parser(type) {
  return function(input, init)  {
    return text(input, init).then(function(text$$1) {
      return (new DOMParser).parseFromString(text$$1, type);
    });
  };
}

var xml = parser("application/xml");

var html = parser("text/html");

var svg = parser("image/svg+xml");

exports.blob = blob;
exports.buffer = buffer;
exports.dsv = dsv;
exports.csv = csv;
exports.tsv = tsv;
exports.image = image;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.html = html;
exports.svg = svg;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dsv":20}],23:[function(require,module,exports){
// https://d3js.org/d3-force/ v1.2.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-quadtree'), require('d3-collection'), require('d3-dispatch'), require('d3-timer')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

function center(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function constant(x) {
  return function() {
    return x;
  };
}

function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function collide(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  return force;
}

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function link(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = d3Collection.map(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
  };

  return force;
}

function x$1(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function simulation(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = d3Collection.map(),
      stepper = d3Timer.timer(step),
      event = d3Dispatch.dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.each(function (force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}

function manyBody() {
  var nodes,
      node,
      alpha,
      strength = constant(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}

function radial(radius, x, y) {
  var nodes,
      strength = constant(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}

function x$2(x) {
  var strength = constant(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
  };

  return force;
}

function y$2(y) {
  var strength = constant(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
  };

  return force;
}

exports.forceCenter = center;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceRadial = radial;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-collection":15,"d3-dispatch":18,"d3-quadtree":30,"d3-timer":38}],24:[function(require,module,exports){
// https://d3js.org/d3-format/ v1.4.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function formatDecimal(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

function exponent(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
}

function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}

function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
function formatTrim(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

var prefixExponent;

function formatPrefixAuto(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}

function formatRounded(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

function identity(x) {
  return x;
}

var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

function formatLocale(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "-" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;

        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}

var locale;

defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}

function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}

function precisionRound(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
}

exports.FormatSpecifier = FormatSpecifier;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],25:[function(require,module,exports){
// https://d3js.org/d3-geo/ v1.11.9 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Array) { 'use strict';

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

function adder() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}

function noop() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

function geoStream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

var areaRingSum = adder();

var areaSum = adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop;
  },
  sphere: function() {
    areaSum.add(tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos(phi),
      sinPhi = sin(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos(adLambda),
      v = k * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function area(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
}

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00$1, phi00$1, // first point
    p0, // previous 3D point
    deltaSum = adder(),
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon) phi1 = 90;
    else if (deltaSum < -epsilon) phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  },
  sphere: function() {
    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees * sign,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function bounds(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
}

var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00$2, phi00$2, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: noop,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroid(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
}

function constant(x) {
  return function() {
    return x;
  };
}

function compose(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}

function rotationIdentity(lambda, phi) {
  return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi),
      sinDeltaPhi = sin(deltaPhi),
      cosDeltaGamma = cos(deltaGamma),
      sinDeltaGamma = sin(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };

  return forward;
}

// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius),
      sinRadius = sin(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

function circle() {
  var center = constant([0, 0]),
      radius = constant(90),
      precision = constant(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees, x[1] *= degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
  };

  return circle;
}

function clipBuffer() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var sum = adder();

function longitude(point) {
  if (abs(point[0]) <= pi)
    return point[0];
  else
    return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
}

function polygonContains(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = sin(phi),
      normal = [sin(lambda), -cos(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  if (sinPhi === 1) phi = halfPi + epsilon;
  else if (sinPhi === -1) phi = -halfPi - epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin(phi0),
        cosPhi0 = cos(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin(phi1),
          cosPhi1 = cos(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > pi,
          k = sinPhi0 * sinPhi1;

      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle += antimeridian ? delta + sign * tau : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
}

function clip(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = d3Array.merge(segments);
        var startInside = polygonContains(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon
      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

function clipCircle(radius) {
  var cr = cos(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi) < epsilon,
        meridian = polar || delta < epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}

function clipLine(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = d3Array.merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

function extent() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

var lengthSum = adder(),
    lambda0$2,
    sinPhi0$1,
    cosPhi0$1;

var lengthStream = {
  sphere: noop,
  point: noop,
  lineStart: lengthLineStart,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin(phi),
      cosPhi = cos(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos(delta),
      sinDelta = sin(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

function length(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
}

var coordinates = [null, null],
    object = {type: "LineString", coordinates: coordinates};

function distance(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length(object);
}

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ao, bo, ab;
  for (var i = 0, n = coordinates.length; i < n; i++) {
    bo = distance(coordinates[i], point);
    if (bo === 0) return true;
    if (i > 0) {
      ab = distance(coordinates[i], coordinates[i - 1]);
      if (
        ab > 0 &&
        ao <= ab &&
        bo <= ab &&
        (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
      )
        return true;
    }
    ao = bo;
  }
  return false;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

function contains(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
}

function graticuleX(y0, y1, dy) {
  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}

function graticule10() {
  return graticule()();
}

function interpolate(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos(y0),
      sy0 = sin(y0),
      cy1 = cos(y1),
      sy1 = sin(y1),
      kx0 = cy0 * cos(x0),
      ky0 = cy0 * sin(x0),
      kx1 = cy1 * cos(x1),
      ky1 = cy1 * sin(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin(d);

  var interpolate = d ? function(t) {
    var B = sin(t *= d) / k,
        A = sin(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees,
      atan2(z, sqrt(x * x + y * y)) * degrees
    ];
  } : function() {
    return [x0 * degrees, y0 * degrees];
  };

  interpolate.distance = d;

  return interpolate;
}

function identity(x) {
  return x;
}

var areaSum$1 = adder(),
    areaRingSum$1 = adder(),
    x00,
    y00,
    x0$1,
    y0$1;

var areaStream$1 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity,
    y0$2 = x0$2,
    x1 = -x0$2,
    y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0,
    Y0$1 = 0,
    Z0$1 = 0,
    X1$1 = 0,
    Y1$1 = 0,
    Z1$1 = 0,
    X2$1 = 0,
    Y2$1 = 0,
    Z2$1 = 0,
    x00$1,
    y00$1,
    x0$3,
    y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

var lengthSum$1 = adder(),
    lengthRing,
    x00$2,
    y00$2,
    x0$4,
    y0$4;

var lengthStream$1 = {
  point: noop,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

function index(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

function transform(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy) {
  function transform(x, y) {
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k, (dy - y) / k];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, alpha) {
  var cosAlpha = cos(alpha),
      sinAlpha = sin(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate
      theta = null, preclip = clipAntimeridian, // pre-clip angle
      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * radians, point[1] * radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * degrees, point[1] * degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose(project, transform);
    projectRotateTransform = compose(rotate, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin(y)) / n;
    return [r * sin(x *= n), r0 - r * cos(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}

function albers() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
function albersUsa() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos(x),
        cy = cos(y),
        k = scale(cx * cy);
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin(c),
        cc = cos(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi];
};

function mercator() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau);
}

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
    var r = f / pow(tany(y), n);
    return [r * sin(n * x), f - r * cos(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
  };

  return project;
}

function conicConformal() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function equirectangular() {
  return projection(equirectangularRaw)
      .scale(152.63);
}

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin(nx), g - gy * cos(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

function conicEquidistant() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}

var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = sqrt(3) / 2,
    iterations = 12;

function equalEarthRaw(lambda, phi) {
  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}

equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs(delta) < epsilon2) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
    asin(sin(l) / M)
  ];
};

function equalEarth() {
  return projection(equalEarthRaw)
      .scale(177.158);
}

function gnomonicRaw(x, y) {
  var cy = cos(y), k = cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

function gnomonic() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}

function scaleTranslate$1(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function identity$1() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = identity,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    },
    fitWidth: function(width, object) {
      return fitWidth(projection, width, object);
    },
    fitHeight: function(height, object) {
      return fitHeight(projection, height, object);
    }
  };
}

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

function naturalEarth1() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
}

function orthographicRaw(x, y) {
  return [cos(y) * sin(x), sin(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

function orthographic() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon);
}

function stereographicRaw(x, y) {
  var cy = cos(y), k = 1 + cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

function stereographic() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi];
};

function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}

exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoArea = area;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipAntimeridian = clipAntimeridian;
exports.geoClipCircle = clipCircle;
exports.geoClipExtent = extent;
exports.geoClipRectangle = clipRectangle;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoContains = contains;
exports.geoDistance = distance;
exports.geoEqualEarth = equalEarth;
exports.geoEqualEarthRaw = equalEarthRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoIdentity = identity$1;
exports.geoInterpolate = interpolate;
exports.geoLength = length;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoNaturalEarth1 = naturalEarth1;
exports.geoNaturalEarth1Raw = naturalEarth1Raw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoPath = index;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoRotation = rotation;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoStream = geoStream;
exports.geoTransform = transform;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-array":11}],26:[function(require,module,exports){
// https://d3js.org/d3-hierarchy/ v1.1.9 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

function cluster() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function siblings(circles) {
  packEnclose(circles);
  return circles;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant(x) {
  return function() {
    return x;
  };
}

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function index() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

function partition() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
function tree() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function index$1() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
}

function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}

var resquarify = (function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(phi);

exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index;
exports.packEnclose = enclose;
exports.packSiblings = siblings;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$1;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapResquarify = resquarify;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],27:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ v1.4.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

function basis$1(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function basisClosed(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

function constant(x) {
  return function() {
    return x;
  };
}

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb(start, end) {
    var r = color((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = d3Color.rgb(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

function array(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}

function date(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

function number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

function object(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

function value(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb) : string)
      : b instanceof d3Color.color ? rgb
      : b instanceof Date ? date
      : isNumberArray(b) ? numberArray
      : Array.isArray(b) ? genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
}

function discrete(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

function hue$1(a, b) {
  var i = hue(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

function round(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var cssNode,
    cssRoot,
    cssView,
    svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
function zoom(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
}

function hsl(hue) {
  return function(start, end) {
    var h = hue((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$1 = hsl(hue);
var hslLong = hsl(nogamma);

function lab(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl(hue) {
  return function(start, end) {
    var h = hue((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$1 = hcl(hue);
var hclLong = hcl(nogamma);

function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

var cubehelix$1 = cubehelix(hue);
var cubehelixLong = cubehelix(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

function quantize(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateCubehelix = cubehelix$1;
exports.interpolateCubehelixLong = cubehelixLong;
exports.interpolateDate = date;
exports.interpolateDiscrete = discrete;
exports.interpolateHcl = hcl$1;
exports.interpolateHclLong = hclLong;
exports.interpolateHsl = hsl$1;
exports.interpolateHslLong = hslLong;
exports.interpolateHue = hue$1;
exports.interpolateLab = lab;
exports.interpolateNumber = number;
exports.interpolateNumberArray = numberArray;
exports.interpolateObject = object;
exports.interpolateRgb = rgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":16}],28:[function(require,module,exports){
// https://d3js.org/d3-path/ v1.0.9 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],29:[function(require,module,exports){
// https://d3js.org/d3-polygon/ v1.0.6 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function area(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}

function centroid(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function cross(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function hull(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}

function contains(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}

function length(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}

exports.polygonArea = area;
exports.polygonCentroid = centroid;
exports.polygonContains = contains;
exports.polygonHull = hull;
exports.polygonLength = length;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],30:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ v1.0.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

function tree_add(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

function tree_cover(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}

function tree_data() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}

function tree_extent(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}

function Quad(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}

function tree_find(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}

function tree_remove(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

function tree_root() {
  return this._root;
}

function tree_size() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}

function tree_visit(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
}

function tree_visitAfter(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}

function defaultX(d) {
  return d[0];
}

function tree_x(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

function defaultY(d) {
  return d[1];
}

function tree_y(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],31:[function(require,module,exports){
// https://d3js.org/d3-random/ v1.1.2 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function defaultSource() {
  return Math.random();
}

var uniform = (function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
})(defaultSource);

var normal = (function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
})(defaultSource);

var logNormal = (function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
})(defaultSource);

var irwinHall = (function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
})(defaultSource);

var bates = (function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
})(defaultSource);

var exponential = (function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
})(defaultSource);

exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],32:[function(require,module,exports){
// https://d3js.org/d3-scale-chromatic/ v1.5.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-interpolate'), require('d3-color')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3));
}(this, function (exports, d3Interpolate, d3Color) { 'use strict';

function colors(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

function ramp(scheme) {
  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
}

var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors);

var BrBG = ramp(scheme);

var scheme$1 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors);

var PRGn = ramp(scheme$1);

var scheme$2 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors);

var PiYG = ramp(scheme$2);

var scheme$3 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors);

var PuOr = ramp(scheme$3);

var scheme$4 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors);

var RdBu = ramp(scheme$4);

var scheme$5 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors);

var RdGy = ramp(scheme$5);

var scheme$6 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors);

var RdYlBu = ramp(scheme$6);

var scheme$7 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors);

var RdYlGn = ramp(scheme$7);

var scheme$8 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors);

var Spectral = ramp(scheme$8);

var scheme$9 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors);

var BuGn = ramp(scheme$9);

var scheme$a = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors);

var BuPu = ramp(scheme$a);

var scheme$b = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors);

var GnBu = ramp(scheme$b);

var scheme$c = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors);

var OrRd = ramp(scheme$c);

var scheme$d = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors);

var PuBuGn = ramp(scheme$d);

var scheme$e = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors);

var PuBu = ramp(scheme$e);

var scheme$f = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors);

var PuRd = ramp(scheme$f);

var scheme$g = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors);

var RdPu = ramp(scheme$g);

var scheme$h = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors);

var YlGnBu = ramp(scheme$h);

var scheme$i = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors);

var YlGn = ramp(scheme$i);

var scheme$j = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors);

var YlOrBr = ramp(scheme$j);

var scheme$k = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors);

var YlOrRd = ramp(scheme$k);

var scheme$l = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors);

var Blues = ramp(scheme$l);

var scheme$m = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors);

var Greens = ramp(scheme$m);

var scheme$n = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors);

var Greys = ramp(scheme$n);

var scheme$o = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors);

var Purples = ramp(scheme$o);

var scheme$p = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors);

var Reds = ramp(scheme$p);

var scheme$q = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors);

var Oranges = ramp(scheme$q);

function cividis(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb("
      + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
      + ")";
}

var cubehelix = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var c = d3Color.cubehelix();

function rainbow(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

var c$1 = d3Color.rgb(),
    pi_1_3 = Math.PI / 3,
    pi_2_3 = Math.PI * 2 / 3;

function sinebow(t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c$1.r = 255 * (x = Math.sin(t)) * x;
  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c$1 + "";
}

function turbo(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb("
      + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
      + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
      + ")";
}

function ramp$1(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

exports.interpolateBlues = Blues;
exports.interpolateBrBG = BrBG;
exports.interpolateBuGn = BuGn;
exports.interpolateBuPu = BuPu;
exports.interpolateCividis = cividis;
exports.interpolateCool = cool;
exports.interpolateCubehelixDefault = cubehelix;
exports.interpolateGnBu = GnBu;
exports.interpolateGreens = Greens;
exports.interpolateGreys = Greys;
exports.interpolateInferno = inferno;
exports.interpolateMagma = magma;
exports.interpolateOrRd = OrRd;
exports.interpolateOranges = Oranges;
exports.interpolatePRGn = PRGn;
exports.interpolatePiYG = PiYG;
exports.interpolatePlasma = plasma;
exports.interpolatePuBu = PuBu;
exports.interpolatePuBuGn = PuBuGn;
exports.interpolatePuOr = PuOr;
exports.interpolatePuRd = PuRd;
exports.interpolatePurples = Purples;
exports.interpolateRainbow = rainbow;
exports.interpolateRdBu = RdBu;
exports.interpolateRdGy = RdGy;
exports.interpolateRdPu = RdPu;
exports.interpolateRdYlBu = RdYlBu;
exports.interpolateRdYlGn = RdYlGn;
exports.interpolateReds = Reds;
exports.interpolateSinebow = sinebow;
exports.interpolateSpectral = Spectral;
exports.interpolateTurbo = turbo;
exports.interpolateViridis = viridis;
exports.interpolateWarm = warm;
exports.interpolateYlGn = YlGn;
exports.interpolateYlGnBu = YlGnBu;
exports.interpolateYlOrBr = YlOrBr;
exports.interpolateYlOrRd = YlOrRd;
exports.schemeAccent = Accent;
exports.schemeBlues = scheme$l;
exports.schemeBrBG = scheme;
exports.schemeBuGn = scheme$9;
exports.schemeBuPu = scheme$a;
exports.schemeCategory10 = category10;
exports.schemeDark2 = Dark2;
exports.schemeGnBu = scheme$b;
exports.schemeGreens = scheme$m;
exports.schemeGreys = scheme$n;
exports.schemeOrRd = scheme$c;
exports.schemeOranges = scheme$q;
exports.schemePRGn = scheme$1;
exports.schemePaired = Paired;
exports.schemePastel1 = Pastel1;
exports.schemePastel2 = Pastel2;
exports.schemePiYG = scheme$2;
exports.schemePuBu = scheme$e;
exports.schemePuBuGn = scheme$d;
exports.schemePuOr = scheme$3;
exports.schemePuRd = scheme$f;
exports.schemePurples = scheme$o;
exports.schemeRdBu = scheme$4;
exports.schemeRdGy = scheme$5;
exports.schemeRdPu = scheme$g;
exports.schemeRdYlBu = scheme$6;
exports.schemeRdYlGn = scheme$7;
exports.schemeReds = scheme$p;
exports.schemeSet1 = Set1;
exports.schemeSet2 = Set2;
exports.schemeSet3 = Set3;
exports.schemeSpectral = scheme$8;
exports.schemeTableau10 = Tableau10;
exports.schemeYlGn = scheme$i;
exports.schemeYlGnBu = scheme$h;
exports.schemeYlOrBr = scheme$j;
exports.schemeYlOrRd = scheme$k;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":16,"d3-interpolate":27}],33:[function(require,module,exports){
// https://d3js.org/d3-scale/ v2.2.2 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-collection'), require('d3-array'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-collection', 'd3-array', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Collection,d3Array,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.interpolator(domain); break;
    default: this.interpolator(interpolator).domain(domain); break;
  }
  return this;
}

var array = Array.prototype;

var map = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal() {
  var index = d3Collection.map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  initRange.apply(scale, arguments);

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), range)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

function constant(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(isNaN(b) ? NaN : 0.5);
}

function clamper(domain) {
  var a = domain[0], b = domain[domain.length - 1], t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3Interpolate.interpolate,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3Interpolate.interpolateNumber)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map.call(_, number), clamp === identity || (clamp = clamper(domain)), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = slice.call(_), interpolate = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? clamper(domain) : identity, scale) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous(transform, untransform) {
  return transformer()(transform, untransform);
}

function tickFormat(start, stop, count, specifier) {
  var step = d3Array.tickStep(start, stop, count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(identity, identity);

  scale.copy = function() {
    return copy(scale, linear());
  };

  initRange.apply(scale, arguments);

  return linearish(scale);
}

function identity$1(domain) {
  var unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity$1(domain).unknown(unknown);
  };

  domain = arguments.length ? map.call(domain, number) : [0, 1];

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, log()).base(scale.base());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return linearish(scale);
}

function symlog() {
  var scale = symlogish(transformer());

  scale.copy = function() {
    return copy(scale, symlog()).constant(scale.constant());
  };

  return initRange.apply(scale, arguments);
}

function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(identity, identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(identity, identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return linearish(scale);
}

function pow() {
  var scale = powish(transformer());

  scale.copy = function() {
    return copy(scale, pow()).exponent(scale.exponent());
  };

  initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}

function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    return isNaN(x = +x) ? unknown : range[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(linearish(scale), arguments);
}

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x <= x ? range[d3Array.bisect(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return initRange.apply(scale, arguments);
}

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = continuous(identity, identity),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

function utcTime() {
  return initRange.apply(calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}

function transformer$1() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = identity,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy$1(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = linearish(transformer$1()(identity));

  scale.copy = function() {
    return copy$1(scale, sequential());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);

  scale.copy = function() {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = symlogish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = powish(transformer$1());

  scale.copy = function() {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}

function sequentialQuantile() {
  var domain = [],
      interpolator = identity;

  function scale(x) {
    if (!isNaN(x = +x)) return interpolator((d3Array.bisect(domain, x) - 1) / (domain.length - 1));
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return scale;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };

  return initInterpolator.apply(scale, arguments);
}

function transformer$2() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (x < t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? (t0 = transform(x0 = +_[0]), t1 = transform(x1 = +_[1]), t2 = transform(x2 = +_[2]), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1);
    return scale;
  };
}

function diverging() {
  var scale = linearish(transformer$2()(identity));

  scale.copy = function() {
    return copy$1(scale, diverging());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = loggish(transformer$2()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return copy$1(scale, divergingLog()).base(scale.base());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = symlogish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = powish(transformer$2());

  scale.copy = function() {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };

  return initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity$1;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleSymlog = symlog;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.scaleSequential = sequential;
exports.scaleSequentialLog = sequentialLog;
exports.scaleSequentialPow = sequentialPow;
exports.scaleSequentialSqrt = sequentialSqrt;
exports.scaleSequentialSymlog = sequentialSymlog;
exports.scaleSequentialQuantile = sequentialQuantile;
exports.scaleDiverging = diverging;
exports.scaleDivergingLog = divergingLog;
exports.scaleDivergingPow = divergingPow;
exports.scaleDivergingSqrt = divergingSqrt;
exports.scaleDivergingSymlog = divergingSymlog;
exports.tickFormat = tickFormat;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":11,"d3-collection":15,"d3-format":24,"d3-interpolate":27,"d3-time":37,"d3-time-format":36}],34:[function(require,module,exports){
// https://d3js.org/d3-selection/ v1.4.1 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.clientPoint = point;
exports.create = create;
exports.creator = creator;
exports.customEvent = customEvent;
exports.local = local;
exports.matcher = matcher;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],35:[function(require,module,exports){
// https://d3js.org/d3-shape/ v1.3.7 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-path')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Path) { 'use strict';

function constant(x) {
  return function constant() {
    return x;
  };
}

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function arc() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

function line() {
  var x$1 = x,
      y$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line) : x$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line) : y$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

function area() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

function identity(d) {
  return d;
}

function pie() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
}

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}

function areaRadial() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
}

function pointRadial(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$1 = x,
      y$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link) : x$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link) : y$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810,
    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),
    kx = Math.sin(tau / 10) * kr,
    ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

function symbol() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

function noop() {}

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function basisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function linearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function natural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function step(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function none(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

function none$1(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
}

function stackValue(d, key) {
  return d[key];
}

function stack() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
}

function expand(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
}

function diverging(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

function silhouette(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
}

function wiggle(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
}

function appearance(series) {
  var peaks = series.map(peak);
  return none$1(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
}

function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  return j;
}

function ascending(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
}

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

function descending$1(series) {
  return ascending(series).reverse();
}

function insideOut(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = appearance(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

function reverse(series) {
  return none$1(series).reverse();
}

exports.arc = arc;
exports.area = area;
exports.areaRadial = areaRadial;
exports.curveBasis = basis;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBundle = bundle;
exports.curveCardinal = cardinal;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCatmullRom = catmullRom;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveLinear = curveLinear;
exports.curveLinearClosed = linearClosed;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.line = line;
exports.lineRadial = lineRadial$1;
exports.linkHorizontal = linkHorizontal;
exports.linkRadial = linkRadial;
exports.linkVertical = linkVertical;
exports.pie = pie;
exports.pointRadial = pointRadial;
exports.radialArea = areaRadial;
exports.radialLine = lineRadial$1;
exports.stack = stack;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetExpand = expand;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAppearance = appearance;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;
exports.symbol = symbol;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.symbols = symbols;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-path":28}],36:[function(require,module,exports){
// https://d3js.org/d3-time-format/ v2.2.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function (exports, d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d) - 1, d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d) - 1, d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.isoFormat = formatIso;
exports.isoParse = parseIso;
exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-time":37}],37:[function(require,module,exports){
// https://d3js.org/d3-time/ v1.1.0 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});
var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});
var minutes = minute.range;

var hour = newInterval(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});
var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});
var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});
var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

exports.timeDay = day;
exports.timeDays = days;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeYear = year;
exports.timeYears = years;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],38:[function(require,module,exports){
// https://d3js.org/d3-timer/ v1.0.10 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}));
}(this, function (exports) { 'use strict';

var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout$1(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

function interval$1(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

exports.interval = interval$1;
exports.now = now;
exports.timeout = timeout$1;
exports.timer = timer;
exports.timerFlush = timerFlush;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{}],39:[function(require,module,exports){
// https://d3js.org/d3-transition/ v1.3.2 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-timer'), require('d3-interpolate'), require('d3-color'), require('d3-ease')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Selection, d3Dispatch, d3Timer, d3Interpolate, d3Color, d3Ease) { 'use strict';

var emptyOn = d3Dispatch.dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = d3Timer.timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return d3Timer.timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    d3Timer.timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? d3Interpolate.interpolateNumber
      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
      : d3Interpolate.interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = d3Selection.namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function transition_filter(match) {
  if (typeof match !== "function") match = d3Selection.matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = d3Selection.selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name),
        string1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = d3Selection.style(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return d3Selection.selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3Selection.selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = d3Timer.now(), defaultTiming;
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

d3Selection.selection.prototype.interrupt = selection_interrupt;
d3Selection.selection.prototype.transition = selection_transition;

var root = [null];

function active(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}

exports.active = active;
exports.interrupt = interrupt;
exports.transition = transition;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-color":16,"d3-dispatch":18,"d3-ease":21,"d3-interpolate":27,"d3-selection":34,"d3-timer":38}],40:[function(require,module,exports){
// https://d3js.org/d3-voronoi/ v1.1.4 Copyright 2018 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon
      && Math.abs(y - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon
      && Math.abs(y - rArc.circle.cy) < epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

function voronoi() {
  var x$$1 = x,
      y$$1 = y,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}

exports.voronoi = voronoi;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],41:[function(require,module,exports){
// https://d3js.org/d3-zoom/ v1.8.3 Copyright 2019 Mike Bostock
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
(global = global || self, factory(global.d3 = global.d3 || {}, global.d3, global.d3, global.d3, global.d3, global.d3));
}(this, function (exports, d3Dispatch, d3Drag, d3Interpolate, d3Selection, d3Transition) { 'use strict';

function constant(x) {
  return function() {
    return x;
  };
}

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  while (!node.__zoom) if (!(node = node.parentNode)) return identity;
  return node.__zoom;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

function noevent() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.ctrlKey && !d3Selection.event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta() {
  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode === 1 ? 0.05 : d3Selection.event.deltaMode ? 1 : 0.002);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

function zoom() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3Interpolate.interpolateZoom,
      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p);
  };

  zoom.scaleTo = function(selection, k, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p);
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y, p) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = d3Selection.mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      d3Transition.interrupt(this);
      g.start();
    }

    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments, true),
        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = d3Selection.mouse(this),
        x0 = d3Selection.event.clientX,
        y0 = d3Selection.event.clientY;

    d3Drag.dragDisable(d3Selection.event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    d3Transition.interrupt(this);
    g.start();

    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      d3Drag.dragEnable(d3Selection.event.view, g.moved);
      noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = d3Selection.mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent();
    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
    else d3Selection.select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.touches,
        n = touches.length,
        g = gesture(this, arguments, d3Selection.event.changedTouches.length === n),
        started, i, t, p;

    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      d3Transition.interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    if (!this.__zooming) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t;

    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        var p = d3Selection.select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}

exports.zoom = zoom;
exports.zoomIdentity = identity;
exports.zoomTransform = transform;

Object.defineProperty(exports, '__esModule', { value: true });

}));

},{"d3-dispatch":18,"d3-drag":19,"d3-interpolate":27,"d3-selection":34,"d3-transition":39}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3Array = require('d3-array');
var d3Axis = require('d3-axis');
var d3Brush = require('d3-brush');
var d3Chord = require('d3-chord');
var d3Collection = require('d3-collection');
var d3Color = require('d3-color');
var d3Contour = require('d3-contour');
var d3Dispatch = require('d3-dispatch');
var d3Drag = require('d3-drag');
var d3Dsv = require('d3-dsv');
var d3Ease = require('d3-ease');
var d3Fetch = require('d3-fetch');
var d3Force = require('d3-force');
var d3Format = require('d3-format');
var d3Geo = require('d3-geo');
var d3Hierarchy = require('d3-hierarchy');
var d3Interpolate = require('d3-interpolate');
var d3Path = require('d3-path');
var d3Polygon = require('d3-polygon');
var d3Quadtree = require('d3-quadtree');
var d3Random = require('d3-random');
var d3Scale = require('d3-scale');
var d3ScaleChromatic = require('d3-scale-chromatic');
var d3Selection = require('d3-selection');
var d3Shape = require('d3-shape');
var d3Time = require('d3-time');
var d3TimeFormat = require('d3-time-format');
var d3Timer = require('d3-timer');
var d3Transition = require('d3-transition');
var d3Voronoi = require('d3-voronoi');
var d3Zoom = require('d3-zoom');

var version = "5.15.0";

Object.keys(d3Array).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Array[k];
		}
	});
});
Object.keys(d3Axis).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Axis[k];
		}
	});
});
Object.keys(d3Brush).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Brush[k];
		}
	});
});
Object.keys(d3Chord).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Chord[k];
		}
	});
});
Object.keys(d3Collection).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Collection[k];
		}
	});
});
Object.keys(d3Color).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Color[k];
		}
	});
});
Object.keys(d3Contour).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Contour[k];
		}
	});
});
Object.keys(d3Dispatch).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Dispatch[k];
		}
	});
});
Object.keys(d3Drag).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Drag[k];
		}
	});
});
Object.keys(d3Dsv).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Dsv[k];
		}
	});
});
Object.keys(d3Ease).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Ease[k];
		}
	});
});
Object.keys(d3Fetch).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Fetch[k];
		}
	});
});
Object.keys(d3Force).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Force[k];
		}
	});
});
Object.keys(d3Format).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Format[k];
		}
	});
});
Object.keys(d3Geo).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Geo[k];
		}
	});
});
Object.keys(d3Hierarchy).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Hierarchy[k];
		}
	});
});
Object.keys(d3Interpolate).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Interpolate[k];
		}
	});
});
Object.keys(d3Path).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Path[k];
		}
	});
});
Object.keys(d3Polygon).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Polygon[k];
		}
	});
});
Object.keys(d3Quadtree).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Quadtree[k];
		}
	});
});
Object.keys(d3Random).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Random[k];
		}
	});
});
Object.keys(d3Scale).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Scale[k];
		}
	});
});
Object.keys(d3ScaleChromatic).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3ScaleChromatic[k];
		}
	});
});
Object.keys(d3Selection).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Selection[k];
		}
	});
});
Object.keys(d3Shape).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Shape[k];
		}
	});
});
Object.keys(d3Time).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Time[k];
		}
	});
});
Object.keys(d3TimeFormat).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3TimeFormat[k];
		}
	});
});
Object.keys(d3Timer).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Timer[k];
		}
	});
});
Object.keys(d3Transition).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Transition[k];
		}
	});
});
Object.keys(d3Voronoi).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Voronoi[k];
		}
	});
});
Object.keys(d3Zoom).forEach(function (k) {
	if (k !== 'default') Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () {
			return d3Zoom[k];
		}
	});
});
exports.version = version;

},{"d3-array":11,"d3-axis":12,"d3-brush":13,"d3-chord":14,"d3-collection":15,"d3-color":16,"d3-contour":17,"d3-dispatch":18,"d3-drag":19,"d3-dsv":20,"d3-ease":21,"d3-fetch":22,"d3-force":23,"d3-format":24,"d3-geo":25,"d3-hierarchy":26,"d3-interpolate":27,"d3-path":28,"d3-polygon":29,"d3-quadtree":30,"d3-random":31,"d3-scale":33,"d3-scale-chromatic":32,"d3-selection":34,"d3-shape":35,"d3-time":37,"d3-time-format":36,"d3-timer":38,"d3-transition":39,"d3-voronoi":40,"d3-zoom":41}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var wrapIdbValue = require('./wrap-idb-value.js');

/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrapIdbValue.wrap(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade(wrapIdbValue.wrap(request.result), event.oldVersion, event.newVersion, wrapIdbValue.wrap(request.transaction));
        });
    }
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking)
            db.addEventListener('versionchange', () => blocking());
    })
        .catch(() => { });
    return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    return wrapIdbValue.wrap(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
wrapIdbValue.replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));

exports.unwrap = wrapIdbValue.unwrap;
exports.wrap = wrapIdbValue.wrap;
exports.deleteDB = deleteDB;
exports.openDB = openDB;

},{"./wrap-idb-value.js":44}],44:[function(require,module,exports){
'use strict';

const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise
        .then((value) => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
    })
        .catch(() => { });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap(tx);
        };
    }
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap(cursorRequestMap.get(this));
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);

exports.instanceOfAny = instanceOfAny;
exports.replaceTraps = replaceTraps;
exports.reverseTransformCache = reverseTransformCache;
exports.unwrap = unwrap;
exports.wrap = wrap;

},{}],45:[function(require,module,exports){
(function (global){
/*!
 * Number-To-Words util
 * @version v1.2.4
 * @link https://github.com/marlun78/number-to-words
 * @author Martin Eneqvist (https://github.com/marlun78)
 * @contributors Aleksey Pilyugin (https://github.com/pilyugin),Jeremiah Hall (https://github.com/jeremiahrhall),Adriano Melo (https://github.com/adrianomelo),dmrzn (https://github.com/dmrzn)
 * @license MIT
 */
!function(){"use strict";var e="object"==typeof self&&self.self===self&&self||"object"==typeof global&&global.global===global&&global||this,t=9007199254740991;function f(e){return!("number"!=typeof e||e!=e||e===1/0||e===-1/0)}function l(e){return"number"==typeof e&&Math.abs(e)<=t}var n=/(hundred|thousand|(m|b|tr|quadr)illion)$/,r=/teen$/,o=/y$/,i=/(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)$/,s={zero:"zeroth",one:"first",two:"second",three:"third",four:"fourth",five:"fifth",six:"sixth",seven:"seventh",eight:"eighth",nine:"ninth",ten:"tenth",eleven:"eleventh",twelve:"twelfth"};function h(e){return n.test(e)||r.test(e)?e+"th":o.test(e)?e.replace(o,"ieth"):i.test(e)?e.replace(i,a):e}function a(e,t){return s[t]}var u=10,d=100,p=1e3,v=1e6,b=1e9,y=1e12,c=1e15,g=9007199254740992,m=["zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","thirteen","fourteen","fifteen","sixteen","seventeen","eighteen","nineteen"],w=["zero","ten","twenty","thirty","forty","fifty","sixty","seventy","eighty","ninety"];function x(e,t){var n,r=parseInt(e,10);if(!f(r))throw new TypeError("Not a finite number: "+e+" ("+typeof e+")");if(!l(r))throw new RangeError("Input is not a safe number, it’s either too large or too small.");return n=function e(t){var n,r,o=arguments[1];if(0===t)return o?o.join(" ").replace(/,$/,""):"zero";o||(o=[]);t<0&&(o.push("minus"),t=Math.abs(t));t<20?(n=0,r=m[t]):t<d?(n=t%u,r=w[Math.floor(t/u)],n&&(r+="-"+m[n],n=0)):t<p?(n=t%d,r=e(Math.floor(t/d))+" hundred"):t<v?(n=t%p,r=e(Math.floor(t/p))+" thousand,"):t<b?(n=t%v,r=e(Math.floor(t/v))+" million,"):t<y?(n=t%b,r=e(Math.floor(t/b))+" billion,"):t<c?(n=t%y,r=e(Math.floor(t/y))+" trillion,"):t<=g&&(n=t%c,r=e(Math.floor(t/c))+" quadrillion,");o.push(r);return e(n,o)}(r),t?h(n):n}var M={toOrdinal:function(e){var t=parseInt(e,10);if(!f(t))throw new TypeError("Not a finite number: "+e+" ("+typeof e+")");if(!l(t))throw new RangeError("Input is not a safe number, it’s either too large or too small.");var n=String(t),r=Math.abs(t%100),o=11<=r&&r<=13,i=n.charAt(n.length-1);return n+(o?"th":"1"===i?"st":"2"===i?"nd":"3"===i?"rd":"th")},toWords:x,toWordsOrdinal:function(e){return h(x(e))}};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=M),exports.numberToWords=M):e.numberToWords=M}();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],46:[function(require,module,exports){
// full library entry point.

"use strict";
module.exports = require("./src/index");

},{"./src/index":55}],47:[function(require,module,exports){
"use strict";
module.exports = common;

var commonRe = /\/|\./;

/**
 * Provides common type definitions.
 * Can also be used to provide additional google types or your own custom types.
 * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name
 * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition
 * @returns {undefined}
 * @property {INamespace} google/protobuf/any.proto Any
 * @property {INamespace} google/protobuf/duration.proto Duration
 * @property {INamespace} google/protobuf/empty.proto Empty
 * @property {INamespace} google/protobuf/field_mask.proto FieldMask
 * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue
 * @property {INamespace} google/protobuf/timestamp.proto Timestamp
 * @property {INamespace} google/protobuf/wrappers.proto Wrappers
 * @example
 * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)
 * protobuf.common("descriptor", descriptorJson);
 *
 * // manually provides a custom definition (uses my.foo namespace)
 * protobuf.common("my/foo/bar.proto", myFooBarJson);
 */
function common(name, json) {
    if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
    }
    common[name] = json;
}

// Not provided because of limited use (feel free to discuss or to provide yourself):
//
// google/protobuf/descriptor.proto
// google/protobuf/source_context.proto
// google/protobuf/type.proto
//
// Stripped and pre-parsed versions of these non-bundled files are instead available as part of
// the repository or package within the google/protobuf directory.

common("any", {

    /**
     * Properties of a google.protobuf.Any message.
     * @interface IAny
     * @type {Object}
     * @property {string} [typeUrl]
     * @property {Uint8Array} [bytes]
     * @memberof common
     */
    Any: {
        fields: {
            type_url: {
                type: "string",
                id: 1
            },
            value: {
                type: "bytes",
                id: 2
            }
        }
    }
});

var timeType;

common("duration", {

    /**
     * Properties of a google.protobuf.Duration message.
     * @interface IDuration
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Duration: timeType = {
        fields: {
            seconds: {
                type: "int64",
                id: 1
            },
            nanos: {
                type: "int32",
                id: 2
            }
        }
    }
});

common("timestamp", {

    /**
     * Properties of a google.protobuf.Timestamp message.
     * @interface ITimestamp
     * @type {Object}
     * @property {number|Long} [seconds]
     * @property {number} [nanos]
     * @memberof common
     */
    Timestamp: timeType
});

common("empty", {

    /**
     * Properties of a google.protobuf.Empty message.
     * @interface IEmpty
     * @memberof common
     */
    Empty: {
        fields: {}
    }
});

common("struct", {

    /**
     * Properties of a google.protobuf.Struct message.
     * @interface IStruct
     * @type {Object}
     * @property {Object.<string,IValue>} [fields]
     * @memberof common
     */
    Struct: {
        fields: {
            fields: {
                keyType: "string",
                type: "Value",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Value message.
     * @interface IValue
     * @type {Object}
     * @property {string} [kind]
     * @property {0} [nullValue]
     * @property {number} [numberValue]
     * @property {string} [stringValue]
     * @property {boolean} [boolValue]
     * @property {IStruct} [structValue]
     * @property {IListValue} [listValue]
     * @memberof common
     */
    Value: {
        oneofs: {
            kind: {
                oneof: [
                    "nullValue",
                    "numberValue",
                    "stringValue",
                    "boolValue",
                    "structValue",
                    "listValue"
                ]
            }
        },
        fields: {
            nullValue: {
                type: "NullValue",
                id: 1
            },
            numberValue: {
                type: "double",
                id: 2
            },
            stringValue: {
                type: "string",
                id: 3
            },
            boolValue: {
                type: "bool",
                id: 4
            },
            structValue: {
                type: "Struct",
                id: 5
            },
            listValue: {
                type: "ListValue",
                id: 6
            }
        }
    },

    NullValue: {
        values: {
            NULL_VALUE: 0
        }
    },

    /**
     * Properties of a google.protobuf.ListValue message.
     * @interface IListValue
     * @type {Object}
     * @property {Array.<IValue>} [values]
     * @memberof common
     */
    ListValue: {
        fields: {
            values: {
                rule: "repeated",
                type: "Value",
                id: 1
            }
        }
    }
});

common("wrappers", {

    /**
     * Properties of a google.protobuf.DoubleValue message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    DoubleValue: {
        fields: {
            value: {
                type: "double",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.FloatValue message.
     * @interface IFloatValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FloatValue: {
        fields: {
            value: {
                type: "float",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int64Value message.
     * @interface IInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    Int64Value: {
        fields: {
            value: {
                type: "int64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt64Value message.
     * @interface IUInt64Value
     * @type {Object}
     * @property {number|Long} [value]
     * @memberof common
     */
    UInt64Value: {
        fields: {
            value: {
                type: "uint64",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.Int32Value message.
     * @interface IInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    Int32Value: {
        fields: {
            value: {
                type: "int32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.UInt32Value message.
     * @interface IUInt32Value
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    UInt32Value: {
        fields: {
            value: {
                type: "uint32",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BoolValue message.
     * @interface IBoolValue
     * @type {Object}
     * @property {boolean} [value]
     * @memberof common
     */
    BoolValue: {
        fields: {
            value: {
                type: "bool",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.StringValue message.
     * @interface IStringValue
     * @type {Object}
     * @property {string} [value]
     * @memberof common
     */
    StringValue: {
        fields: {
            value: {
                type: "string",
                id: 1
            }
        }
    },

    /**
     * Properties of a google.protobuf.BytesValue message.
     * @interface IBytesValue
     * @type {Object}
     * @property {Uint8Array} [value]
     * @memberof common
     */
    BytesValue: {
        fields: {
            value: {
                type: "bytes",
                id: 1
            }
        }
    }
});

common("field_mask", {

    /**
     * Properties of a google.protobuf.FieldMask message.
     * @interface IDoubleValue
     * @type {Object}
     * @property {number} [value]
     * @memberof common
     */
    FieldMask: {
        fields: {
            paths: {
                rule: "repeated",
                type: "string",
                id: 1
            }
        }
    }
});

/**
 * Gets the root definition of the specified common proto file.
 *
 * Bundled definitions are:
 * - google/protobuf/any.proto
 * - google/protobuf/duration.proto
 * - google/protobuf/empty.proto
 * - google/protobuf/field_mask.proto
 * - google/protobuf/struct.proto
 * - google/protobuf/timestamp.proto
 * - google/protobuf/wrappers.proto
 *
 * @param {string} file Proto file name
 * @returns {INamespace|null} Root definition or `null` if not defined
 */
common.get = function get(file) {
    return common[file] || null;
};

},{}],48:[function(require,module,exports){
"use strict";
/**
 * Runtime message from/to plain object converters.
 * @namespace
 */
var converter = exports;

var Enum = require("./enum"),
    util = require("./util");

/**
 * Generates a partial value fromObject conveter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(d%s){", prop);
            for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
                if (field.repeated && values[keys[i]] === field.typeDefault) gen
                ("default:");
                gen
                ("case%j:", keys[i])
                ("case %i:", values[keys[i]])
                    ("m%s=%j", prop, values[keys[i]])
                    ("break");
            } gen
            ("}");
        } else gen
            ("if(typeof d%s!==\"object\")", prop)
                ("throw TypeError(%j)", field.fullName + ": object expected")
            ("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
                ("m%s=Number(d%s)", prop, prop); // also catches "NaN", "Infinity"
                break;
            case "uint32":
            case "fixed32": gen
                ("m%s=d%s>>>0", prop, prop);
                break;
            case "int32":
            case "sint32":
            case "sfixed32": gen
                ("m%s=d%s|0", prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(util.Long)")
                    ("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)
                ("else if(typeof d%s===\"string\")", prop)
                    ("m%s=parseInt(d%s,10)", prop, prop)
                ("else if(typeof d%s===\"number\")", prop)
                    ("m%s=d%s", prop, prop)
                ("else if(typeof d%s===\"object\")", prop)
                    ("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
                break;
            case "bytes": gen
                ("if(typeof d%s===\"string\")", prop)
                    ("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)
                ("else if(d%s.length)", prop)
                    ("m%s=d%s", prop, prop);
                break;
            case "string": gen
                ("m%s=String(d%s)", prop, prop);
                break;
            case "bool": gen
                ("m%s=Boolean(d%s)", prop, prop);
                break;
            /* default: gen
                ("m%s=d%s", prop, prop);
                break; */
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a plain object to runtime message converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.fromObject = function fromObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray;
    var gen = util.codegen(["d"], mtype.name + "$fromObject")
    ("if(d instanceof this.ctor)")
        ("return d");
    if (!fields.length) return gen
    ("return new this.ctor");
    gen
    ("var m=new this.ctor");
    for (var i = 0; i < fields.length; ++i) {
        var field  = fields[i].resolve(),
            prop   = util.safeProp(field.name);

        // Map fields
        if (field.map) { gen
    ("if(d%s){", prop)
        ("if(typeof d%s!==\"object\")", prop)
            ("throw TypeError(%j)", field.fullName + ": object expected")
        ("m%s={}", prop)
        ("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[ks[i]]")
        ("}")
    ("}");

        // Repeated fields
        } else if (field.repeated) { gen
    ("if(d%s){", prop)
        ("if(!Array.isArray(d%s))", prop)
            ("throw TypeError(%j)", field.fullName + ": array expected")
        ("m%s=[]", prop)
        ("for(var i=0;i<d%s.length;++i){", prop);
            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + "[i]")
        ("}")
    ("}");

        // Non-repeated fields
        } else {
            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)
    ("if(d%s!=null){", prop); // !== undefined && !== null
        genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);
            if (!(field.resolvedType instanceof Enum)) gen
    ("}");
        }
    } return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

/**
 * Generates a partial value toObject converter.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} prop Property reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genValuePartial_toObject(gen, field, fieldIndex, prop) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen
            ("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else gen
            ("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
    } else {
        var isUnsigned = false;
        switch (field.type) {
            case "double":
            case "float": gen
            ("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
                break;
            case "uint64":
                isUnsigned = true;
                // eslint-disable-line no-fallthrough
            case "int64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
            ("if(typeof m%s===\"number\")", prop)
                ("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)
            ("else") // Long-like
                ("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true": "", prop);
                break;
            case "bytes": gen
            ("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
                break;
            default: gen
            ("d%s=m%s", prop, prop);
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

/**
 * Generates a runtime message to plain object converter specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
converter.toObject = function toObject(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
    if (!fields.length)
        return util.codegen()("return {}");
    var gen = util.codegen(["m", "o"], mtype.name + "$toObject")
    ("if(!o)")
        ("o={}")
    ("var d={}");

    var repeatedFields = [],
        mapFields = [],
        normalFields = [],
        i = 0;
    for (; i < fields.length; ++i)
        if (!fields[i].partOf)
            ( fields[i].resolve().repeated ? repeatedFields
            : fields[i].map ? mapFields
            : normalFields).push(fields[i]);

    if (repeatedFields.length) { gen
    ("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen
        ("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen
    ("}");
    }

    if (mapFields.length) { gen
    ("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen
        ("d%s={}", util.safeProp(mapFields[i].name));
        gen
    ("}");
    }

    if (normalFields.length) { gen
    ("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
            var field = normalFields[i],
                prop  = util.safeProp(field.name);
            if (field.resolvedType instanceof Enum) gen
        ("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
            else if (field.long) gen
        ("if(util.Long){")
            ("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)
            ("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)
        ("}else")
            ("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
            else if (field.bytes) {
                var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
                gen
        ("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))
        ("else{")
            ("d%s=%s", prop, arrayDefault)
            ("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)
        ("}");
            } else gen
        ("d%s=%j", prop, field.typeDefault); // also messages (=null)
        } gen
    ("}");
    }
    var hasKs2 = false;
    for (i = 0; i < fields.length; ++i) {
        var field = fields[i],
            index = mtype._fieldsArray.indexOf(field),
            prop  = util.safeProp(field.name);
        if (field.map) {
            if (!hasKs2) { hasKs2 = true; gen
    ("var ks2");
            } gen
    ("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)
        ("d%s={}", prop)
        ("for(var j=0;j<ks2.length;++j){");
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[ks2[j]]")
        ("}");
        } else if (field.repeated) { gen
    ("if(m%s&&m%s.length){", prop, prop)
        ("d%s=[]", prop)
        ("for(var j=0;j<m%s.length;++j){", prop);
            genValuePartial_toObject(gen, field, /* sorted */ index, prop + "[j]")
        ("}");
        } else { gen
    ("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name); // !== undefined && !== null
        genValuePartial_toObject(gen, field, /* sorted */ index, prop);
        if (field.partOf) gen
        ("if(o.oneofs)")
            ("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen
    ("}");
    }
    return gen
    ("return d");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
};

},{"./enum":51,"./util":73}],49:[function(require,module,exports){
"use strict";
module.exports = decoder;

var Enum    = require("./enum"),
    types   = require("./types"),
    util    = require("./util");

function missing(field) {
    return "missing required '" + field.name + "'";
}

/**
 * Generates a decoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function decoder(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["r", "l"], mtype.name + "$decode")
    ("if(!(r instanceof Reader))")
        ("r=Reader.create(r)")
    ("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field) { return field.map; }).length ? ",k,value" : ""))
    ("while(r.pos<c){")
        ("var t=r.uint32()");
    if (mtype.group) gen
        ("if((t&7)===4)")
            ("break");
    gen
        ("switch(t>>>3){");

    var i = 0;
    for (; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            type  = field.resolvedType instanceof Enum ? "int32" : field.type,
            ref   = "m" + util.safeProp(field.name); gen
            ("case %i:", field.id);

        // Map fields
        if (field.map) { gen
                ("if(%s===util.emptyObject)", ref)
                    ("%s={}", ref)
                ("var c2 = r.uint32()+r.pos");

            if (types.defaults[field.keyType] !== undefined) gen
                ("k=%j", types.defaults[field.keyType]);
            else gen
                ("k=null");

            if (types.defaults[type] !== undefined) gen
                ("value=%j", types.defaults[type]);
            else gen
                ("value=null");

            gen
                ("while(r.pos<c2){")
                    ("var tag2=r.uint32()")
                    ("switch(tag2>>>3){")
                        ("case 1: k=r.%s(); break", field.keyType)
                        ("case 2:");

            if (types.basic[type] === undefined) gen
                            ("value=types[%i].decode(r,r.uint32())", i); // can't be groups
            else gen
                            ("value=r.%s()", type);

            gen
                            ("break")
                        ("default:")
                            ("r.skipType(tag2&7)")
                            ("break")
                    ("}")
                ("}");

            if (types.long[field.keyType] !== undefined) gen
                ("%s[typeof k===\"object\"?util.longToHash(k):k]=value", ref);
            else gen
                ("%s[k]=value", ref);

        // Repeated fields
        } else if (field.repeated) { gen

                ("if(!(%s&&%s.length))", ref, ref)
                    ("%s=[]", ref);

            // Packable (always check for forward and backward compatiblity)
            if (types.packed[type] !== undefined) gen
                ("if((t&7)===2){")
                    ("var c2=r.uint32()+r.pos")
                    ("while(r.pos<c2)")
                        ("%s.push(r.%s())", ref, type)
                ("}else");

            // Non-packed
            if (types.basic[type] === undefined) gen(field.resolvedType.group
                    ? "%s.push(types[%i].decode(r))"
                    : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
            else gen
                    ("%s.push(r.%s())", ref, type);

        // Non-repeated
        } else if (types.basic[type] === undefined) gen(field.resolvedType.group
                ? "%s=types[%i].decode(r)"
                : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen
                ("%s=r.%s()", ref, type);
        gen
                ("break");
    // Unknown fields
    } gen
            ("default:")
                ("r.skipType(t&7)")
                ("break")

        ("}")
    ("}");

    // Field presence
    for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen
    ("if(!m.hasOwnProperty(%j))", rfield.name)
        ("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
    }

    return gen
    ("return m");
    /* eslint-enable no-unexpected-multiline */
}

},{"./enum":51,"./types":72,"./util":73}],50:[function(require,module,exports){
"use strict";
module.exports = encoder;

var Enum     = require("./enum"),
    types    = require("./types"),
    util     = require("./util");

/**
 * Generates a partial message type encoder.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genTypePartial(gen, field, fieldIndex, ref) {
    return field.resolvedType.group
        ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0)
        : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
}

/**
 * Generates an encoder specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function encoder(mtype) {
    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */
    var gen = util.codegen(["m", "w"], mtype.name + "$encode")
    ("if(!w)")
        ("w=Writer.create()");

    var i, ref;

    // "when a message is serialized its known fields should be written sequentially by field number"
    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);

    for (var i = 0; i < fields.length; ++i) {
        var field    = fields[i].resolve(),
            index    = mtype._fieldsArray.indexOf(field),
            type     = field.resolvedType instanceof Enum ? "int32" : field.type,
            wireType = types.basic[type];
            ref      = "m" + util.safeProp(field.name);

        // Map fields
        if (field.map) {
            gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name) // !== undefined && !== null
        ("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)
            ("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
            if (wireType === undefined) gen
            ("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref); // can't be groups
            else gen
            (".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
            gen
        ("}")
    ("}");

            // Repeated fields
        } else if (field.repeated) { gen
    ("if(%s!=null&&%s.length){", ref, ref); // !== undefined && !== null

            // Packed repeated
            if (field.packed && types.packed[type] !== undefined) { gen

        ("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)
        ("for(var i=0;i<%s.length;++i)", ref)
            ("w.%s(%s[i])", type, ref)
        ("w.ldelim()");

            // Non-packed
            } else { gen

        ("for(var i=0;i<%s.length;++i)", ref);
                if (wireType === undefined)
            genTypePartial(gen, field, index, ref + "[i]");
                else gen
            ("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);

            } gen
    ("}");

        // Non-repeated
        } else {
            if (field.optional) gen
    ("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name); // !== undefined && !== null

            if (wireType === undefined)
        genTypePartial(gen, field, index, ref);
            else gen
        ("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);

        }
    }

    return gen
    ("return w");
    /* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */
}

},{"./enum":51,"./types":72,"./util":73}],51:[function(require,module,exports){
"use strict";
module.exports = Enum;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";

var Namespace = require("./namespace"),
    util = require("./util");

/**
 * Constructs a new enum instance.
 * @classdesc Reflected enum.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {Object.<string,number>} [values] Enum values as an object, by name
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this enum
 * @param {Object.<string,string>} [comments] The value comments for this enum
 */
function Enum(name, values, options, comment, comments) {
    ReflectionObject.call(this, name, options);

    if (values && typeof values !== "object")
        throw TypeError("values must be an object");

    /**
     * Enum values by id.
     * @type {Object.<number,string>}
     */
    this.valuesById = {};

    /**
     * Enum values by name.
     * @type {Object.<string,number>}
     */
    this.values = Object.create(this.valuesById); // toJSON, marker

    /**
     * Enum comment text.
     * @type {string|null}
     */
    this.comment = comment;

    /**
     * Value comment texts, if any.
     * @type {Object.<string,string>}
     */
    this.comments = comments || {};

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    // Note that values inherit valuesById on their prototype which makes them a TypeScript-
    // compatible enum. This is used by pbts to write actual enum definitions that work for
    // static and reflection code alike instead of emitting generic object definitions.

    if (values)
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
            if (typeof values[keys[i]] === "number") // use forward entries only
                this.valuesById[ this.values[keys[i]] = values[keys[i]] ] = keys[i];
}

/**
 * Enum descriptor.
 * @interface IEnum
 * @property {Object.<string,number>} values Enum values
 * @property {Object.<string,*>} [options] Enum options
 */

/**
 * Constructs an enum from an enum descriptor.
 * @param {string} name Enum name
 * @param {IEnum} json Enum descriptor
 * @returns {Enum} Created enum
 * @throws {TypeError} If arguments are invalid
 */
Enum.fromJSON = function fromJSON(name, json) {
    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
    enm.reserved = json.reserved;
    return enm;
};

/**
 * Converts this enum to an enum descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IEnum} Enum descriptor
 */
Enum.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"  , this.options,
        "values"   , this.values,
        "reserved" , this.reserved && this.reserved.length ? this.reserved : undefined,
        "comment"  , keepComments ? this.comment : undefined,
        "comments" , keepComments ? this.comments : undefined
    ]);
};

/**
 * Adds a value to this enum.
 * @param {string} name Value name
 * @param {number} id Value id
 * @param {string} [comment] Comment, if any
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a value with this name or id
 */
Enum.prototype.add = function add(name, id, comment) {
    // utilized by the parser but not by .fromJSON

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (!util.isInteger(id))
        throw TypeError("id must be an integer");

    if (this.values[name] !== undefined)
        throw Error("duplicate name '" + name + "' in " + this);

    if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);

    if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);

    if (this.valuesById[id] !== undefined) {
        if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
    } else
        this.valuesById[this.values[name] = id] = name;

    this.comments[name] = comment || null;
    return this;
};

/**
 * Removes a value from this enum
 * @param {string} name Value name
 * @returns {Enum} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `name` is not a name of this enum
 */
Enum.prototype.remove = function remove(name) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    var val = this.values[name];
    if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);

    delete this.valuesById[val];
    delete this.values[name];
    delete this.comments[name];

    return this;
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Enum.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

},{"./namespace":59,"./object":60,"./util":73}],52:[function(require,module,exports){
"use strict";
module.exports = Field;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";

var Enum  = require("./enum"),
    types = require("./types"),
    util  = require("./util");

var Type; // cyclic

var ruleRe = /^required|optional|repeated$/;

/**
 * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.
 * @name Field
 * @classdesc Reflected message field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a field from a field descriptor.
 * @param {string} name Field name
 * @param {IField} json Field descriptor
 * @returns {Field} Created field
 * @throws {TypeError} If arguments are invalid
 */
Field.fromJSON = function fromJSON(name, json) {
    return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
};

/**
 * Not an actual constructor. Use {@link Field} instead.
 * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports FieldBase
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} type Value type
 * @param {string|Object.<string,*>} [rule="optional"] Field rule
 * @param {string|Object.<string,*>} [extend] Extended type if different from parent
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function Field(name, id, type, rule, extend, options, comment) {

    if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = undefined;
    } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = undefined;
    }

    ReflectionObject.call(this, name, options);

    if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");

    if (!util.isString(type))
        throw TypeError("type must be a string");

    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");

    if (extend !== undefined && !util.isString(extend))
        throw TypeError("extend must be a string");

    /**
     * Field rule, if any.
     * @type {string|undefined}
     */
    this.rule = rule && rule !== "optional" ? rule : undefined; // toJSON

    /**
     * Field type.
     * @type {string}
     */
    this.type = type; // toJSON

    /**
     * Unique field id.
     * @type {number}
     */
    this.id = id; // toJSON, marker

    /**
     * Extended type if different from parent.
     * @type {string|undefined}
     */
    this.extend = extend || undefined; // toJSON

    /**
     * Whether this field is required.
     * @type {boolean}
     */
    this.required = rule === "required";

    /**
     * Whether this field is optional.
     * @type {boolean}
     */
    this.optional = !this.required;

    /**
     * Whether this field is repeated.
     * @type {boolean}
     */
    this.repeated = rule === "repeated";

    /**
     * Whether this field is a map or not.
     * @type {boolean}
     */
    this.map = false;

    /**
     * Message this field belongs to.
     * @type {Type|null}
     */
    this.message = null;

    /**
     * OneOf this field belongs to, if any,
     * @type {OneOf|null}
     */
    this.partOf = null;

    /**
     * The field type's default value.
     * @type {*}
     */
    this.typeDefault = null;

    /**
     * The field's default value on prototypes.
     * @type {*}
     */
    this.defaultValue = null;

    /**
     * Whether this field's value should be treated as a long.
     * @type {boolean}
     */
    this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;

    /**
     * Whether this field's value is a buffer.
     * @type {boolean}
     */
    this.bytes = type === "bytes";

    /**
     * Resolved type if not a basic type.
     * @type {Type|Enum|null}
     */
    this.resolvedType = null;

    /**
     * Sister-field within the extended type if a declaring extension field.
     * @type {Field|null}
     */
    this.extensionField = null;

    /**
     * Sister-field within the declaring namespace if an extended field.
     * @type {Field|null}
     */
    this.declaringField = null;

    /**
     * Internally remembers whether this field is packed.
     * @type {boolean|null}
     * @private
     */
    this._packed = null;

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Determines whether this field is packed. Only relevant when repeated and working with proto2.
 * @name Field#packed
 * @type {boolean}
 * @readonly
 */
Object.defineProperty(Field.prototype, "packed", {
    get: function() {
        // defaults to packed=true if not explicity set to false
        if (this._packed === null)
            this._packed = this.getOption("packed") !== false;
        return this._packed;
    }
});

/**
 * @override
 */
Field.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (name === "packed") // clear cached before setting
        this._packed = null;
    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
};

/**
 * Field descriptor.
 * @interface IField
 * @property {string} [rule="optional"] Field rule
 * @property {string} type Field type
 * @property {number} id Field id
 * @property {Object.<string,*>} [options] Field options
 */

/**
 * Extension field descriptor.
 * @interface IExtensionField
 * @extends IField
 * @property {string} extend Extended type
 */

/**
 * Converts this field to a field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IField} Field descriptor
 */
Field.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "rule"    , this.rule !== "optional" && this.rule || undefined,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Resolves this field's type references.
 * @returns {Field} `this`
 * @throws {Error} If any reference cannot be resolved
 */
Field.prototype.resolve = function resolve() {

    if (this.resolved)
        return this;

    if ((this.typeDefault = types.defaults[this.type]) === undefined) { // if not a basic type, resolve it
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
            this.typeDefault = null;
        else // instanceof Enum
            this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined
    }

    // use explicitly set default value if present
    if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
            this.typeDefault = this.resolvedType.values[this.typeDefault];
    }

    // remove unnecessary options
    if (this.options) {
        if (this.options.packed === true || this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum))
            delete this.options.packed;
        if (!Object.keys(this.options).length)
            this.options = undefined;
    }

    // convert to internal data type if necesssary
    if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");

        /* istanbul ignore else */
        if (Object.freeze)
            Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)

    } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
            util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
            util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
    }

    // take special care of maps and repeated fields
    if (this.map)
        this.defaultValue = util.emptyObject;
    else if (this.repeated)
        this.defaultValue = util.emptyArray;
    else
        this.defaultValue = this.typeDefault;

    // ensure proper value on prototype
    if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;

    return ReflectionObject.prototype.resolve.call(this);
};

/**
 * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).
 * @typedef FieldDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} fieldName Field name
 * @returns {undefined}
 */

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"string"|"bool"|"bytes"|Object} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @param {T} [defaultValue] Default value
 * @returns {FieldDecorator} Decorator function
 * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]
 */
Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {

    // submessage: decorate the submessage and use its name as the type
    if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;

    // enum reference: create a reflected copy of the enum and keep reuseing it
    else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;

    return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
    };
};

/**
 * Field decorator (TypeScript).
 * @name Field.d
 * @function
 * @param {number} fieldId Field id
 * @param {Constructor<T>|string} fieldType Field type
 * @param {"optional"|"required"|"repeated"} [fieldRule="optional"] Field rule
 * @returns {FieldDecorator} Decorator function
 * @template T extends Message<T>
 * @variation 2
 */
// like Field.d but without a default value

// Sets up cyclic dependencies (called in index-light)
Field._configure = function configure(Type_) {
    Type = Type_;
};

},{"./enum":51,"./object":60,"./types":72,"./util":73}],53:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-minimal");

protobuf.build = "light";

/**
 * A node-style callback as used by {@link load} and {@link Root#load}.
 * @typedef LoadCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Root} [root] Root, if there hasn't been an error
 * @returns {undefined}
 */

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} root Root namespace, defaults to create a new one if omitted.
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 */
function load(filename, root, callback) {
    if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
    } else if (!root)
        root = new protobuf.Root();
    return root.load(filename, callback);
}

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @see {@link Root#load}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.
 * @name load
 * @function
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Promise<Root>} Promise
 * @see {@link Root#load}
 * @variation 3
 */
// function load(filename:string, [root:Root]):Promise<Root>

protobuf.load = load;

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).
 * @param {string|string[]} filename One or multiple files to load
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 * @see {@link Root#loadSync}
 */
function loadSync(filename, root) {
    if (!root)
        root = new protobuf.Root();
    return root.loadSync(filename);
}

protobuf.loadSync = loadSync;

// Serialization
protobuf.encoder          = require("./encoder");
protobuf.decoder          = require("./decoder");
protobuf.verifier         = require("./verifier");
protobuf.converter        = require("./converter");

// Reflection
protobuf.ReflectionObject = require("./object");
protobuf.Namespace        = require("./namespace");
protobuf.Root             = require("./root");
protobuf.Enum             = require("./enum");
protobuf.Type             = require("./type");
protobuf.Field            = require("./field");
protobuf.OneOf            = require("./oneof");
protobuf.MapField         = require("./mapfield");
protobuf.Service          = require("./service");
protobuf.Method           = require("./method");

// Runtime
protobuf.Message          = require("./message");
protobuf.wrappers         = require("./wrappers");

// Utility
protobuf.types            = require("./types");
protobuf.util             = require("./util");

// Set up possibly cyclic reflection dependencies
protobuf.ReflectionObject._configure(protobuf.Root);
protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
protobuf.Root._configure(protobuf.Type);
protobuf.Field._configure(protobuf.Type);

},{"./converter":48,"./decoder":49,"./encoder":50,"./enum":51,"./field":52,"./index-minimal":54,"./mapfield":56,"./message":57,"./method":58,"./namespace":59,"./object":60,"./oneof":61,"./root":65,"./service":69,"./type":71,"./types":72,"./util":73,"./verifier":76,"./wrappers":77}],54:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"./reader":63,"./reader_buffer":64,"./roots":66,"./rpc":67,"./util/minimal":75,"./writer":78,"./writer_buffer":79}],55:[function(require,module,exports){
"use strict";
var protobuf = module.exports = require("./index-light");

protobuf.build = "full";

// Parser
protobuf.tokenize         = require("./tokenize");
protobuf.parse            = require("./parse");
protobuf.common           = require("./common");

// Configure parser
protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);

},{"./common":47,"./index-light":53,"./parse":62,"./tokenize":70}],56:[function(require,module,exports){
"use strict";
module.exports = MapField;

// extends Field
var Field = require("./field");
((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";

var types   = require("./types"),
    util    = require("./util");

/**
 * Constructs a new map field instance.
 * @classdesc Reflected map field.
 * @extends FieldBase
 * @constructor
 * @param {string} name Unique name within its namespace
 * @param {number} id Unique id within its namespace
 * @param {string} keyType Key type
 * @param {string} type Value type
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function MapField(name, id, keyType, type, options, comment) {
    Field.call(this, name, id, type, undefined, undefined, options, comment);

    /* istanbul ignore if */
    if (!util.isString(keyType))
        throw TypeError("keyType must be a string");

    /**
     * Key type.
     * @type {string}
     */
    this.keyType = keyType; // toJSON, marker

    /**
     * Resolved key type if not a basic type.
     * @type {ReflectionObject|null}
     */
    this.resolvedKeyType = null;

    // Overrides Field#map
    this.map = true;
}

/**
 * Map field descriptor.
 * @interface IMapField
 * @extends {IField}
 * @property {string} keyType Key type
 */

/**
 * Extension map field descriptor.
 * @interface IExtensionMapField
 * @extends IMapField
 * @property {string} extend Extended type
 */

/**
 * Constructs a map field from a map field descriptor.
 * @param {string} name Field name
 * @param {IMapField} json Map field descriptor
 * @returns {MapField} Created map field
 * @throws {TypeError} If arguments are invalid
 */
MapField.fromJSON = function fromJSON(name, json) {
    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
};

/**
 * Converts this map field to a map field descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMapField} Map field descriptor
 */
MapField.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "keyType" , this.keyType,
        "type"    , this.type,
        "id"      , this.id,
        "extend"  , this.extend,
        "options" , this.options,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
MapField.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;

    // Besides a value type, map fields have a key type that may be "any scalar type except for floating point types and bytes"
    if (types.mapKey[this.keyType] === undefined)
        throw Error("invalid key type: " + this.keyType);

    return Field.prototype.resolve.call(this);
};

/**
 * Map field decorator (TypeScript).
 * @name MapField.d
 * @function
 * @param {number} fieldId Field id
 * @param {"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"} fieldKeyType Field key type
 * @param {"double"|"float"|"int32"|"uint32"|"sint32"|"fixed32"|"sfixed32"|"int64"|"uint64"|"sint64"|"fixed64"|"sfixed64"|"bool"|"string"|"bytes"|Object|Constructor<{}>} fieldValueType Field value type
 * @returns {FieldDecorator} Decorator function
 * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }
 */
MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {

    // submessage value: decorate the submessage and use its name as the type
    if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;

    // enum reference value: create a reflected copy of the enum and keep reuseing it
    else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;

    return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor)
            .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
    };
};

},{"./field":52,"./types":72,"./util":73}],57:[function(require,module,exports){
"use strict";
module.exports = Message;

var util = require("./util/minimal");

/**
 * Constructs a new message instance.
 * @classdesc Abstract runtime message.
 * @constructor
 * @param {Properties<T>} [properties] Properties to set
 * @template T extends object = object
 */
function Message(properties) {
    // not used internally
    if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            this[keys[i]] = properties[keys[i]];
}

/**
 * Reference to the reflected type.
 * @name Message.$type
 * @type {Type}
 * @readonly
 */

/**
 * Reference to the reflected type.
 * @name Message#$type
 * @type {Type}
 * @readonly
 */

/*eslint-disable valid-jsdoc*/

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<T>} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.create = function create(properties) {
    return this.$type.create(properties);
};

/**
 * Encodes a message of this type.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encode = function encode(message, writer) {
    return this.$type.encode(message, writer);
};

/**
 * Encodes a message of this type preceeded by its length as a varint.
 * @param {T|Object.<string,*>} message Message to encode
 * @param {Writer} [writer] Writer to use
 * @returns {Writer} Writer
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.encodeDelimited = function encodeDelimited(message, writer) {
    return this.$type.encodeDelimited(message, writer);
};

/**
 * Decodes a message of this type.
 * @name Message.decode
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decode = function decode(reader) {
    return this.$type.decode(reader);
};

/**
 * Decodes a message of this type preceeded by its length as a varint.
 * @name Message.decodeDelimited
 * @function
 * @param {Reader|Uint8Array} reader Reader or buffer to decode
 * @returns {T} Decoded message
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.decodeDelimited = function decodeDelimited(reader) {
    return this.$type.decodeDelimited(reader);
};

/**
 * Verifies a message of this type.
 * @name Message.verify
 * @function
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {string|null} `null` if valid, otherwise the reason why it is not
 */
Message.verify = function verify(message) {
    return this.$type.verify(message);
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object
 * @returns {T} Message instance
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.fromObject = function fromObject(object) {
    return this.$type.fromObject(object);
};

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {T} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @template T extends Message<T>
 * @this Constructor<T>
 */
Message.toObject = function toObject(message, options) {
    return this.$type.toObject(message, options);
};

/**
 * Converts this message to JSON.
 * @returns {Object.<string,*>} JSON object
 */
Message.prototype.toJSON = function toJSON() {
    return this.$type.toObject(this, util.toJSONOptions);
};

/*eslint-enable valid-jsdoc*/
},{"./util/minimal":75}],58:[function(require,module,exports){
"use strict";
module.exports = Method;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";

var util = require("./util");

/**
 * Constructs a new service method instance.
 * @classdesc Reflected service method.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Method name
 * @param {string|undefined} type Method type, usually `"rpc"`
 * @param {string} requestType Request message type
 * @param {string} responseType Response message type
 * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed
 * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] The comment for this method
 */
function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment) {

    /* istanbul ignore next */
    if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = undefined;
    } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = undefined;
    }

    /* istanbul ignore if */
    if (!(type === undefined || util.isString(type)))
        throw TypeError("type must be a string");

    /* istanbul ignore if */
    if (!util.isString(requestType))
        throw TypeError("requestType must be a string");

    /* istanbul ignore if */
    if (!util.isString(responseType))
        throw TypeError("responseType must be a string");

    ReflectionObject.call(this, name, options);

    /**
     * Method type.
     * @type {string}
     */
    this.type = type || "rpc"; // toJSON

    /**
     * Request type.
     * @type {string}
     */
    this.requestType = requestType; // toJSON, marker

    /**
     * Whether requests are streamed or not.
     * @type {boolean|undefined}
     */
    this.requestStream = requestStream ? true : undefined; // toJSON

    /**
     * Response type.
     * @type {string}
     */
    this.responseType = responseType; // toJSON

    /**
     * Whether responses are streamed or not.
     * @type {boolean|undefined}
     */
    this.responseStream = responseStream ? true : undefined; // toJSON

    /**
     * Resolved request type.
     * @type {Type|null}
     */
    this.resolvedRequestType = null;

    /**
     * Resolved response type.
     * @type {Type|null}
     */
    this.resolvedResponseType = null;

    /**
     * Comment for this method
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Method descriptor.
 * @interface IMethod
 * @property {string} [type="rpc"] Method type
 * @property {string} requestType Request type
 * @property {string} responseType Response type
 * @property {boolean} [requestStream=false] Whether requests are streamed
 * @property {boolean} [responseStream=false] Whether responses are streamed
 * @property {Object.<string,*>} [options] Method options
 */

/**
 * Constructs a method from a method descriptor.
 * @param {string} name Method name
 * @param {IMethod} json Method descriptor
 * @returns {Method} Created method
 * @throws {TypeError} If arguments are invalid
 */
Method.fromJSON = function fromJSON(name, json) {
    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment);
};

/**
 * Converts this method to a method descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IMethod} Method descriptor
 */
Method.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "type"           , this.type !== "rpc" && /* istanbul ignore next */ this.type || undefined,
        "requestType"    , this.requestType,
        "requestStream"  , this.requestStream,
        "responseType"   , this.responseType,
        "responseStream" , this.responseStream,
        "options"        , this.options,
        "comment"        , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Method.prototype.resolve = function resolve() {

    /* istanbul ignore if */
    if (this.resolved)
        return this;

    this.resolvedRequestType = this.parent.lookupType(this.requestType);
    this.resolvedResponseType = this.parent.lookupType(this.responseType);

    return ReflectionObject.prototype.resolve.call(this);
};

},{"./object":60,"./util":73}],59:[function(require,module,exports){
"use strict";
module.exports = Namespace;

// extends ReflectionObject
var ReflectionObject = require("./object");
((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";

var Field    = require("./field"),
    util     = require("./util");

var Type,    // cyclic
    Service,
    Enum;

/**
 * Constructs a new namespace instance.
 * @name Namespace
 * @classdesc Reflected namespace.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 */

/**
 * Constructs a namespace from JSON.
 * @memberof Namespace
 * @function
 * @param {string} name Namespace name
 * @param {Object.<string,*>} json JSON object
 * @returns {Namespace} Created namespace
 * @throws {TypeError} If arguments are invalid
 */
Namespace.fromJSON = function fromJSON(name, json) {
    return new Namespace(name, json.options).addJSON(json.nested);
};

/**
 * Converts an array of reflection objects to JSON.
 * @memberof Namespace
 * @param {ReflectionObject[]} array Object array
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty
 */
function arrayToJSON(array, toJSONOptions) {
    if (!(array && array.length))
        return undefined;
    var obj = {};
    for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
    return obj;
}

Namespace.arrayToJSON = arrayToJSON;

/**
 * Tests if the specified id is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedId = function isReservedId(reserved, id) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
                return true;
    return false;
};

/**
 * Tests if the specified name is reserved.
 * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Namespace.isReservedName = function isReservedName(reserved, name) {
    if (reserved)
        for (var i = 0; i < reserved.length; ++i)
            if (reserved[i] === name)
                return true;
    return false;
};

/**
 * Not an actual constructor. Use {@link Namespace} instead.
 * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.
 * @exports NamespaceBase
 * @extends ReflectionObject
 * @abstract
 * @constructor
 * @param {string} name Namespace name
 * @param {Object.<string,*>} [options] Declared options
 * @see {@link Namespace}
 */
function Namespace(name, options) {
    ReflectionObject.call(this, name, options);

    /**
     * Nested objects by name.
     * @type {Object.<string,ReflectionObject>|undefined}
     */
    this.nested = undefined; // toJSON

    /**
     * Cached nested objects as an array.
     * @type {ReflectionObject[]|null}
     * @private
     */
    this._nestedArray = null;
}

function clearCache(namespace) {
    namespace._nestedArray = null;
    return namespace;
}

/**
 * Nested objects of this namespace as an array for iteration.
 * @name NamespaceBase#nestedArray
 * @type {ReflectionObject[]}
 * @readonly
 */
Object.defineProperty(Namespace.prototype, "nestedArray", {
    get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
    }
});

/**
 * Namespace descriptor.
 * @interface INamespace
 * @property {Object.<string,*>} [options] Namespace options
 * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors
 */

/**
 * Any extension field descriptor.
 * @typedef AnyExtensionField
 * @type {IExtensionField|IExtensionMapField}
 */

/**
 * Any nested object descriptor.
 * @typedef AnyNestedObject
 * @type {IEnum|IType|IService|AnyExtensionField|INamespace}
 */
// ^ BEWARE: VSCode hangs forever when using more than 5 types (that's why AnyExtensionField exists in the first place)

/**
 * Converts this namespace to a namespace descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {INamespace} Namespace descriptor
 */
Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
    return util.toObject([
        "options" , this.options,
        "nested"  , arrayToJSON(this.nestedArray, toJSONOptions)
    ]);
};

/**
 * Adds nested objects to this namespace from nested object descriptors.
 * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors
 * @returns {Namespace} `this`
 */
Namespace.prototype.addJSON = function addJSON(nestedJson) {
    var ns = this;
    /* istanbul ignore else */
    if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
            nested = nestedJson[names[i]];
            ns.add( // most to least likely
                ( nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : nested.id !== undefined
                ? Field.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    }
    return this;
};

/**
 * Gets the nested object of the specified name.
 * @param {string} name Nested object name
 * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist
 */
Namespace.prototype.get = function get(name) {
    return this.nested && this.nested[name]
        || null;
};

/**
 * Gets the values of the nested {@link Enum|enum} of the specified name.
 * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.
 * @param {string} name Nested enum name
 * @returns {Object.<string,number>} Enum values
 * @throws {Error} If there is no such enum
 */
Namespace.prototype.getEnum = function getEnum(name) {
    if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
    throw Error("no such enum: " + name);
};

/**
 * Adds a nested object to this namespace.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name
 */
Namespace.prototype.add = function add(object) {

    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");

    if (!this.nested)
        this.nested = {};
    else {
        var prev = this.get(object.name);
        if (prev) {
            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
                // replace plain namespace but keep existing nested elements and options
                var nested = prev.nestedArray;
                for (var i = 0; i < nested.length; ++i)
                    object.add(nested[i]);
                this.remove(prev);
                if (!this.nested)
                    this.nested = {};
                object.setOptions(prev.options, true);

            } else
                throw Error("duplicate name '" + object.name + "' in " + this);
        }
    }
    this.nested[object.name] = object;
    object.onAdd(this);
    return clearCache(this);
};

/**
 * Removes a nested object from this namespace.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Namespace} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this namespace
 */
Namespace.prototype.remove = function remove(object) {

    if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
    if (object.parent !== this)
        throw Error(object + " is not a member of " + this);

    delete this.nested[object.name];
    if (!Object.keys(this.nested).length)
        this.nested = undefined;

    object.onRemove(this);
    return clearCache(this);
};

/**
 * Defines additial namespaces within this one if not yet existing.
 * @param {string|string[]} path Path to create
 * @param {*} [json] Nested types to create from JSON
 * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty
 */
Namespace.prototype.define = function define(path, json) {

    if (util.isString(path))
        path = path.split(".");
    else if (!Array.isArray(path))
        throw TypeError("illegal path");
    if (path && path.length && path[0] === "")
        throw Error("path must be relative");

    var ptr = this;
    while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
            ptr = ptr.nested[part];
            if (!(ptr instanceof Namespace))
                throw Error("path conflicts with non-namespace objects");
        } else
            ptr.add(ptr = new Namespace(part));
    }
    if (json)
        ptr.addJSON(json);
    return ptr;
};

/**
 * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.
 * @returns {Namespace} `this`
 */
Namespace.prototype.resolveAll = function resolveAll() {
    var nested = this.nestedArray, i = 0;
    while (i < nested.length)
        if (nested[i] instanceof Namespace)
            nested[i++].resolveAll();
        else
            nested[i++].resolve();
    return this.resolve();
};

/**
 * Recursively looks up the reflection object matching the specified path in the scope of this namespace.
 * @param {string|string[]} path Path to look up
 * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.
 * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 */
Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {

    /* istanbul ignore next */
    if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = undefined;
    } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [ filterTypes ];

    if (util.isString(path) && path.length) {
        if (path === ".")
            return this.root;
        path = path.split(".");
    } else if (!path.length)
        return this;

    // Start at root if path is absolute
    if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);

    // Test if the first part matches any nested object, and if so, traverse if path contains more
    var found = this.get(path[0]);
    if (found) {
        if (path.length === 1) {
            if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
                return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
            return found;

    // Otherwise try each nested namespace
    } else
        for (var i = 0; i < this.nestedArray.length; ++i)
            if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
                return found;

    // If there hasn't been a match, try again at the parent
    if (this.parent === null || parentAlreadyChecked)
        return null;
    return this.parent.lookup(path, filterTypes);
};

/**
 * Looks up the reflection object at the specified path, relative to this namespace.
 * @name NamespaceBase#lookup
 * @function
 * @param {string|string[]} path Path to look up
 * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked
 * @returns {ReflectionObject|null} Looked up object or `null` if none could be found
 * @variation 2
 */
// lookup(path: string, [parentAlreadyChecked: boolean])

/**
 * Looks up the {@link Type|type} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type
 * @throws {Error} If `path` does not point to a type
 */
Namespace.prototype.lookupType = function lookupType(path) {
    var found = this.lookup(path, [ Type ]);
    if (!found)
        throw Error("no such type: " + path);
    return found;
};

/**
 * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Enum} Looked up enum
 * @throws {Error} If `path` does not point to an enum
 */
Namespace.prototype.lookupEnum = function lookupEnum(path) {
    var found = this.lookup(path, [ Enum ]);
    if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Type} Looked up type or enum
 * @throws {Error} If `path` does not point to a type or enum
 */
Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
    var found = this.lookup(path, [ Type, Enum ]);
    if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
    return found;
};

/**
 * Looks up the {@link Service|service} at the specified path, relative to this namespace.
 * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.
 * @param {string|string[]} path Path to look up
 * @returns {Service} Looked up service
 * @throws {Error} If `path` does not point to a service
 */
Namespace.prototype.lookupService = function lookupService(path) {
    var found = this.lookup(path, [ Service ]);
    if (!found)
        throw Error("no such Service '" + path + "' in " + this);
    return found;
};

// Sets up cyclic dependencies (called in index-light)
Namespace._configure = function(Type_, Service_, Enum_) {
    Type    = Type_;
    Service = Service_;
    Enum    = Enum_;
};

},{"./field":52,"./object":60,"./util":73}],60:[function(require,module,exports){
"use strict";
module.exports = ReflectionObject;

ReflectionObject.className = "ReflectionObject";

var util = require("./util");

var Root; // cyclic

/**
 * Constructs a new reflection object instance.
 * @classdesc Base class of all reflection objects.
 * @constructor
 * @param {string} name Object name
 * @param {Object.<string,*>} [options] Declared options
 * @abstract
 */
function ReflectionObject(name, options) {

    if (!util.isString(name))
        throw TypeError("name must be a string");

    if (options && !util.isObject(options))
        throw TypeError("options must be an object");

    /**
     * Options.
     * @type {Object.<string,*>|undefined}
     */
    this.options = options; // toJSON

    /**
     * Parsed Options.
     * @type {Array.<Object.<string,*>>|undefined}
     */
    this.parsedOptions = null;

    /**
     * Unique name within its namespace.
     * @type {string}
     */
    this.name = name;

    /**
     * Parent namespace.
     * @type {Namespace|null}
     */
    this.parent = null;

    /**
     * Whether already resolved or not.
     * @type {boolean}
     */
    this.resolved = false;

    /**
     * Comment text, if any.
     * @type {string|null}
     */
    this.comment = null;

    /**
     * Defining file name.
     * @type {string|null}
     */
    this.filename = null;
}

Object.defineProperties(ReflectionObject.prototype, {

    /**
     * Reference to the root namespace.
     * @name ReflectionObject#root
     * @type {Root}
     * @readonly
     */
    root: {
        get: function() {
            var ptr = this;
            while (ptr.parent !== null)
                ptr = ptr.parent;
            return ptr;
        }
    },

    /**
     * Full name including leading dot.
     * @name ReflectionObject#fullName
     * @type {string}
     * @readonly
     */
    fullName: {
        get: function() {
            var path = [ this.name ],
                ptr = this.parent;
            while (ptr) {
                path.unshift(ptr.name);
                ptr = ptr.parent;
            }
            return path.join(".");
        }
    }
});

/**
 * Converts this reflection object to its descriptor representation.
 * @returns {Object.<string,*>} Descriptor
 * @abstract
 */
ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {
    throw Error(); // not implemented, shouldn't happen
};

/**
 * Called when this object is added to a parent.
 * @param {ReflectionObject} parent Parent added to
 * @returns {undefined}
 */
ReflectionObject.prototype.onAdd = function onAdd(parent) {
    if (this.parent && this.parent !== parent)
        this.parent.remove(this);
    this.parent = parent;
    this.resolved = false;
    var root = parent.root;
    if (root instanceof Root)
        root._handleAdd(this);
};

/**
 * Called when this object is removed from a parent.
 * @param {ReflectionObject} parent Parent removed from
 * @returns {undefined}
 */
ReflectionObject.prototype.onRemove = function onRemove(parent) {
    var root = parent.root;
    if (root instanceof Root)
        root._handleRemove(this);
    this.parent = null;
    this.resolved = false;
};

/**
 * Resolves this objects type references.
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.resolve = function resolve() {
    if (this.resolved)
        return this;
    if (this.root instanceof Root)
        this.resolved = true; // only if part of a root
    return this;
};

/**
 * Gets an option value.
 * @param {string} name Option name
 * @returns {*} Option value or `undefined` if not set
 */
ReflectionObject.prototype.getOption = function getOption(name) {
    if (this.options)
        return this.options[name];
    return undefined;
};

/**
 * Sets an option.
 * @param {string} name Option name
 * @param {*} value Option value
 * @param {boolean} [ifNotSet] Sets the option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
    if (!ifNotSet || !this.options || this.options[name] === undefined)
        (this.options || (this.options = {}))[name] = value;
    return this;
};

/**
 * Sets a parsed option.
 * @param {string} name parsed Option name
 * @param {*} value Option value
 * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\empty, will add a new option with that value
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
    if (!this.parsedOptions) {
        this.parsedOptions = [];
    }
    var parsedOptions = this.parsedOptions;
    if (propName) {
        // If setting a sub property of an option then try to merge it
        // with an existing option
        var opt = parsedOptions.find(function (opt) {
            return Object.prototype.hasOwnProperty.call(opt, name);
        });
        if (opt) {
            // If we found an existing option - just merge the property value
            var newValue = opt[name];
            util.setProperty(newValue, propName, value);
        } else {
            // otherwise, create a new option, set it's property and add it to the list
            opt = {};
            opt[name] = util.setProperty({}, propName, value);
            parsedOptions.push(opt);
        }
    } else {
        // Always create a new option when setting the value of the option itself
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
    }
    return this;
};

/**
 * Sets multiple options.
 * @param {Object.<string,*>} options Options to set
 * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set
 * @returns {ReflectionObject} `this`
 */
ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
    if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
            this.setOption(keys[i], options[keys[i]], ifNotSet);
    return this;
};

/**
 * Converts this instance to its string representation.
 * @returns {string} Class name[, space, full name]
 */
ReflectionObject.prototype.toString = function toString() {
    var className = this.constructor.className,
        fullName  = this.fullName;
    if (fullName.length)
        return className + " " + fullName;
    return className;
};

// Sets up cyclic dependencies (called in index-light)
ReflectionObject._configure = function(Root_) {
    Root = Root_;
};

},{"./util":73}],61:[function(require,module,exports){
"use strict";
module.exports = OneOf;

// extends ReflectionObject
var ReflectionObject = require("./object");
((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";

var Field = require("./field"),
    util  = require("./util");

/**
 * Constructs a new oneof instance.
 * @classdesc Reflected oneof.
 * @extends ReflectionObject
 * @constructor
 * @param {string} name Oneof name
 * @param {string[]|Object.<string,*>} [fieldNames] Field names
 * @param {Object.<string,*>} [options] Declared options
 * @param {string} [comment] Comment associated with this field
 */
function OneOf(name, fieldNames, options, comment) {
    if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = undefined;
    }
    ReflectionObject.call(this, name, options);

    /* istanbul ignore if */
    if (!(fieldNames === undefined || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");

    /**
     * Field names that belong to this oneof.
     * @type {string[]}
     */
    this.oneof = fieldNames || []; // toJSON, marker

    /**
     * Fields that belong to this oneof as an array for iteration.
     * @type {Field[]}
     * @readonly
     */
    this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent

    /**
     * Comment for this field.
     * @type {string|null}
     */
    this.comment = comment;
}

/**
 * Oneof descriptor.
 * @interface IOneOf
 * @property {Array.<string>} oneof Oneof field names
 * @property {Object.<string,*>} [options] Oneof options
 */

/**
 * Constructs a oneof from a oneof descriptor.
 * @param {string} name Oneof name
 * @param {IOneOf} json Oneof descriptor
 * @returns {OneOf} Created oneof
 * @throws {TypeError} If arguments are invalid
 */
OneOf.fromJSON = function fromJSON(name, json) {
    return new OneOf(name, json.oneof, json.options, json.comment);
};

/**
 * Converts this oneof to a oneof descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IOneOf} Oneof descriptor
 */
OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , this.options,
        "oneof"   , this.oneof,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Adds the fields of the specified oneof to the parent if not already done so.
 * @param {OneOf} oneof The oneof
 * @returns {undefined}
 * @inner
 * @ignore
 */
function addFieldsToParent(oneof) {
    if (oneof.parent)
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
            if (!oneof.fieldsArray[i].parent)
                oneof.parent.add(oneof.fieldsArray[i]);
}

/**
 * Adds a field to this oneof and removes it from its current parent, if any.
 * @param {Field} field Field to add
 * @returns {OneOf} `this`
 */
OneOf.prototype.add = function add(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
    this.oneof.push(field.name);
    this.fieldsArray.push(field);
    field.partOf = this; // field.parent remains null
    addFieldsToParent(this);
    return this;
};

/**
 * Removes a field from this oneof and puts it back to the oneof's parent.
 * @param {Field} field Field to remove
 * @returns {OneOf} `this`
 */
OneOf.prototype.remove = function remove(field) {

    /* istanbul ignore if */
    if (!(field instanceof Field))
        throw TypeError("field must be a Field");

    var index = this.fieldsArray.indexOf(field);

    /* istanbul ignore if */
    if (index < 0)
        throw Error(field + " is not a member of " + this);

    this.fieldsArray.splice(index, 1);
    index = this.oneof.indexOf(field.name);

    /* istanbul ignore else */
    if (index > -1) // theoretical
        this.oneof.splice(index, 1);

    field.partOf = null;
    return this;
};

/**
 * @override
 */
OneOf.prototype.onAdd = function onAdd(parent) {
    ReflectionObject.prototype.onAdd.call(this, parent);
    var self = this;
    // Collect present fields
    for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
            field.partOf = self;
            self.fieldsArray.push(field);
        }
    }
    // Add not yet present fields
    addFieldsToParent(this);
};

/**
 * @override
 */
OneOf.prototype.onRemove = function onRemove(parent) {
    for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
            field.parent.remove(field);
    ReflectionObject.prototype.onRemove.call(this, parent);
};

/**
 * Decorator function as returned by {@link OneOf.d} (TypeScript).
 * @typedef OneOfDecorator
 * @type {function}
 * @param {Object} prototype Target prototype
 * @param {string} oneofName OneOf name
 * @returns {undefined}
 */

/**
 * OneOf decorator (TypeScript).
 * @function
 * @param {...string} fieldNames Field names
 * @returns {OneOfDecorator} Decorator function
 * @template T extends string
 */
OneOf.d = function decorateOneOf() {
    var fieldNames = new Array(arguments.length),
        index = 0;
    while (index < arguments.length)
        fieldNames[index] = arguments[index++];
    return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor)
            .add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
            get: util.oneOfGetter(fieldNames),
            set: util.oneOfSetter(fieldNames)
        });
    };
};

},{"./field":52,"./object":60,"./util":73}],62:[function(require,module,exports){
"use strict";
module.exports = parse;

parse.filename = null;
parse.defaults = { keepCase: false };

var tokenize  = require("./tokenize"),
    Root      = require("./root"),
    Type      = require("./type"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    OneOf     = require("./oneof"),
    Enum      = require("./enum"),
    Service   = require("./service"),
    Method    = require("./method"),
    types     = require("./types"),
    util      = require("./util");

var base10Re    = /^[1-9][0-9]*$/,
    base10NegRe = /^-?[1-9][0-9]*$/,
    base16Re    = /^0[x][0-9a-fA-F]+$/,
    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,
    base8Re     = /^0[0-7]+$/,
    base8NegRe  = /^-?0[0-7]+$/,
    numberRe    = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
    nameRe      = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
    typeRefRe   = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,
    fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;

/**
 * Result object returned from {@link parse}.
 * @interface IParserResult
 * @property {string|undefined} package Package name, if declared
 * @property {string[]|undefined} imports Imports, if any
 * @property {string[]|undefined} weakImports Weak imports, if any
 * @property {string|undefined} syntax Syntax, if specified (either `"proto2"` or `"proto3"`)
 * @property {Root} root Populated root instance
 */

/**
 * Options modifying the behavior of {@link parse}.
 * @interface IParseOptions
 * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case
 * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.
 * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.
 */

/**
 * Options modifying the behavior of JSON serialization.
 * @interface IToJSONOptions
 * @property {boolean} [keepComments=false] Serializes comments.
 */

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @param {string} source Source contents
 * @param {Root} root Root to populate
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 */
function parse(source, root, options) {
    /* eslint-disable callback-return */
    if (!(root instanceof Root)) {
        options = root;
        root = new Root();
    }
    if (!options)
        options = parse.defaults;

    var preferTrailingComment = options.preferTrailingComment || false;
    var tn = tokenize(source, options.alternateCommentMode || false),
        next = tn.next,
        push = tn.push,
        peek = tn.peek,
        skip = tn.skip,
        cmnt = tn.cmnt;

    var head = true,
        pkg,
        imports,
        weakImports,
        syntax,
        isProto3 = false;

    var ptr = root;

    var applyCase = options.keepCase ? function(name) { return name; } : util.camelCase;

    /* istanbul ignore next */
    function illegal(token, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
            parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
    }

    function readString() {
        var values = [],
            token;
        do {
            /* istanbul ignore if */
            if ((token = next()) !== "\"" && token !== "'")
                throw illegal(token);

            values.push(next());
            skip(token);
            token = peek();
        } while (token === "\"" || token === "'");
        return values.join("");
    }

    function readValue(acceptTypeRef) {
        var token = next();
        switch (token) {
            case "'":
            case "\"":
                push(token);
                return readString();
            case "true": case "TRUE":
                return true;
            case "false": case "FALSE":
                return false;
        }
        try {
            return parseNumber(token, /* insideTryCatch */ true);
        } catch (e) {

            /* istanbul ignore else */
            if (acceptTypeRef && typeRefRe.test(token))
                return token;

            /* istanbul ignore next */
            throw illegal(token, "value");
        }
    }

    function readRanges(target, acceptStrings) {
        var token, start;
        do {
            if (acceptStrings && ((token = peek()) === "\"" || token === "'"))
                target.push(readString());
            else
                target.push([ start = parseId(next()), skip("to", true) ? parseId(next()) : start ]);
        } while (skip(",", true));
        skip(";");
    }

    function parseNumber(token, insideTryCatch) {
        var sign = 1;
        if (token.charAt(0) === "-") {
            sign = -1;
            token = token.substring(1);
        }
        switch (token) {
            case "inf": case "INF": case "Inf":
                return sign * Infinity;
            case "nan": case "NAN": case "Nan": case "NaN":
                return NaN;
            case "0":
                return 0;
        }
        if (base10Re.test(token))
            return sign * parseInt(token, 10);
        if (base16Re.test(token))
            return sign * parseInt(token, 16);
        if (base8Re.test(token))
            return sign * parseInt(token, 8);

        /* istanbul ignore else */
        if (numberRe.test(token))
            return sign * parseFloat(token);

        /* istanbul ignore next */
        throw illegal(token, "number", insideTryCatch);
    }

    function parseId(token, acceptNegative) {
        switch (token) {
            case "max": case "MAX": case "Max":
                return 536870911;
            case "0":
                return 0;
        }

        /* istanbul ignore if */
        if (!acceptNegative && token.charAt(0) === "-")
            throw illegal(token, "id");

        if (base10NegRe.test(token))
            return parseInt(token, 10);
        if (base16NegRe.test(token))
            return parseInt(token, 16);

        /* istanbul ignore else */
        if (base8NegRe.test(token))
            return parseInt(token, 8);

        /* istanbul ignore next */
        throw illegal(token, "id");
    }

    function parsePackage() {

        /* istanbul ignore if */
        if (pkg !== undefined)
            throw illegal("package");

        pkg = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(pkg))
            throw illegal(pkg, "name");

        ptr = ptr.define(pkg);
        skip(";");
    }

    function parseImport() {
        var token = peek();
        var whichImports;
        switch (token) {
            case "weak":
                whichImports = weakImports || (weakImports = []);
                next();
                break;
            case "public":
                next();
                // eslint-disable-line no-fallthrough
            default:
                whichImports = imports || (imports = []);
                break;
        }
        token = readString();
        skip(";");
        whichImports.push(token);
    }

    function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";

        /* istanbul ignore if */
        if (!isProto3 && syntax !== "proto2")
            throw illegal(syntax, "syntax");

        skip(";");
    }

    function parseCommon(parent, token) {
        switch (token) {

            case "option":
                parseOption(parent, token);
                skip(";");
                return true;

            case "message":
                parseType(parent, token);
                return true;

            case "enum":
                parseEnum(parent, token);
                return true;

            case "service":
                parseService(parent, token);
                return true;

            case "extend":
                parseExtension(parent, token);
                return true;
        }
        return false;
    }

    function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
            if(typeof obj.comment !== "string") {
              obj.comment = cmnt(); // try block-type comment
            }
            obj.filename = parse.filename;
        }
        if (skip("{", true)) {
            var token;
            while ((token = next()) !== "}")
                fnIf(token);
            skip(";", true);
        } else {
            if (fnElse)
                fnElse();
            skip(";");
            if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
                obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment
        }
    }

    function parseType(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "type name");

        var type = new Type(token);
        ifBlock(type, function parseType_block(token) {
            if (parseCommon(type, token))
                return;

            switch (token) {

                case "map":
                    parseMapField(type, token);
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                case "oneof":
                    parseOneOf(type, token);
                    break;

                case "extensions":
                    readRanges(type.extensions || (type.extensions = []));
                    break;

                case "reserved":
                    readRanges(type.reserved || (type.reserved = []), true);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);

                    push(token);
                    parseField(type, "optional");
                    break;
            }
        });
        parent.add(type);
    }

    function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
            parseGroup(parent, rule);
            return;
        }

        /* istanbul ignore if */
        if (!typeRefRe.test(type))
            throw illegal(type, "type");

        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        name = applyCase(name);
        skip("=");

        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);

        // JSON defaults to packed=true if not set so we have to set packed=false explicity when
        // parsing proto2 descriptors without the option, where applicable. This must be done for
        // all known packable types and anything that could be an enum (= is not a basic type).
        if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined))
            field.setOption("packed", false, /* ifNotSet */ true);
    }

    function parseGroup(parent, rule) {
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        var fieldName = util.lcFirst(name);
        if (name === fieldName)
            name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token) {
            switch (token) {

                case "option":
                    parseOption(type, token);
                    skip(";");
                    break;

                case "required":
                case "optional":
                case "repeated":
                    parseField(type, token);
                    break;

                /* istanbul ignore next */
                default:
                    throw illegal(token); // there are no groups with proto3 semantics
            }
        });
        parent.add(type)
              .add(field);
    }

    function parseMapField(parent) {
        skip("<");
        var keyType = next();

        /* istanbul ignore if */
        if (types.mapKey[keyType] === undefined)
            throw illegal(keyType, "type");

        skip(",");
        var valueType = next();

        /* istanbul ignore if */
        if (!typeRefRe.test(valueType))
            throw illegal(valueType, "type");

        skip(">");
        var name = next();

        /* istanbul ignore if */
        if (!nameRe.test(name))
            throw illegal(name, "name");

        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(field, token);
                skip(";");
            } else
                throw illegal(token);

        }, function parseMapField_line() {
            parseInlineOptions(field);
        });
        parent.add(field);
    }

    function parseOneOf(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var oneof = new OneOf(applyCase(token));
        ifBlock(oneof, function parseOneOf_block(token) {
            if (token === "option") {
                parseOption(oneof, token);
                skip(";");
            } else {
                push(token);
                parseField(oneof, "optional");
            }
        });
        parent.add(oneof);
    }

    function parseEnum(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var enm = new Enum(token);
        ifBlock(enm, function parseEnum_block(token) {
          switch(token) {
            case "option":
              parseOption(enm, token);
              skip(";");
              break;

            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;

            default:
              parseEnumValue(enm, token);
          }
        });
        parent.add(enm);
    }

    function parseEnumValue(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token))
            throw illegal(token, "name");

        skip("=");
        var value = parseId(next(), true),
            dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(dummy, token); // skip
                skip(";");
            } else
                throw illegal(token);

        }, function parseEnumValue_line() {
            parseInlineOptions(dummy); // skip
        });
        parent.add(token, value, dummy.comment);
    }

    function parseOption(parent, token) {
        var isCustom = skip("(", true);

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "name");

        var name = token;
        var option = name;
        var propName;

        if (isCustom) {
            skip(")");
            name = "(" + name + ")";
            option = name;
            token = peek();
            if (fqTypeRefRe.test(token)) {
                propName = token.substr(1); //remove '.' before property name
                name += token;
                next();
            }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
    }

    function parseOptionValue(parent, name) {
        if (skip("{", true)) { // { a: "foo" b { c: "bar" } }
            var result = {};
            while (!skip("}", true)) {
                /* istanbul ignore if */
                if (!nameRe.test(token = next()))
                    throw illegal(token, "name");

                var value;
                var propName = token;
                if (peek() === "{")
                    value = parseOptionValue(parent, name + "." + token);
                else {
                    skip(":");
                    if (peek() === "{")
                        value = parseOptionValue(parent, name + "." + token);
                    else {
                        value = readValue(true);
                        setOption(parent, name + "." + token, value);
                    }
                }
                var prevValue = result[propName];
                if (prevValue)
                    value = [].concat(prevValue).concat(value);
                result[propName] = value;
                skip(",", true);
            }
            return result;
        }

        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
        // Does not enforce a delimiter to be universal
    }

    function setOption(parent, name, value) {
        if (parent.setOption)
            parent.setOption(name, value);
    }

    function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
            parent.setParsedOption(name, value, propName);
    }

    function parseInlineOptions(parent) {
        if (skip("[", true)) {
            do {
                parseOption(parent, "option");
            } while (skip(",", true));
            skip("]");
        }
        return parent;
    }

    function parseService(parent, token) {

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "service name");

        var service = new Service(token);
        ifBlock(service, function parseService_block(token) {
            if (parseCommon(service, token))
                return;

            /* istanbul ignore else */
            if (token === "rpc")
                parseMethod(service, token);
            else
                throw illegal(token);
        });
        parent.add(service);
    }

    function parseMethod(parent, token) {
        // Get the comment of the preceding line now (if one exists) in case the
        // method is defined across multiple lines.
        var commentText = cmnt();

        var type = token;

        /* istanbul ignore if */
        if (!nameRe.test(token = next()))
            throw illegal(token, "name");

        var name = token,
            requestType, requestStream,
            responseType, responseStream;

        skip("(");
        if (skip("stream", true))
            requestStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        requestType = token;
        skip(")"); skip("returns"); skip("(");
        if (skip("stream", true))
            responseStream = true;

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token);

        responseType = token;
        skip(")");

        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token) {

            /* istanbul ignore else */
            if (token === "option") {
                parseOption(method, token);
                skip(";");
            } else
                throw illegal(token);

        });
        parent.add(method);
    }

    function parseExtension(parent, token) {

        /* istanbul ignore if */
        if (!typeRefRe.test(token = next()))
            throw illegal(token, "reference");

        var reference = token;
        ifBlock(null, function parseExtension_block(token) {
            switch (token) {

                case "required":
                case "repeated":
                case "optional":
                    parseField(parent, token, reference);
                    break;

                default:
                    /* istanbul ignore if */
                    if (!isProto3 || !typeRefRe.test(token))
                        throw illegal(token);
                    push(token);
                    parseField(parent, "optional", reference);
                    break;
            }
        });
    }

    var token;
    while ((token = next()) !== null) {
        switch (token) {

            case "package":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parsePackage();
                break;

            case "import":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseImport();
                break;

            case "syntax":

                /* istanbul ignore if */
                if (!head)
                    throw illegal(token);

                parseSyntax();
                break;

            case "option":

                parseOption(ptr, token);
                skip(";");
                break;

            default:

                /* istanbul ignore else */
                if (parseCommon(ptr, token)) {
                    head = false;
                    continue;
                }

                /* istanbul ignore next */
                throw illegal(token);
        }
    }

    parse.filename = null;
    return {
        "package"     : pkg,
        "imports"     : imports,
         weakImports  : weakImports,
         syntax       : syntax,
         root         : root
    };
}

/**
 * Parses the given .proto source and returns an object with the parsed contents.
 * @name parse
 * @function
 * @param {string} source Source contents
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {IParserResult} Parser result
 * @property {string} filename=null Currently processing file name for error reporting, if known
 * @property {IParseOptions} defaults Default {@link IParseOptions}
 * @variation 2
 */

},{"./enum":51,"./field":52,"./mapfield":56,"./method":58,"./oneof":61,"./root":65,"./service":69,"./tokenize":70,"./type":71,"./types":72,"./util":73}],63:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":75}],64:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"./reader":63,"./util/minimal":75}],65:[function(require,module,exports){
"use strict";
module.exports = Root;

// extends Namespace
var Namespace = require("./namespace");
((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";

var Field   = require("./field"),
    Enum    = require("./enum"),
    OneOf   = require("./oneof"),
    util    = require("./util");

var Type,   // cyclic
    parse,  // might be excluded
    common; // "

/**
 * Constructs a new root namespace instance.
 * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.
 * @extends NamespaceBase
 * @constructor
 * @param {Object.<string,*>} [options] Top level options
 */
function Root(options) {
    Namespace.call(this, "", options);

    /**
     * Deferred extension fields.
     * @type {Field[]}
     */
    this.deferred = [];

    /**
     * Resolved file names of loaded files.
     * @type {string[]}
     */
    this.files = [];
}

/**
 * Loads a namespace descriptor into a root namespace.
 * @param {INamespace} json Nameespace descriptor
 * @param {Root} [root] Root namespace, defaults to create a new one if omitted
 * @returns {Root} Root namespace
 */
Root.fromJSON = function fromJSON(json, root) {
    if (!root)
        root = new Root();
    if (json.options)
        root.setOptions(json.options);
    return root.addJSON(json.nested);
};

/**
 * Resolves the path of an imported file, relative to the importing origin.
 * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.
 * @function
 * @param {string} origin The file name of the importing file
 * @param {string} target The file name being imported
 * @returns {string|null} Resolved path to `target` or `null` to skip the file
 */
Root.prototype.resolvePath = util.path.resolve;

/**
 * Fetch content from file path or url
 * This method exists so you can override it with your own logic.
 * @function
 * @param {string} path File path or url
 * @param {FetchCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.fetch = util.fetch;

// A symbol-like function to safely signal synchronous loading
/* istanbul ignore next */
function SYNC() {} // eslint-disable-line no-empty-function

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} options Parse options
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 */
Root.prototype.load = function load(filename, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = undefined;
    }
    var self = this;
    if (!callback)
        return util.asPromise(load, self, filename, options);

    var sync = callback === SYNC; // undocumented

    // Finishes loading by calling the callback (exactly once)
    function finish(err, root) {
        /* istanbul ignore if */
        if (!callback)
            return;
        var cb = callback;
        callback = null;
        if (sync)
            throw err;
        cb(err, root);
    }

    // Bundled definition existence checking
    function getBundledFileName(filename) {
        var idx = filename.lastIndexOf("google/protobuf/");
        if (idx > -1) {
            var altname = filename.substring(idx);
            if (altname in common) return altname;
        }
        return null;
    }

    // Processes a single file
    function process(filename, source) {
        try {
            if (util.isString(source) && source.charAt(0) === "{")
                source = JSON.parse(source);
            if (!util.isString(source))
                self.setOptions(source.options).addJSON(source.nested);
            else {
                parse.filename = filename;
                var parsed = parse(source, self, options),
                    resolved,
                    i = 0;
                if (parsed.imports)
                    for (; i < parsed.imports.length; ++i)
                        if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i]))
                            fetch(resolved);
                if (parsed.weakImports)
                    for (i = 0; i < parsed.weakImports.length; ++i)
                        if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i]))
                            fetch(resolved, true);
            }
        } catch (err) {
            finish(err);
        }
        if (!sync && !queued)
            finish(null, self); // only once anyway
    }

    // Fetches a single file
    function fetch(filename, weak) {

        // Skip if already loaded / attempted
        if (self.files.indexOf(filename) > -1)
            return;
        self.files.push(filename);

        // Shortcut bundled definitions
        if (filename in common) {
            if (sync)
                process(filename, common[filename]);
            else {
                ++queued;
                setTimeout(function() {
                    --queued;
                    process(filename, common[filename]);
                });
            }
            return;
        }

        // Otherwise fetch from disk or network
        if (sync) {
            var source;
            try {
                source = util.fs.readFileSync(filename).toString("utf8");
            } catch (err) {
                if (!weak)
                    finish(err);
                return;
            }
            process(filename, source);
        } else {
            ++queued;
            self.fetch(filename, function(err, source) {
                --queued;
                /* istanbul ignore if */
                if (!callback)
                    return; // terminated meanwhile
                if (err) {
                    /* istanbul ignore else */
                    if (!weak)
                        finish(err);
                    else if (!queued) // can't be covered reliably
                        finish(null, self);
                    return;
                }
                process(filename, source);
            });
        }
    }
    var queued = 0;

    // Assembling the root namespace doesn't require working type
    // references anymore, so we can load everything in parallel
    if (util.isString(filename))
        filename = [ filename ];
    for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self.resolvePath("", filename[i]))
            fetch(resolved);

    if (sync)
        return self;
    if (!queued)
        finish(null, self);
    return undefined;
};
// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {LoadCallback} callback Callback function
 * @returns {undefined}
 * @variation 2
 */
// function load(filename:string, callback:LoadCallback):undefined

/**
 * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.
 * @function Root#load
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Promise<Root>} Promise
 * @variation 3
 */
// function load(filename:string, [options:IParseOptions]):Promise<Root>

/**
 * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).
 * @function Root#loadSync
 * @param {string|string[]} filename Names of one or multiple files to load
 * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.
 * @returns {Root} Root namespace
 * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid
 */
Root.prototype.loadSync = function loadSync(filename, options) {
    if (!util.isNode)
        throw Error("not supported");
    return this.load(filename, options, SYNC);
};

/**
 * @override
 */
Root.prototype.resolveAll = function resolveAll() {
    if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
            return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
    return Namespace.prototype.resolveAll.call(this);
};

// only uppercased (and thus conflict-free) children are exposed, see below
var exposeRe = /^[A-Z]/;

/**
 * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.
 * @param {Root} root Root instance
 * @param {Field} field Declaring extension field witin the declaring type
 * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise
 * @inner
 * @ignore
 */
function tryHandleExtension(root, field) {
    var extendedType = field.parent.lookup(field.extend);
    if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
    }
    return false;
}

/**
 * Called when any object is added to this root or its sub-namespaces.
 * @param {ReflectionObject} object Object added
 * @returns {undefined}
 * @private
 */
Root.prototype._handleAdd = function _handleAdd(object) {
    if (object instanceof Field) {

        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField)
            if (!tryHandleExtension(this, object))
                this.deferred.push(object);

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            object.parent[object.name] = object.values; // expose enum values as property of its parent

    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {

        if (object instanceof Type) // Try to handle any deferred extensions
            for (var i = 0; i < this.deferred.length;)
                if (tryHandleExtension(this, this.deferred[i]))
                    this.deferred.splice(i, 1);
                else
                    ++i;
        for (var j = 0; j < /* initializes */ object.nestedArray.length; ++j) // recurse into the namespace
            this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
            object.parent[object.name] = object; // expose namespace as property of its parent
    }

    // The above also adds uppercased (and thus conflict-free) nested types, services and enums as
    // properties of namespaces just like static code does. This allows using a .d.ts generated for
    // a static module with reflection-based solutions where the condition is met.
};

/**
 * Called when any object is removed from this root or its sub-namespaces.
 * @param {ReflectionObject} object Object removed
 * @returns {undefined}
 * @private
 */
Root.prototype._handleRemove = function _handleRemove(object) {
    if (object instanceof Field) {

        if (/* an extension field */ object.extend !== undefined) {
            if (/* already handled */ object.extensionField) { // remove its sister field
                object.extensionField.parent.remove(object.extensionField);
                object.extensionField = null;
            } else { // cancel the extension
                var index = this.deferred.indexOf(object);
                /* istanbul ignore else */
                if (index > -1)
                    this.deferred.splice(index, 1);
            }
        }

    } else if (object instanceof Enum) {

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose enum values

    } else if (object instanceof Namespace) {

        for (var i = 0; i < /* initializes */ object.nestedArray.length; ++i) // recurse into the namespace
            this._handleRemove(object._nestedArray[i]);

        if (exposeRe.test(object.name))
            delete object.parent[object.name]; // unexpose namespaces

    }
};

// Sets up cyclic dependencies (called in index-light)
Root._configure = function(Type_, parse_, common_) {
    Type   = Type_;
    parse  = parse_;
    common = common_;
};

},{"./enum":51,"./field":52,"./namespace":59,"./oneof":61,"./util":73}],66:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],67:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":68}],68:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":75}],69:[function(require,module,exports){
"use strict";
module.exports = Service;

// extends Namespace
var Namespace = require("./namespace");
((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";

var Method = require("./method"),
    util   = require("./util"),
    rpc    = require("./rpc");

/**
 * Constructs a new service instance.
 * @classdesc Reflected service.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Service name
 * @param {Object.<string,*>} [options] Service options
 * @throws {TypeError} If arguments are invalid
 */
function Service(name, options) {
    Namespace.call(this, name, options);

    /**
     * Service methods.
     * @type {Object.<string,Method>}
     */
    this.methods = {}; // toJSON, marker

    /**
     * Cached methods as an array.
     * @type {Method[]|null}
     * @private
     */
    this._methodsArray = null;
}

/**
 * Service descriptor.
 * @interface IService
 * @extends INamespace
 * @property {Object.<string,IMethod>} methods Method descriptors
 */

/**
 * Constructs a service from a service descriptor.
 * @param {string} name Service name
 * @param {IService} json Service descriptor
 * @returns {Service} Created service
 * @throws {TypeError} If arguments are invalid
 */
Service.fromJSON = function fromJSON(name, json) {
    var service = new Service(name, json.options);
    /* istanbul ignore else */
    if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
            service.add(Method.fromJSON(names[i], json.methods[names[i]]));
    if (json.nested)
        service.addJSON(json.nested);
    service.comment = json.comment;
    return service;
};

/**
 * Converts this service to a service descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IService} Service descriptor
 */
Service.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options" , inherited && inherited.options || undefined,
        "methods" , Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},
        "nested"  , inherited && inherited.nested || undefined,
        "comment" , keepComments ? this.comment : undefined
    ]);
};

/**
 * Methods of this service as an array for iteration.
 * @name Service#methodsArray
 * @type {Method[]}
 * @readonly
 */
Object.defineProperty(Service.prototype, "methodsArray", {
    get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
    }
});

function clearCache(service) {
    service._methodsArray = null;
    return service;
}

/**
 * @override
 */
Service.prototype.get = function get(name) {
    return this.methods[name]
        || Namespace.prototype.get.call(this, name);
};

/**
 * @override
 */
Service.prototype.resolveAll = function resolveAll() {
    var methods = this.methodsArray;
    for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
    return Namespace.prototype.resolve.call(this);
};

/**
 * @override
 */
Service.prototype.add = function add(object) {

    /* istanbul ignore if */
    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * @override
 */
Service.prototype.remove = function remove(object) {
    if (object instanceof Method) {

        /* istanbul ignore if */
        if (this.methods[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Creates a runtime service using the specified rpc implementation.
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.
 */
Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
    for (var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r","c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
            m: method,
            q: method.resolvedRequestType.ctor,
            s: method.resolvedResponseType.ctor
        });
    }
    return rpcService;
};

},{"./method":58,"./namespace":59,"./rpc":67,"./util":73}],70:[function(require,module,exports){
"use strict";
module.exports = tokenize;

var delimRe        = /[\s{}=;:[\],'"()<>]/g,
    stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
    stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;

var setCommentRe = /^ *[*/]+ */,
    setCommentAltRe = /^\s*\*?\/*/,
    setCommentSplitRe = /\n/g,
    whitespaceRe = /\s/,
    unescapeRe = /\\(.?)/g;

var unescapeMap = {
    "0": "\0",
    "r": "\r",
    "n": "\n",
    "t": "\t"
};

/**
 * Unescapes a string.
 * @param {string} str String to unescape
 * @returns {string} Unescaped string
 * @property {Object.<string,string>} map Special characters map
 * @memberof tokenize
 */
function unescape(str) {
    return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
            case "\\":
            case "":
                return $1;
            default:
                return unescapeMap[$1] || "";
        }
    });
}

tokenize.unescape = unescape;

/**
 * Gets the next token and advances.
 * @typedef TokenizerHandleNext
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Peeks for the next token.
 * @typedef TokenizerHandlePeek
 * @type {function}
 * @returns {string|null} Next token or `null` on eof
 */

/**
 * Pushes a token back to the stack.
 * @typedef TokenizerHandlePush
 * @type {function}
 * @param {string} token Token
 * @returns {undefined}
 */

/**
 * Skips the next token.
 * @typedef TokenizerHandleSkip
 * @type {function}
 * @param {string} expected Expected token
 * @param {boolean} [optional=false] If optional
 * @returns {boolean} Whether the token matched
 * @throws {Error} If the token didn't match and is not optional
 */

/**
 * Gets the comment on the previous line or, alternatively, the line comment on the specified line.
 * @typedef TokenizerHandleCmnt
 * @type {function}
 * @param {number} [line] Line number
 * @returns {string|null} Comment text or `null` if none
 */

/**
 * Handle object returned from {@link tokenize}.
 * @interface ITokenizerHandle
 * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)
 * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)
 * @property {TokenizerHandlePush} push Pushes a token back to the stack
 * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws
 * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any
 * @property {number} line Current line number
 */

/**
 * Tokenizes the given .proto source and returns an object with useful utility functions.
 * @param {string} source Source contents
 * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.
 * @returns {ITokenizerHandle} Tokenizer handle
 */
function tokenize(source, alternateCommentMode) {
    /* eslint-disable callback-return */
    source = source.toString();

    var offset = 0,
        length = source.length,
        line = 1,
        commentType = null,
        commentText = null,
        commentLine = 0,
        commentLineEmpty = false,
        commentIsLeading = false;

    var stack = [];

    var stringDelim = null;

    /* istanbul ignore next */
    /**
     * Creates an error for illegal syntax.
     * @param {string} subject Subject
     * @returns {Error} Error created
     * @inner
     */
    function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
    }

    /**
     * Reads a string till its end.
     * @returns {string} String read
     * @inner
     */
    function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
            throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
    }

    /**
     * Gets the character at `pos` within the source.
     * @param {number} pos Position
     * @returns {string} Character
     * @inner
     */
    function charAt(pos) {
        return source.charAt(pos);
    }

    /**
     * Sets the current comment text.
     * @param {number} start Start offset
     * @param {number} end End offset
     * @param {boolean} isLeading set if a leading comment
     * @returns {undefined}
     * @inner
     */
    function setComment(start, end, isLeading) {
        commentType = source.charAt(start++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
            lookback = 2;  // alternate comment parsing: "//" or "/*"
        } else {
            lookback = 3;  // "///" or "/**"
        }
        var commentOffset = start - lookback,
            c;
        do {
            if (--commentOffset < 0 ||
                    (c = source.charAt(commentOffset)) === "\n") {
                commentLineEmpty = true;
                break;
            }
        } while (c === " " || c === "\t");
        var lines = source
            .substring(start, end)
            .split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
            lines[i] = lines[i]
                .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "")
                .trim();
        commentText = lines
            .join("\n")
            .trim();
    }

    function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);

        // see if remaining line matches comment pattern
        var lineText = source.substring(startOffset, endOffset);
        // look for 1 or 2 slashes since startOffset would already point past
        // the first slash that started the comment.
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
    }

    function findEndOfLine(cursor) {
        // find end of cursor's line
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
            endOffset++;
        }
        return endOffset;
    }

    /**
     * Obtains the next token.
     * @returns {string|null} Next token or `null` on eof
     * @inner
     */
    function next() {
        if (stack.length > 0)
            return stack.shift();
        if (stringDelim)
            return readString();
        var repeat,
            prev,
            curr,
            start,
            isDoc,
            isLeadingComment = offset === 0;
        do {
            if (offset === length)
                return null;
            repeat = false;
            while (whitespaceRe.test(curr = charAt(offset))) {
                if (curr === "\n") {
                    isLeadingComment = true;
                    ++line;
                }
                if (++offset === length)
                    return null;
            }

            if (charAt(offset) === "/") {
                if (++offset === length) {
                    throw illegal("comment");
                }
                if (charAt(offset) === "/") { // Line
                    if (!alternateCommentMode) {
                        // check for triple-slash comment
                        isDoc = charAt(start = offset + 1) === "/";

                        while (charAt(++offset) !== "\n") {
                            if (offset === length) {
                                return null;
                            }
                        }
                        ++offset;
                        if (isDoc) {
                            setComment(start, offset - 1, isLeadingComment);
                        }
                        ++line;
                        repeat = true;
                    } else {
                        // check for double-slash comments, consolidating consecutive lines
                        start = offset;
                        isDoc = false;
                        if (isDoubleSlashCommentLine(offset)) {
                            isDoc = true;
                            do {
                                offset = findEndOfLine(offset);
                                if (offset === length) {
                                    break;
                                }
                                offset++;
                            } while (isDoubleSlashCommentLine(offset));
                        } else {
                            offset = Math.min(length, findEndOfLine(offset) + 1);
                        }
                        if (isDoc) {
                            setComment(start, offset, isLeadingComment);
                        }
                        line++;
                        repeat = true;
                    }
                } else if ((curr = charAt(offset)) === "*") { /* Block */
                    // check for /** (regular comment mode) or /* (alternate comment mode)
                    start = offset + 1;
                    isDoc = alternateCommentMode || charAt(start) === "*";
                    do {
                        if (curr === "\n") {
                            ++line;
                        }
                        if (++offset === length) {
                            throw illegal("comment");
                        }
                        prev = curr;
                        curr = charAt(offset);
                    } while (prev !== "*" || curr !== "/");
                    ++offset;
                    if (isDoc) {
                        setComment(start, offset - 2, isLeadingComment);
                    }
                    repeat = true;
                } else {
                    return "/";
                }
            }
        } while (repeat);

        // offset !== length if we got here

        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
            while (end < length && !delimRe.test(charAt(end)))
                ++end;
        var token = source.substring(offset, offset = end);
        if (token === "\"" || token === "'")
            stringDelim = token;
        return token;
    }

    /**
     * Pushes a token back to the stack.
     * @param {string} token Token
     * @returns {undefined}
     * @inner
     */
    function push(token) {
        stack.push(token);
    }

    /**
     * Peeks for the next token.
     * @returns {string|null} Token or `null` on eof
     * @inner
     */
    function peek() {
        if (!stack.length) {
            var token = next();
            if (token === null)
                return null;
            push(token);
        }
        return stack[0];
    }

    /**
     * Skips a token.
     * @param {string} expected Expected token
     * @param {boolean} [optional=false] Whether the token is optional
     * @returns {boolean} `true` when skipped, `false` if not
     * @throws {Error} When a required token is not present
     * @inner
     */
    function skip(expected, optional) {
        var actual = peek(),
            equals = actual === expected;
        if (equals) {
            next();
            return true;
        }
        if (!optional)
            throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
    }

    /**
     * Gets a comment.
     * @param {number} [trailingLine] Line number if looking for a trailing comment
     * @returns {string|null} Comment text
     * @inner
     */
    function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === undefined) {
            if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
                ret = commentIsLeading ? commentText : null;
            }
        } else {
            /* istanbul ignore else */
            if (commentLine < trailingLine) {
                peek();
            }
            if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
                ret = commentIsLeading ? null : commentText;
            }
        }
        return ret;
    }

    return Object.defineProperty({
        next: next,
        peek: peek,
        push: push,
        skip: skip,
        cmnt: cmnt
    }, "line", {
        get: function() { return line; }
    });
    /* eslint-enable callback-return */
}

},{}],71:[function(require,module,exports){
"use strict";
module.exports = Type;

// extends Namespace
var Namespace = require("./namespace");
((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";

var Enum      = require("./enum"),
    OneOf     = require("./oneof"),
    Field     = require("./field"),
    MapField  = require("./mapfield"),
    Service   = require("./service"),
    Message   = require("./message"),
    Reader    = require("./reader"),
    Writer    = require("./writer"),
    util      = require("./util"),
    encoder   = require("./encoder"),
    decoder   = require("./decoder"),
    verifier  = require("./verifier"),
    converter = require("./converter"),
    wrappers  = require("./wrappers");

/**
 * Constructs a new reflected message type instance.
 * @classdesc Reflected message type.
 * @extends NamespaceBase
 * @constructor
 * @param {string} name Message name
 * @param {Object.<string,*>} [options] Declared options
 */
function Type(name, options) {
    Namespace.call(this, name, options);

    /**
     * Message fields.
     * @type {Object.<string,Field>}
     */
    this.fields = {};  // toJSON, marker

    /**
     * Oneofs declared within this namespace, if any.
     * @type {Object.<string,OneOf>}
     */
    this.oneofs = undefined; // toJSON

    /**
     * Extension ranges, if any.
     * @type {number[][]}
     */
    this.extensions = undefined; // toJSON

    /**
     * Reserved ranges, if any.
     * @type {Array.<number[]|string>}
     */
    this.reserved = undefined; // toJSON

    /*?
     * Whether this type is a legacy group.
     * @type {boolean|undefined}
     */
    this.group = undefined; // toJSON

    /**
     * Cached fields by id.
     * @type {Object.<number,Field>|null}
     * @private
     */
    this._fieldsById = null;

    /**
     * Cached fields as an array.
     * @type {Field[]|null}
     * @private
     */
    this._fieldsArray = null;

    /**
     * Cached oneofs as an array.
     * @type {OneOf[]|null}
     * @private
     */
    this._oneofsArray = null;

    /**
     * Cached constructor.
     * @type {Constructor<{}>}
     * @private
     */
    this._ctor = null;
}

Object.defineProperties(Type.prototype, {

    /**
     * Message fields by id.
     * @name Type#fieldsById
     * @type {Object.<number,Field>}
     * @readonly
     */
    fieldsById: {
        get: function() {

            /* istanbul ignore if */
            if (this._fieldsById)
                return this._fieldsById;

            this._fieldsById = {};
            for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
                var field = this.fields[names[i]],
                    id = field.id;

                /* istanbul ignore if */
                if (this._fieldsById[id])
                    throw Error("duplicate id " + id + " in " + this);

                this._fieldsById[id] = field;
            }
            return this._fieldsById;
        }
    },

    /**
     * Fields of this message as an array for iteration.
     * @name Type#fieldsArray
     * @type {Field[]}
     * @readonly
     */
    fieldsArray: {
        get: function() {
            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
    },

    /**
     * Oneofs of this message as an array for iteration.
     * @name Type#oneofsArray
     * @type {OneOf[]}
     * @readonly
     */
    oneofsArray: {
        get: function() {
            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
    },

    /**
     * The registered constructor, if any registered, otherwise a generic constructor.
     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
     * @name Type#ctor
     * @type {Constructor<{}>}
     */
    ctor: {
        get: function() {
            return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {

            // Ensure proper prototype
            var prototype = ctor.prototype;
            if (!(prototype instanceof Message)) {
                (ctor.prototype = new Message()).constructor = ctor;
                util.merge(ctor.prototype, prototype);
            }

            // Classes and messages reference their reflected type
            ctor.$type = ctor.prototype.$type = this;

            // Mix in static methods
            util.merge(ctor, Message, true);

            this._ctor = ctor;

            // Messages have non-enumerable default values on their prototype
            var i = 0;
            for (; i < /* initializes */ this.fieldsArray.length; ++i)
                this._fieldsArray[i].resolve(); // ensures a proper value

            // Messages have non-enumerable getters and setters for each virtual oneof field
            var ctorProperties = {};
            for (i = 0; i < /* initializes */ this.oneofsArray.length; ++i)
                ctorProperties[this._oneofsArray[i].resolve().name] = {
                    get: util.oneOfGetter(this._oneofsArray[i].oneof),
                    set: util.oneOfSetter(this._oneofsArray[i].oneof)
                };
            if (i)
                Object.defineProperties(ctor.prototype, ctorProperties);
        }
    }
});

/**
 * Generates a constructor function for the specified type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
Type.generateConstructor = function generateConstructor(mtype) {
    /* eslint-disable no-unexpected-multiline */
    var gen = util.codegen(["p"], mtype.name);
    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype
    for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen
            ("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen
            ("this%s=[]", util.safeProp(field.name));
    return gen
    ("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)") // omit undefined or null
        ("this[ks[i]]=p[ks[i]]");
    /* eslint-enable no-unexpected-multiline */
};

function clearCache(type) {
    type._fieldsById = type._fieldsArray = type._oneofsArray = null;
    delete type.encode;
    delete type.decode;
    delete type.verify;
    return type;
}

/**
 * Message type descriptor.
 * @interface IType
 * @extends INamespace
 * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors
 * @property {Object.<string,IField>} fields Field descriptors
 * @property {number[][]} [extensions] Extension ranges
 * @property {number[][]} [reserved] Reserved ranges
 * @property {boolean} [group=false] Whether a legacy group or not
 */

/**
 * Creates a message type from a message type descriptor.
 * @param {string} name Message name
 * @param {IType} json Message type descriptor
 * @returns {Type} Created message type
 */
Type.fromJSON = function fromJSON(name, json) {
    var type = new Type(name, json.options);
    type.extensions = json.extensions;
    type.reserved = json.reserved;
    var names = Object.keys(json.fields),
        i = 0;
    for (; i < names.length; ++i)
        type.add(
            ( typeof json.fields[names[i]].keyType !== "undefined"
            ? MapField.fromJSON
            : Field.fromJSON )(names[i], json.fields[names[i]])
        );
    if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
            type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
    if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
            var nested = json.nested[names[i]];
            type.add( // most to least likely
                ( nested.id !== undefined
                ? Field.fromJSON
                : nested.fields !== undefined
                ? Type.fromJSON
                : nested.values !== undefined
                ? Enum.fromJSON
                : nested.methods !== undefined
                ? Service.fromJSON
                : Namespace.fromJSON )(names[i], nested)
            );
        }
    if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
    if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
    if (json.group)
        type.group = true;
    if (json.comment)
        type.comment = json.comment;
    return type;
};

/**
 * Converts this message type to a message type descriptor.
 * @param {IToJSONOptions} [toJSONOptions] JSON conversion options
 * @returns {IType} Message type descriptor
 */
Type.prototype.toJSON = function toJSON(toJSONOptions) {
    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
    return util.toObject([
        "options"    , inherited && inherited.options || undefined,
        "oneofs"     , Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields"     , Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) { return !obj.declaringField; }), toJSONOptions) || {},
        "extensions" , this.extensions && this.extensions.length ? this.extensions : undefined,
        "reserved"   , this.reserved && this.reserved.length ? this.reserved : undefined,
        "group"      , this.group || undefined,
        "nested"     , inherited && inherited.nested || undefined,
        "comment"    , keepComments ? this.comment : undefined
    ]);
};

/**
 * @override
 */
Type.prototype.resolveAll = function resolveAll() {
    var fields = this.fieldsArray, i = 0;
    while (i < fields.length)
        fields[i++].resolve();
    var oneofs = this.oneofsArray; i = 0;
    while (i < oneofs.length)
        oneofs[i++].resolve();
    return Namespace.prototype.resolveAll.call(this);
};

/**
 * @override
 */
Type.prototype.get = function get(name) {
    return this.fields[name]
        || this.oneofs && this.oneofs[name]
        || this.nested && this.nested[name]
        || null;
};

/**
 * Adds a nested object to this type.
 * @param {ReflectionObject} object Nested object to add
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id
 */
Type.prototype.add = function add(object) {

    if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);

    if (object instanceof Field && object.extend === undefined) {
        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.
        // The root object takes care of adding distinct sister-fields to the respective extended
        // type instead.

        // avoids calling the getter if not absolutely necessary because it's called quite frequently
        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id])
            throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
            throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
            throw Error("name '" + object.name + "' is reserved in " + this);

        if (object.parent)
            object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {
        if (!this.oneofs)
            this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
    }
    return Namespace.prototype.add.call(this, object);
};

/**
 * Removes a nested object from this type.
 * @param {ReflectionObject} object Nested object to remove
 * @returns {Type} `this`
 * @throws {TypeError} If arguments are invalid
 * @throws {Error} If `object` is not a member of this type
 */
Type.prototype.remove = function remove(object) {
    if (object instanceof Field && object.extend === undefined) {
        // See Type#add for the reason why extension fields are excluded here.

        /* istanbul ignore if */
        if (!this.fields || this.fields[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    if (object instanceof OneOf) {

        /* istanbul ignore if */
        if (!this.oneofs || this.oneofs[object.name] !== object)
            throw Error(object + " is not a member of " + this);

        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
    }
    return Namespace.prototype.remove.call(this, object);
};

/**
 * Tests if the specified id is reserved.
 * @param {number} id Id to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedId = function isReservedId(id) {
    return Namespace.isReservedId(this.reserved, id);
};

/**
 * Tests if the specified name is reserved.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
Type.prototype.isReservedName = function isReservedName(name) {
    return Namespace.isReservedName(this.reserved, name);
};

/**
 * Creates a new message of this type using the specified properties.
 * @param {Object.<string,*>} [properties] Properties to set
 * @returns {Message<{}>} Message instance
 */
Type.prototype.create = function create(properties) {
    return new this.ctor(properties);
};

/**
 * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.
 * @returns {Type} `this`
 */
Type.prototype.setup = function setup() {
    // Sets up everything at once so that the prototype chain does not have to be re-evaluated
    // multiple times (V8, soft-deopt prototype-check).

    var fullName = this.fullName,
        types    = [];
    for (var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);

    // Replace setup methods with type-specific generated functions
    this.encode = encoder(this)({
        Writer : Writer,
        types  : types,
        util   : util
    });
    this.decode = decoder(this)({
        Reader : Reader,
        types  : types,
        util   : util
    });
    this.verify = verifier(this)({
        types : types,
        util  : util
    });
    this.fromObject = converter.fromObject(this)({
        types : types,
        util  : util
    });
    this.toObject = converter.toObject(this)({
        types : types,
        util  : util
    });

    // Inject custom wrappers for common types
    var wrapper = wrappers[fullName];
    if (wrapper) {
        var originalThis = Object.create(this);
        // if (wrapper.fromObject) {
            originalThis.fromObject = this.fromObject;
            this.fromObject = wrapper.fromObject.bind(originalThis);
        // }
        // if (wrapper.toObject) {
            originalThis.toObject = this.toObject;
            this.toObject = wrapper.toObject.bind(originalThis);
        // }
    }

    return this;
};

/**
 * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encode = function encode_setup(message, writer) {
    return this.setup().encode(message, writer); // overrides this method
};

/**
 * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.
 * @param {Message<{}>|Object.<string,*>} message Message instance or plain object
 * @param {Writer} [writer] Writer to encode to
 * @returns {Writer} writer
 */
Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
};

/**
 * Decodes a message of this type.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @param {number} [length] Length of the message, if known beforehand
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError<{}>} If required fields are missing
 */
Type.prototype.decode = function decode_setup(reader, length) {
    return this.setup().decode(reader, length); // overrides this method
};

/**
 * Decodes a message of this type preceeded by its byte length as a varint.
 * @param {Reader|Uint8Array} reader Reader or buffer to decode from
 * @returns {Message<{}>} Decoded message
 * @throws {Error} If the payload is not a reader or valid buffer
 * @throws {util.ProtocolError} If required fields are missing
 */
Type.prototype.decodeDelimited = function decodeDelimited(reader) {
    if (!(reader instanceof Reader))
        reader = Reader.create(reader);
    return this.decode(reader, reader.uint32());
};

/**
 * Verifies that field values are valid and that required fields are present.
 * @param {Object.<string,*>} message Plain object to verify
 * @returns {null|string} `null` if valid, otherwise the reason why it is not
 */
Type.prototype.verify = function verify_setup(message) {
    return this.setup().verify(message); // overrides this method
};

/**
 * Creates a new message of this type from a plain object. Also converts values to their respective internal types.
 * @param {Object.<string,*>} object Plain object to convert
 * @returns {Message<{}>} Message instance
 */
Type.prototype.fromObject = function fromObject(object) {
    return this.setup().fromObject(object);
};

/**
 * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.
 * @interface IConversionOptions
 * @property {Function} [longs] Long conversion type.
 * Valid values are `String` and `Number` (the global types).
 * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.
 * @property {Function} [enums] Enum value conversion type.
 * Only valid value is `String` (the global type).
 * Defaults to copy the present value, which is the numeric id.
 * @property {Function} [bytes] Bytes value conversion type.
 * Valid values are `Array` and (a base64 encoded) `String` (the global types).
 * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.
 * @property {boolean} [defaults=false] Also sets default values on the resulting object
 * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`
 * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`
 * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any
 * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings
 */

/**
 * Creates a plain object from a message of this type. Also converts values to other types if specified.
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 */
Type.prototype.toObject = function toObject(message, options) {
    return this.setup().toObject(message, options);
};

/**
 * Decorator function as returned by {@link Type.d} (TypeScript).
 * @typedef TypeDecorator
 * @type {function}
 * @param {Constructor<T>} target Target constructor
 * @returns {undefined}
 * @template T extends Message<T>
 */

/**
 * Type decorator (TypeScript).
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {TypeDecorator<T>} Decorator function
 * @template T extends Message<T>
 */
Type.d = function decorateType(typeName) {
    return function typeDecorator(target) {
        util.decorateType(target, typeName);
    };
};

},{"./converter":48,"./decoder":49,"./encoder":50,"./enum":51,"./field":52,"./mapfield":56,"./message":57,"./namespace":59,"./oneof":61,"./reader":63,"./service":69,"./util":73,"./verifier":76,"./wrappers":77,"./writer":78}],72:[function(require,module,exports){
"use strict";

/**
 * Common type constants.
 * @namespace
 */
var types = exports;

var util = require("./util");

var s = [
    "double",   // 0
    "float",    // 1
    "int32",    // 2
    "uint32",   // 3
    "sint32",   // 4
    "fixed32",  // 5
    "sfixed32", // 6
    "int64",    // 7
    "uint64",   // 8
    "sint64",   // 9
    "fixed64",  // 10
    "sfixed64", // 11
    "bool",     // 12
    "string",   // 13
    "bytes"     // 14
];

function bake(values, offset) {
    var i = 0, o = {};
    offset |= 0;
    while (i < values.length) o[s[i + offset]] = values[i++];
    return o;
}

/**
 * Basic type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 * @property {number} bytes=2 Ldelim wire type
 */
types.basic = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2,
    /* bytes    */ 2
]);

/**
 * Basic type defaults.
 * @type {Object.<string,*>}
 * @const
 * @property {number} double=0 Double default
 * @property {number} float=0 Float default
 * @property {number} int32=0 Int32 default
 * @property {number} uint32=0 Uint32 default
 * @property {number} sint32=0 Sint32 default
 * @property {number} fixed32=0 Fixed32 default
 * @property {number} sfixed32=0 Sfixed32 default
 * @property {number} int64=0 Int64 default
 * @property {number} uint64=0 Uint64 default
 * @property {number} sint64=0 Sint32 default
 * @property {number} fixed64=0 Fixed64 default
 * @property {number} sfixed64=0 Sfixed64 default
 * @property {boolean} bool=false Bool default
 * @property {string} string="" String default
 * @property {Array.<number>} bytes=Array(0) Bytes default
 * @property {null} message=null Message default
 */
types.defaults = bake([
    /* double   */ 0,
    /* float    */ 0,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 0,
    /* sfixed32 */ 0,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 0,
    /* sfixed64 */ 0,
    /* bool     */ false,
    /* string   */ "",
    /* bytes    */ util.emptyArray,
    /* message  */ null
]);

/**
 * Basic long type wire types.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 */
types.long = bake([
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1
], 7);

/**
 * Allowed types for map keys with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 * @property {number} string=2 Ldelim wire type
 */
types.mapKey = bake([
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0,
    /* string   */ 2
], 2);

/**
 * Allowed types for packed repeated fields with their associated wire type.
 * @type {Object.<string,number>}
 * @const
 * @property {number} double=1 Fixed64 wire type
 * @property {number} float=5 Fixed32 wire type
 * @property {number} int32=0 Varint wire type
 * @property {number} uint32=0 Varint wire type
 * @property {number} sint32=0 Varint wire type
 * @property {number} fixed32=5 Fixed32 wire type
 * @property {number} sfixed32=5 Fixed32 wire type
 * @property {number} int64=0 Varint wire type
 * @property {number} uint64=0 Varint wire type
 * @property {number} sint64=0 Varint wire type
 * @property {number} fixed64=1 Fixed64 wire type
 * @property {number} sfixed64=1 Fixed64 wire type
 * @property {number} bool=0 Varint wire type
 */
types.packed = bake([
    /* double   */ 1,
    /* float    */ 5,
    /* int32    */ 0,
    /* uint32   */ 0,
    /* sint32   */ 0,
    /* fixed32  */ 5,
    /* sfixed32 */ 5,
    /* int64    */ 0,
    /* uint64   */ 0,
    /* sint64   */ 0,
    /* fixed64  */ 1,
    /* sfixed64 */ 1,
    /* bool     */ 0
]);

},{"./util":73}],73:[function(require,module,exports){
"use strict";

/**
 * Various utility functions.
 * @namespace
 */
var util = module.exports = require("./util/minimal");

var roots = require("./roots");

var Type, // cyclic
    Enum;

util.codegen = require("@protobufjs/codegen");
util.fetch   = require("@protobufjs/fetch");
util.path    = require("@protobufjs/path");

/**
 * Node's fs module if available.
 * @type {Object.<string,*>}
 */
util.fs = util.inquire("fs");

/**
 * Converts an object's values to an array.
 * @param {Object.<string,*>} object Object to convert
 * @returns {Array.<*>} Converted array
 */
util.toArray = function toArray(object) {
    if (object) {
        var keys  = Object.keys(object),
            array = new Array(keys.length),
            index = 0;
        while (index < keys.length)
            array[index] = object[keys[index++]];
        return array;
    }
    return [];
};

/**
 * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.
 * @param {Array.<*>} array Array to convert
 * @returns {Object.<string,*>} Converted object
 */
util.toObject = function toObject(array) {
    var object = {},
        index  = 0;
    while (index < array.length) {
        var key = array[index++],
            val = array[index++];
        if (val !== undefined)
            object[key] = val;
    }
    return object;
};

var safePropBackslashRe = /\\/g,
    safePropQuoteRe     = /"/g;

/**
 * Tests whether the specified name is a reserved word in JS.
 * @param {string} name Name to test
 * @returns {boolean} `true` if reserved, otherwise `false`
 */
util.isReserved = function isReserved(name) {
    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
};

/**
 * Returns a safe property accessor for the specified property name.
 * @param {string} prop Property name
 * @returns {string} Safe accessor
 */
util.safeProp = function safeProp(prop) {
    if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return "[\"" + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, "\\\"") + "\"]";
    return "." + prop;
};

/**
 * Converts the first character of a string to upper case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.ucFirst = function ucFirst(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
};

var camelCaseRe = /_([a-z])/g;

/**
 * Converts a string to camel case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.camelCase = function camelCase(str) {
    return str.substring(0, 1)
         + str.substring(1)
               .replace(camelCaseRe, function($0, $1) { return $1.toUpperCase(); });
};

/**
 * Compares reflected fields by id.
 * @param {Field} a First field
 * @param {Field} b Second field
 * @returns {number} Comparison value
 */
util.compareFieldsById = function compareFieldsById(a, b) {
    return a.id - b.id;
};

/**
 * Decorator helper for types (TypeScript).
 * @param {Constructor<T>} ctor Constructor function
 * @param {string} [typeName] Type name, defaults to the constructor's name
 * @returns {Type} Reflected type
 * @template T extends Message<T>
 * @property {Root} root Decorators root
 */
util.decorateType = function decorateType(ctor, typeName) {

    /* istanbul ignore if */
    if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
            util.decorateRoot.remove(ctor.$type);
            ctor.$type.name = typeName;
            util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
    }

    /* istanbul ignore next */
    if (!Type)
        Type = require("./type");

    var type = new Type(typeName || ctor.name);
    util.decorateRoot.add(type);
    type.ctor = ctor; // sets up .encode, .decode etc.
    Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
    Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
    return type;
};

var decorateEnumIndex = 0;

/**
 * Decorator helper for enums (TypeScript).
 * @param {Object} object Enum object
 * @returns {Enum} Reflected enum
 */
util.decorateEnum = function decorateEnum(object) {

    /* istanbul ignore if */
    if (object.$type)
        return object.$type;

    /* istanbul ignore next */
    if (!Enum)
        Enum = require("./enum");

    var enm = new Enum("Enum" + decorateEnumIndex++, object);
    util.decorateRoot.add(enm);
    Object.defineProperty(object, "$type", { value: enm, enumerable: false });
    return enm;
};


/**
 * Sets the value of a property by property path. If a value already exists, it is turned to an array
 * @param {Object.<string,*>} dst Destination object
 * @param {string} path dot '.' delimited path of the property to set
 * @param {Object} value the value to set
 * @returns {Object.<string,*>} Destination object
 */
util.setProperty = function setProperty(dst, path, value) {
    function setProp(dst, path, value) {
        var part = path.shift();
        if (path.length > 0) {
            dst[part] = setProp(dst[part] || {}, path, value);
        } else {
            var prevValue = dst[part];
            if (prevValue)
                value = [].concat(prevValue).concat(value);
            dst[part] = value;
        }
        return dst;
    }

    if (typeof dst !== "object")
        throw TypeError("dst must be an object");
    if (!path)
        throw TypeError("path must be specified");

    path = path.split(".");
    return setProp(dst, path, value);
};

/**
 * Decorator root (TypeScript).
 * @name util.decorateRoot
 * @type {Root}
 * @readonly
 */
Object.defineProperty(util, "decorateRoot", {
    get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require("./root"))());
    }
});

},{"./enum":51,"./root":65,"./roots":66,"./type":71,"./util/minimal":75,"@protobufjs/codegen":3,"@protobufjs/fetch":5,"@protobufjs/path":8}],74:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":75}],75:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./longbits":74,"@protobufjs/aspromise":1,"@protobufjs/base64":2,"@protobufjs/eventemitter":4,"@protobufjs/float":6,"@protobufjs/inquire":7,"@protobufjs/pool":9,"@protobufjs/utf8":10}],76:[function(require,module,exports){
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
},{"./enum":51,"./util":73}],77:[function(require,module,exports){
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.substr(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

},{"./message":57}],78:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"./util/minimal":75}],79:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"./util/minimal":75,"./writer":78}],80:[function(require,module,exports){
const quickSelect = require('./src/quickSelect')

module.exports = quickSelect

},{"./src/quickSelect":81}],81:[function(require,module,exports){
const randIntBetween = (min, max) => Math.floor(Math.random() * max) + min

const defaultAccessor = element => element

const checkArguments = (array, k, accessor) => {
  if (!Array.isArray(array)) throw new Error('The first argument should be a javascript array!')
  if (typeof k !== 'number') throw new Error('The second argument should be a javascript number!')
  if (typeof accessor !== 'function') throw new Error('The third argument should be a javascript function!')
  if (array.length < k) {
    throw new Error('K should not be greater than array length!')
  }
}

/**
 * Quickselect
 * https://en.wikipedia.org/wiki/Quickselect
 * @param {Array} array - Data
 * @param {Number} k - Position of smallest element (starts from 0)
 * @param {Function} accessor - Function which return value for processing (optional)
 */
const quickSelect = (array, k, accessor = defaultAccessor) => {
  checkArguments(array, k, accessor)
  if (array.length === 1 && k === 0) return array[0]

  while (true) {
    const pivot = accessor(array[randIntBetween(0, array.length - 1)])
    const lows = []
    const highs = []
    const pivots = []
    for (let i = 0; i < array.length; i += 1) {
      if (accessor(array[i]) < pivot) lows.push(array[i])
      if (accessor(array[i]) > pivot) highs.push(array[i])
      if (accessor(array[i]) === pivot) pivots.push(array[i])
    }

    /* eslint-disable no-param-reassign */
    if (k < lows.length) {
      array = lows
    } else if (k < lows.length + pivots.length) {
      return pivots[0]
    } else {
      array = highs
      k = k - lows.length - pivots.length
    }
    /* eslint-enable no-param-reassign */
  }
}

module.exports = quickSelect

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./Components/BaseWidget");
const Toolbar_1 = require("./Components/Toolbar");
const Plot2dPathsWidget_1 = require("./Components/Plot2dPathsWidget");
const MetricDistributionWidget_1 = require("./Components/MetricDistributionWidget");
const ImageSelectionWidget_1 = require("./Components/ImageSelectionWidget");
const LayoutFramework_1 = require("./LayoutFramework");
const types_1 = require("./types");
const DataEvents_1 = require("./DataModel/DataEvents");
const DetailedDistributionWidget_1 = require("./Components/DetailedDistributionWidget");
const DevlibTSUtil_1 = require("./devlib/DevlibTSUtil");
const idb_1 = require("idb");
class App {
    constructor(container, fromCsvObject, derivedTrackDataFunctions, derivedPointDataFunctions) {
        this._container = container;
        this._componentList = [];
        this._layoutFramework = new LayoutFramework_1.LayoutFramework(container);
        this._dataFromCSVObject = fromCsvObject;
        this._trackDerivationFunctions = derivedTrackDataFunctions;
        this._pointDerivationFunctions = derivedPointDataFunctions;
        document.addEventListener(DataEvents_1.DataEvents.brushChange, (e) => { this.onBrushChange(); });
        document.addEventListener(DataEvents_1.DataEvents.selectionToFilter, (e) => { this.onSelectionToFilter(); });
        document.addEventListener(DataEvents_1.DataEvents.applyNewFilter, (e) => { this.onApplyNewFilter(); });
    }
    get data() {
        return this._data;
    }
    get filteredData() {
        return this._filteredData;
    }
    get container() {
        return this._container;
    }
    get componentList() {
        return this._componentList;
    }
    get layoutFramework() {
        return this._layoutFramework;
    }
    get componentContainers() {
        return this._componentContainers;
    }
    get dataFromCSVObject() {
        return this._dataFromCSVObject;
    }
    get trackDerivationFunctions() {
        return this._trackDerivationFunctions;
    }
    get pointDerivationFunctions() {
        return this._pointDerivationFunctions;
    }
    get dataStore() {
        return this._dataStore;
    }
    async InitDataStore() {
        const dataStore = await idb_1.openDB('loon-db', undefined, {
            upgrade(db, _oldVersion, _newVersion, _transaction) {
                if (!db.objectStoreNames.contains('tracks')) {
                    db.createObjectStore('tracks');
                }
                if (!db.objectStoreNames.contains('images')) {
                    db.createObjectStore('images');
                }
            }
        });
        this._dataStore = dataStore;
    }
    InitializeLayout(frame) {
        // console.log(frame);
        this._componentContainers = this.layoutFramework.InitializeLayout(frame);
        DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
        for (let [container, componentInfo] of this.componentContainers) {
            this.InitializeComponent(componentInfo, container);
        }
    }
    InitializeComponent(compontentInfo, container) {
        let newComponent;
        let componentType;
        let initArgs = null;
        if (typeof (compontentInfo) === "string") {
            componentType = compontentInfo;
        }
        else {
            componentType = compontentInfo.type;
            initArgs = compontentInfo.initArgs;
        }
        switch (componentType) {
            case types_1.ComponentType.Plot2dPathsWidget:
                let squareAspectRatio = true;
                if (typeof (initArgs.squareAspectRatio) !== 'undefined') {
                    squareAspectRatio = initArgs.squareAspectRatio;
                }
                const defaultOption = 0;
                newComponent = new Plot2dPathsWidget_1.Plot2dPathsWidget(container, initArgs.quickPickOptions, defaultOption, squareAspectRatio);
                break;
            case types_1.ComponentType.MetricDistributionWidget:
                newComponent = new MetricDistributionWidget_1.MetricDistributionWidget(container, initArgs.metricDistributionCollectionLevel);
                break;
            case types_1.ComponentType.ImageSelectionWidget:
                newComponent = new ImageSelectionWidget_1.ImageSelectionWidget(container, initArgs.samplingStrat);
                break;
            case types_1.ComponentType.DetailedDistribution:
                newComponent = new DetailedDistributionWidget_1.DetailedDistributionWidget(container, initArgs.metricDistributionCollectionLevel, initArgs.attributeKey);
                break;
            case types_1.ComponentType.Toolbar:
                newComponent = new Toolbar_1.Toolbar(container);
                break;
            default:
                console.error(`Cannot Initialize Component of type: ${componentType}`);
                break;
        }
        this.componentList.push(newComponent);
    }
    LoadDataset(datasetId) {
        this.fetchJson(`${datasetId}.json`);
    }
    async fetchJson(filename) {
        await d3.json("../../../data/" + filename).then(async (data) => {
            if (this.dataStore) {
                let store = this.dataStore.transaction('tracks', 'readonly').objectStore('tracks');
                let storedAllData = await store.get(data.googleDriveId);
                if (storedAllData) {
                    this.initData(storedAllData, data);
                    return;
                }
            }
            this.fetchCsv(`${data.googleDriveId}/massOverTime.csv`, data, data.googleDriveId);
        });
    }
    async fetchCsv(filename, dataSpec, key) {
        await d3.csv("../../../data/" + filename).then(async (data) => {
            if (this.dataStore) {
                await this.dataStore.put('tracks', data, key);
            }
            this.initData(data, dataSpec);
        });
    }
    initData(data, dataSpec) {
        let allData = this.dataFromCSVObject(data, this.trackDerivationFunctions, this.pointDerivationFunctions, dataSpec);
        allData.ApplyDefaultFilters();
        allData.ApplyNewFilter();
        let filteredData = allData.CreateFilteredCurveList();
        // remove inBrush attributes set on tracks based on conditions filters
        // this is needed to get the appropriate filtered data in the condition
        // curve matrix widget.
        allData.OnBrushChange();
        this.SetData(filteredData, allData);
    }
    SetData(filteredData, allData) {
        console.log("App.SetData: ");
        console.log(allData);
        this._filteredData = filteredData;
        this._data = allData;
        for (let component of this.componentList) {
            if (component instanceof BaseWidget_1.BaseWidget) {
                component.SetData(filteredData, allData);
            }
        }
    }
    OnWindowResize() {
        for (let component of this.componentList) {
            component.Resize();
        }
    }
    onBrushChange() {
        this.filteredData.OnBrushChange();
        for (let component of this.componentList) {
            if (component instanceof BaseWidget_1.BaseWidget) {
                component.OnBrushChange();
            }
        }
    }
    onSelectionToFilter() {
        this.data.ConsumeFilters(this.filteredData);
        let filteredData = this.filteredData.CreateFilteredCurveList();
        this.SetData(filteredData, this.data);
    }
    onApplyNewFilter() {
        this.data.ApplyNewFilter();
        let filteredData = this.data.CreateFilteredCurveList();
        // remove inBrush attributes set on tracks based on conditions filters
        // this is needed to get the appropriate filtered data in the condition
        // curve matrix widget.
        this.data.OnBrushChange();
        this.SetData(filteredData, this.data);
    }
}
exports.App = App;

},{"./Components/BaseWidget":84,"./Components/DetailedDistributionWidget":85,"./Components/ImageSelectionWidget":88,"./Components/MetricDistributionWidget":91,"./Components/Plot2dPathsWidget":93,"./Components/Toolbar":96,"./DataModel/DataEvents":104,"./LayoutFramework":113,"./devlib/DevlibTSUtil":116,"./types":118,"d3":42,"idb":43}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class BaseComponent {
    constructor(container, ...props) {
        this._container = container;
        this._componentIndex = BaseComponent._componentCount;
        BaseComponent._componentCount++;
        this.initProps(props);
        this.setWidthHeight();
        this.init();
    }
    get container() {
        return this._container;
    }
    get width() {
        return this._width;
    }
    get height() {
        return this._height;
    }
    get ComponentId() {
        return this.constructor.name + "_" + this._componentIndex;
    }
    initProps(props) {
    }
    init() {
        let notImplementDiv = document.createElement("div");
        notImplementDiv.textContent = `Class ${this.constructor.name} has not implement 'init' function`;
        notImplementDiv.classList.add("notImplementedWarning");
        this.container.innerHTML = null;
        this.container.appendChild(notImplementDiv);
    }
    Resize() {
        this.setWidthHeight();
        this.OnResize();
    }
    setWidthHeight() {
        this._width = this.container.clientWidth;
        this._height = this.container.clientHeight;
    }
    OnResize() {
        this.container.innerHTML = null;
        let notImplementDiv = document.createElement("div");
        notImplementDiv.textContent = `Resized to: (${this.width}, ${this.height})
override ${this.constructor.name}.OnResizeDraw() to ensure content is resized correctly`;
        notImplementDiv.classList.add("notImplementedWarning");
        this.container.appendChild(notImplementDiv);
    }
}
exports.BaseComponent = BaseComponent;
BaseComponent._componentCount = 0;

},{}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseComponent_1 = require("./BaseComponent");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const GroupByWidget_1 = require("./GroupByWidget");
class BaseWidget extends BaseComponent_1.BaseComponent {
    constructor(container, canFacet = false, ...props) {
        super(container, ...props);
        this._canFacet = canFacet;
        if (canFacet) {
            this.addFacetButton();
        }
        this.initButtonListContainer();
        this._dataSuperset = null;
        document.addEventListener('groupByChanged', (e) => {
            if (this.showingFacetPopup) {
                this.drawFacetedData(e.detail.flatFacetList);
            }
        });
        this._showingFacetPopup = false;
    }
    get data() {
        return this._data;
    }
    get dataSuperset() {
        return this._dataSuperset;
    }
    get fullData() {
        if (this._dataSuperset) {
            return this.dataSuperset;
        }
        return this.data;
    }
    get margin() {
        return this._margin;
    }
    get vizWidth() {
        return this._vizWidth;
    }
    get vizHeight() {
        return this._vizHeight;
    }
    get canFacet() {
        return this._canFacet;
    }
    set canFacet(v) {
        if (!v) {
            this.removeFacetButton();
        }
        this._canFacet = v;
    }
    get showingFacetPopup() {
        return this._showingFacetPopup;
    }
    get buttonList() {
        if (!this._buttonList) {
            this._buttonList = [];
        }
        return this._buttonList;
    }
    get buttonListContainer() {
        return this._buttonListContainer;
    }
    get facetButton() {
        return this._facetButton;
    }
    get largePopupOuter() {
        if (this._largePopupOuter) {
            return this._largePopupOuter;
        }
        let largePopupOuter = document.getElementById('largePopupContainerOuter');
        if (largePopupOuter) {
            this._largePopupOuter = largePopupOuter;
            return this._largePopupOuter;
        }
        this.initLargePopup();
        return this._largePopupOuter;
    }
    get largePopup() {
        if (this._largePopup) {
            return this._largePopup;
        }
        let largePopup = document.getElementById('largePopupContainer');
        if (largePopup) {
            this._largePopup = largePopup;
            return this._largePopup;
        }
        this.initLargePopup();
        return this._largePopup;
    }
    get largePopupContent() {
        return this._largePopupContent;
    }
    initProps(props) {
        this.setMargin();
    }
    setMargin() {
        this._margin = {
            top: 20,
            right: 20,
            bottom: 20,
            left: 20
        };
    }
    SetData(data, dataSuperset) {
        this._data = data;
        if (dataSuperset) {
            this._dataSuperset = dataSuperset;
        }
        let facetOptions = data.GetFacetOptions();
        if (facetOptions.length === 0) {
            this.canFacet = false;
        }
        this.OnDataChange();
    }
    OnBrushChange() {
        console.log('base: OnBrushChange');
    }
    setWidthHeight() {
        super.setWidthHeight();
        this._vizWidth = this.width - this.margin.left - this.margin.right;
        this._vizHeight = this.height - this.margin.top - this.margin.bottom;
    }
    initButtonListContainer() {
        this._buttonListContainer = document.createElement('div');
        this.buttonListContainer.classList.add('noDisp');
        let style = this.buttonListContainer.style;
        style.position = 'absolute';
        style.right = '0px';
        style.top = '0px';
        style.pointerEvents = 'none';
        style.display = 'flex';
        style.flexDirection = 'row-reverse';
        this.container.addEventListener('mouseenter', this.onMouseEnter());
        this.container.addEventListener('mouseleave', this.onMouseLeave());
        this.container.appendChild(this.buttonListContainer);
        for (let button of this.buttonList) {
            this.buttonListContainer.appendChild(button);
        }
    }
    addFacetButton() {
        this._facetButton = this.AddButton('layer-group', 'Facet chart by conditions', () => {
            this.drawFacetContent();
        });
    }
    AddButton(iconKey, tooltip, callback, title) {
        let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(iconKey, callback, title);
        button.title = tooltip;
        button.style.pointerEvents = 'all';
        this.buttonList.unshift(button);
        return button;
    }
    removeFacetButton() {
        if (this.facetButton) {
            this.buttonListContainer.removeChild(this.facetButton);
        }
    }
    onMouseEnter() {
        return () => DevlibTSUtil_1.DevlibTSUtil.show(this.buttonListContainer);
    }
    onMouseLeave() {
        return () => DevlibTSUtil_1.DevlibTSUtil.hide(this.buttonListContainer);
    }
    drawFacetContent() {
        this.largePopup.innerHTML = null;
        DevlibTSUtil_1.DevlibTSUtil.show(this.largePopupOuter);
        this._showingFacetPopup = true;
        const groupByWidget = new GroupByWidget_1.GroupByWidget(d3.select(this.largePopup));
        groupByWidget.updateGroupByOptions(this.data, true);
        let contentContainer = document.createElement('div');
        contentContainer.classList.add('largePopupContent');
        this.largePopup.appendChild(contentContainer);
        this._largePopupContent = contentContainer;
        this.drawFacetedData(groupByWidget.getFlatFacetList());
    }
    drawFacetedData(facetList) {
        const width = '500px';
        const height = '250px';
        this.drawFacetedDataDefault(facetList, width, height);
    }
    drawFacetedDataDefault(facetList, width, height) {
        if (this.largePopupContent) {
            this.largePopupContent.innerHTML = null;
        }
        for (let facet of facetList) {
            this.drawSingleFacetedData(facet.name.join(' '), facet.data, width, height);
        }
    }
    drawSingleFacetedData(title, data, width, height) {
        let outerContainer = document.createElement('div');
        outerContainer.classList.add('outerFacetContainer');
        outerContainer.style.width = width;
        outerContainer.style.height = height;
        // this.largePopupContent.appendChild(outerContainer);
        let titleContainer = document.createElement('div');
        titleContainer.classList.add('facetTitle');
        titleContainer.innerText = title;
        outerContainer.appendChild(titleContainer);
        let newContainer = document.createElement('div');
        newContainer.classList.add('facetContainer');
        outerContainer.appendChild(newContainer);
        this.largePopupContent.appendChild(outerContainer);
        this.initSubWidget(newContainer, title, data);
    }
    initSubWidget(newContainer, name, data) {
        let subWidget = this.Clone(newContainer);
        subWidget.canFacet = false;
        subWidget.SetData(data, this.data);
    }
    initLargePopup() {
        let largePopupOuter = document.createElement('div');
        largePopupOuter.id = "largePopupContainerOuter";
        largePopupOuter.classList.add('largePopupContainerOuter');
        largePopupOuter.addEventListener('click', () => {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.largePopupOuter);
            this._showingFacetPopup = false;
        });
        let largePopup = document.createElement('div');
        largePopup.id = 'largePopupContainer';
        largePopup.classList.add('largePopupContainer');
        largePopup.addEventListener('click', (ev) => {
            ev.stopPropagation();
        });
        this._largePopup = largePopup;
        largePopupOuter.appendChild(largePopup);
        DevlibTSUtil_1.DevlibTSUtil.hide(largePopupOuter);
        document.body.appendChild(largePopupOuter);
        this._largePopupOuter = largePopupOuter;
    }
}
exports.BaseWidget = BaseWidget;

},{"../devlib/DevlibTSUtil":116,"./BaseComponent":83,"./GroupByWidget":86,"d3":42}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const types_1 = require("../types");
class DetailedDistributionWidget extends BaseWidget_1.BaseWidget {
    constructor(container, metricDistributionCollectionLevel, attributeKey, isClone = false) {
        super(container, true);
        this._metricDistributionCollectionLevel = metricDistributionCollectionLevel;
        this._attributeKey = attributeKey;
        this.setLabel();
        this._isClone = isClone;
    }
    Clone(container) {
        let clone = new DetailedDistributionWidget(container, this.metricDistributionCollectionLevel, this.attributeKey, true);
        return clone;
    }
    get isClone() {
        return this._isClone;
    }
    get metricDistributionCollectionLevel() {
        return this._metricDistributionCollectionLevel;
    }
    get attributeKey() {
        return this._attributeKey;
    }
    get pointCollection() {
        return this._pointCollection;
    }
    get fullPointCollection() {
        return this._fullPointCollection;
    }
    get randomNoiseList() {
        return this._randomNoiseList;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleY() {
        return this._scaleY;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get canvasElement() {
        return this._canvasElement;
    }
    get totalBoxplotContainerSelectOutline() {
        return this._totalBoxplotContainerSelectOutline;
    }
    get totalBoxplotContainerSelect() {
        return this._totalBoxplotContainerSelect;
    }
    get filteredBoxplotContainerSelectOutline() {
        return this._filteredBoxplotContainerSelectOutline;
    }
    get filteredBoxplotContainerSelect() {
        return this._filteredBoxplotContainerSelect;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get boxplotStatsPopupSelect() {
        return this._boxplotStatsPopupSelect;
    }
    set boxplotStatsPopupSelect(v) {
        this._boxplotStatsPopupSelect = v;
    }
    get axisPadding() {
        return this._axisPadding;
    }
    get xAxisGroupSelect() {
        return this._xAxisGroupSelect;
    }
    get xLabelTextSelect() {
        return this._xLabelTextSelect;
    }
    get brush() {
        return this._brush;
    }
    get totalBoxplotStats() {
        return this._totalBoxplotStats;
    }
    get filteredBoxplotStats() {
        return this._filteredBoxplotStats;
    }
    get scatterplotPadding() {
        return this._scatterplotPadding;
    }
    get betweenBoxplotPadding() {
        return this._betweenBoxplotPadding;
    }
    setMargin() {
        this._margin = {
            top: 6,
            right: 8,
            bottom: 56,
            left: 8
        };
    }
    init() {
        this._scatterplotPadding = 8;
        const containerSelect = d3.select(this.container);
        this._canvasElement = containerSelect
            .append('xhtml:canvas')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight - 2 * this.scatterplotPadding)
            .attr('style', `position: absolute;
                transform: translate(${this.margin.left}px, ${this.margin.top + this.scatterplotPadding}px);`)
            .node();
        // I originally put the canvas inside the svg in a foreignObject. This didn't work because
        // of Chrome bug 148499
        // https://bugs.chromium.org/p/chromium/issues/detail?id=148499
        this._svgSelect = containerSelect.append("svg")
            .attr("width", this.width)
            .attr("height", this.height)
            .attr('style', 'z-index: 0;');
        this._boxplotStatsPopupSelect = containerSelect.append('div')
            .classed('boxplotStatsPopup', true);
        this.hideBoxplotStatsPopup();
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.scatterplotPadding})`);
        this._totalBoxplotContainerSelectOutline = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed('boxplot-container', true);
        this._totalBoxplotContainerSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed('boxplot-container', true);
        this._filteredBoxplotContainerSelectOutline = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed('boxplot-container', true);
        this._filteredBoxplotContainerSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed('boxplot-container', true);
        this._brushGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed("brushContainer", true);
        this._axisPadding = 4;
        this._xAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .classed("labelColor", true);
        this._betweenBoxplotPadding = 4;
    }
    setLabel() {
        this._xLabelTextSelect = this.svgSelect.append('text')
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .classed('noDisp', true)
            .text(this.attributeKey);
        this.positionLabels();
    }
    positionLabels() {
        let bufferForAxis = 32 + this.axisPadding;
        ;
        this.xLabelTextSelect
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`);
    }
    OnDataChange() {
        switch (this.metricDistributionCollectionLevel) {
            case types_1.MetricDistributionCollectionLevel.Point:
                this._pointCollection = this.data;
                this._fullPointCollection = this.fullData;
                break;
            case types_1.MetricDistributionCollectionLevel.Curve:
                this._pointCollection = this.data.curveCollection;
                this._fullPointCollection = this.fullData.curveCollection;
                break;
            default:
                throw new Error("DetailedDistribution needs a valid MetricDistributionCollectionLevel");
                this._pointCollection = null;
                this._fullPointCollection = null;
                break;
        }
        this._randomNoiseList = [];
        for (let i = 0; i < this.pointCollection.length; i++) {
            this.randomNoiseList.push(Math.random());
        }
        this.updateTotalBoxplotStats();
        this.updateScales();
        this.draw();
        this.showLabel();
    }
    updateTotalBoxplotStats() {
        let validNumbers = this.pointCollection.Array
            .map(d => d.get(this.attributeKey)) // get actual value
            .filter(d => !isNaN(d)) // filter out NaN values.
            .sort((a, b) => a - b); // d3.quantile requires it to be sorted. This could technically be done faster without sorting.
        this._totalBoxplotStats = DetailedDistributionWidget.calculateBoxplotStats(validNumbers);
    }
    updateFilteredBoxplotStats() {
        let validBrushedNumbers = this.pointCollection.Array
            .filter(d => d.inBrush)
            .map(d => d.get(this.attributeKey)) // get actual value
            .filter(d => !isNaN(d)) // filter out NaN values.
            .sort((a, b) => a - b); // d3.quantile requires it to be sorted. This could technically be done faster without sorting.
        this._filteredBoxplotStats = DetailedDistributionWidget.calculateBoxplotStats(validBrushedNumbers);
    }
    static calculateBoxplotStats(numbers) {
        const median = d3.median(numbers);
        let lowQuartile = d3.quantile(numbers, 0.25);
        let highQuartile = d3.quantile(numbers, 0.75);
        const quartileRange = [lowQuartile, highQuartile];
        let interQuartileRange = highQuartile - lowQuartile;
        let lowWhisker = lowQuartile - 1.5 * interQuartileRange;
        let highWhisker = highQuartile + 1.5 * interQuartileRange;
        const whiskerRange = [lowWhisker, highWhisker];
        let boxplotStats = {
            median: median,
            quartileRange: quartileRange,
            whiskerRange: whiskerRange
        };
        return boxplotStats;
    }
    updateScales() {
        let data;
        if (this.isClone) {
            data = this.fullPointCollection;
        }
        else {
            data = this.pointCollection;
        }
        let distributionMinMax = data.getMinMax(this.attributeKey);
        // let distributionMinMax = this.pointCollection.getMinMax(this.attributeKey);
        this._scaleX = d3.scaleLinear()
            .domain(distributionMinMax)
            .range([0, this.vizWidth]);
        this._scaleY = d3.scaleLinear()
            .domain([0, 1]) // bounds of Math.random
            .range([this.vizHeight - 2 * this.scatterplotPadding, 0]);
    }
    draw() {
        // it's probably faster to filter out all the NaNs once than noDisp them all. There might be as many as 50% NaNs
        let validPoints = this.pointCollection.Array.filter(d => !isNaN(d.get(this.attributeKey)));
        // draw jittered scatterplot
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight - 2 * this.scatterplotPadding);
        canvasContext.fillStyle = 'black';
        canvasContext.globalAlpha = 0.6;
        for (let i = 0; i < validPoints.length; i++) {
            let point = validPoints[i];
            let x = this.scaleX(point.get(this.attributeKey));
            let y = this.scaleY(this.randomNoiseList[i]);
            canvasContext.beginPath();
            const radius = 0.5;
            canvasContext.arc(x, y, radius, 0, 2 * Math.PI);
            canvasContext.fill();
        }
        if (this.data.brushApplied) {
            const smallBoxplotHeight = (this.vizHeight - this.betweenBoxplotPadding) / 2;
            this.drawBoxplot(this.totalBoxplotContainerSelectOutline, this.totalBoxplotStats, 0, smallBoxplotHeight, true);
            this.drawBoxplot(this.totalBoxplotContainerSelect, this.totalBoxplotStats, 0, smallBoxplotHeight);
            this.drawBoxplot(this.filteredBoxplotContainerSelectOutline, this.filteredBoxplotStats, smallBoxplotHeight + this.betweenBoxplotPadding, smallBoxplotHeight, true, true);
            this.drawBoxplot(this.filteredBoxplotContainerSelect, this.filteredBoxplotStats, smallBoxplotHeight + this.betweenBoxplotPadding, smallBoxplotHeight, false, true);
            this.filteredBoxplotContainerSelectOutline.classed('noDisp', false);
            this.filteredBoxplotContainerSelect.classed('noDisp', false);
        }
        else {
            this.drawBoxplot(this.totalBoxplotContainerSelectOutline, this.totalBoxplotStats, 0, this.vizHeight, true);
            this.drawBoxplot(this.totalBoxplotContainerSelect, this.totalBoxplotStats, 0, this.vizHeight);
            this.filteredBoxplotContainerSelectOutline.classed('noDisp', true);
            this.filteredBoxplotContainerSelect.classed('noDisp', true);
        }
        this.drawAxis();
        this.positionLabels();
    }
    drawFacetedData(facetList) {
        this.drawFacetedDataDefault(facetList, "95%", "120px");
    }
    showLabel() {
        this.xLabelTextSelect.classed('noDisp', false);
    }
    drawBoxplot(containerSelect, boxplotStats, top, height, outline = false, selection = false) {
        // Median
        containerSelect.selectAll('.boxplotMedianLine')
            .data([boxplotStats.median])
            .join('line')
            .attr('x1', d => this.scaleX(d))
            .attr('y1', top)
            .attr('x2', d => this.scaleX(d))
            .attr('y2', top + height)
            .classed('boxplotMedianLine', true)
            .classed('outline', outline)
            .classed('selection', selection);
        // IQR Box
        containerSelect.selectAll('rect')
            .data([boxplotStats.quartileRange])
            .join('rect')
            .classed('IQR-Box', true)
            .classed('selection', selection)
            .classed('outline', outline)
            .attr('x', d => this.scaleX(d[0]))
            .attr('y', top)
            .attr('width', d => this.scaleX(d[1]) - this.scaleX(d[0]))
            .attr('height', height)
            .on('mouseover', () => {
            this.showBoxplotStatsPopup(boxplotStats, containerSelect);
        })
            .on('mouseout', () => {
            this.hideBoxplotStatsPopup();
        });
        // Horizontal whisker lines
        const vertMiddle = top + (height / 2);
        containerSelect.selectAll('.boxplotWhiskers')
            .data([
            [boxplotStats.whiskerRange[0], boxplotStats.quartileRange[0]],
            [boxplotStats.whiskerRange[1], boxplotStats.quartileRange[1]]
        ])
            .join('line')
            .attr('x1', d => this.scaleX(d[0]))
            .attr('y1', vertMiddle)
            .attr('x2', d => this.scaleX(d[1]))
            .attr('y2', vertMiddle)
            .classed('selection', selection)
            .classed('outline', outline)
            .classed('boxplotWhiskers', true);
        // vertical whisker endpoints
        const relativeSize = 0.66; // height of whisker endpoints compared to box height
        const padSize = height * (1 - relativeSize) / 2;
        containerSelect.selectAll('.boxplotWhiskerEnds')
            .data(boxplotStats.whiskerRange)
            .join('line')
            .attr('x1', d => this.scaleX(d))
            .attr('y1', top + padSize)
            .attr('x2', d => this.scaleX(d))
            .attr('y2', top + height - padSize)
            .classed('selection', selection)
            .classed('outline', outline)
            .classed('boxplotWhiskerEnds', true);
    }
    showBoxplotStatsPopup(boxplotStats, boxplotContainer) {
        this.boxplotStatsPopupSelect.html(null);
        const boundRect = boxplotContainer.node().getBoundingClientRect();
        this.boxplotStatsPopupSelect
            .attr('style', `left: ${(boundRect.left + boundRect.right) / 2}px; top:${boundRect.bottom}px`);
        this.boxplotStatsPopupSelect.append('div')
            .attr('id', 'boxplotStatsPopup-q1')
            .text('Q1: ' + boxplotStats.quartileRange[0].toFixed(4));
        this.boxplotStatsPopupSelect.append('div')
            .attr('id', 'boxplotStatsPopup-median')
            .text('Median: ' + boxplotStats.median.toFixed(4));
        this.boxplotStatsPopupSelect.append('div')
            .attr('id', 'boxplotStatsPopup-q3')
            .text('Q3: ' + boxplotStats.quartileRange[1].toFixed(4));
        this.boxplotStatsPopupSelect.classed('noDisp', false);
    }
    hideBoxplotStatsPopup() {
        this.boxplotStatsPopupSelect.classed('noDisp', true);
    }
    drawAxis() {
        this.xAxisGroupSelect
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .call(d3.axisBottom(this.scaleX));
    }
    OnResize() {
        this.svgSelect
            .attr('width', this.width)
            .attr('height', this.height);
        d3.select(this.canvasElement)
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight - 2 * this.scatterplotPadding);
        this.updateScales();
        this.draw();
    }
    OnBrushChange() {
        this.updateFilteredBoxplotStats();
        this.draw();
    }
}
exports.DetailedDistributionWidget = DetailedDistributionWidget;

},{"../types":118,"./BaseWidget":84,"d3":42}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const OptionSelect_1 = require("./OptionSelect");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class GroupByWidget {
    constructor(container) {
        this._outerContainer = container;
        this._mainContainer = this.outerContainer.append('div')
            .classed('groupByMainContainer', true);
        this._innerComponentId = 'groupByInnerContainer_' + GroupByWidget._componentCount + '_';
        GroupByWidget._componentCount++;
        this._groupByInnerConainerIdList = [];
        this.addComponentId();
        this.drawLines([0]);
        this.addGroupByLine(); // draw two lines by default
    }
    get outerContainer() {
        return this._outerContainer;
    }
    get innerComponentId() {
        return this._innerComponentId;
    }
    get mainContainer() {
        return this._mainContainer;
    }
    get groupByOuterContainerList() {
        return this._groupByOuterContainerList;
    }
    get data() {
        return this._data;
    }
    set data(v) {
        this._data = v;
    }
    get groupByInnerConainerIdList() {
        return this._groupByInnerConainerIdList;
    }
    get groupByOptionSelectList() {
        return this._groupByOptionSelectList;
    }
    get currentSelectionIndexList() {
        return this.groupByOptionSelectList.map(optionSelect => optionSelect.currentSelectionIndex);
    }
    drawLines(previousSelections) {
        this._groupByOuterContainerList = this.mainContainer.selectAll('.groupByElementContainer')
            .data(this.groupByInnerConainerIdList)
            .join('div')
            .classed('groupByElementContainer', true);
        this.groupByOuterContainerList.html(null);
        this.groupByOuterContainerList.append('div')
            .classed('groupByContainer', true)
            .classed('smallText', true)
            .attr('id', d => d);
        const self = this;
        this.groupByOuterContainerList
            .each(function (d, i) {
            let iconKey;
            let callback;
            if (i === 0) {
                iconKey = 'plus';
                callback = () => self.addGroupByLine();
            }
            else {
                iconKey = 'minus';
                callback = () => self.removeGroupByLine(i);
            }
            let iconButton = DevlibTSUtil_1.DevlibTSUtil.getIconButton(iconKey, callback);
            iconButton.classList.add('compact');
            d3.select(this).node().appendChild(iconButton);
        });
        this._groupByOptionSelectList = [];
        for (let i = 0; i < this.groupByInnerConainerIdList.length; i++) {
            let containerId = this.groupByInnerConainerIdList[i];
            let selection;
            if (i < previousSelections.length) {
                selection = previousSelections[i];
            }
            else {
                selection = this.getFirstUnselectedOption(previousSelections);
            }
            let label;
            if (i === 0) {
                label = "Group by";
            }
            else {
                label = 'and';
            }
            let optionSelect = new OptionSelect_1.OptionSelect(containerId, label, selection);
            this.groupByOptionSelectList.push(optionSelect);
        }
        if (this.data) {
            this.updateGroupByOptions(this.data);
        }
    }
    getFirstUnselectedOption(selections) {
        let maxIndex;
        if (this.data) {
            maxIndex = this.data.GetFacetOptions().length;
        }
        else {
            maxIndex = 0;
        }
        let candidate = 0;
        while (selections.includes(candidate) && candidate <= maxIndex) {
            candidate++;
        }
        return candidate;
    }
    addGroupByLine() {
        const previousSelections = this.currentSelectionIndexList;
        const added = this.addComponentId();
        if (!added) {
            return;
        }
        this.drawLines(previousSelections);
    }
    addComponentId() {
        const numberOfExistingLines = this.groupByInnerConainerIdList.length;
        if (this.data) {
            let facetOptions = this.data.GetFacetOptions();
            if (facetOptions.length === numberOfExistingLines) {
                return false;
            }
        }
        const newId = this.innerComponentId + numberOfExistingLines;
        this.groupByInnerConainerIdList.push(newId);
        return true;
    }
    removeGroupByLine(lineIndex) {
        const previousSelections = this.currentSelectionIndexList;
        previousSelections.splice(lineIndex, 1);
        if (this.groupByInnerConainerIdList.length > 1) {
            this.groupByInnerConainerIdList.pop();
        }
        this.drawLines(previousSelections);
    }
    updateGroupByOptions(data, skipEventTrigger = false) {
        this._data = data;
        let facetOptions = data.GetFacetOptions();
        for (let i = 0; i < this.groupByOptionSelectList.length; i++) {
            let buttonPropsList = [];
            for (let facetOption of facetOptions) {
                let buttonProps = {
                    displayName: facetOption.name,
                    callback: () => this.onGroupSelection()
                };
                buttonPropsList.push(buttonProps);
            }
            this.groupByOptionSelectList[i].onDataChange(buttonPropsList);
        }
        if (!skipEventTrigger) {
            this.onGroupSelection();
        }
    }
    onGroupSelection() {
        const flatFacetList = this.getFlatFacetList();
        const colorLookup = this.getColorLookup();
        const customEvent = new CustomEvent('groupByChanged', { detail: {
                groupIndex: this.currentSelectionIndexList,
                flatFacetList: flatFacetList,
                colorLookup: colorLookup
            } });
        document.dispatchEvent(customEvent);
    }
    getFlatFacetList() {
        let flatFacetList = [{ name: [], data: this.data }];
        let nestedFacetList = []; // only get the last two layers of the faceting
        for (let i = 0; i < this.currentSelectionIndexList.length; i++) {
            let index = this.currentSelectionIndexList[i];
            let nextList = [];
            for (let { name: nameSoFar, data: data } of flatFacetList) {
                let facetOptions = data.GetFacetOptions();
                let currentOption = facetOptions[index];
                let subFacets = currentOption.GetFacets();
                subFacets = subFacets.map(facet => {
                    let newName = nameSoFar.map(x => x);
                    newName.push(...facet.name);
                    return {
                        name: newName,
                        data: facet.data
                    };
                });
                nextList.push(...subFacets);
            }
            flatFacetList = nextList;
        }
        return flatFacetList;
    }
    getColorLookup() {
        const colorLookup = new Map();
        if (!this.data.defaultFacetAxisTicks) {
            return colorLookup;
        }
        const { yAxisTicks: condition1Labels, xAxisTicks: condition2Labels } = this.data.defaultFacetAxisTicks;
        const firstFacetIndex = this.currentSelectionIndexList[0];
        const labels = firstFacetIndex === 1 ? condition2Labels : condition1Labels;
        const controlNames = GroupByWidget.getControlNames();
        const controlColor = GroupByWidget.getControlColor();
        const { scheme: colorScheme, skipIndices: skipColors } = GroupByWidget.getColorScheme();
        let colorIndex = 0;
        for (let label of labels) {
            while (skipColors.has(colorIndex)) {
                colorIndex++;
                colorIndex = colorIndex % colorScheme.length;
            }
            const color = controlNames.has(label) ? controlColor : colorScheme[colorIndex++];
            colorLookup.set(label, color);
        }
        return colorLookup;
    }
    static getControlNames() {
        return new Set([
            'DMSO',
            'Ethanol',
            '0.0 um'
        ]);
    }
    static getControlColor() {
        return 'grey';
    }
    static getColorScheme() {
        return { scheme: d3.schemeSet1, skipIndices: new Set([5, 8]) };
    }
    static getColor(labels, colorLookup) {
        for (let key of labels) {
            if (colorLookup.has(key)) {
                return colorLookup.get(key);
            }
        }
        return 'grey';
    }
}
exports.GroupByWidget = GroupByWidget;
GroupByWidget._componentCount = 0;

},{"../devlib/DevlibTSUtil":116,"./OptionSelect":92,"d3":42}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class HistogramWidget extends BaseWidget_1.BaseWidget {
    constructor(container, valueKey, canBrush = true, includeExemplarTrackButton = false, isClone = false) {
        super(container, true, canBrush, includeExemplarTrackButton);
        this._valueKey = valueKey;
        this.setLabel();
        this._isClone = isClone;
    }
    Clone(container) {
        const canBrush = false;
        let clone = new HistogramWidget(container, this.valueKey, canBrush, false);
        return clone;
    }
    get isClone() {
        return this._isClone;
    }
    initProps(props) {
        super.initProps();
        this._canBrush = props[0];
        this._includeExemplarTrackButton = props[1];
    }
    get valueKey() {
        return this._valueKey;
    }
    get sortedData() {
        return this._sortedData;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get totalHistogramGroupSelect() {
        return this._totalHistogramGroupSelect;
    }
    get brushedHistogramGroupSelect() {
        return this._brushedHistogramGroupSelect;
    }
    get totalKDEGroupSelect() {
        return this._totalKDEGroupSelect;
    }
    get brushedKDEGroupSelect() {
        return this._brushedKDEGroupSelect;
    }
    get canBrush() {
        return this._canBrush;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get axisGroupSelect() {
        return this._axisGroupSelect;
    }
    get labelTextSelect() {
        return this._labelTextSelect;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleYHistogramAbsolute() {
        return this._scaleYHistogramAbsolute;
    }
    get scaleYHistogramRelative() {
        return this._scaleYHistogramRelative;
    }
    get scaleYKdeAbsolute() {
        return this._scaleYKdeAbsolute;
    }
    get scaleYKdeRelative() {
        return this._scaleYKdeRelative;
    }
    get allBins() {
        return this._allBins;
    }
    get brushedBins() {
        return this._brushedBins;
    }
    set brushedBins(v) {
        this._brushedBins = v;
    }
    get allPathPoints() {
        return this._allPathPoints;
    }
    get maxDensityAll() {
        return this._maxDensityAll;
    }
    get brushedPathPoints() {
        return this._brushedPathPoints;
    }
    get brushedPointsLength() {
        return this._brushedPointsLength;
    }
    get axisPadding() {
        return this._axisPadding;
    }
    get brush() {
        return this._brush;
    }
    get useHistogramButton() {
        return this._useHistogramButton;
    }
    get useKDEButton() {
        return this._useKDEButton;
    }
    static get useKdeInsteadOfHistogram() {
        return HistogramWidget._useKdeInsteadOfHistogram;
    }
    static set useKdeInsteadOfHistogram(v) {
        HistogramWidget._useKdeInsteadOfHistogram = v;
        let event = new Event('switchBetweenKdeAndHistogram');
        document.dispatchEvent(event);
    }
    get useAbsoluteButton() {
        return this._useAbsoluteButton;
    }
    get useRelativeButton() {
        return this._useRelativeButton;
    }
    static get useAbsoluteScaling() {
        return HistogramWidget._useAbsoluteScaling;
    }
    static set useAbsoluteScaling(v) {
        HistogramWidget._useAbsoluteScaling = v;
        let event = new Event('switchBetweenAbsoluteAndRelativeScaling');
        document.dispatchEvent(event);
    }
    get includeExemplarTrackButton() {
        return this._includeExemplarTrackButton;
    }
    set includeExemplarTrackButton(v) {
        this._includeExemplarTrackButton = v;
    }
    setMargin() {
        this._margin = {
            top: 6,
            right: 8,
            bottom: 50,
            left: 8
        };
    }
    init() {
        this.initKDEHIstogramToggle();
        this.initAbsoluteRelativeToggle();
        if (this.includeExemplarTrackButton) {
            this.initExemplarTrackButton();
        }
        this._svgSelect = d3.select(this.container).append("svg")
            .attr("width", this.width)
            .attr("height", this.height);
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        if (this.canBrush) {
            this._brushGroupSelect = this.svgSelect.append("g")
                .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
                .classed("brushContainer", true);
            this._brush = d3.brushX()
                .extent([[0, 0], [this.vizWidth, this.vizHeight]])
                .on("end", () => { this.brushHandler(); });
            this.brushGroupSelect.call(this.brush);
        }
        this._totalHistogramGroupSelect = this.mainGroupSelect.append('g');
        this._brushedHistogramGroupSelect = this.mainGroupSelect.append('g');
        this._totalKDEGroupSelect = this.mainGroupSelect.append('g');
        this._brushedKDEGroupSelect = this.mainGroupSelect.append('g');
        this._axisPadding = 2;
        this._axisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight + this.axisPadding})`)
            .classed('labelColor', true);
        document.addEventListener('exemplarAttributeChange', (e) => {
            let newExemplarAttribute = e.detail;
            if (newExemplarAttribute === this.valueKey) {
                this.container.classList.add('selected');
            }
            else {
                this.container.classList.remove('selected');
            }
        });
    }
    initKDEHIstogramToggle() {
        this._useHistogramButton = this.AddButton('chart-bar', 'Change to histograms', () => {
            HistogramWidget.useKdeInsteadOfHistogram = false;
        });
        this._useKDEButton = this.AddButton('chart-area', 'Change to kernel density plots', () => {
            HistogramWidget.useKdeInsteadOfHistogram = true;
        });
        if (HistogramWidget.useKdeInsteadOfHistogram) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useKDEButton);
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useHistogramButton);
        }
        document.addEventListener('switchBetweenKdeAndHistogram', (e) => {
            if (HistogramWidget.useKdeInsteadOfHistogram) {
                DevlibTSUtil_1.DevlibTSUtil.show(this.useHistogramButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useKDEButton);
            }
            else {
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useHistogramButton);
                DevlibTSUtil_1.DevlibTSUtil.show(this.useKDEButton);
            }
            this.OnDataChange();
        });
    }
    initAbsoluteRelativeToggle() {
        this._useAbsoluteButton = this.AddButton('hashtag', 'Change to absolute comparison of selections.', () => {
            HistogramWidget.useAbsoluteScaling = true;
        });
        this._useRelativeButton = this.AddButton('percent', 'Change to relative comparison of selections.', () => {
            HistogramWidget.useAbsoluteScaling = false;
        });
        if (HistogramWidget.useAbsoluteScaling) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useAbsoluteButton);
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.useRelativeButton);
        }
        document.addEventListener('switchBetweenAbsoluteAndRelativeScaling', (e) => {
            if (this.container.classList.contains("noDisp")) {
                return;
            }
            if (HistogramWidget.useAbsoluteScaling) {
                DevlibTSUtil_1.DevlibTSUtil.show(this.useRelativeButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useAbsoluteButton);
            }
            else {
                DevlibTSUtil_1.DevlibTSUtil.hide(this.useRelativeButton);
                DevlibTSUtil_1.DevlibTSUtil.show(this.useAbsoluteButton);
            }
            if (HistogramWidget.useKdeInsteadOfHistogram) {
                this.drawAllKDE(false);
            }
            else {
                this.drawAllHistograms([], true);
            }
        });
    }
    initExemplarTrackButton() {
        this.AddButton('rocket', 'Sample new exemplars from this attribute.', async () => {
            let event = new CustomEvent('launchExemplarCurve', { detail: this.valueKey });
            DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
            await DevlibTSUtil_1.DevlibTSUtil.makeAsync(() => document.dispatchEvent(event));
        });
    }
    setLabel() {
        const bufferForAxis = 32 + this.axisPadding;
        this._labelTextSelect = this.svgSelect.append('text')
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`)
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .text(this.valueKey);
    }
    OnDataChange() {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        let validNumbers = this.data.Array.filter(d => !isNaN(d.get(this.valueKey)));
        this._allBins = this.calculateBins(validNumbers);
        this.updateScales(validNumbers.length);
        if (HistogramWidget._useKdeInsteadOfHistogram) {
            let shallowCopy = [...validNumbers];
            const key = this.valueKey;
            this._sortedData = shallowCopy.sort((a, b) => d3.ascending(a.get(key), b.get(key)));
            this._allPathPoints = this.kde(this.sortedData);
            this._maxDensityAll = d3.max(this.allPathPoints, d => d[1]);
            this.drawAllKDE(false);
            this.removeHistograms();
        }
        else {
            this.drawAllHistograms(validNumbers);
            this.removeKDEs();
        }
        this.drawAxis();
    }
    calculateBins(points) {
        let bins = HistogramWidget.calculateBins(points, this.valueKey, this.fullData);
        return bins;
    }
    static calculateBins(points, valueKey, fullData, numBins, skipNice = false) {
        let count;
        if (numBins) {
            count = numBins;
        }
        else {
            count = Math.round(Math.sqrt(fullData.length)) / 3;
        }
        let minMax = fullData.getMinMax(valueKey);
        let x = d3.scaleLinear()
            .domain(minMax);
        let thresholds;
        if (!skipNice) {
            x = x.nice(count);
            thresholds = x.ticks(count);
        }
        else {
            thresholds = d3.range(minMax[0], minMax[1], (minMax[1] - minMax[0]) / count);
        }
        let bins = d3.histogram()
            .domain(x.domain())
            .thresholds(thresholds)
            .value(d => d.get(valueKey))(points);
        // account for degenerate last bin -_-
        let ultimateBin = bins[bins.length - 1];
        if (ultimateBin.x0 === ultimateBin.x1) {
            let penultimateBin = bins[bins.length - 2];
            if (penultimateBin) {
                for (let point of ultimateBin) {
                    penultimateBin.push(point);
                }
            }
        }
        return bins;
    }
    removeHistograms() {
        this.totalHistogramGroupSelect.html(null);
        this.brushedHistogramGroupSelect.html(null);
    }
    drawAllHistograms(validNumbers, skipRecalculation = false) {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        if (!skipRecalculation) {
            let brushedNumbers = validNumbers.filter(d => d.inBrush);
            if (validNumbers.length === brushedNumbers.length) {
                this.brushedHistogramGroupSelect.html(null);
                this._brushedBins = [];
            }
            else {
                this._brushedBins = this.calculateBins(brushedNumbers);
            }
            let biggestBinRelativeAll = d3.max(this.allBins, d => d.length / validNumbers.length);
            let biggestBinRelativeBrushed = d3.max(this.brushedBins, d => d.length / brushedNumbers.length);
            this._scaleYHistogramRelative = d3.scaleLinear()
                .domain([0, d3.max([biggestBinRelativeAll, biggestBinRelativeBrushed])])
                .range([0, this.vizHeight]);
        }
        this.drawHistogram(this.totalHistogramGroupSelect, this.allBins);
        this.drawHistogram(this.brushedHistogramGroupSelect, this.brushedBins, true);
    }
    drawHistogram(select, bins, inBrush = false) {
        if (bins.length === 0) {
            select.html(null);
            return;
        }
        let pathPoints = this.getHistogramSkyline(bins);
        let lineFunc = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .defined(d => d[0] !== null);
        select.selectAll('path')
            .data([lineFunc(pathPoints)])
            .join('path')
            .classed('kdePath', true)
            .classed('inBrush', inBrush)
            .transition()
            .attr('d', d => d);
    }
    getHistogramSkyline(bins, singleWidth = 18) {
        let pathPoints = [];
        if (bins.length === 1) {
            let left = (this.vizWidth - singleWidth) / 2;
            let right = (this.vizWidth + singleWidth) / 2;
            pathPoints.push([left, this.vizHeight]);
            pathPoints.push([left, 0]);
            pathPoints.push([right, 0]);
            pathPoints.push([right, this.vizHeight]);
            return pathPoints;
        }
        const totalCount = d3.sum(bins, bin => bin.length);
        for (let bin of bins) {
            let x1 = this.scaleX(bin.x0);
            let offset;
            if (HistogramWidget.useAbsoluteScaling) {
                offset = this.scaleYHistogramAbsolute(bin.length);
            }
            else {
                offset = this.scaleYHistogramRelative(bin.length / totalCount);
            }
            let y = this.vizHeight - offset;
            pathPoints.push([x1, y]);
            if (bin.length === 0) {
                let splitPoint = [null, null];
                pathPoints.push(splitPoint);
            }
            let x2 = this.scaleX(bin.x1);
            pathPoints.push([x2, y]);
        }
        pathPoints.unshift([0, this.vizHeight]);
        pathPoints.push([this.vizWidth, this.vizHeight]);
        return pathPoints;
    }
    removeKDEs() {
        this.totalKDEGroupSelect.html(null);
        this.brushedKDEGroupSelect.html(null);
    }
    drawAllKDE(filterChanged) {
        let brushedPoints = this.sortedData.filter(d => d.inBrush);
        this._brushedPathPoints = this.kde(brushedPoints);
        this._brushedPointsLength = brushedPoints.length;
        let maxDomain = this.maxDensityAll;
        if (!HistogramWidget.useAbsoluteScaling) {
            let maxValBrushed = d3.max(this.brushedPathPoints, d => d[1]);
            maxDomain = d3.max([maxDomain, maxValBrushed]);
        }
        this._scaleYKdeRelative = d3.scaleLinear()
            .domain([0, maxDomain])
            .range([this.vizHeight, 0]);
        if (!filterChanged || HistogramWidget.useAbsoluteScaling) {
            this.drawKDE(this.sortedData.length, this.allPathPoints, false, this.totalKDEGroupSelect);
        }
        if (this.brushedPointsLength === this.sortedData.length) {
            this.brushedKDEGroupSelect.html(null);
        }
        else {
            this.drawKDE(this.brushedPointsLength, this.brushedPathPoints, true, this.brushedKDEGroupSelect);
        }
    }
    drawKDE(numPoints, pathPoints, inBrush, select) {
        let yFunc;
        if (HistogramWidget.useAbsoluteScaling) {
            yFunc = d => this.scaleYKdeRelative((numPoints / this.sortedData.length) * d[1]);
        }
        else {
            yFunc = d => this.scaleYKdeRelative(d[1]);
        }
        let lineFunc = d3.line()
            // .curve(d3.curveBasis)
            .x(d => this.scaleX(d[0]))
            .y(yFunc);
        select.selectAll('path')
            .data([lineFunc(pathPoints)])
            .join('path')
            .classed('kdePath', true)
            .classed('inBrush', inBrush)
            .transition()
            .attr('d', d => d);
    }
    kde(points) {
        // Assumes that points is sorted based on valueKey
        const kernel = this.epanechnikov;
        let [low, high] = this.scaleX.domain();
        const bandwidth = 0.01 * (high - low);
        let ticks = this.scaleX.ticks(100);
        let pathPoints = [];
        for (let t of ticks) {
            // get index with value closest to t
            let compareFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(t, (point) => {
                return point.get(this.valueKey);
            });
            let startIndex;
            let searchResult = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(points, compareFunction);
            if (typeof searchResult === "number") {
                startIndex = searchResult;
            }
            else {
                const [idx1, idx2] = searchResult;
                if (typeof idx1 !== "undefined") {
                    startIndex = idx1;
                }
                else {
                    startIndex = idx2;
                }
            }
            let kernelSum = 0;
            // look forward
            for (let i = startIndex + 1; i < points.length; i++) {
                let point = points[i];
                let u = (t - point.get(this.valueKey)) / bandwidth;
                if (Math.abs(u) > 1) {
                    break;
                }
                kernelSum += kernel(u);
            }
            // look backward
            for (let i = startIndex; i >= 0; i--) {
                let point = points[i];
                let u = (t - point.get(this.valueKey)) / bandwidth;
                if (Math.abs(u) > 1) {
                    break;
                }
                kernelSum += kernel(u);
            }
            pathPoints.push([t, kernelSum / points.length]);
        }
        pathPoints.unshift([low, 0]);
        pathPoints.push([high, 0]);
        return pathPoints;
    }
    epanechnikov(u) {
        //https://en.wikipedia.org/wiki/Kernel_(statistics)#Kernel_functions_in_common_use
        if (Math.abs(u) <= 1) {
            return 0.75 * (1 - u * u);
        }
        return 0;
    }
    updateScales(totalCount) {
        let minBinBoundary = this.allBins[0].x0;
        let maxBinBoundary = this.allBins[this.allBins.length - 1].x1;
        this._scaleX = d3.scaleLinear()
            .domain([minBinBoundary, maxBinBoundary])
            .range([0, this.vizWidth]);
        let biggestBinCount = d3.max(this.allBins, d => d.length);
        this._scaleYHistogramAbsolute = d3.scaleLinear()
            .domain([0, biggestBinCount])
            .range([0, this.vizHeight]);
    }
    MoveBrush(newRange) {
        if (newRange) {
            newRange[0] = this.scaleX(newRange[0]);
            newRange[1] = this.scaleX(newRange[1]);
        }
        this.brushGroupSelect.call(this.brush.move, newRange);
    }
    drawAxis() {
        this.axisGroupSelect
            .call(d3.axisBottom(this.scaleX).ticks(5));
    }
    OnResize() {
        this.OnDataChange();
    }
    brushHandler() {
        const selection = d3.event.selection;
        if (typeof selection === "undefined" || selection === null) {
            this.data.removeBrush(this.ComponentId);
            return;
        }
        let [minBound, maxBound] = selection;
        let minV = this.scaleX.invert(minBound);
        let maxV = this.scaleX.invert(maxBound);
        let valueFilter = {
            key: this.valueKey,
            bound: [minV, maxV]
        };
        this.data.addBrush(this.ComponentId, valueFilter);
    }
    OnBrushChange() {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        if (HistogramWidget._useKdeInsteadOfHistogram) {
            // this.drawBrushedKDE();
            this.drawAllKDE(true);
        }
        else {
            let validNumbers = this.data.Array.filter(d => !isNaN(d.get(this.valueKey)));
            this.drawAllHistograms(validNumbers);
        }
    }
}
exports.HistogramWidget = HistogramWidget;
HistogramWidget._useKdeInsteadOfHistogram = false;
HistogramWidget._useAbsoluteScaling = true;

},{"../devlib/DevlibAlgo":114,"../devlib/DevlibTSUtil":116,"./BaseWidget":84,"d3":42}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const ImageStackWidget_1 = require("./ImageStackWidget");
const ImageMetaData_1 = require("../DataModel/ImageMetaData");
const DevlibMath_1 = require("../devlib/DevlibMath");
const RichTooltip_1 = require("./RichTooltip");
const GroupByWidget_1 = require("./GroupByWidget");
const ImageStackDataRequest_1 = require("../DataModel/ImageStackDataRequest");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class ImageSelectionWidget extends BaseWidget_1.BaseWidget {
    constructor(container, samplingStratOptions, isClone = false) {
        super(container, false, samplingStratOptions);
        this._isClone = isClone;
    }
    Clone(container) {
        return new ImageSelectionWidget(container, this.samplingStratOptions, true);
    }
    get isClone() {
        return this._isClone;
    }
    get imageMetaData() {
        return this._imageMetaData;
    }
    get imageStackDataRequest() {
        return this._imageStackDataRequest;
    }
    get innerContainer() {
        return this._innerContainer;
    }
    get imageTrackContainer() {
        return this._imageTrackContainer;
    }
    get locationSelectionContainer() {
        return this._locationSelectionContainer;
    }
    get menuBarContainer() {
        return this._menuBarContainer;
    }
    get legendContentContainer() {
        return this._legendContentContainer;
    }
    get groupByWidget() {
        return this._groupByWidget;
    }
    get locationListContainer() {
        return this._locationListContainer;
    }
    get imageStackContainer() {
        return this._imageStackContainer;
    }
    get imageStackWidget() {
        return this._imageStackWidget;
    }
    get selectedLocationId() {
        return this._selectedLocationId;
    }
    get hoveredLocationId() {
        return this._hoveredLocationId;
    }
    get frameTooltip() {
        return this._frameTooltip;
    }
    get frameHeight() {
        return this._frameHeight;
    }
    get frameHeightSelected() {
        return this._frameHeightSelected;
    }
    get frameMarginTopBot() {
        return this._frameMarginTopBot;
    }
    get frameScaleX() {
        return this._frameScaleX;
    }
    get frameScaleHeight() {
        return this._frameScaleHeight;
    }
    get hoveredLocFrame() {
        return this._hoveredLocFrame;
    }
    get selectedLocFrame() {
        return this._selectedLocFrame;
    }
    get hoveredLocId() {
        return this._hoveredLocId;
    }
    get samplingStratOptions() {
        return this._samplingStratOptions;
    }
    initProps(props) {
        super.initProps();
        this._samplingStratOptions = props[0];
    }
    init() {
        this._frameHeight = 32; // hardcoded based on CSS
        this._frameHeightSelected = 32; // also based on CSS
        this._frameMarginTopBot = 12;
        this._frameTooltip = new RichTooltip_1.RichTooltip(0, 0);
        this._selectedLocFrame = [1, 1];
        this._hoveredLocFrame = null;
        this._hoveredLocId = null;
        this._innerContainer = d3.select(this.container).append('div');
        this.innerContainer.classed('imageSelectionContainer', true);
        this._imageTrackContainer = d3.select(this.container).append('div');
        this.imageTrackContainer
            .classed('imageTrackContainer', true);
        this._locationSelectionContainer = this.innerContainer.append('div')
            .classed('locationSelectionContainer', true);
        this._menuBarContainer = this.locationSelectionContainer.append('div')
            .classed('menuBarContainer', true);
        document.onkeydown = (event) => { this.handleKeyDown(event); };
        this._groupByWidget = new GroupByWidget_1.GroupByWidget(this.menuBarContainer);
        const legendButton = DevlibTSUtil_1.DevlibTSUtil.getIconButton('question-circle', () => {
            const showLegend = this.legendContentContainer.classed('noDisp');
            d3.select(legendButton).classed('selected', showLegend);
            this.legendContentContainer.classed('noDisp', !showLegend);
        }, 'Legend');
        this.menuBarContainer.node().appendChild(legendButton);
        this._legendContentContainer = this.menuBarContainer.append('div')
            .classed('legendContentContainer', true)
            .classed('noDisp', true);
        this.legendContentContainer.append('img')
            .attr('src', '/static/assets/image-selection-legend.png');
        this._locationListContainer = this.locationSelectionContainer.append('div')
            .classed('locationListContainer', true);
        this._imageStackContainer = this.innerContainer.append('div')
            .classed('imageStackContainer', true)
            .classed('overflow-scroll', true);
        this._imageStackWidget = new ImageStackWidget_1.ImageStackWidget(this.imageStackContainer.node(), this.imageTrackContainer.node(), this.vizHeight, this.samplingStratOptions);
        document.addEventListener('frameHoverChange', (e) => {
            const locId = e.detail.locationId;
            const frameId = e.detail.frameId;
            const cellId = e.detail.cellId;
            this.onHoverLocationFrame(locId, frameId, cellId, false);
        });
        document.addEventListener('locFrameClicked', (e) => {
            const locId = e.detail.locationId;
            const frameId = e.detail.frameId;
            this.onClickLocationFrame(locId, frameId);
        });
        document.addEventListener('imageSelectionRedraw', (e) => {
            this.draw();
        });
        document.addEventListener('manualPinToggle', (e) => {
            this.updateAllExtractedDots();
        });
        this.OnResize();
    }
    OnDataChange() {
        this._imageMetaData = ImageMetaData_1.ImageMetaData.fromPointCollection(this.fullData);
        this._imageStackDataRequest = new ImageStackDataRequest_1.ImageStackDataRequest(this.data.Specification.googleDriveId);
        this._selectedLocationId = this.imageMetaData.locationList[0].locationId;
        this.groupByWidget.updateGroupByOptions(this.data);
        this._hoveredLocationId = null;
        this.setImageStackWidget(true);
        this.OnBrushChange();
    }
    setImageStackWidget(skipImageTrackDraw = false) {
        const [locId, frameId] = this.selectedLocFrame;
        this.imageStackDataRequest.getImage(locId, frameId, (top, left, blob) => {
            this.imageStackWidget.SetImageProperties(skipImageTrackDraw, blob);
        });
        let currentLocation = this.imageMetaData.locationLookup.get(this.selectedLocationId);
        this.imageStackWidget.SetData(this.data, this.fullData, currentLocation, this.imageStackDataRequest, skipImageTrackDraw);
    }
    OnResize() {
        const topHeightMax = 0.5 * this.height;
        const botHeightMax = this.height - topHeightMax;
        this.imageStackWidget.OnResize(topHeightMax, botHeightMax, this.width);
        this.locationSelectionContainer
            .classed('overflow-scroll', true)
            .attr('style', `max-height: ${topHeightMax}px`);
        this.imageTrackContainer
            .attr('style', `max-width: ${this.width}px;
            max-height: ${botHeightMax}px;
            width: ${this.width}px;
            height: ${botHeightMax}px;`);
    }
    OnBrushChange() {
        this.imageMetaData.updateInBrushProp(this.data);
        this.draw();
        this.imageStackWidget.OnBrushChange();
    }
    draw() {
        this.locationListContainer.html(null);
        this.drawFacetRecurse(this.groupByWidget.currentSelectionIndexList);
        this.drawSelectedDots();
    }
    drawFacetRecurse(remainingSubFacetIndices, verticalPosition = 0, facet, containerSelection) {
        let container;
        if (containerSelection) {
            container = containerSelection;
        }
        else {
            container = this.locationListContainer;
        }
        if (remainingSubFacetIndices.length === 0) {
            this.drawTerminalFacet(container, facet.name.join(' '), facet.data, verticalPosition, 0);
            return 1;
        }
        let data;
        if (facet) {
            data = facet.data;
        }
        else {
            data = this.data;
        }
        const facetIndex = remainingSubFacetIndices[0];
        let facetOptions = data.GetFacetOptions();
        let hardCodedOption = facetOptions[facetIndex];
        let facetList = hardCodedOption.GetFacets();
        let grouperDiv;
        if (facet) {
            grouperDiv = this.drawGrouperFacet(container, facet.name.join(' '), verticalPosition, remainingSubFacetIndices.length);
        }
        let childPosition = verticalPosition;
        let thisCount = 0;
        for (let childFacet of facetList) {
            childPosition++;
            let count = this.drawFacetRecurse(remainingSubFacetIndices.slice(1), childPosition, childFacet, grouperDiv);
            thisCount += count;
        }
        return thisCount;
    }
    drawGrouperFacet(containerSelection, name, verticalPosition, zIndex) {
        this.drawTitleElement(containerSelection, name, verticalPosition, zIndex);
        const grouperDiv = containerSelection.append('div')
            .classed('locationListGrouper', true);
        return grouperDiv;
    }
    drawTitleElement(containerSelection, name, verticalPosition, zIndex) {
        const topPos = (verticalPosition - 1) * 19;
        let styleString = `top: ${topPos}px;`;
        if (zIndex > 0) {
            styleString += ` z-index: ${zIndex};`;
        }
        if (this.imageStackWidget.colorLookup.has(name)) {
            let colorString = GroupByWidget_1.GroupByWidget.getColor([name], this.imageStackWidget.colorLookup);
            let color = d3.hsl(colorString);
            styleString += `color: ${color.darker(1.0).toString()};`;
            color.l = 0.95;
            styleString += `background: ${color.toString()};`;
        }
        containerSelection.append('div')
            .text(name)
            .classed('locationListCatTitle', true)
            .attr('style', styleString);
    }
    drawTerminalFacet(containerSelection, name, data, verticalPosition, zIndex) {
        this.drawTitleElement(containerSelection, name, verticalPosition, zIndex);
        const subListContainer = containerSelection.append('ul')
            .classed('subListContainer', true);
        let locationList = data.locationList;
        if (this.imageStackWidget.inCondensedMode) {
            locationList = locationList.filter(loc => this.imageStackWidget.exemplarLocations.has(loc));
        }
        if (locationList.length === 0) {
            return;
        }
        const listElement = subListContainer.selectAll('li')
            .data(locationList)
            .join('li');
        let countToPercent;
        if (!this.data.brushApplied) {
            const maxTotalCells = d3.max(this.imageMetaData.locationList, loc => loc.totalCount);
            countToPercent = d3.scaleLinear()
                .domain([0, maxTotalCells])
                .range([0, 1.0]);
        }
        else {
            const maxInBrushCells = d3.max(this.imageMetaData.locationList, loc => loc.inBrushCount);
            countToPercent = d3.scaleLinear()
                .domain([0, maxInBrushCells])
                .range([0, 1.0]);
        }
        listElement.html(null)
            .append('button')
            .text(d => d)
            .classed('locationButton', true)
            .classed('toggleButton', true)
            .classed('selected', d => d == this.selectedLocationId)
            .attr('id', d => 'imageLocation-' + d)
            .attr('style', d => {
            const location = this.imageMetaData.locationLookup.get(d);
            const percent = this.data.brushApplied ? countToPercent(location.inBrushCount) : countToPercent(location.totalCount);
            const stop = (1 - percent) * 100;
            const barColor = '#EDCAC9'; // lighter firebrick
            return `background: linear-gradient(to left, rgba(255,255,255,0), rgba(255,255,255,0) ${stop}%, ${barColor}, ${stop}%, ${barColor})`;
        })
            .on('click', d => {
            this.onClickLocation(d);
        });
        const wraperSelection = listElement.append('div')
            .classed('frameListContainer', true);
        // getting the first one, they should all be the same
        const bbox = wraperSelection.node().getBoundingClientRect();
        const miniWidth = bbox.width;
        const svgSelection = wraperSelection.append('svg')
            .attr('width', miniWidth)
            .attr('height', d => d === this.selectedLocationId ? this.frameHeightSelected : this.frameHeight)
            .attr('id', d => 'frameTicksViz-' + d)
            .attr('data-locId', d => d)
            .on('mouseleave', () => {
            this._hoveredLocId = null;
            this.hideFrameTooltip();
            this.removeHoverDots(svgSelection);
            this.changeHoveredLocation(null);
        });
        const marginW = 4;
        const frameExtent = this.fullData.getMinMax('Frame ID');
        this._frameScaleX = d3.scaleLinear()
            .domain(frameExtent)
            .range([marginW, miniWidth - marginW]);
        let domainMax;
        if (this.data.brushApplied) {
            domainMax = d3.max(this.imageMetaData.locationList, imgLoc => d3.max(imgLoc.frameList, frame => frame.inBrushCount));
        }
        else {
            domainMax = d3.max(this.imageMetaData.locationList, imgLoc => d3.max(imgLoc.frameList, frame => frame.totalCount));
        }
        const scaleLineWidth = d3.scaleLinear()
            .domain([0, domainMax])
            .range([1.0, 3.0]);
        this._frameScaleHeight = d3.scaleLinear()
            .domain([0, domainMax])
            .range([1, this.frameHeight - 2 * this.frameMarginTopBot]);
        svgSelection.selectAll('line')
            .data(d => this.getFrameList(d))
            .join('line')
            .attr('x1', d => this.frameScaleX(d.frameId))
            .attr('x2', d => this.frameScaleX(d.frameId))
            .attr('y1', d => {
            let toScale = this.data.brushApplied ? d.inBrushCount : d.totalCount;
            return (this.frameHeight - this.frameScaleHeight(toScale)) / 2;
        })
            .attr('y2', d => {
            let toScale = this.data.brushApplied ? d.inBrushCount : d.totalCount;
            return this.frameHeight - (this.frameHeight - this.frameScaleHeight(toScale)) / 2;
        })
            .attr('stroke-width', d => this.data.brushApplied ? scaleLineWidth(d.inBrushCount) : scaleLineWidth(d.totalCount))
            .attr('stroke', d => d.inBrush ? 'firebrick' : 'black')
            .classed('tickMark', true);
        let svgList = svgSelection.nodes();
        for (let i = 0; i < svgList.length; i++) {
            const svgElement = svgList[i];
            const locId = +svgElement.dataset['locId'];
            if (this.imageStackWidget.inCondensedMode) {
                this.drawExtractedDots(d3.select(svgElement), locId, this.imageStackWidget.exemplarFrames.get(locId));
            }
            svgElement.addEventListener('mousemove', (event) => {
                this._hoveredLocId = locId;
                const mouseX = event.offsetX;
                let frameId = this.frameScaleX.invert(mouseX);
                frameId = DevlibMath_1.DevlibMath.clamp(Math.round(frameId), frameExtent);
                this.onHoverLocationFrame(locId, frameId, null, true);
            });
            svgElement.addEventListener('click', (event) => {
                const mouseX = event.offsetX;
                let frameId = this.frameScaleX.invert(mouseX);
                frameId = DevlibMath_1.DevlibMath.clamp(Math.round(frameId), frameExtent);
                // this.onClickLocationFrame(locId, frameId);
                document.dispatchEvent(new CustomEvent('locFrameClicked', { detail: {
                        locationId: locId,
                        frameId: frameId
                    } }));
            });
        }
    }
    handleKeyDown(event) {
        let newIndex;
        // const [locId, frameId] = this.hoveredLocFrame;
        const [locId, frameId] = this.selectedLocFrame;
        const location = this.imageMetaData.locationLookup.get(locId);
        let nextFrameId;
        switch (event.keyCode) {
            case 37: // left
                const minFrameId = location.frameList[0].frameId;
                nextFrameId = Math.max(frameId - 1, minFrameId);
                // this.onClickLocationFrame(locId, nextFrameId);
                document.dispatchEvent(new CustomEvent('locFrameClicked', { detail: {
                        locationId: locId,
                        frameId: nextFrameId
                    } }));
                break;
            case 39: // right
                const maxFrameId = location.frameList[location.frameList.length - 1].frameId;
                nextFrameId = Math.min(frameId + 1, maxFrameId);
                // this.onClickLocationFrame(locId, nextFrameId);
                document.dispatchEvent(new CustomEvent('locFrameClicked', { detail: {
                        locationId: locId,
                        frameId: nextFrameId
                    } }));
                break;
        }
    }
    onHoverLocationFrame(locationId, frameId, cellId, showTooltip) {
        this._hoveredLocFrame = [locationId, frameId];
        const lastSvgContainer = d3.select('#frameTicksViz-' + this.hoveredLocationId);
        this.removeHoverDots(lastSvgContainer);
        this.removeHoverBar(lastSvgContainer);
        const svgContainer = d3.select('#frameTicksViz-' + locationId);
        this.changeHoveredLocation(locationId);
        this.frameTooltip.Hide();
        if (frameId === null) {
            return;
        }
        if (showTooltip) {
            const bbox = svgContainer.node().getBoundingClientRect();
            const xPos = bbox.right;
            const yPos = bbox.top + bbox.height / 2;
            const htmlString = this.createTooltipContent(locationId, frameId);
            this.frameTooltip.Show(htmlString, xPos, yPos);
        }
        this.drawHoverDots(svgContainer, locationId, frameId);
        this.drawFrameRange(svgContainer, cellId);
    }
    drawFrameRange(svgContainer, cellId) {
        if (cellId === null) {
            this.removeHoverBar(svgContainer);
            return;
        }
        const curve = this.fullData.curveLookup.get(cellId);
        const firstPoint = curve.pointList[0];
        const lowFrameId = firstPoint.get("Frame ID");
        const locId = firstPoint.get('Location ID');
        const location = this.imageMetaData.locationLookup.get(locId);
        const frameLow = location.frameLookup.get(lowFrameId);
        const lastPoint = curve.pointList[curve.pointList.length - 1];
        const highFrameId = lastPoint.get("Frame ID");
        const frameHigh = location.frameLookup.get(highFrameId);
        const xLow = this.frameScaleX(lowFrameId);
        const xHigh = this.frameScaleX(highFrameId);
        const h1 = (this.frameScaleHeight(frameLow.inBrushCount) + this.frameHeight) / 2;
        const h2 = (this.frameScaleHeight(frameHigh.inBrushCount) + this.frameHeight) / 2;
        const betweenTickMargin = 2;
        const fromBottomMargin = 6;
        const y1 = h1 + betweenTickMargin;
        const y2 = this.frameHeightSelected - fromBottomMargin;
        const y3 = h2 + betweenTickMargin;
        const pointList = [
            [xLow, y1],
            [xLow, y2],
            [xHigh, y2],
            [xHigh, y3]
        ];
        const lineFunction = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .curve(d3.curveBasis);
        const path = lineFunction(pointList);
        svgContainer.selectAll('.hoverBar')
            .data([path])
            .join('path')
            .attr('d', path)
            .classed('hoverBar', true);
    }
    removeHoverBar(svgContainer) {
        svgContainer.selectAll('.hoverBar').remove();
    }
    updateAllExtractedDots() {
        if (!this.imageStackWidget.inCondensedMode) {
            return;
        }
        // todo this should be more targeted.
        this.draw();
        // this.drawExtractedDots(d3.select(svgElement), locId, this.imageStackWidget.exemplarFrames.get(locId));
    }
    drawExtractedDots(svgContainer, locationId, frameSet) {
        let frameList = Array.from(frameSet);
        let xyList = frameList.map(frame => this.getDotCenters(locationId, frame)[0]);
        const dotR = 1.5;
        svgContainer.selectAll('.extractDot')
            .data(xyList)
            .join('circle')
            .classed('extractDot', true)
            .attr('cx', d => d[0])
            .attr('cy', d => d[1])
            .attr('fill', '#ECECEC')
            .attr('stroke', 'black')
            .attr('r', dotR)
            .attr('opacity', 0.6)
            .attr('stroke-width', 0.5);
    }
    drawHoverDots(svgContainer, locationId, frameId) {
        const xyPositions = this.getDotCenters(locationId, frameId);
        const dotR = 2;
        svgContainer.selectAll('.hoverDot')
            .data(xyPositions)
            .join('circle')
            .classed('hoverDot', true)
            .attr('cx', d => d[0])
            .attr('cy', d => d[1])
            .attr('fill', '#ECECEC')
            .attr('stroke', 'black')
            .attr('r', dotR)
            .attr('stroke-width', 0.5);
    }
    drawSelectedDots() {
        if (!this.frameScaleX) {
            return;
        }
        const [locationId, frameId] = this.selectedLocFrame;
        const xyPositions = this.getDotCenters(locationId, frameId);
        const dotR = 3;
        const svgContainer = d3.select('#frameTicksViz-' + locationId);
        svgContainer.selectAll('.selectedDot')
            .data(xyPositions)
            .join('circle')
            .classed('selectedDot', true)
            .attr('cx', d => d[0])
            .attr('cy', d => d[1])
            .attr('fill', 'black')
            .attr('stroke', 'black')
            .attr('r', dotR)
            .attr('stroke-width', 0.5);
    }
    getDotCenters(locationId, frameId) {
        const frame = this.imageMetaData.locationLookup.get(locationId).frameLookup.get(frameId);
        const xPos = this.frameScaleX(frameId);
        const tickHeight = this.frameScaleHeight(frame.inBrushCount);
        const dotR = 2;
        const dotMargin = 3;
        const margin = (this.frameHeight - tickHeight) / 2;
        const yPos1 = margin - dotR - dotMargin;
        const yPos2 = margin + tickHeight + dotR + dotMargin;
        return [[xPos, yPos1], [xPos, yPos2]];
    }
    removeHoverDots(svgContainer) {
        svgContainer.selectAll('.hoverDot').remove();
    }
    removeCurrentSelectedDots() {
        const svgContainer = d3.select('#frameTicksViz-' + this.selectedLocFrame[0]);
        svgContainer.selectAll('.selectedDot').remove();
    }
    onClickLocation(locationId) {
        if (locationId === this.selectedLocationId) {
            return;
        }
        this.changeLocationSelection(locationId);
        const skipImageTrackDraw = true;
        this.setImageStackWidget(skipImageTrackDraw);
    }
    onClickLocationFrame(locationId, frameId) {
        let [oldLocId, oldFrameId] = this.selectedLocFrame;
        if (oldLocId === locationId && oldFrameId === frameId) {
            return;
        }
        this.onClickLocation(locationId);
        this.imageStackWidget.changeSelectedImage(frameId - 1); // matlab
        this.updateSelectedDots(locationId, frameId);
        this.imageStackWidget.imageTrackWidget.updateCurrentFrameIndicator(frameId);
    }
    updateSelectedDots(locationId, frameId) {
        this.removeCurrentSelectedDots();
        this._selectedLocFrame = [locationId, frameId];
        this.drawSelectedDots();
    }
    createTooltipContent(locationId, frameId) {
        const labelValueList = [
            ['Location', locationId.toString()],
            ['Frame', frameId.toString()],
        ];
        return RichTooltip_1.RichTooltip.createLabelValueListContent(labelValueList);
    }
    hideFrameTooltip() {
        this.frameTooltip.Hide();
    }
    getFrameList(locationId) {
        const imageLocation = this.imageMetaData.locationLookup.get(locationId);
        return imageLocation.frameList;
    }
    changeLocationSelection(newId) {
        let lastSelected = d3.select("#imageLocation-" + this.selectedLocationId);
        lastSelected.classed('selected', false);
        let lastSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.selectedLocationId);
        lastSelectedFrameTickViz.attr('height', this.frameHeight);
        this._selectedLocationId = newId;
        let newSelected = d3.select("#imageLocation-" + this.selectedLocationId);
        newSelected.classed('selected', true);
        let newSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.selectedLocationId);
        newSelectedFrameTickViz.attr('height', this.frameHeightSelected);
    }
    changeHoveredLocation(newId) {
        if (this.hoveredLocationId !== null) {
            let lastSelected = d3.select("#imageLocation-" + this.hoveredLocationId);
            lastSelected.classed('hovered', false);
            if (this.hoveredLocationId !== this.selectedLocationId) {
                let lastSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.hoveredLocationId);
                lastSelectedFrameTickViz.attr('height', this.frameHeight);
            }
        }
        this._hoveredLocationId = newId;
        if (this.hoveredLocationId !== null) {
            let newSelected = d3.select("#imageLocation-" + this.hoveredLocationId);
            newSelected.classed('hovered', true);
            let newSelectedFrameTickViz = d3.select('#frameTicksViz-' + this.hoveredLocationId);
            newSelectedFrameTickViz.attr('height', this.frameHeightSelected);
        }
    }
}
exports.ImageSelectionWidget = ImageSelectionWidget;

},{"../DataModel/ImageMetaData":109,"../DataModel/ImageStackDataRequest":110,"../devlib/DevlibMath":115,"../devlib/DevlibTSUtil":116,"./BaseWidget":84,"./GroupByWidget":86,"./ImageStackWidget":89,"./RichTooltip":94,"d3":42}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const quickSelect = require("quickselect.js");
const RichTooltip_1 = require("../Components/RichTooltip");
const ImageTrackWidget_1 = require("./ImageTrackWidget");
const ImageStackDataRequest_1 = require("../DataModel/ImageStackDataRequest");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class ImageStackWidget {
    constructor(container, imageTrackContainer, maxHeight, samplingStratOptions) {
        this._container = container;
        this._imageTrackWidget = new ImageTrackWidget_1.ImageTrackWidget(imageTrackContainer, this, samplingStratOptions);
        this._maxHeight = maxHeight;
        this.init();
        this._cellHovered = 0;
        this._selectedImgIndex = 0;
        console.log(d3);
        console.log(this);
        this._tooltip = new RichTooltip_1.RichTooltip();
        this._exemplarAttribute = 'Avg. Mass (pg)'; // TODO change default
        this._inExemplarMode = true;
        this._inCondensedMode = true;
        this._condensedModeCount = 7;
        this._exemplarLocations = new Set();
        this._exemplarFrames = new Map();
        this._colorLookup = new Map();
        this._facetList = [];
        this._manuallyPinnedTracks = [];
        this._mousePos = null;
        this.setNumExemplars();
    }
    setNumExemplars() {
        const currentStrat = this.imageTrackWidget.currentSamplingStategy.strat;
        if (Array.isArray(currentStrat)) {
            this._numExemplars = currentStrat.length;
        }
        else {
            this._numExemplars = currentStrat;
        }
        this._numExemplars += this.imageTrackWidget.manualSampleValues.length;
    }
    get container() {
        return this._container;
    }
    get imageTrackWidget() {
        return this._imageTrackWidget;
    }
    get maxHeight() {
        return this._maxHeight;
    }
    get imageLocation() {
        return this._imageLocation;
    }
    get imageStackBlob() {
        return this._imageStackBlob;
    }
    get numPixelsInTile() {
        var _a, _b;
        return ((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth) * ((_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight);
    }
    get firstIndex() {
        return this.numPixelsInTile * this.selectedImgIndex;
    }
    get imageStackLabelUrl() {
        return this._imageStackLabelUrl;
    }
    get imageStackWidth() {
        return this._imageStackWidth;
    }
    get imageStackHeight() {
        return this._imageStackHeight;
    }
    get selectedImgIndex() {
        return this._selectedImgIndex;
    }
    get innerContainer() {
        return this._innerContainer;
    }
    get conditionLabel() {
        return this._conditionLabel;
    }
    get locationLabel() {
        return this._locationLabel;
    }
    get frameLabel() {
        return this._frameLabel;
    }
    get toggleOptionsContainer() {
        return this._toggleOptionsContainer;
    }
    get legendToggleContainer() {
        return this._legendToggleContainer;
    }
    get showOutlineToggle() {
        return this._showOutlineToggle;
    }
    get invertImageToggle() {
        return this._invertImageToggle;
    }
    get legendToggleSelected() {
        return this._legendToggleSelected;
    }
    get legendToggleFilteredOut() {
        return this._legendToggleFilteredOut;
    }
    get legendToggleNotSelected() {
        return this._legendToggleNotSelected;
    }
    get imageAndLegendContainer() {
        return this._imageAndLegendContainer;
    }
    get selectedImageContainer() {
        return this._selectedImageContainer;
    }
    get selectedImageCanvas() {
        return this._selectedImageCanvas;
    }
    get canvasContext() {
        return this._canvasContext;
    }
    get data() {
        return this._data;
    }
    get fullData() {
        return this._fullData;
    }
    get imageStackDataRequest() {
        return this._imageStackDataRequest;
    }
    get defaultCanvasState() {
        return this._defaultCanvasState;
    }
    get cellHovered() {
        return this._cellHovered;
    }
    get tooltip() {
        return this._tooltip;
    }
    get exemplarAttribute() {
        return this._exemplarAttribute;
    }
    get inExemplarMode() {
        return this._inExemplarMode;
    }
    get inCondensedMode() {
        return this._inCondensedMode;
    }
    get condensedModeCount() {
        return this._condensedModeCount;
    }
    get exemplarLocations() {
        return this._exemplarLocations;
    }
    get exemplarFrames() {
        return this._exemplarFrames;
    }
    get facetList() {
        return this._facetList;
    }
    get colorLookup() {
        return this._colorLookup;
    }
    get numExemplars() {
        return this._numExemplars;
    }
    get manuallyPinnedTracks() {
        return this._manuallyPinnedTracks;
    }
    get mousePos() {
        return this._mousePos;
    }
    init() {
        const containerSelect = d3.select(this.container);
        const locationFrameLabelContainer = containerSelect.append('div')
            .classed('locationFrameLabelContainer', true);
        this._innerContainer = containerSelect.append('div')
            .classed('innerContainer', true);
        const locationFrameLabel = locationFrameLabelContainer.append('h3')
            .classed('locationFrameLabel', true);
        locationFrameLabel.node().append('Condition: ');
        this._conditionLabel = locationFrameLabel.append('span')
            .classed('locationFrameLabelValue', true);
        locationFrameLabel.node().append('Location: ');
        this._locationLabel = locationFrameLabel.append('span')
            .classed('locationFrameLabelValue', true);
        locationFrameLabel.node().append('Frame: ');
        this._frameLabel = locationFrameLabel.append('span')
            .classed('locationFrameLabelValue', true);
        this.innerContainer.append('div').attr('style', 'flex-grow: 1;');
        this._toggleOptionsContainer = this.innerContainer.append('div')
            .classed('toggleOptions', true)
            .classed('smallText', true);
        const outlineId = 'imageToggle-outlines';
        this._showOutlineToggle = this.toggleOptionsContainer.append('input')
            .attr('type', 'checkbox')
            .on('change', () => {
            this.OnBrushChange();
        })
            .attr('id', outlineId);
        this.toggleOptionsContainer.append('label')
            .attr('for', outlineId)
            .text('Show Outlines');
        this.showOutlineToggle.node().checked = true;
        const invertId = 'imageToggle-invert';
        this._invertImageToggle = this.toggleOptionsContainer.append('input')
            .attr('type', 'checkbox')
            .on('change', () => {
            let node = document.getElementById(invertId);
            this.selectedImageContainer.classed('invert', node.checked);
            this.selectedImageCanvas.classed('invert', node.checked);
            this.updateCanvas();
        })
            .attr('id', invertId);
        this.toggleOptionsContainer.append('label')
            .attr('for', invertId)
            .text('Invert');
        this._imageAndLegendContainer = this.innerContainer.append('div')
            .classed('imageAndLegendContainer', true);
        this._selectedImageContainer = this.imageAndLegendContainer.append('div')
            .classed('noShrink', true);
        this.innerContainer.append('div').attr('style', 'flex-grow: 2;');
        this._selectedImageCanvas = this.selectedImageContainer.append('canvas');
        this.selectedImageCanvas.node().addEventListener('mousemove', (e) => {
            this.onCanvasMouseMove(e);
        });
        this.selectedImageCanvas.node().addEventListener('click', (e) => {
            this.onCanvasClick(e);
        });
        this._canvasContext = this.selectedImageCanvas.node().getContext('2d');
        this.selectedImageContainer
            .on('mouseleave', () => {
            this._mousePos = null;
            this.hideSegmentHover();
        });
        // add three toggles for a legend and to hide only some outlines
        this._legendToggleContainer = this.imageAndLegendContainer.append('div')
            .classed('toggleOptions', true)
            .classed('vertical', true)
            .classed('smallText', true);
        this.legendToggleContainer.append('div').attr('style', 'flex-grow: 1;'); // to center legend.
        this._legendToggleSelected = this.legendToggleContainer.append('input')
            .attr('type', 'checkbox')
            .on('change', () => {
            this.OnBrushChange();
        })
            .classed('noDisp', true)
            .attr('id', 'legendToggle-selected');
        this.legendToggleContainer.append('label')
            .attr('for', 'legendToggle-selected')
            .classed('colorLegendLabel', true)
            .classed('red', true)
            .text('Selected');
        this.legendToggleSelected.node().checked = true;
        this._legendToggleFilteredOut = this.legendToggleContainer.append('input')
            .attr('type', 'checkbox')
            .on('change', () => {
            this.OnBrushChange();
        })
            .classed('noDisp', true)
            .attr('id', 'legendToggle-filteredOut');
        this.legendToggleContainer.append('label')
            .attr('for', 'legendToggle-filteredOut')
            .classed('colorLegendLabel', true)
            .classed('green', true)
            .text('Filtered Out');
        this.legendToggleFilteredOut.node().checked = true;
        this._legendToggleNotSelected = this.legendToggleContainer.append('input')
            .attr('type', 'checkbox')
            .on('change', () => {
            this.OnBrushChange();
        })
            .classed('noDisp', true)
            .attr('id', 'legendToggle-notSelected');
        this.legendToggleContainer.append('label')
            .attr('for', 'legendToggle-notSelected')
            .classed('colorLegendLabel', true)
            .classed('blue', true)
            .text('Not Selected');
        this.legendToggleNotSelected.node().checked = true;
        this.legendToggleContainer.append('div').attr('style', 'flex-grow: 1;'); // to center legend.
        this.imageTrackWidget.init();
        document.addEventListener('samplingStrategyChange', (e) => {
            this.setNumExemplars();
            this.updateTracksCanvas();
            document.dispatchEvent(new CustomEvent('imageSelectionRedraw'));
        });
        document.addEventListener('launchExemplarCurve', (e) => {
            this._exemplarAttribute = e.detail;
            this.imageTrackWidget.manualSampleValues = [];
            this.setNumExemplars();
            let buttonChangeEvent = new CustomEvent('changeModeSelect', { detail: 0 });
            document.dispatchEvent(buttonChangeEvent);
            let modeChangeEvent = new CustomEvent('modeChange', {
                detail: {
                    inCondensedMode: true,
                    inExemplarMode: true
                }
            });
            document.dispatchEvent(modeChangeEvent);
        });
        document.addEventListener('modeChange', (e) => {
            this._inExemplarMode = e.detail.inExemplarMode;
            this._inCondensedMode = e.detail.inCondensedMode;
            this.updateTracksCanvas();
            document.dispatchEvent(new CustomEvent('imageSelectionRedraw'));
            document.dispatchEvent(new CustomEvent('exemplarAttributeChange', { detail: this.inExemplarMode ? this.exemplarAttribute : null }));
        });
        document.addEventListener('groupByChanged', async (e) => {
            let popupContainer = d3.select('#largePopupContainerOuter');
            if (!popupContainer.empty() && !popupContainer.classed('noDisp')) {
                return;
            }
            DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
            await DevlibTSUtil_1.DevlibTSUtil.makeAsync(() => this._facetList = e.detail.flatFacetList);
            this._colorLookup = e.detail.colorLookup;
            this.updateTracksCanvas();
            document.dispatchEvent(new CustomEvent('imageSelectionRedraw'));
        });
    }
    SetData(data, fullData, imageLocation, imageStackDataRequest, skipImageTrackDraw = false) {
        this._data = data;
        this._fullData = fullData;
        this._imageStackDataRequest = imageStackDataRequest;
        this._selectedImgIndex = 0;
        this._imageLocation = imageLocation;
        this.SetImageProperties(skipImageTrackDraw); // default values before image load
        this.draw(skipImageTrackDraw);
        document.dispatchEvent(new CustomEvent('exemplarAttributeChange', { detail: this.inExemplarMode ? this.exemplarAttribute : null }));
    }
    SetImageProperties(skipImageTrackDraw, blob, imageWidth, imageHeight, numColumns, scaleFactor) {
        // default values for when loading, or if image isn't found
        if (!imageWidth) {
            imageWidth = 256;
        }
        if (!imageHeight) {
            imageHeight = 256;
        }
        if (!numColumns) {
            numColumns = 10;
        }
        this._imageStackBlob = blob;
        this.draw(skipImageTrackDraw);
    }
    draw(skipImageTrackDraw = false) {
        this.drawSelectedImage(skipImageTrackDraw);
        this.updateLocationFrameLabel();
    }
    OnBrushChange() {
        this.draw(true);
        this.imageTrackWidget.OnBrushChange();
    }
    drawUpdate() {
        this.updateBackgroundPosition(this.selectedImgIndex);
        this.updateCanvas(this.inExemplarMode);
        this.updateLocationFrameLabel();
        this.updateBasedOnMousePosition(true);
    }
    drawSelectedImage(skipImageTrackDraw = false) {
        this.setImageInlineStyle(this.selectedImgIndex);
        this.updateCanvas(skipImageTrackDraw);
    }
    updateLocationFrameLabel() {
        const locId = this.getCurrentLocationId();
        const labelList = this.fullData.inverseLocationMap.get(locId);
        this.conditionLabel.text(labelList.join(' '));
        this.locationLabel.text(locId);
        this.frameLabel.text(this.getCurrentFrameId());
    }
    getCurrentLocationId() {
        return this.imageLocation.locationId;
    }
    getCurrentFrameId() {
        return this.selectedImgIndex + 1;
    }
    updateCanvas(skipImageTrackDraw = false) {
        var _a, _b, _c;
        if (!this.imageStackDataRequest) {
            return;
        }
        this.selectedImageCanvas
            .attr('width', (_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth)
            .attr('height', (_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight);
        if (this.showOutlineToggle.node().checked) {
            (_c = this.imageStackDataRequest) === null || _c === void 0 ? void 0 : _c.getLabel(this.getCurrentLocationId(), this.selectedImgIndex, (data, firstIndex) => {
                this.createOutlineImage(data, firstIndex);
                this.drawDefaultCanvas();
            });
        }
        else {
            this.clearCanvas();
        }
        this.drawPinnedCellMarkers();
        let locId = this.imageLocation.locationId;
        if (!skipImageTrackDraw) {
            this.updateTracksCanvas();
        }
    }
    updateTracksCanvas() {
        let autoCurveList;
        let eventToDispatch = null;
        if (this.inExemplarMode) {
            this.exemplarLocations.clear();
            this.exemplarFrames.clear();
            autoCurveList = this.getExemplarCurves();
            let justData = autoCurveList.map(d => d.data);
            for (let curveList of [justData, this.manuallyPinnedTracks]) {
                for (let curve of curveList) {
                    const firstPoint = curve.pointList[0];
                    const locId = firstPoint.get('Location ID');
                    this.exemplarLocations.add(locId);
                    if (!this.exemplarFrames.has(locId)) {
                        this.exemplarFrames.set(locId, new Set());
                    }
                    let frameSet = this.exemplarFrames.get(locId);
                    for (let i = 0; i < this.condensedModeCount; i++) {
                        const point = this.imageTrackWidget.getPointInCondensedMode(curve, i);
                        const frame = point.get('Frame ID');
                        frameSet.add(frame);
                    }
                }
            }
            if (!this.exemplarLocations.has(this.getCurrentLocationId())) {
                eventToDispatch = new CustomEvent('locFrameClicked', { detail: {
                        locationId: justData[0].pointList[0].get('Location ID'),
                        frameId: justData[0].pointList[0].get('Frame ID')
                    } });
            }
        }
        else {
            autoCurveList = this.getCurvesBasedOnPointsAtCurrentFrame();
            this.exemplarLocations.clear();
            this.exemplarFrames.clear();
        }
        this.imageTrackWidget.draw(autoCurveList, this.manuallyPinnedTracks);
        if (eventToDispatch) {
            document.dispatchEvent(eventToDispatch);
        }
    }
    getExemplarCurves() {
        let curveList = [];
        const trackLengthKey = 'Track Length';
        for (let facet of this.facetList) {
            let facetData = facet.data;
            let tracks = facetData.curveList;
            let numCurves = tracks.length;
            const samplingStat = this.imageTrackWidget.currentSamplingStategy.strat;
            let percentages;
            if (Array.isArray(samplingStat)) {
                percentages = samplingStat;
            }
            else {
                percentages = [];
                for (let i = 0; i < samplingStat; i++) {
                    percentages.push(Math.random());
                }
            }
            const conditionList = [];
            for (let p of percentages) {
                let index = Math.round((numCurves - 1) * p);
                let exemplarCurve = quickSelect(tracks, index, (curve) => curve.get(this.exemplarAttribute));
                conditionList.push({ data: exemplarCurve, type: 'auto' });
            }
            for (let val of this.imageTrackWidget.manualSampleValues) {
                let closestCurve = this.getClosestCurve(tracks, val, this.exemplarAttribute);
                conditionList.push({ data: closestCurve, type: 'manual', anchorVal: val });
            }
            conditionList.sort((a, b) => a.data.get(this.exemplarAttribute) - b.data.get(this.exemplarAttribute));
            curveList.push(...conditionList);
        }
        return curveList;
    }
    getClosestCurve(curveList, value, attribute) {
        let closestCurve = null;
        let smallestDifference = Infinity;
        for (let curve of curveList) {
            let diff = Math.abs(curve.get(attribute) - value);
            if (diff < smallestDifference) {
                smallestDifference = diff;
                closestCurve = curve;
            }
        }
        return closestCurve;
    }
    getCurvesBasedOnPointsAtCurrentFrame() {
        let curveList = [];
        const pointsAtFrame = this.data.GetCellsAtFrame(this.getCurrentLocationId(), this.getCurrentFrameId());
        for (let point of pointsAtFrame) {
            curveList.push({ data: point.parent, type: 'auto' });
        }
        return curveList;
    }
    createOutlineImage(rowArray, firstIndex) {
        if (!this.imageStackDataRequest) {
            return;
        }
        let myImageData = this.canvasContext.createImageData(this.imageStackDataRequest.tileWidth, this.imageStackDataRequest.tileHeight);
        for (let rowIdx = firstIndex; rowIdx < firstIndex + this.imageStackDataRequest.tileHeight; rowIdx++) {
            let row = rowArray.rowList[rowIdx];
            for (let labelRun of row.row) {
                for (let colIdx = labelRun.start; colIdx < labelRun.start + labelRun.length; colIdx++) {
                    if (this.isBorder(labelRun.label, rowIdx, colIdx, rowArray)) {
                        let flatIdx = (rowIdx - firstIndex) * this.imageStackDataRequest.tileWidth + colIdx;
                        flatIdx *= 4;
                        let [cell, _index] = this.getCell(labelRun.label, this.data);
                        let { color: color, show: show } = this.getCellColor(cell);
                        if (show) {
                            let [r, g, b] = color;
                            myImageData.data[flatIdx] = r;
                            myImageData.data[flatIdx + 1] = g;
                            myImageData.data[flatIdx + 2] = b;
                            myImageData.data[flatIdx + 3] = 255;
                        }
                    }
                }
            }
        }
        this._defaultCanvasState = myImageData;
    }
    drawDefaultCanvas() {
        if (this.defaultCanvasState) {
            this.canvasContext.putImageData(this.defaultCanvasState, 0, 0);
        }
    }
    drawPinnedCellMarkers() {
        for (let track of this.manuallyPinnedTracks) {
            for (let point of track.pointList) {
                if (point.get('Location ID') !== this.getCurrentLocationId()) {
                    break;
                }
                if (point.get('Frame ID') === this.getCurrentFrameId()) {
                    this.drawCellCenter(point, 3);
                }
            }
        }
    }
    clearCanvas() {
        this.canvasContext.clearRect(0, 0, this.imageStackWidth, this.imageStackHeight);
        this._defaultCanvasState = this.canvasContext.createImageData(this.imageStackDataRequest.tileWidth, this.imageStackDataRequest.tileHeight);
    }
    isBorder(label, rowIdx, colIdx, rowArray) {
        let neighborIndices = [];
        // 4-neighbor
        neighborIndices.push([rowIdx - 1, colIdx]);
        neighborIndices.push([rowIdx + 1, colIdx]);
        neighborIndices.push([rowIdx, colIdx - 1]);
        neighborIndices.push([rowIdx, colIdx + 1]);
        // 8-neighbor
        neighborIndices.push([rowIdx - 1, colIdx - 1]);
        neighborIndices.push([rowIdx + 1, colIdx - 1]);
        neighborIndices.push([rowIdx + 1, colIdx - 1]);
        neighborIndices.push([rowIdx - 1, colIdx + 1]);
        // 12-neighbor
        neighborIndices.push([rowIdx - 2, colIdx]);
        neighborIndices.push([rowIdx + 2, colIdx]);
        neighborIndices.push([rowIdx, colIdx - 2]);
        neighborIndices.push([rowIdx, colIdx + 2]);
        for (let [rI, cI] of neighborIndices) {
            if (rI < 0
                || rI >= rowArray.rowList.length
                || cI < 0
                || cI >= this.imageStackDataRequest.tileWidth) {
                // neighbor out of bounds of tile
                continue;
            }
            let nVal = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rI, cI, rowArray);
            if (nVal !== label) {
                return true;
            }
        }
        return false;
    }
    onCanvasMouseMove(e) {
        if (!this.imageStackDataRequest || !this.defaultCanvasState) {
            return;
        }
        this._mousePos = { offset: [e.offsetX, e.offsetY], page: [e.pageX, e.pageY] };
        this.updateBasedOnMousePosition();
    }
    updateBasedOnMousePosition(forceDraw = false) {
        if (this.mousePos === null) {
            this.hideSegmentHover();
            return;
        }
        this.imageStackDataRequest.getLabel(this.getCurrentLocationId(), this.selectedImgIndex, (rowArray, firstIndex) => {
            const rowIdx = this.mousePos.offset[1] + firstIndex;
            const colIdx = this.mousePos.offset[0];
            const label = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rowIdx, colIdx, rowArray);
            if (label === this.cellHovered && !forceDraw) {
                return;
            }
            this._cellHovered = label;
            if (label === 0) {
                this.drawDefaultCanvas();
                this.drawPinnedCellMarkers();
                this.tooltip.Hide();
                const customEvent = new CustomEvent('frameHoverChange', {
                    detail: {
                        locationId: this.getCurrentLocationId(),
                        frameId: this.getCurrentFrameId(),
                        cellId: null
                    }
                });
                document.dispatchEvent(customEvent);
            }
            else {
                this.showSegmentHover(rowArray, label, firstIndex, forceDraw);
            }
        });
    }
    onCanvasClick(e) {
        if (!this.imageStackDataRequest || !this.defaultCanvasState) {
            return;
        }
        this.imageStackDataRequest.getLabel(this.getCurrentLocationId(), this.selectedImgIndex, (rowArray, firstIndex) => {
            const rowIdx = e.offsetY + firstIndex;
            const colIdx = e.offsetX;
            const label = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rowIdx, colIdx, rowArray);
            let [cell, _index] = this.getCell(label, this.fullData);
            if (cell) {
                const track = cell.parent;
                this.togglePin(track);
            }
        });
    }
    togglePin(track) {
        if (this.manuallyPinnedTracks.includes(track)) {
            const index = this.manuallyPinnedTracks.indexOf(track);
            this.manuallyPinnedTracks.splice(index, 1);
        }
        else {
            this.manuallyPinnedTracks.unshift(track);
        }
        this.updateCanvas();
        const manualPinToggleEvent = new CustomEvent('manualPinToggle', { detail: this.manuallyPinnedTracks });
        document.dispatchEvent(manualPinToggleEvent);
    }
    hideSegmentHover(hideTooltipImmediately = false) {
        this.drawDefaultCanvas();
        this.drawPinnedCellMarkers();
        let delayOverride;
        if (hideTooltipImmediately) {
            delayOverride = 0;
        }
        this.tooltip.Hide(delayOverride);
    }
    showSegmentHover(rowArray, segmentId, firstIndex, showTooltipImmediately = false) {
        var _a, _b;
        this._cellHovered = segmentId;
        let [cell, index] = this.getCell(segmentId, this.fullData);
        let cellX = 0;
        let cellY = 0;
        let pageX = 0;
        let pageY = 0;
        if (cell) {
            let canvasBoundRect = this.selectedImageCanvas.node().getBoundingClientRect();
            cellX = (cell.get('X') + cell.get('xShift')) / this.imageStackDataRequest.scaleFactor;
            cellY = (cell.get('Y') + cell.get('yShift')) / this.imageStackDataRequest.scaleFactor;
            pageX = canvasBoundRect.x + cellX;
            pageY = canvasBoundRect.y + cellY;
            const customEvent = new CustomEvent('frameHoverChange', {
                detail: {
                    locationId: this.getCurrentLocationId(),
                    frameId: this.getCurrentFrameId(),
                    cellId: cell.parent.id
                }
            });
            document.dispatchEvent(customEvent);
        }
        else if (this.mousePos) {
            pageX = this.mousePos.page[0];
            pageY = this.mousePos.page[1];
        }
        let myImageData = this.canvasContext.createImageData((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth, (_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight);
        myImageData.data.set(this.defaultCanvasState.data);
        for (let rowIdx = firstIndex; rowIdx < firstIndex + this.imageStackDataRequest.tileHeight; rowIdx++) {
            let row = rowArray.rowList[rowIdx];
            for (let labelRun of row.row) {
                if (labelRun.label === this.cellHovered) {
                    for (let colIdx = labelRun.start; colIdx < labelRun.start + labelRun.length; colIdx++) {
                        let flatIdx = (rowIdx - firstIndex) * this.imageStackDataRequest.tileWidth + colIdx;
                        flatIdx *= 4;
                        let [cell, _index] = this.getCell(labelRun.label, this.data);
                        let { color: color, show: show } = this.getCellColor(cell);
                        let [r, g, b] = color;
                        myImageData.data[flatIdx] = r;
                        myImageData.data[flatIdx + 1] = g;
                        myImageData.data[flatIdx + 2] = b;
                        myImageData.data[flatIdx + 3] = 200;
                    }
                }
            }
        }
        this.canvasContext.putImageData(myImageData, 0, 0);
        this.drawPinnedCellMarkers();
        this.drawCellCenter(cell, 5);
        let tooltipContent = this.getTooltipContent(segmentId, cell, index);
        let delayOverride;
        if (showTooltipImmediately) {
            delayOverride = 0;
        }
        this.tooltip.Show(tooltipContent, pageX, pageY, delayOverride);
    }
    drawCellCenter(cell, radius) {
        if (cell) {
            let cellX = (cell.get('X') + cell.get('xShift')) / this.imageStackDataRequest.scaleFactor;
            let cellY = (cell.get('Y') + cell.get('yShift')) / this.imageStackDataRequest.scaleFactor;
            this.canvasContext.beginPath();
            this.canvasContext.arc(cellX, cellY, radius, 0, 2 * Math.PI);
            this.canvasContext.strokeStyle = 'black';
            this.canvasContext.stroke();
            this.canvasContext.fillStyle = '#FF00FF';
            this.canvasContext.fill();
        }
    }
    getLabelIndexFromBigImgPixelXY(frameIndex, x, y) {
        var _a, _b, _c, _d;
        x = Math.round(x);
        y = Math.round(y);
        let colIdx = x % ((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth);
        let rowIdx = (y % ((_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight)) + (frameIndex % ((_c = this.imageStackDataRequest) === null || _c === void 0 ? void 0 : _c.tilesPerFile)) * ((_d = this.imageStackDataRequest) === null || _d === void 0 ? void 0 : _d.tileHeight);
        return [rowIdx, colIdx];
    }
    getTileIndexFromBigImgPixelXY(x, y) {
        var _a, _b, _c;
        let colIndex = Math.floor(x / ((_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth));
        let rowIndex = Math.floor(y / ((_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight));
        return rowIndex * ((_c = this.imageStackDataRequest) === null || _c === void 0 ? void 0 : _c.numberOfColumns) + colIndex;
    }
    getTooltipContent(label, cell, index) {
        var _a, _b;
        let labelValuePairs = [];
        let cellId = (_b = (_a = cell) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.id;
        if (cellId) {
            for (let key of ['X', 'Y', 'Mass (pg)', 'Area', 'Mean Intensity']) {
                let value = cell.get(key);
                if (typeof value !== 'undefined') {
                    labelValuePairs.push([key, value.toFixed(1)]);
                }
            }
            labelValuePairs.push(['Row', index.toString()]);
            labelValuePairs.push(['Segment', label.toString()]);
        }
        else {
            labelValuePairs.push(['Segment', label.toString()]);
            labelValuePairs.push(['No cell linked', null]);
        }
        return RichTooltip_1.RichTooltip.createLabelValueListContent(labelValuePairs);
    }
    getCell(label, dataSource) {
        return dataSource.GetCellFromLabel(this.getCurrentLocationId(), this.getCurrentFrameId(), label);
    }
    getCellColor(cell) {
        let color = [0, 0, 0];
        let show;
        if (!cell) {
            // nuted/darkened from SpringGreen
            color = [119, 140, 77];
            show = this.legendToggleFilteredOut.node().checked;
        }
        else if (cell.inBrush) {
            // FireBrick
            color = [178, 34, 34];
            show = this.legendToggleSelected.node().checked;
        }
        else {
            // SteelBlue
            color = [70, 130, 180];
            show = this.legendToggleNotSelected.node().checked;
        }
        return { color: color, show: show };
    }
    changeSelectedImage(newIndex) {
        this._selectedImgIndex = newIndex;
        this.drawUpdate();
    }
    setImageInlineStyle(index, includeFallback = true) {
        var _a;
        (_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.getImage(this.getCurrentLocationId(), index, (top, left, _blob, imageUrl) => {
            var _a, _b;
            let styleString = `
					background-position-x: ${-left}px;
					background-position-y: ${-top}px;
					width: ${(_a = this.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileWidth}px;
					height: ${(_b = this.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileHeight}px;
					`;
            if (imageUrl) {
                styleString += `background-image: url(${imageUrl});`;
            }
            if (includeFallback) {
                styleString += 'background-color: #ebebeb;';
            }
            this.selectedImageContainer.attr("style", styleString);
        });
    }
    updateBackgroundPosition(index) {
        this.setImageInlineStyle(index);
        return;
    }
    OnResize(newMaxHeight, imageTrackMaxHeight, newWidth) {
        this._maxHeight = newMaxHeight;
        this.container.setAttribute('style', `max-height: ${this.maxHeight}px;`);
        this.imageTrackWidget.OnResize(newWidth, imageTrackMaxHeight);
    }
}
exports.ImageStackWidget = ImageStackWidget;

},{"../Components/RichTooltip":94,"../DataModel/ImageStackDataRequest":110,"../devlib/DevlibTSUtil":116,"./ImageTrackWidget":90,"d3":42,"quickselect.js":80}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const number_to_words_1 = require("number-to-words");
const DevlibMath_1 = require("../devlib/DevlibMath");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const ImageStackDataRequest_1 = require("../DataModel/ImageStackDataRequest");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const CurveList_1 = require("../DataModel/CurveList");
const HistogramWidget_1 = require("./HistogramWidget");
const OptionSelect_1 = require("./OptionSelect");
const GroupByWidget_1 = require("./GroupByWidget");
class ImageTrackWidget {
    constructor(container, parent, samplingStratOptions) {
        this._container = container;
        this._parentWidget = parent;
        this._verticalPad = 24;
        this._horizontalPad = 8;
        this._trackToPlotPadding = 48;
        this._exemplarMinWidth = 80;
        this._minHeightForFavorites = 120 + 2 * this.verticalPad;
        this._frameLabelPositions = [];
        this._cellLabelPositions = [];
        this._exemplarYKey = 'Mass_norm';
        this._samplingStratOptions = samplingStratOptions;
        this._smoothCurves = true;
        this._draggingPin = false;
        // hardcoded from css
        this._cellTimelineMargin = {
            top: 36,
            right: 4,
            bottom: 4,
            left: 124
        };
        this._latestScroll = [0, 0];
        this._scrollChangeTicking = false;
        this._sourceDestCell = [];
        this._histogramScaleYList = [];
    }
    get container() {
        return this._container;
    }
    get parentWidget() {
        return this._parentWidget;
    }
    get innerContainer() {
        return this._innerContainer;
    }
    get innerContainerW() {
        return this._innerContainerW;
    }
    get innerContainerH() {
        return this._innerContainerH;
    }
    get titleContainer() {
        return this._titleContainer;
    }
    get samplingStrategySelect() {
        return this._samplingStrategySelect;
    }
    get samplingStratOptions() {
        return this._samplingStratOptions;
    }
    get currentSamplingStategy() {
        return this._currentSamplingStategy;
    }
    get manualSampleValues() {
        return this._manualSampleValues;
    }
    set manualSampleValues(v) {
        this._manualSampleValues = v;
    }
    get svgContainer() {
        return this._svgContainer;
    }
    get cellLabelGroup() {
        return this._cellLabelGroup;
    }
    get labelLinePad() {
        return this._labelLinePad;
    }
    get scentedWidgetGroup() {
        return this._scentedWidgetGroup;
    }
    get exemplarPinGroup() {
        return this._exemplarPinGroup;
    }
    get addPinRectGroup() {
        return this._addPinRectGroup;
    }
    get manualExemplarPinGroup() {
        return this._manualExemplarPinGroup;
    }
    get frameLabelGroup() {
        return this._frameLabelGroup;
    }
    get exemplarCurvesGroup() {
        return this._exemplarCurvesGroup;
    }
    get shameRectangle() {
        return this._shameRectangle;
    }
    get selectedImageCanvas() {
        return this._selectedImageCanvas;
    }
    get canvasContext() {
        return this._canvasContext;
    }
    get defaultCanvasState() {
        return this._defaultCanvasState;
    }
    get trackList() {
        return this._trackList;
    }
    get manuallyPinnedTracks() {
        return this._manuallyPinnedTracks;
    }
    get minHeightForFavorites() {
        return this._minHeightForFavorites;
    }
    get verticalPad() {
        return this._verticalPad;
    }
    get horizontalPad() {
        return this._horizontalPad;
    }
    get trackToPlotPadding() {
        return this._trackToPlotPadding;
    }
    get frameLabelPositions() {
        return this._frameLabelPositions;
    }
    get cellLabelPositions() {
        return this._cellLabelPositions;
    }
    get conditionLabelPositions() {
        return this._conditionLabelPositions;
    }
    get histogramScaleX() {
        return this._histogramScaleX;
    }
    get histogramScaleYList() {
        return this._histogramScaleYList;
    }
    get normalizedHistogramScaleY() {
        return this._normalizedHistogramScaleY;
    }
    get cellTimelineMargin() {
        return this._cellTimelineMargin;
    }
    get scrollChangeTicking() {
        return this._scrollChangeTicking;
    }
    get latestScroll() {
        return this._latestScroll;
    }
    get latestMouseCanvasOffset() {
        return this._latestMouseCanvasOffset;
    }
    get sourceDestCell() {
        return this._sourceDestCell;
    }
    get exemplarScaleX() {
        return this._exemplarScaleX;
    }
    get exemplarScaleY() {
        return this._exemplarScaleY;
    }
    get exemplarMinWidth() {
        return this._exemplarMinWidth;
    }
    get exemplarYKey() {
        return this._exemplarYKey;
    }
    get smoothCurves() {
        return this._smoothCurves;
    }
    get draggingPin() {
        return this._draggingPin;
    }
    get draggingPinElement() {
        return this._draggingPinElement;
    }
    get needleSelection() {
        return this._needleSelection;
    }
    get textSelection() {
        return this._textSelection;
    }
    get initialDragCoords() {
        return this._initialDragCoords;
    }
    get totalDragOffset() {
        return this._totalDragOffset;
    }
    get initialPinValue() {
        return this._initialPinValue;
    }
    get anchorPinValue() {
        return this._anchorPinValue;
    }
    get pinMoved() {
        return this._pinMoved;
    }
    get dragGroupIndex() {
        return this._dragGroupIndex;
    }
    init() {
        const containerSelect = d3.select(this.container);
        const titleBarDiv = containerSelect.append('div')
            .classed('trackModeTitleContainer', true)
            .classed('mediumText', true);
        this._titleContainer = titleBarDiv.append('span');
        const optionSelectContainer = titleBarDiv.append('span')
            .attr('id', 'exemplarSamplingStratSelection');
        this._samplingStrategySelect = new OptionSelect_1.OptionSelect('exemplarSamplingStratSelection', 'Sampled at');
        let buttonPropList = [];
        this._currentSamplingStategy = this.samplingStratOptions[0]; // default to first
        this._manualSampleValues = []; // todo remove
        for (let option of this.samplingStratOptions) {
            let optionName;
            if (option.label) {
                optionName = option.label;
            }
            else if (Array.isArray(option.strat)) {
                let optionCopy = option.strat.map(x => x);
                if (option.strat.length < 8) {
                    optionCopy = optionCopy.map(x => {
                        if (x == 0) {
                            return 'Min';
                        }
                        if (x == 0.5) {
                            return 'Median';
                        }
                        if (x == 1) {
                            return 'Max';
                        }
                        return number_to_words_1.toOrdinal(100 * x) + ' percentile';
                    });
                }
                optionName = optionCopy.join(', ');
            }
            else {
                optionName = `${option.strat} random track`;
                if (option.strat > 1) {
                    optionName += 's';
                }
            }
            let buttonProp = {
                displayName: optionName,
                callback: () => {
                    this._currentSamplingStategy = option;
                    document.dispatchEvent(new CustomEvent('samplingStrategyChange', { detail: option }));
                }
            };
            buttonPropList.push(buttonProp);
        }
        this.samplingStrategySelect.onDataChange(buttonPropList);
        this._svgContainer = containerSelect.append('svg');
        this._cellLabelGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top})`);
        this._labelLinePad = 16;
        this._scentedWidgetGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top})`);
        this._exemplarPinGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top})`);
        this._addPinRectGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top})`);
        this._manualExemplarPinGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top})`);
        const offsetToExemplarCurves = this.cellTimelineMargin.left;
        this._exemplarCurvesGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(${offsetToExemplarCurves}, ${this.cellTimelineMargin.top})`);
        this._shameRectangle = this.svgContainer.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', 10000)
            .attr('height', this.cellTimelineMargin.top)
            .attr('fill', 'white')
            .attr('stroke-width', 0);
        this._frameLabelGroup = this.svgContainer.append('g')
            .attr('transform', d => `translate(${this.cellTimelineMargin.left}, 0)`);
        this._innerContainer = containerSelect.append('div')
            .classed('cellTimelineInnerContainer', true)
            .classed('overflow-scroll', true);
        this.innerContainer.node().addEventListener('scroll', (e) => {
            this.onCellTimelineScroll(e);
        });
        this._selectedImageCanvas = this.innerContainer.append('canvas');
        const canvasElement = this.selectedImageCanvas.node();
        canvasElement.addEventListener('mousemove', (e) => this.onCanvasMouseMove(e));
        canvasElement.addEventListener('click', (e) => this.onCanvasClick(e));
        this.selectedImageCanvas.on('mouseleave', () => this.onCanvasMouseLeave());
        this._canvasContext = canvasElement.getContext('2d');
        document.addEventListener('frameHoverChange', (e) => {
            const frameId = e.detail.frameId;
            const cellId = e.detail.cellId;
            const rowIndex = e.detail.rowIndex;
            if (frameId !== null && cellId !== null) {
                let frameIndex;
                if (this.parentWidget.inCondensedMode) {
                    let curve = this.parentWidget.fullData.curveLookup.get(cellId);
                    let pointIndex = curve.pointList.findIndex(point => point.get('Frame ID') === frameId);
                    const L = curve.pointList.length - 1;
                    let percent = pointIndex / L;
                    frameIndex = percent * (this.parentWidget.condensedModeCount - 1);
                    let frameIndexRounded = Math.round(frameIndex);
                    let realPercent = frameIndexRounded / (this.parentWidget.condensedModeCount - 1);
                    const epsilon = 1 / L;
                    if (Math.abs(percent - realPercent) < epsilon) {
                        frameIndex = frameIndexRounded;
                    }
                    else {
                        frameIndex = -1;
                    }
                }
                else {
                    frameIndex = frameId - 1;
                }
                this.updateLabelsOnMouseMove(cellId, frameIndex, rowIndex);
            }
            else {
                this.updateLabelsOnMouseMove('', -1, -1);
            }
        });
        document.addEventListener('averageCurveKeyChange', (e) => {
            this._exemplarYKey = e.detail.yKey;
            this.drawExemplarGrowthCurves();
        });
        document.addEventListener('smoothCurveChange', (e) => {
            this._smoothCurves = e.detail;
            this.drawExemplarGrowthCurves();
        });
        document.addEventListener('manualPinToggle', (e) => {
            this.drawExemplarGrowthCurves();
        });
        const self = this;
        document.addEventListener('mousemove', function (e) {
            self.onDrag(e.movementX, e.movementY);
        });
        document.addEventListener('mouseup', function (e) {
            self.onDragEnd();
        });
        document.addEventListener('locFrameClicked', (e) => {
            const frameId = e.detail.frameId;
            this.updateCurrentFrameIndicator(frameId);
        });
    }
    async draw(tracks, manuallyPinnedTracks) {
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        if (!this.parentWidget.imageStackDataRequest) {
            return;
        }
        if (tracks === this.trackList) {
            return;
        }
        DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
        this._trackList = tracks;
        this._manuallyPinnedTracks = manuallyPinnedTracks;
        this.updateTitle();
        await this.drawTrackList();
        this.drawLabels();
        this.drawAllPins(tracks);
        this.drawExemplarGrowthCurves();
    }
    updateTitle() {
        if (this.parentWidget.inExemplarMode) {
            this.titleContainer.text('Exemplars of ' + this.parentWidget.exemplarAttribute + ' - ');
        }
        else {
            this.titleContainer.text('Frame Extraction Mode');
        }
    }
    OnBrushChange() {
        this.drawOutlines();
    }
    async drawTrackList() {
        const justData = this.trackList.map(d => d.data);
        const combinedTracks = [...this.manuallyPinnedTracks, ...justData];
        this._sourceDestCell = [];
        let listOfBoundingBoxLists = await this.getBoundingBoxLists(combinedTracks);
        let maxHeightList = [];
        let maxWidth = d3.max(listOfBoundingBoxLists, (rectList) => {
            return d3.max(rectList, r => ImageTrackWidget.rectWidth(r));
        });
        for (let rectList of listOfBoundingBoxLists) {
            let thisHeight = d3.max(rectList, r => ImageTrackWidget.rectHeight(r));
            maxHeightList.push(thisHeight);
        }
        let minFrameId = d3.min(combinedTracks, (track) => {
            return d3.min(track.pointList, point => point.get('Frame ID'));
        });
        let maxFrameId = d3.max(combinedTracks, (track) => {
            return d3.max(track.pointList, point => point.get('Frame ID'));
        });
        let numFrames;
        if (this.parentWidget.inCondensedMode) {
            numFrames = this.parentWidget.condensedModeCount;
        }
        else {
            numFrames = maxFrameId - minFrameId + 1;
        }
        const maxGroupContentHeight = this.getMaxGroupHeight(maxHeightList);
        const numExemplars = this.parentWidget.numExemplars;
        const canvasWidth = numFrames * maxWidth + this.horizontalPad * (numFrames + 1);
        let totalHeight = this.verticalPad * (combinedTracks.length + 1);
        const betweenGroupPad = 16;
        const heightOfManuallyPinned = d3.sum(maxHeightList.slice(0, this.manuallyPinnedTracks.length));
        if (this.parentWidget.inExemplarMode) {
            const numGroups = (this.trackList.length / numExemplars);
            totalHeight += maxGroupContentHeight * numGroups;
            totalHeight += betweenGroupPad * numGroups;
            totalHeight += heightOfManuallyPinned;
        }
        else {
            totalHeight += d3.sum(maxHeightList);
        }
        this.selectedImageCanvas
            .attr('width', canvasWidth)
            .attr('height', totalHeight);
        let verticalOffset = this.verticalPad;
        this._cellLabelPositions = [];
        let drawTrackPromises = [];
        let verticalOffsetList = [];
        const pinOffset = this.manuallyPinnedTracks.length;
        for (let i = 0; i < combinedTracks.length; i++) {
            const isStarred = i < pinOffset;
            const sampledIdx = i - pinOffset;
            let track = combinedTracks[i];
            let boundingBoxList = listOfBoundingBoxLists[i];
            let trackHeight = maxHeightList[i];
            if (this.parentWidget.inExemplarMode && i === this.manuallyPinnedTracks.length && this.manuallyPinnedTracks.length > 0) {
                verticalOffset = Math.max(verticalOffset, this.minHeightForFavorites);
            }
            verticalOffsetList.push(verticalOffset);
            const categoryIndex = Math.floor(sampledIdx / numExemplars);
            let done = this.drawTrack(track, boundingBoxList, maxWidth, trackHeight, minFrameId, verticalOffset, categoryIndex, isStarred);
            drawTrackPromises.push(done);
            this.cellLabelPositions.push([track.id, verticalOffset + trackHeight / 2]);
            verticalOffset += trackHeight + this.verticalPad;
            if (this.parentWidget.inExemplarMode && !isStarred) {
                let groupStartIdx = (sampledIdx - (sampledIdx % numExemplars)) + pinOffset; // I have regrets combining these lists.
                let diffBetweenMax = maxGroupContentHeight - d3.sum(maxHeightList.slice(groupStartIdx, groupStartIdx + numExemplars));
                if (i % numExemplars < numExemplars) {
                    let extraPadding = diffBetweenMax / (numExemplars - 1);
                    verticalOffset += extraPadding;
                }
                else {
                    verticalOffset += betweenGroupPad;
                }
            }
        }
        if (this.parentWidget.inExemplarMode) {
            this._conditionLabelPositions = [];
            const conditionNames = this.getConditionNames();
            for (let i = 0; i < this.trackList.length; i += numExemplars) {
                const idx = i + pinOffset;
                const groupIndex = i / numExemplars;
                let name = conditionNames[groupIndex];
                const top = verticalOffsetList[idx];
                const indexBot = idx + numExemplars - 1;
                const bot = verticalOffsetList[indexBot] + maxHeightList[indexBot];
                this.conditionLabelPositions.push([name, [top, bot]]);
            }
        }
        this._frameLabelPositions = [];
        for (let i = 0; i < numFrames; i++) {
            let frameId = (i + minFrameId).toString();
            let offset = this.horizontalPad;
            offset += i * (maxWidth + this.horizontalPad);
            offset += maxWidth / 2;
            this._frameLabelPositions.push([frameId, offset]);
        }
        // I don't know why gulp isn't recognizing allSettled. The version should
        // be correct. But I'm tired of seeing the error.
        await Promise.allSettled(drawTrackPromises);
        this._defaultCanvasState = this.canvasContext.getImageData(0, 0, canvasWidth, totalHeight);
        await this.drawOutlines(false);
        DevlibTSUtil_1.DevlibTSUtil.stopSpinner();
    }
    getMaxGroupHeight(maxHeightList) {
        if (!this.parentWidget.inExemplarMode) {
            // only useful for exemplar mode
            return 0;
        }
        let maxGroupHeight = 0;
        for (let i = this.manuallyPinnedTracks.length; i < maxHeightList.length; i += this.parentWidget.numExemplars) {
            let groupContentHeight = d3.sum(maxHeightList.slice(i, i + this.parentWidget.numExemplars));
            maxGroupHeight = Math.max(maxGroupHeight, groupContentHeight);
        }
        return maxGroupHeight;
    }
    getConditionNames() {
        return this.parentWidget.facetList.map(facet => facet.name.join('___'));
    }
    async getBoundingBoxLists(trackList) {
        let listOfLists = [];
        for (let track of trackList) {
            let thisList = [];
            if (this.parentWidget.inCondensedMode) {
                const end = Math.min(track.length, this.parentWidget.condensedModeCount);
                for (let i = 0; i < end; i++) {
                    let point = this.getPointInCondensedMode(track, i);
                    const boundingBox = await this.getCellBoundingBox(point);
                    thisList.push(boundingBox);
                }
            }
            else {
                for (let point of track.pointList) {
                    const boundingBox = await this.getCellBoundingBox(point);
                    thisList.push(boundingBox);
                }
            }
            listOfLists.push(thisList);
        }
        return listOfLists;
    }
    getPointInCondensedMode(track, index) {
        if (track.pointList.length === 1) {
            return track.pointList[0];
        }
        const maxCount = Math.min(this.parentWidget.condensedModeCount, track.pointList.length);
        let percent = index / (maxCount - 1);
        let trackIndex = Math.min(Math.floor(percent * track.pointList.length), track.pointList.length - 1);
        return track.pointList[trackIndex];
    }
    async drawTrack(trackData, boundingBoxList, maxWidth, maxHeight, minFrame, verticalOffset, categoryIndex, isStarred) {
        var _a, _b;
        // draw track background
        this.drawTrackBackgroundAndTimeRange(trackData, maxWidth, maxHeight, minFrame, verticalOffset, categoryIndex, isStarred);
        let asyncFunctionList = [];
        let blobRequests = [];
        let offsetArray = [];
        for (let i = 0; i < boundingBoxList.length; i++) {
            // this is a bit painful. The biggest addition to the complexity
            // is accounting for edge cases in the tile of the tiled image.
            // if it gets to an edge only only copies what it can, then centers in
            // a rect of the same size as others in the cell.
            let point;
            if (this.parentWidget.inCondensedMode) {
                point = this.getPointInCondensedMode(trackData, i);
            }
            else {
                point = trackData.pointList[i];
            }
            const frameId = point.get('Frame ID');
            const frameIndex = frameId - 1;
            let blobRequest = this.parentWidget.imageStackDataRequest.getImagePromise(point.get('Location ID'), frameIndex);
            blobRequests.push(blobRequest);
        }
        let results = await Promise.all(blobRequests);
        let sourceDestCell = [];
        let workerData = [];
        let webWorker = new Worker('/static/script/dist/ImageWorker.js');
        for (let j = 0; j < results.length; j++) {
            let [tileTop, tileLeft, blob, _url] = results[j];
            let bbox = boundingBoxList[j];
            const [sX, sY] = bbox[0];
            let width = ImageTrackWidget.rectWidth(bbox);
            let height = ImageTrackWidget.rectHeight(bbox);
            const extraX = Math.round((maxWidth - width) / 2);
            const extraY = Math.round((maxHeight - height) / 2);
            let point;
            if (this.parentWidget.inCondensedMode) {
                point = this.getPointInCondensedMode(trackData, j);
            }
            else {
                point = trackData.pointList[j];
            }
            const frameId = point.get('Frame ID');
            let offsetIndex;
            if (this.parentWidget.inCondensedMode) {
                if (results.length === this.parentWidget.condensedModeCount) {
                    offsetIndex = j;
                }
                else {
                    let fraction;
                    if (results.length === 1) {
                        fraction = 0.5;
                    }
                    else {
                        fraction = j / (results.length - 1);
                    }
                    offsetIndex = fraction * (this.parentWidget.condensedModeCount - 1);
                    // index here is a float - gotcha!
                }
            }
            else {
                offsetIndex = frameId - minFrame;
            }
            const tileBot = tileTop + ((_a = this.parentWidget.imageStackDataRequest) === null || _a === void 0 ? void 0 : _a.tileHeight);
            const tileRight = tileLeft + ((_b = this.parentWidget.imageStackDataRequest) === null || _b === void 0 ? void 0 : _b.tileWidth);
            const copyTop = DevlibMath_1.DevlibMath.clamp(sY - extraY, [tileTop, tileBot]);
            const copyLeft = DevlibMath_1.DevlibMath.clamp(sX - extraX, [tileLeft, tileRight]);
            const copyWidth = Math.min(maxWidth, tileRight - copyLeft);
            const copyHeight = Math.min(maxHeight, tileBot - copyTop);
            const offsetX = Math.round(this.horizontalPad + offsetIndex * (maxWidth + this.horizontalPad) + (maxWidth - copyWidth) / 2);
            const offsetY = Math.round(verticalOffset + (maxHeight - copyHeight) / 2);
            const destOffset = [offsetX, offsetY];
            offsetArray.push(destOffset);
            let sourceRect = [[copyLeft, copyTop], [copyLeft + copyWidth, copyTop + copyHeight]];
            this.sourceDestCell.push([sourceRect, destOffset, point]);
            sourceDestCell.push([sourceRect, destOffset, point]);
            workerData.push([blob, copyLeft, copyTop, copyWidth, copyHeight]);
        }
        webWorker.postMessage(workerData);
        return new Promise((resolve, reject) => {
            webWorker.onmessage = (event) => {
                let bitMapList = event.data;
                for (let i = 0; i < bitMapList.length; i++) {
                    const imgBitmap = bitMapList[i];
                    let point;
                    if (this.parentWidget.inCondensedMode) {
                        point = this.getPointInCondensedMode(trackData, i);
                    }
                    else {
                        point = trackData.pointList[i];
                    }
                    const frameId = point.get('Frame ID');
                    const currentFrame = frameId === this.parentWidget.getCurrentFrameId();
                    let offsetIndex = frameId - minFrame;
                    if (this.parentWidget.inCondensedMode) {
                        // offsetIndex = i;
                        if (bitMapList.length === this.parentWidget.condensedModeCount) {
                            offsetIndex = i;
                        }
                        else {
                            let fraction;
                            if (bitMapList.length === 1) {
                                fraction = 0.5;
                            }
                            else {
                                fraction = i / (bitMapList.length - 1);
                            }
                            offsetIndex = fraction * (this.parentWidget.condensedModeCount - 1);
                            // index here is a float - gotcha!
                        }
                    }
                    else {
                        offsetIndex = frameId - minFrame;
                    }
                    const frameX = this.horizontalPad + offsetIndex * (maxWidth + this.horizontalPad);
                    const frameY = verticalOffset;
                    const [offsetX, offsetY] = offsetArray[i];
                    this.canvasContext.beginPath();
                    this.canvasContext.rect(frameX, frameY, maxWidth, maxHeight);
                    if (currentFrame && !this.parentWidget.inExemplarMode) {
                        this.canvasContext.strokeStyle = 'MediumSeaGreen';
                        this.canvasContext.lineWidth = 8;
                    }
                    else {
                        this.canvasContext.strokeStyle = 'grey';
                        this.canvasContext.lineWidth = 1;
                    }
                    this.canvasContext.fillStyle = 'black';
                    this.canvasContext.stroke();
                    this.canvasContext.fill();
                    this.canvasContext.closePath();
                    if (imgBitmap.status === 'fulfilled') {
                        if (this.parentWidget.invertImageToggle.node().checked) {
                            this.canvasContext.filter = 'invert(1)';
                        }
                        this.canvasContext.drawImage(imgBitmap.value, offsetX, offsetY);
                        this.canvasContext.filter = '';
                    }
                }
                resolve();
                webWorker.terminate();
            };
        });
    }
    drawTrackBackgroundAndTimeRange(trackData, maxWidth, maxHeight, minFrame, verticalOffset, categoryIndex, isStarred) {
        // draw track background
        let offsetIndex;
        if (this.parentWidget.inCondensedMode) {
            offsetIndex = 0;
        }
        else {
            offsetIndex = trackData.pointList[0].get('Frame ID') - minFrame;
        }
        const minDestX = this.horizontalPad + offsetIndex * (maxWidth + this.horizontalPad);
        if (this.parentWidget.inCondensedMode) {
            offsetIndex = this.parentWidget.condensedModeCount;
        }
        else {
            const lastIndex = trackData.pointList.length - 1;
            offsetIndex = trackData.pointList[lastIndex].get('Frame ID') - minFrame + 1;
        }
        const maxDestX = offsetIndex * (maxWidth + this.horizontalPad);
        const minDestY = verticalOffset;
        this.canvasContext.beginPath();
        const marginX = 4;
        const marginY = 4;
        this.canvasContext.rect(minDestX - marginX, minDestY - marginY, maxDestX - minDestX + 1 + 2 * marginX, maxHeight + 2 * marginY);
        let backgroundColor;
        if (isStarred) {
            backgroundColor = 'rgb(180,180,180)';
        }
        else {
            backgroundColor = 'rgb(240,240,240)';
        }
        this.canvasContext.strokeStyle = backgroundColor;
        this.canvasContext.fillStyle = backgroundColor;
        this.canvasContext.stroke();
        this.canvasContext.fill();
        this.canvasContext.closePath();
        const timeRangeHeight = 6;
        const timeRangeVerticalOffset = verticalOffset - marginY - timeRangeHeight;
        this.drawTimeRange(trackData, [minDestX, maxDestX], timeRangeHeight, timeRangeVerticalOffset, categoryIndex);
    }
    drawTimeRange(trackData, extentX, height, verticalOffset, categoryIndex) {
        if (!this.parentWidget.inCondensedMode) {
            return;
        }
        let maxTimeRange = this.parentWidget.fullData.getMinMax('Frame ID');
        let scaleX = d3.scaleLinear()
            .domain(maxTimeRange)
            .range(extentX);
        let timeRange = d3.extent(trackData.pointList, point => point.get('Frame ID'));
        let timeRangePx = timeRange.map(t => scaleX(t));
        // Total possible time
        const smallHeight = 0.5 * height;
        const heightDiff = height - smallHeight;
        this.canvasContext.beginPath();
        this.canvasContext.rect(extentX[0], verticalOffset + (heightDiff / 2), extentX[1] - extentX[0] + 1, smallHeight);
        this.canvasContext.fillStyle = 'grey';
        this.canvasContext.fill();
        this.canvasContext.closePath();
        // This time
        this.canvasContext.beginPath();
        this.canvasContext.rect(timeRangePx[0], verticalOffset, timeRangePx[1] - timeRangePx[0] + 1, height);
        const locationId = trackData.pointList[0].get('Location ID');
        const labelList = this.parentWidget.fullData.inverseLocationMap.get(locationId);
        const color = GroupByWidget_1.GroupByWidget.getColor(labelList, this.parentWidget.colorLookup);
        this.canvasContext.strokeStyle = color;
        this.canvasContext.fillStyle = color;
        this.canvasContext.stroke();
        this.canvasContext.fill();
        this.canvasContext.closePath();
    }
    static rectWidth(rect) {
        return rect[1][0] - rect[0][0] + 1;
    }
    static rectHeight(rect) {
        return rect[1][1] - rect[0][1] + 1;
    }
    async getCellBoundingBox(point) {
        const locId = point.get('Location ID');
        const frameId = point.get('Frame ID');
        const frameIndex = frameId - 1; // MatLab..        
        const segmentId = point.get('segmentLabel');
        const numPixelsInTile = this.parentWidget.numPixelsInTile;
        // const firstIndex = frameIndex * numPixelsInTile;
        let extent = [[Infinity, Infinity], [-Infinity, -Infinity]];
        let [rowArray, firstIndex] = await this.parentWidget.imageStackDataRequest.getLabelPromise(locId, frameIndex);
        for (let rowIdx = firstIndex; rowIdx < firstIndex + this.parentWidget.imageStackDataRequest.tileHeight; rowIdx++) {
            let row = rowArray.rowList[rowIdx];
            for (let labelRun of row.row) {
                let [top, left] = this.parentWidget.imageStackDataRequest.getTileTopLeft(frameIndex);
                let bigImgXMin = left + labelRun.start;
                let bigImgXMax = left + labelRun.start + labelRun.length;
                let bigImgY = top + (rowIdx % this.parentWidget.imageStackDataRequest.tileHeight);
                if (labelRun.label === segmentId) {
                    let [[minX, minY], [maxX, maxY]] = extent;
                    minX = Math.min(minX, bigImgXMin);
                    minY = Math.min(minY, bigImgY);
                    maxX = Math.max(maxX, bigImgXMax);
                    maxY = Math.max(maxY, bigImgY);
                    extent = [[minX, minY], [maxX, maxY]];
                }
            }
        }
        return extent;
    }
    onCellTimelineScroll(event) {
        let el = this.innerContainer.node();
        this._latestScroll = [el.scrollLeft, el.scrollTop];
        if (!this.scrollChangeTicking) {
            window.requestAnimationFrame(() => {
                this.drawLabels(true);
                this._scrollChangeTicking = false;
            });
            this._scrollChangeTicking = true;
        }
    }
    onCanvasClick(e) {
        if (!this.parentWidget.imageStackDataRequest) {
            return;
        }
        let xPos = e.offsetX;
        let yPos = e.offsetY;
        const [cellId, cellIdIndex] = ImageTrackWidget.getClosestLabel(this.cellLabelPositions, yPos);
        let curve = this.parentWidget.fullData.curveLookup.get(cellId);
        let frameId;
        const [frameLabel, frameLabelIndex] = ImageTrackWidget.getClosestLabel(this.frameLabelPositions, xPos);
        let frameIndex = +frameLabel - 1;
        if (this.parentWidget.inCondensedMode) {
            if (curve.pointList.length < this.parentWidget.condensedModeCount) {
                const percent = xPos / Number(this.selectedImageCanvas.attr('width'));
                frameIndex = Math.floor(percent * curve.pointList.length);
                frameIndex = Math.min(frameIndex, curve.pointList.length - 1);
            }
            let point = this.getPointInCondensedMode(curve, frameIndex);
            frameId = point.get('Frame ID');
        }
        else {
            frameId = frameIndex + 1;
        }
        let firstPoint = curve.pointList[0];
        const trackLocation = firstPoint.get('Location ID');
        let event = new CustomEvent('locFrameClicked', { detail: {
                locationId: trackLocation,
                frameId: frameId
            } });
        document.dispatchEvent(event);
    }
    onCanvasMouseMove(e) {
        if (!this.parentWidget.imageStackDataRequest) {
            return;
        }
        let xPos = e.offsetX;
        let yPos = e.offsetY;
        const [cellId, cellIdIndex] = ImageTrackWidget.getClosestLabel(this.cellLabelPositions, yPos);
        let curve = this.parentWidget.fullData.curveLookup.get(cellId);
        let frameId;
        const [frameLabel, frameLabelIndex] = ImageTrackWidget.getClosestLabel(this.frameLabelPositions, xPos);
        let frameIndex = +frameLabel - 1;
        if (this.parentWidget.inCondensedMode) {
            if (curve.pointList.length < this.parentWidget.condensedModeCount) {
                const percent = xPos / Number(this.selectedImageCanvas.attr('width'));
                frameIndex = Math.floor(percent * curve.pointList.length);
                frameIndex = Math.min(frameIndex, curve.pointList.length - 1);
            }
            let point = this.getPointInCondensedMode(curve, frameIndex);
            frameId = point.get('Frame ID');
        }
        else {
            frameId = frameIndex + 1;
        }
        this.parentWidget.selectedImgIndex;
        const displayedFrameId = this.parentWidget.getCurrentFrameId();
        let firstPoint = curve.pointList[0];
        const trackLocation = firstPoint.get('Location ID');
        const currentLocation = this.parentWidget.getCurrentLocationId();
        if (trackLocation == currentLocation) {
            let displayedPoint = curve.pointList.find(point => point.get('Frame ID') === displayedFrameId);
            if (displayedPoint) {
                this.parentWidget.imageStackDataRequest.getLabel(displayedPoint.get('Location ID'), displayedPoint.get('Frame ID') - 1, (rowArray, firstIndex) => {
                    this.parentWidget.showSegmentHover(rowArray, displayedPoint.get('segmentLabel'), firstIndex, true);
                });
            }
            else {
                this.parentWidget.hideSegmentHover(true);
            }
        }
        else {
            this.parentWidget.hideSegmentHover(true);
        }
        this.updateLabelsOnMouseMove(cellId, frameIndex, cellIdIndex);
        let event = new CustomEvent('frameHoverChange', { detail: {
                locationId: trackLocation,
                frameId: frameId,
                cellId: cellId,
                rowIndex: cellIdIndex,
            } });
        document.dispatchEvent(event);
    }
    onCanvasMouseLeave() {
        this.parentWidget.hideSegmentHover(true);
        this.updateLabelsOnMouseMove('', -1, -1);
        const locId = this.parentWidget.getCurrentLocationId();
        let event = new CustomEvent('frameHoverChange', { detail: {
                locationId: locId,
                frameId: null,
                cellId: null
            } });
        document.dispatchEvent(event);
    }
    static getClosestLabel(labelPositions, pos) {
        let compareFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(pos, labelPos => labelPos[1]);
        let indices = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(labelPositions, compareFunction);
        if (typeof indices === 'undefined') {
            console.log(pos);
            return ['-1', -1]; // todo
        }
        let labelIndex;
        if (typeof indices === 'number') {
            labelIndex = indices;
        }
        else {
            let [indexLow, indexHigh] = indices;
            if (typeof indexLow === 'undefined') {
                labelIndex = indexHigh;
            }
            else if (typeof indexHigh === 'undefined') {
                labelIndex = indexLow;
            }
            else {
                const [_labelLow, labelPosLow] = labelPositions[indexLow];
                const [_labelHeigh, labelPosHigh] = labelPositions[indexHigh];
                const distToLow = pos - labelPosLow;
                const distToHigh = labelPosHigh - pos;
                if (distToLow < distToHigh) {
                    labelIndex = indexLow;
                }
                else {
                    labelIndex = indexHigh;
                }
            }
        }
        return [labelPositions[labelIndex][0], labelIndex];
    }
    async drawOutlines(drawDefaultCanvas = true) {
        if (!this.defaultCanvasState) {
            return;
        }
        if (drawDefaultCanvas) {
            this.canvasContext.putImageData(this.defaultCanvasState, 0, 0);
        }
        if (!this.parentWidget.showOutlineToggle.node().checked) {
            // don't do it!
            return;
        }
        for (let [sourceRect, [dX, dY], point] of this.sourceDestCell) {
            let width = ImageTrackWidget.rectWidth(sourceRect);
            let height = ImageTrackWidget.rectHeight(sourceRect);
            let [[sLeft, sTop], [sRight, sBot]] = sourceRect;
            let outlineTileData = this.canvasContext.getImageData(dX, dY, width, height);
            let labelToMatch = point.get('segmentLabel');
            let frameIndex = point.get('Frame ID') - 1;
            let rIdx = 0;
            let [labelArray, firstIndex] = await this.parentWidget.imageStackDataRequest.getLabelPromise(point.get('Location ID'), frameIndex);
            for (let y = sTop; y <= sBot; y++) {
                for (let x = sLeft; x <= sRight; x++) {
                    let [rowIdx, colIdx] = this.parentWidget.getLabelIndexFromBigImgPixelXY(frameIndex, x, y);
                    let label = ImageStackDataRequest_1.ImageStackDataRequest.getLabelValue(rowIdx, colIdx, labelArray);
                    if (label == labelToMatch) {
                        if (this.parentWidget.isBorder(label, rowIdx, colIdx, labelArray)) {
                            // should use data, not full data to get the right color.
                            const [cell, _index] = this.parentWidget.data.GetCellFromLabel(point.get('Location ID'), point.get('Frame ID'), labelToMatch);
                            let { color: color, show: show } = this.parentWidget.getCellColor(cell);
                            if (show) {
                                let [r, g, b] = color;
                                outlineTileData.data[rIdx] = r;
                                outlineTileData.data[rIdx + 1] = g;
                                outlineTileData.data[rIdx + 2] = b;
                                outlineTileData.data[rIdx + 3] = 255;
                            }
                        }
                    }
                    rIdx += 4;
                }
            }
            this.canvasContext.putImageData(outlineTileData, dX, dY);
        }
    }
    drawLabels(onScroll = false) {
        // cell labels
        if (!this.parentWidget.inExemplarMode) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.scentedWidgetGroup.node());
            DevlibTSUtil_1.DevlibTSUtil.hide(this.exemplarPinGroup.node());
            DevlibTSUtil_1.DevlibTSUtil.hide(this.manualExemplarPinGroup.node());
            DevlibTSUtil_1.DevlibTSUtil.hide(this.addPinRectGroup.node());
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.show(this.scentedWidgetGroup.node());
            DevlibTSUtil_1.DevlibTSUtil.show(this.exemplarPinGroup.node());
            DevlibTSUtil_1.DevlibTSUtil.show(this.manualExemplarPinGroup.node());
            DevlibTSUtil_1.DevlibTSUtil.show(this.addPinRectGroup.node());
            let xAnchor = this.drawConditionLabels();
            if (onScroll) {
                this.shiftScentedWidgets();
            }
            else {
                this.drawScentedWidgets(xAnchor);
                this.drawAddPinRects(xAnchor);
            }
        }
        this.drawCellLabels(); // todo make this function conditional to always show pinned with star and only show others depending on if it's in exemplar mode.
        // frame labels
        let pad = 6;
        const yAnchor = this.cellTimelineMargin.top - pad;
        let labelsInView = this.frameLabelPositions.filter((labelPos) => {
            const pos = labelPos[1] - this.latestScroll[0];
            return 0 <= pos && pos <= this.innerContainerW;
        });
        if (this.parentWidget.inCondensedMode) {
            labelsInView = labelsInView.map((labelPos) => {
                let index = +labelPos[0] - 1;
                let percent = index / (this.parentWidget.condensedModeCount - 1);
                return [percent.toFixed(2), labelPos[1]];
            });
        }
        const currentFrame = this.parentWidget.getCurrentFrameId();
        this.frameLabelGroup.selectAll('text')
            .data(labelsInView)
            .join('text')
            .text(d => d[0])
            .attr('x', d => d[1] - this.latestScroll[0])
            .attr('y', yAnchor)
            .classed('currentFrame', d => +d[0] === currentFrame && !this.parentWidget.inExemplarMode)
            .classed('cellAxisLabel', true)
            .classed('right', true);
    }
    drawCellLabels() {
        const pad = 10;
        const starButtonSize = 32;
        const starExtraOffset = 2;
        const xAnchor = this.cellTimelineMargin.left - pad;
        let labelsWithIndex = this.cellLabelPositions.map((x, i) => [i, x]);
        let labelsInView = labelsWithIndex.filter((labelPos, index) => {
            if (index >= this.manuallyPinnedTracks.length && this.parentWidget.inExemplarMode) {
                return false;
            }
            const pos = labelPos[1][1] - this.latestScroll[1];
            return 0 <= pos && pos <= this.innerContainerH;
        });
        this.cellLabelGroup.selectAll('text.trackLabel')
            .data(labelsInView)
            .join('text')
            .classed('trackLabel', true)
            .text(d => d[1][0])
            .attr('x', d => {
            if (d[0] < this.manuallyPinnedTracks.length) {
                return xAnchor - starButtonSize;
            }
            return xAnchor;
        })
            .attr('y', d => d[1][1] - this.latestScroll[1])
            .attr('transform', '')
            .attr('fill', d => {
            if (d[0] < this.manuallyPinnedTracks.length) {
                const track = this.manuallyPinnedTracks[d[0]];
                const locId = track.pointList[0].get('Location ID');
                const labelList = this.parentWidget.fullData.inverseLocationMap.get(locId);
                return GroupByWidget_1.GroupByWidget.getColor(labelList, this.parentWidget.colorLookup);
            }
            return 'black';
        })
            .classed('cellAxisLabel', true)
            .classed('left', true)
            .classed('rotated', false);
        let manuallyPinnedInView = labelsWithIndex.filter((labelPos, index) => {
            if (index < this.manuallyPinnedTracks.length) {
                const pos = labelPos[1][1] - this.latestScroll[1];
                return 0 <= pos && pos <= this.innerContainerH;
            }
            return false;
        });
        this.cellLabelGroup.selectAll('foreignObject')
            .data(manuallyPinnedInView)
            .join('foreignObject')
            .attr('transform', d => {
            const xOffset = xAnchor - starButtonSize;
            const yOffset = d[1][1] - this.latestScroll[1] - (starButtonSize / 2) - starExtraOffset;
            return `translate(${xOffset}, ${yOffset})`;
        })
            .attr('width', starButtonSize)
            .attr('height', starButtonSize)
            .selectAll('div')
            .data(d => [d])
            .join('xhtml:div')
            .selectAll('button')
            .data(d => [d])
            .join('button')
            .attr('style', d => {
            if (d[0] < this.manuallyPinnedTracks.length) {
                const track = this.manuallyPinnedTracks[d[0]];
                const locId = track.pointList[0].get('Location ID');
                const labelList = this.parentWidget.fullData.inverseLocationMap.get(locId);
                return `color: ${GroupByWidget_1.GroupByWidget.getColor(labelList, this.parentWidget.colorLookup)};`;
            }
        })
            .attr('title', 'Click to remove this favorite.')
            .html('<i class="fas fa-star"></i>')
            .classed('basicIconButton', true)
            .on('click', d => {
            const track = this.parentWidget.fullData.curveLookup.get(d[1][0]);
            this.parentWidget.togglePin(track);
        });
        if (!this.parentWidget.inExemplarMode) {
            this.cellLabelGroup.selectAll('line').remove();
            this.cellLabelGroup.selectAll('text.conditionLabel').remove();
        }
    }
    drawConditionLabels() {
        const xAnchor = this.cellTimelineMargin.left - this.labelLinePad;
        const xAnchorLine = xAnchor - 4;
        this.cellLabelGroup.selectAll('text.conditionLabel')
            .data(this.conditionLabelPositions)
            .join('text')
            .classed('conditionLabel', true)
            .text(d => d[0].replace('___', ' '))
            .attr('x', xAnchor)
            .attr('y', d => (d[1][0] + d[1][1]) / 2 - this.latestScroll[1])
            .attr('transform', d => `rotate(-90, ${xAnchor}, ${(d[1][0] + d[1][1]) / 2 - this.latestScroll[1]})`)
            .attr('fill', (d, i) => GroupByWidget_1.GroupByWidget.getColor(d[0].split('___'), this.parentWidget.colorLookup))
            .classed('cellAxisLabel', true)
            .classed('rotated', true);
        this.cellLabelGroup.selectAll('line')
            .data(this.conditionLabelPositions)
            .join('line')
            .attr('x1', xAnchorLine)
            .attr('x2', xAnchorLine)
            .attr('y1', d => Math.max(0, d[1][0] - this.latestScroll[1]))
            .attr('y2', d => Math.max(0, d[1][1] - this.latestScroll[1]))
            .attr('stroke', (d, i) => GroupByWidget_1.GroupByWidget.getColor(d[0].split('___'), this.parentWidget.colorLookup))
            .attr('stroke-width', '2px');
        return xAnchorLine;
    }
    shiftScentedWidgets() {
        this.scentedWidgetGroup
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top - this.latestScroll[1]})`);
        this.exemplarPinGroup
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top - this.latestScroll[1]})`);
        this.manualExemplarPinGroup
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top - this.latestScroll[1]})`);
        this.addPinRectGroup
            .attr('transform', d => `translate(0, ${this.cellTimelineMargin.top - this.latestScroll[1]})`);
        this.updateExemplarCurvesOffset();
    }
    drawAddPinRects(axisAnchor) {
        const self = this;
        this.addPinRectGroup.selectAll('rect')
            .data(this.conditionLabelPositions)
            .join('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('transform', d => `translate(0, ${d[1][0]})`)
            .attr('width', this.cellTimelineMargin.left - this.labelLinePad)
            .attr('height', d => d[1][1] - d[1][0])
            .attr('stroke-width', '0px')
            .attr('fill', 'tomato')
            .attr('opacity', 0.0)
            .attr('style', 'cursor: crosshair;')
            .on('click', function (d) {
            const [_xPos, yPos] = d3.mouse(this);
            const value = self.normalizedHistogramScaleY.invert(yPos);
            self.manualSampleValues.push(value);
            document.dispatchEvent(new CustomEvent('samplingStrategyChange', { detail: self.currentSamplingStategy }));
        });
    }
    drawScentedWidgets(axisAnchor) {
        let binArray = [];
        const numBins = 48;
        this._histogramScaleYList = [];
        for (let i = 0; i < this.parentWidget.facetList.length; i++) {
            let data = this.parentWidget.facetList[i].data;
            let bins = HistogramWidget_1.HistogramWidget.calculateBins(data.curveCollection.Array.filter(d => !isNaN(d.get(this.parentWidget.exemplarAttribute))), this.parentWidget.exemplarAttribute, data.curveCollection, numBins, true);
            binArray.push(bins);
        }
        let minBinBoundary = d3.min(binArray, bins => bins[0].x0);
        let maxBinBoundary = d3.max(binArray, bins => bins[bins.length - 1].x1);
        for (let i = 0; i < binArray.length; i++) {
            let positionExtent = this.conditionLabelPositions[i][1];
            let scaleY = d3.scaleLinear()
                .domain([minBinBoundary, maxBinBoundary])
                .range(positionExtent);
            this.histogramScaleYList.push(scaleY);
        }
        const firstExtent = this.conditionLabelPositions[0][1];
        this._normalizedHistogramScaleY = d3.scaleLinear()
            .domain([minBinBoundary, maxBinBoundary])
            .range([0, firstExtent[1] - firstExtent[0]]);
        const padding = 4;
        let biggestBinPercentage = d3.max(binArray, bin => d3.max(bin, d => d.length) / d3.sum(bin, d => d.length));
        const maxWidth = 52;
        this._histogramScaleX = d3.scaleLinear()
            .domain([0, biggestBinPercentage])
            .range([axisAnchor - padding, axisAnchor - maxWidth]);
        this.scentedWidgetGroup.selectAll('path')
            .data(this.conditionLabelPositions)
            .join('path')
            .attr('d', (d, i) => {
            let bins = binArray[i];
            return this.getHistogramSkylinePath(bins, this.histogramScaleX, this.histogramScaleYList[i]);
        })
            .classed('kdePath', true);
    }
    getHistogramSkylinePath(bins, scaleX, scaleY) {
        let pathPoints = [];
        const totalCount = d3.sum(bins, bin => bin.length);
        for (let bin of bins) {
            let y1 = scaleY(bin.x0);
            let x = scaleX(bin.length / totalCount);
            pathPoints.push([x, y1]);
            if (bin.length === 0) {
                let splitPoint = [null, null];
                pathPoints.push(splitPoint);
            }
            let y2 = scaleY(bin.x1);
            pathPoints.push([x, y2]);
        }
        let minYval = bins[0].x0;
        let maxYval = bins[bins.length - 1].x1;
        pathPoints.unshift([scaleX.range()[0], scaleY(minYval)]);
        pathPoints.push([scaleX.range()[0], scaleY(maxYval)]);
        let lineFunc = d3.line()
            .x(d => d[0])
            .y(d => d[1])
            .defined(d => d[0] !== null);
        return lineFunc(pathPoints);
    }
    clearPins() {
        this.exemplarPinGroup.html(null);
        this.manualExemplarPinGroup.html(null);
    }
    drawAllPins(curveList) {
        this.clearPins();
        for (let i = 0; i < curveList.length; i++) {
            const categoryIndex = Math.floor(i / this.parentWidget.numExemplars);
            this.drawPin(curveList[i], categoryIndex);
        }
    }
    drawPin(trackData, categoryIndex) {
        let exemplarValue = trackData.data.get(this.parentWidget.exemplarAttribute);
        let yPos = this.histogramScaleYList[categoryIndex](exemplarValue);
        let [xPosPin, xPosHead] = this.histogramScaleX.range();
        const manual = trackData.type === 'manual';
        if (manual) {
            const needleElement = this.manualExemplarPinGroup.append('line')
                .attr('x1', xPosHead)
                .attr('x2', xPosPin)
                .attr('y1', yPos)
                .attr('y2', yPos)
                .classed('pinLine', true)
                .classed(trackData.data.id, true);
            const myPushPinDesign = "M17.2,0.3c-2,0.4-2.7,1-3,1.5c-0.7,1.1,0,2.6-0.8,3c-0.1,0-0.1,0-0.2,0c-1,0-1.4,0-4,0c-2.9,0-4,0-5,0c-0.7,0-0.8-1-1-1.5C2.9,2.6,3,2.3,2.7,2C1.8,1.4,0.3,1.8,0.3,1.8s0-0.8,0,6.5c0,7.2,0,6.5,0,6.5s1.5,0.4,2.4-0.2C3,14.3,2.9,14,3.3,13.3c0.2-0.6,0.3-1.5,1-1.5c1,0,2.1,0,5,0c2.6,0,3,0,4,0s0.1,1.8,1,3c0.7,0.9,2.1,1.3,3,1.5c0-2.7,0-5.3,0-8S17.2,3,17.2,0.3z";
            const iconWidth = 17;
            const iconHeight = 16;
            const self = this;
            const transX = xPosHead - iconWidth;
            const transY = yPos - iconHeight / 2;
            this.manualExemplarPinGroup.append('path')
                .classed('pinHead', true)
                .attr('transform', `translate(${transX}, ${transY})`)
                .attr('d', myPushPinDesign)
                .on('mousedown', function (d) {
                self.onDragStart(this, transX, transY, needleElement, textSelect, exemplarValue, trackData.anchorVal, categoryIndex);
            })
                .classed(trackData.data.id, true);
            const textPad = 4;
            const textSelect = this.exemplarPinGroup.append('text') // put in semantically incorrect group to avoid mouseover problems and because I'm tired.
                .attr('x', textPad)
                .attr('y', yPos)
                .attr('alignment-baseline', 'middle')
                .classed('pinLabel', true)
                .classed('tinyText', true)
                .classed('noSelect', true)
                .text(this.formatPinLabel(exemplarValue))
                .classed(trackData.data.id, true);
        }
        else {
            this.exemplarPinGroup.append('line')
                .attr('x1', xPosHead)
                .attr('x2', xPosPin)
                .attr('y1', yPos)
                .attr('y2', yPos)
                .classed('pinLine', true)
                .classed(trackData.data.id, true);
            const radius = 3;
            this.exemplarPinGroup.append('circle')
                .attr('cx', xPosHead - radius)
                .attr('cy', yPos)
                .attr('r', radius)
                .classed('pinHead', true)
                .classed(trackData.data.id, true);
        }
    }
    formatPinLabel(value) {
        let absVal = Math.abs(value);
        if (absVal > 99.5) {
            return Math.round(value).toString();
        }
        if (absVal > 9.5) {
            return value.toFixed(1);
        }
        return value.toFixed(2);
    }
    onDragStart(pinElement, transX, transY, needleSelect, textSelect, initialValue, anchorValue, groupIndex) {
        const coords = d3.mouse(pinElement);
        this._draggingPin = true;
        this._draggingPinElement = pinElement;
        this._initialDragCoords = [transX, transY];
        this._needleSelection = needleSelect;
        this._textSelection = textSelect;
        this._totalDragOffset = [0, 0];
        this._initialPinValue = initialValue;
        this._anchorPinValue = anchorValue;
        this._dragGroupIndex = groupIndex;
        this._pinMoved = false;
        const unpinOffset = 12;
        d3.select(pinElement)
            .attr('transform', `translate(${transX - unpinOffset}, ${transY})`)
            .classed('grabbed', true);
        needleSelect.attr('transform', `translate(${-unpinOffset}, 0)`);
        textSelect.text('X');
        this.addPinRectGroup.selectAll('rect').classed('grabbed', true);
        this.needleSelection.classed('grabbed', true);
        // document.body.style.cursor = 'grabbing';
    }
    onDragEnd() {
        if (!this.draggingPin) {
            return;
        }
        this._draggingPin = false;
        d3.select(this.draggingPinElement).classed('grabbed', false);
        this.addPinRectGroup.selectAll('rect').classed('grabbed', false);
        this.needleSelection.classed('grabbed', false);
        const index = this.manualSampleValues.indexOf(this.anchorPinValue);
        if (index !== -1) {
            if (!this.pinMoved) {
                this.manualSampleValues.splice(index, 1);
            }
            else {
                this.manualSampleValues[index] = this.getCurrentDraggedValue();
            }
            document.dispatchEvent(new CustomEvent('samplingStrategyChange', { detail: this.currentSamplingStategy }));
        }
    }
    onDrag(moveX, moveY) {
        if (!this.draggingPin) {
            return;
        }
        this.totalDragOffset[1] += moveY;
        const removePixelRoom = 2;
        this._pinMoved = Math.abs(this.totalDragOffset[1]) > removePixelRoom;
        const valueOffsetPixels = this.normalizedHistogramScaleY(this.anchorPinValue);
        const extent = this.normalizedHistogramScaleY.range().map(y => y - valueOffsetPixels);
        let yOffset = DevlibMath_1.DevlibMath.clamp(this.totalDragOffset[1], extent);
        const unpinOffset = this.pinMoved ? 4 : 12;
        d3.select(this.draggingPinElement)
            .attr('transform', `translate(${this.initialDragCoords[0] + this.totalDragOffset[0] - unpinOffset}, ${this.initialDragCoords[1] + yOffset})`);
        this.needleSelection
            .attr('transform', `translate(${-unpinOffset}, ${yOffset})`);
        this.textSelection
            .attr('transform', `translate(0, ${yOffset})`)
            .text(this.pinMoved ? this.formatPinLabel(this.getCurrentDraggedValue()) : 'X');
    }
    getCurrentDraggedValue() {
        const pixelDifference = this.totalDragOffset[1];
        const valueDifference = this.normalizedHistogramScaleY.invert(pixelDifference) - this.normalizedHistogramScaleY.invert(0);
        let currentValue = this.initialPinValue + valueDifference;
        currentValue = DevlibMath_1.DevlibMath.clamp(currentValue, this.normalizedHistogramScaleY.domain());
        return currentValue;
    }
    drawExemplarGrowthCurves() {
        // todo make this work for exemplar mode when there is not enough space
        if (!this.parentWidget.inExemplarMode || !this.parentWidget.inCondensedMode) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.exemplarCurvesGroup.node());
            return;
        }
        DevlibTSUtil_1.DevlibTSUtil.show(this.exemplarCurvesGroup.node());
        this.updateExemplarCurvesOffset();
        let groupListSelection = this.exemplarCurvesGroup.selectAll('.exemplar.plotGrouper')
            .data(this.conditionLabelPositions)
            .join('g')
            .classed('exemplar', true)
            .classed('plotGrouper', true)
            .attr('transform', d => `translate(0, ${d[1][0]})`);
        const rightPadding = 4;
        let width = this.innerContainer.node().getBoundingClientRect().width
            - Number(this.selectedImageCanvas.attr('width'))
            - this.trackToPlotPadding
            - rightPadding;
        width = Math.max(width, this.exemplarMinWidth); // min-width: 80
        width = Math.min(width, 240); // max-width: 240
        const frameExtent = this.parentWidget.fullData.getMinMax('Frame ID');
        this._exemplarScaleX = d3.scaleLinear()
            .domain(frameExtent)
            .range([0, width]);
        const yKey = this.exemplarYKey;
        const allData = [...this.manuallyPinnedTracks, ...this.trackList.map(exemplar => exemplar.data)];
        let yMin = d3.min(allData, curve => d3.min(curve.pointList, point => point.get(yKey)));
        let yMax = d3.max(allData, curve => d3.max(curve.pointList, point => point.get(yKey)));
        for (let facet of this.parentWidget.facetList) {
            let averageGrowthCurve = facet.data.getAverageCurve(yKey, false, this.smoothCurves);
            let [thisMin, thisMax] = d3.extent(averageGrowthCurve, d => d[1]);
            yMin = Math.min(yMin, thisMin);
            yMax = Math.max(yMax, thisMax);
        }
        const firstPosition = this.conditionLabelPositions[0][1];
        let height = firstPosition[1] - firstPosition[0] + 1;
        height = Math.min(height, 120); // max-height 120
        this._exemplarScaleY = d3.scaleLinear()
            .domain([yMin, yMax])
            .range([height, 0]);
        let { favoriteCurves: favoriteCurves, exemplarCurves: exemplarGrowthCurves, averageCurves: averageGrowthLines } = this.generateExemplarGrowthCurves();
        const currentFrame = this.parentWidget.getCurrentFrameId();
        groupListSelection.selectAll('.currentFrameLine')
            .data((d, i) => [i])
            .join('line')
            .attr('x1', this.exemplarScaleX(currentFrame))
            .attr('x2', this.exemplarScaleX(currentFrame))
            .attr('y1', this.exemplarScaleY.range()[0])
            .attr('y2', this.exemplarScaleY.range()[1])
            .attr('stroke', 'black')
            .classed('currentFrameLine', true);
        groupListSelection.selectAll('.averageCurve')
            .data((d, i) => [[averageGrowthLines[i], d[0]]])
            .join('path')
            .attr('d', d => d[0])
            .attr('stroke', d => GroupByWidget_1.GroupByWidget.getColor(d[1].split('___'), this.parentWidget.colorLookup))
            .classed('averageCurve', true);
        groupListSelection.selectAll('.exemplarCurve')
            .data((d, i) => exemplarGrowthCurves[i].map(x => {
            return {
                pathString: x,
                label: d[0],
                groupIndex: i
            };
        }))
            .join('path')
            .attr('d', d => d.pathString)
            .attr('stroke', d => GroupByWidget_1.GroupByWidget.getColor(d.label.split('___'), this.parentWidget.colorLookup))
            .attr('data-cellId', (d, i) => this.trackList[i + this.parentWidget.numExemplars * d.groupIndex].data.id)
            .classed('exemplarCurve', true);
        let scaleList = [
            [d3.axisBottom(this.exemplarScaleX).ticks(5), height],
            [d3.axisLeft(this.exemplarScaleY), 0]
        ];
        groupListSelection.selectAll('.exemplarPlotAxis')
            .data((d, i) => scaleList.map(x => [x, i]))
            .join('g')
            .classed('exemplarPlotAxis', true)
            .attr('transform', (d) => `translate(0, ${d[0][1]})`)
            .each(function (d) {
            let axisFunc;
            axisFunc = d[0][0];
            axisFunc(d3.select(this));
        });
        this.drawFavoriteGrowthCurves(favoriteCurves, scaleList);
    }
    drawFavoriteGrowthCurves(favoriteCurves, scaleList) {
        if (this.manuallyPinnedTracks.length === 0) {
            this.exemplarCurvesGroup.selectAll('.favorite.plotGrouper').classed('noDisp', true);
            return;
        }
        const groupSelection = this.exemplarCurvesGroup.selectAll('.favorite.plotGrouper')
            .data([42])
            .join('g')
            .classed('favorite', true)
            .classed('plotGrouper', true)
            .classed('noDisp', false)
            .attr('transform', d => `translate(0, ${this.verticalPad})`);
        const currentFrame = this.parentWidget.getCurrentFrameId();
        groupSelection.selectAll('.currentFrameLine')
            .data((d, i) => [i])
            .join('line')
            .attr('x1', this.exemplarScaleX(currentFrame))
            .attr('x2', this.exemplarScaleX(currentFrame))
            .attr('y1', this.exemplarScaleY.range()[0])
            .attr('y2', this.exemplarScaleY.range()[1])
            .attr('stroke', 'black')
            .classed('currentFrameLine', true);
        groupSelection.selectAll('.exemplarCurve')
            .data(d => favoriteCurves)
            .join('path')
            .attr('d', d => d)
            .attr('stroke', (d, i) => {
            const track = this.manuallyPinnedTracks[i];
            const firstPoint = track.pointList[0];
            const locId = firstPoint.get('Location ID');
            const labelList = this.parentWidget.fullData.inverseLocationMap.get(locId);
            const color = GroupByWidget_1.GroupByWidget.getColor(labelList, this.parentWidget.colorLookup);
            return color;
        })
            .attr('data-cellId', (d, i) => this.manuallyPinnedTracks[i].id)
            .classed('exemplarCurve', true);
        groupSelection.selectAll('.exemplarPlotAxis')
            .data((d, i) => scaleList.map(x => [x, i]))
            .join('g')
            .classed('exemplarPlotAxis', true)
            .attr('transform', (d) => `translate(0, ${d[0][1]})`)
            .each(function (d) {
            let axisFunc;
            axisFunc = d[0][0];
            axisFunc(d3.select(this));
        });
    }
    updateCurrentFrameIndicator(frameId) {
        if (!this.exemplarScaleX) {
            return;
        }
        let groupListSelection = this.exemplarCurvesGroup.selectAll('.plotGrouper');
        groupListSelection.selectAll('.currentFrameLine')
            .data([42])
            .join('line')
            .attr('x1', this.exemplarScaleX(frameId))
            .attr('x2', this.exemplarScaleX(frameId))
            .attr('y1', this.exemplarScaleY.range()[0])
            .attr('y2', this.exemplarScaleY.range()[1])
            .attr('stroke', 'black')
            .classed('currentFrameLine', true);
    }
    updateExemplarCurvesOffset() {
        const contentOffset = Number(this.selectedImageCanvas.attr('width'));
        const offsetToExemplarCurves = this.cellTimelineMargin.left + contentOffset + this.trackToPlotPadding;
        this.exemplarCurvesGroup.attr('transform', d => `translate(${offsetToExemplarCurves}, ${this.cellTimelineMargin.top - this.latestScroll[1]})`);
    }
    generateExemplarGrowthCurves() {
        const xKey = 'Frame ID';
        const yKey = this.exemplarYKey;
        let line = d3.line()
            .x(d => this.exemplarScaleX(d[0]))
            .y(d => this.exemplarScaleY(d[1]));
        // todo - maybe normalize this to a [number, number][] so filtering is easier.
        let favoriteCurves = [];
        for (let track of this.manuallyPinnedTracks) {
            let pointList = this.extract2DArray(track.pointList, xKey, yKey);
            if (this.smoothCurves) {
                pointList = CurveList_1.CurveList.medianFilter(pointList);
            }
            let pathString = line(pointList);
            favoriteCurves.push(pathString);
        }
        let exemplarCurves = [];
        for (let i = 0; i < this.trackList.length; i += this.parentWidget.numExemplars) {
            let pathList = [];
            for (let path of this.trackList.slice(i, i + this.parentWidget.numExemplars)) {
                let pointList = this.extract2DArray(path.data.pointList, xKey, yKey);
                if (this.smoothCurves) {
                    pointList = CurveList_1.CurveList.medianFilter(pointList);
                }
                let pathString = line(pointList);
                pathList.push(pathString);
            }
            exemplarCurves.push(pathList);
        }
        // average growth calculation
        let [minFrame, maxFrame] = this.parentWidget.fullData.getMinMax('Frame ID');
        let lineAvg = d3.line()
            .x(d => this.exemplarScaleX(d[0]))
            .y(d => this.exemplarScaleY(d[1]));
        let averageGrowthLines = [];
        for (let facet of this.parentWidget.facetList) {
            let averageGrowthCurve = facet.data.getAverageCurve(yKey, false, this.smoothCurves);
            let averageGrowthCurveString = lineAvg(averageGrowthCurve);
            averageGrowthLines.push(averageGrowthCurveString);
        }
        return {
            favoriteCurves: favoriteCurves,
            exemplarCurves: exemplarCurves,
            averageCurves: averageGrowthLines
        };
    }
    extract2DArray(pointList, xKey, yKey) {
        return pointList.map(point => [point.get(xKey), point.get(yKey)]);
    }
    updateLabelsOnMouseMove(cellId, frameIndex, rowIndex) {
        let svgSelection = this.cellLabelGroup.selectAll('text');
        if (!this.parentWidget.inExemplarMode) {
            let foundMatch = this.hoverNodeWithText(svgSelection.nodes(), cellId);
            svgSelection = this.frameLabelGroup.selectAll('text');
            if (!foundMatch) {
                this.hoverNodeWithText(svgSelection.nodes(), '');
                return;
            }
        }
        else {
            this.exemplarCurvesGroup.selectAll('.exemplarCurve').classed('selected', false);
            this.exemplarPinGroup.selectAll('*').classed('selected', false);
            this.manualExemplarPinGroup.selectAll('*').classed('selected', false);
            if (typeof (rowIndex) !== 'undefined') {
                if (rowIndex < this.manuallyPinnedTracks.length) {
                    let foundMatch = this.hoverNodeWithText(svgSelection.nodes(), cellId);
                    svgSelection = this.frameLabelGroup.selectAll('text');
                    if (!foundMatch) {
                        this.hoverNodeWithText(svgSelection.nodes(), '');
                        // return
                    }
                }
                if (cellId) {
                    const data = [...this.manuallyPinnedTracks, ...this.trackList.map(exemplar => exemplar.data)];
                    this.exemplarCurvesGroup.selectAll('.exemplarCurve')
                        .data(data)
                        .classed('selected', function (d, i) {
                        i == rowIndex;
                        const thisCellId = d3.select(this).attr('data-cellId');
                        return thisCellId === cellId;
                    });
                    this.exemplarPinGroup.selectAll('*')
                        .classed('selected', function (d, i) {
                        return d3.select(this).classed(cellId);
                    });
                    this.manualExemplarPinGroup.selectAll('*')
                        .classed('selected', function (d, i) {
                        return d3.select(this).classed(cellId);
                    });
                }
                let searchText;
                if (rowIndex < 0) {
                    searchText = '';
                }
                else {
                    let categoryIndex = Math.floor(rowIndex / this.parentWidget.numExemplars);
                    searchText = this.conditionLabelPositions[categoryIndex][0];
                }
                this.hoverNodeWithText(svgSelection.nodes(), searchText);
            }
        }
        svgSelection = this.frameLabelGroup.selectAll('text');
        let frameText;
        if (this.parentWidget.inCondensedMode) {
            let percent = frameIndex / (this.parentWidget.condensedModeCount - 1);
            frameText = percent.toFixed(2);
        }
        else {
            frameText = (frameIndex + 1).toString();
        }
        this.hoverNodeWithText(svgSelection.nodes(), frameText);
    }
    hoverNodeWithText(svgElementList, text) {
        let fountMatch = false;
        for (let node of svgElementList) {
            let nodeEl = node;
            if (nodeEl.textContent === text) {
                nodeEl.classList.add('hovered');
                fountMatch = true;
            }
            else {
                nodeEl.classList.remove('hovered');
            }
        }
        return fountMatch;
    }
    OnResize(width, height) {
        height -= 30; // hacky, but see .cellTimelineInnerContainer.top for explanation
        this.svgContainer
            .attr('height', height)
            .attr('width', width);
        this.shameRectangle.attr('width', width);
        const innerW = width - this.cellTimelineMargin.left - this.cellTimelineMargin.right;
        this._innerContainerW = innerW;
        const innerH = height - this.cellTimelineMargin.top - this.cellTimelineMargin.bottom;
        this._innerContainerH = innerH;
        this.innerContainer
            .attr('style', `max-width: ${innerW}px;
            max-height: ${innerH}px;
            width: ${innerW}px;
            height: ${innerH}px;`);
    }
}
exports.ImageTrackWidget = ImageTrackWidget;

},{"../DataModel/CurveList":100,"../DataModel/ImageStackDataRequest":110,"../devlib/DevlibAlgo":114,"../devlib/DevlibMath":115,"../devlib/DevlibTSUtil":116,"./GroupByWidget":86,"./HistogramWidget":87,"./OptionSelect":92,"d3":42,"number-to-words":45}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const BaseWidget_1 = require("./BaseWidget");
const LayoutFramework_1 = require("../LayoutFramework");
const HistogramWidget_1 = require("./HistogramWidget");
const ScatterPlotWidget_1 = require("./ScatterPlotWidget");
const types_1 = require("../types");
class MetricDistributionWidget extends BaseWidget_1.BaseWidget {
    constructor(container, metricDistributionCollectionLevel, isClone = false) {
        super(container, false, metricDistributionCollectionLevel);
        this._isClone = isClone;
    }
    Clone(container) {
        return new MetricDistributionWidget(container, this.metricDistributionCollectionLevel, true);
    }
    get isClone() {
        return this._isClone;
    }
    get wrapperContainer() {
        return this._wrapperContainer;
    }
    get layoutFramework() {
        return this._layoutFramework;
    }
    get subComponentLookup() {
        return this._subComponentLookup;
    }
    get titleContainerSelection() {
        return this._titleContainerSelection;
    }
    get basisSelectContainerSelection() {
        return this._basisSelectContainerSelection;
    }
    get scatterPlotSelectContainerSelection() {
        return this._scatterPlotSelectContainerSelection;
    }
    get yAxisMatrixSelect() {
        return this._yAxisMatrixSelect;
    }
    get xAxisMatrixSelect() {
        return this._xAxisMatrixSelect;
    }
    get distributionPlotContainerSelection() {
        return this._distributionPlotContainerSelection;
    }
    get scatterPlotContainerSelection() {
        return this._scatterPlotContainerSelection;
    }
    get collapseButtonSelect() {
        return this._collapseButtonSelect;
    }
    get expandButtonSelect() {
        return this._expandButtonSelect;
    }
    get attributeToIndex() {
        return this._attributeToIndex;
    }
    get basisSelectionBooleans() {
        return this._basisSelectionBooleans;
    }
    get scatterplotSelectionBooleans() {
        return this._scatterplotSelectionBooleans;
    }
    get histogramWidgets() {
        return this._histogramWidgets;
    }
    get scatterPlotWidgets() {
        return this._scatterPlotWidgets;
    }
    get pointCollection() {
        return this._pointCollection;
    }
    get metricDistributionCollectionLevel() {
        return this._metricDistributionCollectionLevel;
    }
    get includeExemplarTrackButton() {
        return this._includeExemplarTrackButton;
    }
    get showingSelectionMatrix() {
        return this._showingSelectionMatrix;
    }
    initProps(props) {
        super.initProps();
        this._metricDistributionCollectionLevel = props[0];
        this._showingSelectionMatrix = false;
    }
    init() {
        this._wrapperContainer = document.createElement("div");
        this.wrapperContainer.classList.add("frame", "dir-row", "wrapperContainer");
        this.container.appendChild(this.wrapperContainer);
        this._layoutFramework = new LayoutFramework_1.LayoutFramework(this.wrapperContainer, false);
        let layout = {
            direction: types_1.Direction.row,
            wrap: true,
            overflowScroll: true,
            inside: [
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.Title,
                    minSize: '100%',
                    fraction: 0
                },
                {
                    direction: types_1.Direction.column,
                    minSize: '80px',
                    maxSize: '80px',
                    inside: types_1.MetricDistributionSubComponentTypes.BasisSelect
                },
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.ScatterplotSelect
                },
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.DistributionPlot
                },
                {
                    direction: types_1.Direction.column,
                    inside: types_1.MetricDistributionSubComponentTypes.Scatterplot
                }
            ]
        };
        this._subComponentLookup = this.layoutFramework.InitializeLayout(layout);
        this.initSubComponents();
    }
    initSubComponents() {
        for (let [container, subComponent] of this.subComponentLookup) {
            switch (subComponent) {
                case types_1.MetricDistributionSubComponentTypes.Title:
                    this._titleContainerSelection = this.initSubComponent(container, "titleContainer");
                    let title;
                    if (this.metricDistributionCollectionLevel == types_1.MetricDistributionCollectionLevel.Curve) {
                        title = 'Track-Level Attributes';
                    }
                    else {
                        title = 'Cell-Level Attributes';
                    }
                    this.titleContainerSelection
                        .append('div')
                        .attr('style', 'width: 32px'); // spacer div
                    this.titleContainerSelection
                        .append('span')
                        .text(title)
                        .classed('attributeTitle', true)
                        .classed('mediumText', true);
                    break;
                case types_1.MetricDistributionSubComponentTypes.BasisSelect:
                    this._basisSelectContainerSelection = this.initSubComponent(container, "toggleButtonContainer");
                    break;
                case types_1.MetricDistributionSubComponentTypes.ScatterplotSelect:
                    let wrapper = d3.select(container).append('div')
                        .classed("matrixWrapperContainer", true)
                        .attr("id", "matrixWrapperContainer");
                    this._yAxisMatrixSelect = this.initSubComponent(wrapper.node(), "yAxisMatrixContainer");
                    let rightWrapper = wrapper.append('div')
                        .classed("matrixRightWrapperContainer", true);
                    this._scatterPlotSelectContainerSelection = this.initSubComponent(rightWrapper.node(), "matrixContainer");
                    this._xAxisMatrixSelect = this.initSubComponent(rightWrapper.node(), "xAxisMatrixContainer");
                    let collapseExpandList = [
                        this.basisSelectContainerSelection.node().parentElement,
                        wrapper.node().parentElement
                    ];
                    this.hideElements(collapseExpandList); // collapsed by default
                    this.initExpandCollapseButton(collapseExpandList);
                    break;
                case types_1.MetricDistributionSubComponentTypes.DistributionPlot:
                    this._distributionPlotContainerSelection = this.initSubComponent(container, "distributionPlotContainer");
                    this.distributionPlotContainerSelection.node().style.minWidth = '300px'; // this is hardcoded based on max width of histogram
                    this.distributionPlotContainerSelection.node().style.maxWidth = '300px'; // this is hardcoded based on max width of histogram
                    break;
                case types_1.MetricDistributionSubComponentTypes.Scatterplot:
                    this._scatterPlotContainerSelection = this.initSubComponent(container, "scatterPlotOuterContainer");
                    this._scatterPlotContainerSelection.node().style.minWidth = '300px'; // this is hardcoded based on max width of scatterplot
                    this._scatterPlotContainerSelection.node().style.maxWidth = '300px'; // this is hardcoded based on max width of scatterplot
                    break;
                default:
                    break;
            }
        }
        this.resizeSubComponents();
    }
    initSubComponent(container, className) {
        return d3.select(container)
            .append("div")
            .classed(className, true)
            // .classed("overflow-scroll", true)
            .attr("id", className);
    }
    hideElements(toHide) {
        for (let element of toHide) {
            element.classList.add("noDisp");
        }
    }
    initExpandCollapseButton(toShow) {
        this._expandButtonSelect = this.titleContainerSelection.append('button')
            // .lower()
            .classed('basicIconButton', true)
            .classed('tab', true)
            .classed('noDisp', true)
            .attr('id', 'MetricDistributionWidget-expandButton')
            .attr("title", "Open distribution selection widget.")
            .on('click', () => {
            if (this.showingSelectionMatrix) {
                for (let element of toShow) {
                    element.classList.add('noDisp');
                }
                this.expandButtonSelect.classed('selected', false);
            }
            else {
                for (let element of toShow) {
                    element.classList.remove('noDisp');
                }
                this.expandButtonSelect.classed('selected', true);
            }
            this._showingSelectionMatrix = !this.showingSelectionMatrix;
        });
        let icon = DevlibTSUtil_1.DevlibTSUtil.getFontAwesomeIcon('cog');
        this.expandButtonSelect.node().appendChild(icon);
    }
    OnDataChange() {
        switch (this.metricDistributionCollectionLevel) {
            case types_1.MetricDistributionCollectionLevel.Point:
                this._pointCollection = this.data;
                this._includeExemplarTrackButton = false;
                break;
            case types_1.MetricDistributionCollectionLevel.Curve:
                this._pointCollection = this.data.curveCollection;
                this._includeExemplarTrackButton = true;
                break;
            default:
                this._pointCollection = null;
                this._includeExemplarTrackButton = false;
                throw new Error('MetricDistributionCollectionLevel not set.');
                break;
        }
        this._attributeToIndex = new Map();
        for (let [index, attr] of this.pointCollection.attributeList.entries()) {
            this.attributeToIndex.set(attr, index);
        }
        this.updateUIData();
        this.drawBasisSelect();
        this.drawScatterPlotSelectContainerSelection();
        this.drawMatrixAxis();
        this.expandButtonSelect.classed('noDisp', false);
        this.drawHistograms();
        this.drawScatterPlots(this.getScatterOptionsMatrix());
    }
    OnBrushChange() {
        for (let hist of this.histogramWidgets) {
            hist.OnBrushChange();
        }
        for (let scatter of this.scatterPlotWidgets) {
            scatter.OnBrushChange();
        }
    }
    updateUIData() {
        this._basisSelectionBooleans = [];
        // Todo - it would be nice if this was configurable.
        const defaultIncluded = new Set(['Mass (pg)', 'Time (h)', 'Mass_norm', 'Track Length', 'Avg. Mass (pg)', 'Growth Rate', 'Exponential Growth Constant']);
        const maxDefaultMatrixSize = 15;
        this._scatterplotSelectionBooleans = [];
        for (let [rowIndex, attr1] of this.pointCollection.attributeList.entries()) {
            this.basisSelectionBooleans.push(rowIndex < maxDefaultMatrixSize && defaultIncluded.has(attr1));
            let row = [];
            for (let [colIndex, attr2] of this.pointCollection.attributeList.entries()) {
                row.push({
                    value: attr1 === attr2,
                    index: [rowIndex, colIndex]
                });
            }
            this.scatterplotSelectionBooleans.push(row);
        }
        this.drawBasisSelect();
    }
    drawBasisSelect() {
        let thisWidget = this;
        let flatData = this.getScatterOptionsMatrix();
        this.basisSelectContainerSelection
            .selectAll("button")
            .data(this.pointCollection.attributeList)
            .join("button")
            .text(d => d)
            .attr('title', d => d)
            .classed("toggleButton", true)
            .classed("on", (d, i) => this.basisSelectionBooleans[i])
            .attr("id", d => "MetricDistributionWidget-varSelect-" + d)
            .on('click', function (d, i) {
            let buttonSelect = d3.select(this);
            let turnOn = !thisWidget.basisSelectionBooleans[i];
            buttonSelect.classed("on", turnOn);
            thisWidget.basisSelectionBooleans[i] = turnOn;
            thisWidget.drawScatterPlotSelectContainerSelection();
            thisWidget.drawMatrixAxis();
            thisWidget.updateHistograms();
            thisWidget.updateScatterPlots(flatData);
        });
    }
    drawMatrixAxis() {
        const buttonWidth = 80;
        const buttonHeight = 18;
        let options = this.getCurrentOptions();
        this.yAxisMatrixSelect.selectAll("button")
            .data(options)
            .join("button")
            .classed('axisButton', true)
            .classed('y', true)
            .attr("style", (d, i) => `
				width: ${buttonWidth}px;
				height: ${buttonHeight}px;`)
            .text(d => d)
            .attr('title', d => d)
            .on("click", (d) => {
            let rowIndex = this.attributeToIndex.get(d);
            let row = this.scatterplotSelectionBooleans[rowIndex];
            let allTrue = true;
            for (let cell of row) {
                if (this.basisSelectionBooleans[cell.index[1]]) {
                    if (!cell.value) {
                        allTrue = false;
                    }
                    cell.value = true;
                }
            }
            if (allTrue) {
                for (let cell of row) {
                    if (this.basisSelectionBooleans[cell.index[1]]) {
                        cell.value = false;
                    }
                }
            }
            this.afterMultipleMatrixChanges();
        })
            .on("mouseenter", function (d) {
            d3.select(this).classed("hovered", true);
        })
            .on("mouseleave", function (d) {
            d3.select(this).classed("hovered", false);
        });
        // add triangle quick selects
        const triangleButtonSvg = this.yAxisMatrixSelect.selectAll('svg')
            .data([42])
            .join('svg')
            .attr('width', buttonWidth)
            .attr('height', buttonWidth)
            .classed('triangleQuickSelect', true)
            .raise();
        const trianglePad = 4;
        const triangleScale = d3.scaleLinear()
            .domain([0, 1])
            .range([trianglePad, buttonWidth - trianglePad]);
        const gap = 0.05;
        const upperTrianglePoints = [[gap, 0], [1, 0], [1, 1 - gap], [gap, 0]];
        const lowerTrianglePoints = [[0, gap], [1 - gap, 1], [0, 1], [0, gap]];
        const line = d3.line()
            .x(d => triangleScale(d[0]))
            .y(d => triangleScale(d[1]));
        triangleButtonSvg.selectAll('path')
            .data([upperTrianglePoints, lowerTrianglePoints])
            .join('path')
            .attr('d', d => line(d))
            .classed('triangleButton', true)
            .on('mouseenter', function (d) {
            d3.select(this).classed('hover', true);
        })
            .on('mouseleave', function (d) {
            d3.select(this).classed('hover', false);
        })
            .on('click', (d, i) => {
            if (i == 0) {
                this.toggleUpperTriangle();
                this.afterMultipleMatrixChanges();
            }
            else {
                this.toggleLowerTriangle();
                this.afterMultipleMatrixChanges();
            }
        });
        const halfWidth = buttonWidth / 2;
        const rotate = -90;
        const theta = Math.PI * rotate / 180;
        const xOffset = -0.5 * (buttonWidth + buttonWidth * Math.cos(-theta) + buttonHeight * Math.sin(-theta));
        const yOffset = 0.5 * (buttonWidth * Math.sin(-theta) + buttonHeight * Math.cos(-theta) - buttonHeight);
        let theta2 = 90 + rotate;
        theta2 = Math.PI * theta2 / 180;
        const horizontalPadding = 2;
        let stepSize = horizontalPadding + buttonHeight / Math.cos(theta2);
        this.xAxisMatrixSelect.selectAll("button")
            .data(options)
            .join("button")
            .classed('axisButton', true)
            .classed('x', true)
            .attr("style", (d, i) => `
				width: ${buttonWidth}px;
				height: ${buttonHeight}px;
				transform: translate( ${stepSize * (i + 1) + xOffset}px, ${yOffset}px) rotate(${rotate}deg);`)
            .text(d => d)
            .attr('title', d => d)
            .on("click", (d) => {
            let colIndex = this.attributeToIndex.get(d);
            let allTrue = true;
            for (let row of this.scatterplotSelectionBooleans) {
                for (let cell of row) {
                    let cellRowIndex = cell.index[0];
                    let cellColIndex = cell.index[1];
                    if (colIndex === cellColIndex && this.basisSelectionBooleans[cellRowIndex]) {
                        if (!cell.value) {
                            allTrue = false;
                        }
                        cell.value = true;
                    }
                }
            }
            if (allTrue) {
                for (let row of this.scatterplotSelectionBooleans) {
                    for (let cell of row) {
                        let cellRowIndex = cell.index[0];
                        let cellColIndex = cell.index[1];
                        if (colIndex === cellColIndex && this.basisSelectionBooleans[cellRowIndex]) {
                            cell.value = false;
                        }
                    }
                }
            }
            this.afterMultipleMatrixChanges();
        })
            .on("mouseenter", function (d) {
            d3.select(this).classed("hovered", true);
        })
            .on("mouseleave", function (d) {
            d3.select(this).classed("hovered", false);
        });
    }
    toggleUpperTriangle() {
        this.toggleTriangle(true);
    }
    toggleLowerTriangle() {
        this.toggleTriangle(false);
    }
    toggleTriangle(upper) {
        let allTrue = true;
        for (let i = 0; i < this.scatterplotSelectionBooleans.length; i++) {
            if (!this.basisSelectionBooleans[i]) {
                continue;
            }
            let row = this.scatterplotSelectionBooleans[i];
            let low;
            let high;
            if (upper) {
                low = i + 1;
                high = row.length;
            }
            else {
                low = 0;
                high = i;
            }
            for (let j = low; j < high; j++) {
                if (!this.basisSelectionBooleans[j]) {
                    continue;
                }
                if (!row[j].value) {
                    allTrue = false;
                    break;
                }
            }
            if (!allTrue) {
                break;
            }
        }
        const newValue = !allTrue;
        for (let i = 0; i < this.scatterplotSelectionBooleans.length; i++) {
            if (!this.basisSelectionBooleans[i]) {
                continue;
            }
            let row = this.scatterplotSelectionBooleans[i];
            let low;
            let high;
            if (upper) {
                low = i + 1;
                high = row.length;
            }
            else {
                low = 0;
                high = i;
            }
            for (let j = low; j < high; j++) {
                if (this.basisSelectionBooleans[j]) {
                    row[j].value = newValue;
                }
            }
        }
    }
    getCurrentOptions() {
        return this.pointCollection.attributeList.filter((d, i) => this.basisSelectionBooleans[i]);
    }
    afterMultipleMatrixChanges() {
        this.updateMatrixCellSelections();
        let flatData = this.getScatterOptionsMatrix();
        this.updateHistograms();
        this.updateScatterPlots(flatData);
    }
    updateMatrixCellSelections() {
        this.scatterPlotSelectContainerSelection
            .selectAll("div")
            .data(this.scatterplotSelectionBooleans)
            .join("div")
            .selectAll("button")
            .data(d => d)
            .join("button")
            .classed("on", d => d.value);
    }
    drawScatterPlotSelectContainerSelection() {
        let thisWidget = this;
        let flatData = this.getScatterOptionsMatrix();
        this.scatterPlotSelectContainerSelection
            .selectAll("div")
            .data(this.scatterplotSelectionBooleans)
            .join("div")
            .classed("rowContainer", true)
            .classed("noDisp", (d, i) => !thisWidget.basisSelectionBooleans[i])
            .selectAll("button")
            .data(d => d)
            .join("button")
            .classed("squareButton", true)
            .classed("on", d => d.value)
            .classed("noDisp", (d, i) => !thisWidget.basisSelectionBooleans[i])
            .attr("id", d => "MetricDistributionWidget-scatterSelect-" + d.index[0] + "-" + d.index[1])
            .on("click", function (d, i) {
            let buttonSelect = d3.select(this);
            let turnOn = !d.value;
            buttonSelect.classed("on", turnOn);
            thisWidget.scatterplotSelectionBooleans[d.index[0]][i].value = turnOn;
            if (i === d.index[0]) {
                thisWidget.updateHistograms();
            }
            else {
                thisWidget.updateScatterPlots(flatData);
            }
        })
            .on("mouseenter", function (d) {
            let [rowIdx, colIdx] = d.index;
            let buttonSelect = d3.select(this);
            buttonSelect.classed("hovered", true);
            let options = thisWidget.getCurrentOptions();
            let rowName = thisWidget.pointCollection.attributeList[rowIdx];
            let colName = thisWidget.pointCollection.attributeList[colIdx];
            thisWidget.yAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", d => d === rowName);
            thisWidget.xAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", d => d === colName);
        })
            .on("mouseleave", function (d) {
            let buttonSelect = d3.select(this);
            buttonSelect.classed("hovered", false);
            let options = thisWidget.getCurrentOptions();
            thisWidget.yAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", false);
            thisWidget.xAxisMatrixSelect.selectAll("button")
                .data(options)
                .classed("hovered", false);
        });
    }
    drawHistograms() {
        let thisWidget = this;
        this._histogramWidgets = [];
        let parentElement = this.distributionPlotContainerSelection.node().parentElement;
        parentElement.classList.remove("noDisp");
        this.distributionPlotContainerSelection.html(null)
            .classed("noDisp", false)
            .selectAll("div")
            .data(this.pointCollection.attributeList)
            .join("div")
            .classed("histogramContainer", true)
            .attr("id", d => "MetricDistributionWidget-histogramContainer-" + d)
            .each(function (d) {
            let container = this;
            const canBrush = true;
            let newWidget = new HistogramWidget_1.HistogramWidget(container, d, canBrush, thisWidget.includeExemplarTrackButton);
            thisWidget.histogramWidgets.push(newWidget);
        });
        this.updateHistograms();
    }
    updateHistograms() {
        let thisWidget = this;
        let allHidden = true;
        this.distributionPlotContainerSelection
            .selectAll(".histogramContainer")
            .data(this.pointCollection.attributeList)
            .classed("noDisp", (d, i) => {
            let shouldHide = this.shouldHide(i);
            if (!shouldHide) {
                allHidden = false;
            }
            return shouldHide;
        })
            .each(function (d, i) {
            let container = this;
            let histogramWidget = thisWidget.histogramWidgets[i];
            if (!thisWidget.shouldHide(i) && !histogramWidget.data) {
                histogramWidget.SetData(thisWidget.pointCollection);
            }
        });
        let parentElement = this.distributionPlotContainerSelection.node().parentElement;
        if (allHidden) {
            parentElement.classList.add("noDisp");
        }
        else {
            parentElement.classList.remove("noDisp");
        }
    }
    getScatterOptionsMatrix() {
        let flatData = this.scatterplotSelectionBooleans.flat();
        flatData = flatData.filter(d => d.index[0] !== d.index[1]);
        return flatData;
    }
    drawScatterPlots(flatData) {
        this._scatterPlotWidgets = [];
        let thisWidget = this;
        let parentElement = this.scatterPlotContainerSelection.node().parentElement;
        parentElement.classList.remove("noDisp");
        this.scatterPlotContainerSelection.html(null)
            .selectAll("div")
            .data(flatData)
            .join("div")
            .classed("scatterPlotContainer", true)
            .each(function (d) {
            let container = this;
            let xKey = thisWidget.pointCollection.attributeList[d.index[1]];
            let yKey = thisWidget.pointCollection.attributeList[d.index[0]];
            let newWidget = new ScatterPlotWidget_1.ScatterPlotWidget(container, xKey, yKey);
            thisWidget.scatterPlotWidgets.push(newWidget);
        });
        this.updateScatterPlots(flatData);
    }
    updateScatterPlots(flatData) {
        let thisWidget = this;
        let allHidden = true;
        this.scatterPlotContainerSelection
            .selectAll(".scatterPlotContainer")
            .data(flatData)
            .classed("noDisp", (d) => {
            let shouldHide = this.shouldHide(d);
            if (!shouldHide) {
                allHidden = false;
            }
            return shouldHide;
        })
            .each(function (d, i) {
            let scatterWidget = thisWidget.scatterPlotWidgets[i];
            if (!thisWidget.shouldHide(d) && !scatterWidget.data) {
                scatterWidget.SetData(thisWidget.pointCollection);
            }
        });
        let parentElement = this.scatterPlotContainerSelection.node().parentElement;
        if (allHidden) {
            parentElement.classList.add("noDisp");
        }
        else {
            parentElement.classList.remove("noDisp");
        }
    }
    shouldHide(d) {
        if (typeof d === "number") {
            if (!this.basisSelectionBooleans[d]) {
                return true;
            }
            return !this.scatterplotSelectionBooleans[d][d].value;
        }
        if (!this.basisSelectionBooleans[d.index[0]] || !this.basisSelectionBooleans[d.index[1]]) {
            return true;
        }
        return !d.value;
    }
    OnResize() {
        this.resizeSubComponents();
    }
    resizeSubComponents() {
        // this.layoutFramework.container.chil
        // this.basisSelectContainerSelection.node().style.maxHeight = this.height + "px"
        // this.basisSelectContainerSelection.node().style.maxHeight = this.height + "px"
        // this.scatterPlotSelectContainerSelection.node().style.maxHeight = this.height + "px"
        // this.distributionPlotContainerSelection.node().style.maxHeight = this.height + "px"
        this.scatterPlotContainerSelection.node().style.maxHeight = this.height + "px";
    }
}
exports.MetricDistributionWidget = MetricDistributionWidget;

},{"../LayoutFramework":113,"../devlib/DevlibTSUtil":116,"../types":118,"./BaseWidget":84,"./HistogramWidget":87,"./ScatterPlotWidget":95,"d3":42}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
var OptionMode;
(function (OptionMode) {
    OptionMode[OptionMode["ButtonList"] = 0] = "ButtonList";
    OptionMode[OptionMode["Dropdown"] = 1] = "Dropdown";
})(OptionMode || (OptionMode = {}));
class OptionSelect {
    constructor(htmlContainerId, label, defaultSelectionIndex) {
        this._containerSelect = d3.select("#" + htmlContainerId);
        this._label = label;
        this._uniqueId = 'OptionSelectDropdown_' + OptionSelect._instanceCount++;
        this._currentSelectionIndex = null;
        if (typeof defaultSelectionIndex !== 'undefined') {
            this._currentSelectionIndex = defaultSelectionIndex;
        }
    }
    get data() {
        return this._data;
    }
    get containerSelect() {
        return this._containerSelect;
    }
    get label() {
        return this._label;
    }
    get mode() {
        return this._mode;
    }
    get uniqueId() {
        return this._uniqueId;
    }
    get currentSelectionIndex() {
        return this._currentSelectionIndex;
    }
    clearSelectedButton() {
        this.containerSelect.selectAll(".on")
            .classed("on", false);
    }
    onDataChange(data, defaultSelection) {
        this._data = data;
        console.log(data);
        this.containerSelect.html(null);
        if (this.data.length === 1) {
            if (this.label) {
                this.containerSelect
                    .append('span')
                    .classed('optionSelectLabel', true)
                    .text(this.label);
            }
            this.containerSelect
                .append("span")
                .classed("valueHeader", true)
                .text(this.data[0].displayName);
            return;
        }
        this.updateButtons(defaultSelection);
    }
    updateButtons(defaultSelection) {
        if (typeof defaultSelection !== 'undefined') {
            this._currentSelectionIndex = defaultSelection;
        }
        if (this.data.length < 4) {
            this.drawQuickSelectButtons(this.currentSelectionIndex);
        }
        else {
            this.drawDropDownButtons(this.currentSelectionIndex);
        }
    }
    drawQuickSelectButtons(defaultSelection) {
        this._mode = OptionMode.ButtonList;
        let thisOptionSelect = this;
        this.containerSelect.html(null);
        if (this.label) {
            this.containerSelect
                .append('span')
                .classed('optionSelectLabel', true)
                .text(this.label);
        }
        this.containerSelect
            .selectAll("button")
            .data(this.data)
            .join("button")
            .text(d => d.displayName)
            .classed("toggleButton", true)
            .classed("on", (d, i) => defaultSelection === i)
            .on("click", function (buttonProps, index) {
            if (this.classList.contains("on")) {
                return;
            }
            thisOptionSelect._currentSelectionIndex = index;
            thisOptionSelect.clearSelectedButton();
            d3.select(this).classed("on", true);
            buttonProps.callback();
        });
    }
    drawDropDownButtons(defaultSelection) {
        this._mode = OptionMode.Dropdown;
        let thisOptionSelect = this;
        this.containerSelect.html(null);
        if (this.label) {
            this.containerSelect.append('label')
                .text(this.label)
                .classed('optionSelectLabel', true)
                .attr('for', this.uniqueId);
        }
        this.containerSelect
            .append('select')
            .attr('id', this.uniqueId)
            .classed('optionSelectSelect', true)
            .on('change', () => {
            let optionSelect = this.containerSelect.select('#' + this.uniqueId);
            let newIndex = +optionSelect.property('value');
            this.data[newIndex].callback();
            thisOptionSelect._currentSelectionIndex = newIndex;
        })
            .selectAll('option')
            .data(this.data)
            .join('option')
            .attr('value', (d, i) => i)
            .property('selected', (d, i) => defaultSelection === i)
            .text(d => d.displayName);
    }
    addButton(buttonProps, selectIndex) {
        this.data.push(buttonProps);
        this.updateButtons(selectIndex);
    }
    removeButton(displayName, callDefaultCallback = true) {
        if (!this.data) {
            return;
        }
        let removeIndex = this.data.findIndex((button) => button.displayName === displayName);
        if (removeIndex === -1) {
            return;
        }
        this.data.splice(removeIndex);
        let selectionIndex;
        if (callDefaultCallback && this.currentSelectionIndex === removeIndex) {
            selectionIndex = 0;
            this.data[0].callback();
        }
        else {
            selectionIndex = this.currentSelectionIndex;
        }
        this.updateButtons(selectionIndex);
        return;
    }
    replaceButton(oldButtonName, newButtonProps) {
        this.removeButton(oldButtonName, false);
        this.addButton(newButtonProps, this.currentSelectionIndex);
        if (this.currentSelectionIndex === this.data.length - 1) {
            this.data[this.currentSelectionIndex].callback();
        }
    }
}
exports.OptionSelect = OptionSelect;
OptionSelect._instanceCount = 0;

},{"d3":42}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
const OptionSelect_1 = require("./OptionSelect");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const DataEvents_1 = require("../DataModel/DataEvents");
const GroupByWidget_1 = require("./GroupByWidget");
class Plot2dPathsWidget extends BaseWidget_1.BaseWidget {
    constructor(container, quickPickOptions, initialQuickPickOptionIndex = 0, squareAspectRatio = true, canBrush = true, isClone = false) {
        super(container, true, quickPickOptions, initialQuickPickOptionIndex, canBrush);
        this._squareAspectRatio = squareAspectRatio;
        this.addLabel();
        this._facetList = [];
        this._colorLookup = new Map();
        this._isClone = isClone;
        if (isClone) {
            this._inAverageMode = false;
            this._inFacetMode = false;
            DevlibTSUtil_1.DevlibTSUtil.hide(this.averageLegendSelect.node());
            DevlibTSUtil_1.DevlibTSUtil.hide(this.selectConditionButton);
            DevlibTSUtil_1.DevlibTSUtil.hide(this.compareConditionButton);
        }
        this.swapSvgVisibility();
        if (this.inAverageMode) {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.facetButton);
        }
    }
    Clone(container) {
        const canBrush = false;
        return new Plot2dPathsWidget(container, this.quickPickOptions, this.quickPickOptionSelect.currentSelectionIndex, this.squareAspectRatio, canBrush, true);
    }
    get isClone() {
        return this._isClone;
    }
    initProps(props) {
        super.initProps();
        this._quickPickOptions = props[0];
        this._initialQuickPickOptionIndex = props[1];
        let initialOption = this.quickPickOptions[this.initialQuickPickOptionIndex];
        this._canBrush = props[2];
        this._xKey = initialOption.xKey;
        this._yKey = initialOption.yKey;
        this._inAverageMode = initialOption.averaged;
        this._inFacetMode = true;
        this._tempConditionFilterState = new Map();
        this._smoothCurves = true;
    }
    get titleBarContainer() {
        return this._titleBarContainer;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get svgFacetSelect() {
        return this._svgFacetSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get mainGroupFacetSelect() {
        return this._mainGroupFacetSelect;
    }
    get yAxisFacetSelect() {
        return this._yAxisFacetSelect;
    }
    get xAxisFacetSelect() {
        return this._xAxisFacetSelect;
    }
    get averageLegendSelect() {
        return this._averageLegendSelect;
    }
    get facetLegendSelect() {
        return this._facetLegendSelect;
    }
    get canvasContainer() {
        return this._canvasContainer;
    }
    get canvasElement() {
        return this._canvasElement;
    }
    get averageCurveLabelContainer() {
        return this._averageCurveLabelContainer;
    }
    get currentFrameIndicator() {
        return this._currentFrameIndicator;
    }
    get canBrush() {
        return this._canBrush;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get xAxisGroupSelect() {
        return this._xAxisGroupSelect;
    }
    get xLabelTextSelect() {
        return this._xLabelTextSelect;
    }
    get yAxisGroupSelect() {
        return this._yAxisGroupSelect;
    }
    get yLabelTextSelect() {
        return this._yLabelTextSelect;
    }
    get quickPickContainerSelect() {
        return this._quickPickContainerSelect;
    }
    set quickPickContainerSelect(v) {
        this._quickPickContainerSelect = v;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleY() {
        return this._scaleY;
    }
    get xKey() {
        return this._xKey;
    }
    get yKey() {
        return this._yKey;
    }
    get quickPickOptions() {
        return this._quickPickOptions;
    }
    get initialQuickPickOptionIndex() {
        return this._initialQuickPickOptionIndex;
    }
    get quickPickOptionSelect() {
        return this._quickPickOptionSelect;
    }
    get squareAspectRatio() {
        return this._squareAspectRatio;
    }
    get brush() {
        return this._brush;
    }
    get lastXValueBrushBound() {
        return this._lastXValueBrushBound;
    }
    get lastYValueBrushBound() {
        return this._lastYValueBrushBound;
    }
    get inAverageMode() {
        return this._inAverageMode;
    }
    get inFacetMode() {
        return this._inFacetMode;
    }
    get smoothCurves() {
        return this._smoothCurves;
    }
    get facetList() {
        return this._facetList;
    }
    get colorLookup() {
        return this._colorLookup;
    }
    get forceSimulation() {
        return this._forceSimulation;
    }
    get tempConditionFilterState() {
        return this._tempConditionFilterState;
    }
    get miniCellSelect() {
        return this._miniCellSelect;
    }
    get selectConditionButton() {
        return this._selectConditionButton;
    }
    get compareConditionButton() {
        return this._compareConditionButton;
    }
    setMargin() {
        this._margin = {
            top: 54,
            right: 120,
            bottom: 62,
            left: 64
        };
    }
    init() {
        const containerSelect = d3.select(this.container);
        this._titleBarContainer = containerSelect.append('div')
            .classed('titleBarContainer', true);
        this._svgSelect = containerSelect.append("svg");
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._svgFacetSelect = containerSelect.append('svg');
        this._mainGroupFacetSelect = this.svgFacetSelect.append('g');
        this._yAxisFacetSelect = this.svgFacetSelect.append('g');
        this._xAxisFacetSelect = this.svgFacetSelect.append('g');
        // this.swapSvgVisibility();
        this._canvasContainer = this.mainGroupSelect
            .append('foreignObject')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight);
        this._canvasElement = this.canvasContainer.append('xhtml:canvas')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight)
            .node();
        if (this.canBrush) {
            this._brushGroupSelect = this.svgSelect.append("g")
                .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
                .classed('brushContainer', true)
                .classed('noDisp', this.inAverageMode);
            this.initBrush();
        }
        this.svgSelect.attr('width', this.width);
        this.svgSelect.attr('height', this.height);
        this.svgFacetSelect.attr('width', this.width);
        this.svgFacetSelect.attr('height', this.height);
        this._xAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight})`)
            .classed("labelColor", true);
        this._yAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed("labelColor", true);
        this._currentFrameIndicator = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._averageCurveLabelContainer = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._averageLegendSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left / 2}, ${this.margin.top + this.vizHeight + 44})`);
        this._facetLegendSelect = this.svgFacetSelect.append('g')
            .attr('transform', `translate(${this.margin.left / 2}, ${this.margin.top + this.vizHeight + 44})`);
        this.drawLegend();
        document.addEventListener('groupByChanged', async (e) => {
            let popupContainer = d3.select('#largePopupContainerOuter');
            if (!popupContainer.empty() && !popupContainer.classed('noDisp')) {
                return;
            }
            this._facetList = e.detail.flatFacetList;
            this._colorLookup = e.detail.colorLookup;
            if (this.inAverageMode) {
                this.OnDataChange();
            }
        });
        document.addEventListener('smoothCurveChange', (e) => {
            this._smoothCurves = e.detail;
            if (this.inAverageMode) {
                this.OnDataChange();
            }
        });
        document.addEventListener('locFrameClicked', (e) => {
            const frameId = e.detail.frameId;
            this.updateCurrentFrameIndicator(frameId);
        });
        this._selectConditionButton = DevlibTSUtil_1.DevlibTSUtil.getIconButton('th', () => {
            this._inFacetMode = true;
            this.selectConditionButton.classList.add('selected');
            this.compareConditionButton.classList.remove('selected');
            this.drawFacetContent();
        }, 'Facet');
        this.selectConditionButton.title = 'Filter data on experimental conditions';
        this.selectConditionButton.style.height = '100%';
        this.selectConditionButton.classList.add('tab');
        this.titleBarContainer.node().appendChild(this.selectConditionButton);
        this._compareConditionButton = DevlibTSUtil_1.DevlibTSUtil.getIconButton('chart-line', () => {
            this._inFacetMode = false;
            this.selectConditionButton.classList.remove('selected');
            this.compareConditionButton.classList.add('selected');
            this.drawFacetContent();
        }, 'Compare');
        this.compareConditionButton.title = 'Compare average curves across experimental conditions';
        this.compareConditionButton.style.height = '100%';
        this.compareConditionButton.classList.add('tab');
        this.titleBarContainer.node().appendChild(this.compareConditionButton);
        this.titleBarContainer.append('div').attr('style', 'flex-grow: 1;');
        if (this.inFacetMode) {
            this.selectConditionButton.classList.add('selected');
        }
        else {
            this.compareConditionButton.classList.add('selected');
        }
        this.initQuickPickOptions();
    }
    initQuickPickOptions() {
        const containerId = this.ComponentId + '-quickPickContainer';
        this._quickPickContainerSelect = this.titleBarContainer.append('div')
            .classed('quickPickContainer', true)
            .attr('id', containerId);
        this._quickPickOptionSelect = new OptionSelect_1.OptionSelect(containerId, "Axes");
        let buttonPropList = [];
        for (let quickPickOption of this.quickPickOptions) {
            let optionName;
            if (quickPickOption.averaged) {
                optionName = 'Averaged: ' + quickPickOption.yKey + ' over ' + quickPickOption.xKey;
            }
            else {
                optionName = quickPickOption.yKey + " v. " + quickPickOption.xKey;
            }
            let buttonProp = {
                displayName: optionName,
                callback: () => this.changeAxes(quickPickOption.xKey, quickPickOption.yKey, quickPickOption.averaged, quickPickOption.squareAspectRatio)
            };
            buttonPropList.push(buttonProp);
        }
        this.quickPickOptionSelect.onDataChange(buttonPropList, this.initialQuickPickOptionIndex);
    }
    initBrush() {
        this._brush = d3.brush()
            .extent([[0, 0], [this.vizWidth, this.vizHeight]])
            .on("end", () => { this.brushHandler(); });
        this.brushGroupSelect.call(this.brush);
    }
    addLabel() {
        this._xLabelTextSelect = this.svgSelect.append('text')
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .classed('noDisp', true);
        this._yLabelTextSelect = this.svgSelect.append('text')
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .classed('noDisp', true);
        this.positionLabels();
    }
    positionLabels() {
        // X-Axis
        let bufferForAxis = 32;
        this.xLabelTextSelect
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`);
        bufferForAxis = 40;
        // Y-Axis
        let transX = this.margin.left - bufferForAxis;
        let transY = this.margin.top + this.vizHeight / 2;
        let transformText;
        transformText = `rotate(-90) translate(${-transY}, ${transX})`;
        this.yLabelTextSelect.attr('transform', transformText);
    }
    OnDataChange() {
        this.updateScales();
        this.tempConditionFilterState.clear();
        this.resetTempConditionFilter();
        this.updatePaths();
        this.drawAxis();
        this.showLabel();
    }
    changeAxes(xKey, yKey, inAverageMode, squareAspectRatio) {
        this._xKey = xKey;
        this._yKey = yKey;
        if (this._inAverageMode !== inAverageMode) {
            this._inAverageMode = inAverageMode;
            if (inAverageMode) {
                this.margin.right = 120;
                DevlibTSUtil_1.DevlibTSUtil.hide(this.facetButton);
                DevlibTSUtil_1.DevlibTSUtil.show(this.averageLegendSelect.node());
                DevlibTSUtil_1.DevlibTSUtil.show(this.facetLegendSelect.node());
                DevlibTSUtil_1.DevlibTSUtil.show(this.compareConditionButton);
                DevlibTSUtil_1.DevlibTSUtil.show(this.selectConditionButton);
            }
            else {
                this.margin.right = 8;
                if (this.inFacetMode) {
                    this._inFacetMode = false;
                    this.swapSvgVisibility();
                }
                DevlibTSUtil_1.DevlibTSUtil.show(this.facetButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.selectConditionButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.compareConditionButton);
                DevlibTSUtil_1.DevlibTSUtil.hide(this.averageLegendSelect.node());
                DevlibTSUtil_1.DevlibTSUtil.hide(this.facetLegendSelect.node());
            }
            this.setWidthHeight();
            this.OnResize();
        }
        if (this.canBrush) {
            let brushElement = this.brushGroupSelect.node();
            if (this.inAverageMode) {
                DevlibTSUtil_1.DevlibTSUtil.hide(brushElement);
            }
            else {
                DevlibTSUtil_1.DevlibTSUtil.show(brushElement);
            }
        }
        this._squareAspectRatio = squareAspectRatio;
        this.removeBrush();
        this.OnDataChange();
        document.dispatchEvent(new CustomEvent('averageCurveKeyChange', {
            detail: {
                yKey: yKey
            }
        }));
    }
    removeBrush() {
        this.brushGroupSelect.call(this.brush.move, null);
    }
    updateScales() {
        let minX, maxX, minY, maxY;
        if (this.inAverageMode) {
            minY = d3.min(this.facetList, facet => d3.min(facet.data.getAverageCurve(this.yKey, false, this.smoothCurves), d => d[1]));
            maxY = d3.max(this.facetList, facet => d3.max(facet.data.getAverageCurve(this.yKey, false, this.smoothCurves), d => d[1]));
            if (this.data.brushApplied) {
                minY = d3.min([minY, d3.min(this.facetList, facet => d3.min(facet.data.getAverageCurve(this.yKey, true, this.smoothCurves), d => d[1]))]);
                maxY = d3.max([maxY, d3.max(this.facetList, facet => d3.max(facet.data.getAverageCurve(this.yKey, true, this.smoothCurves), d => d[1]))]);
            }
        }
        else {
            let data;
            if (this.isClone) {
                data = this.fullData;
            }
            else {
                data = this.data;
            }
            [minY, maxY] = data.minMaxMap.get(this.yKey);
        }
        [minX, maxX] = this.data.minMaxMap.get(this.xKey);
        if (this.squareAspectRatio) {
            this.makeSquareAspectRatioScales(minX, maxX, minY, maxY);
        }
        else {
            this.makeStretchedAspectRatioScales(minX, maxX, minY, maxY);
        }
    }
    makeSquareAspectRatioScales(minX, maxX, minY, maxY) {
        // this code keeps the data aspect ratio square and keeps it centered and as large
        // as possible in it's container
        let containerRatio = this.vizHeight / this.vizWidth;
        let dataRatio = (maxY - minY) / (maxX - minX);
        if (containerRatio > dataRatio) {
            this._scaleX = d3.scaleLinear()
                .domain([minX, maxX])
                .range([0, this.vizWidth]);
            let [scaledMinY, scaledMaxY] = [this.scaleX(minY), this.scaleX(maxY)];
            let dataLength = scaledMaxY - scaledMinY;
            let offset = (this.vizHeight - dataLength) / 2.0 - scaledMinY;
            this._scaleY = d3.scaleLinear()
                .domain([minY, maxY])
                .range([scaledMaxY + offset, scaledMinY + offset]);
        }
        else {
            this._scaleY = d3.scaleLinear()
                .domain([minY, maxY])
                .range([this.vizHeight, 0]);
            let [scaledMinX, scaledMaxX] = [this.scaleY(minX), this.scaleY(maxX)];
            let dataLength = scaledMaxX - scaledMinX;
            let offset = (this.vizWidth - dataLength) / 2.0 - scaledMinX;
            this._scaleX = d3.scaleLinear()
                .domain([minX, maxX])
                .range([scaledMaxX + offset, scaledMinX + offset]);
        }
    }
    makeStretchedAspectRatioScales(minX, maxX, minY, maxY) {
        this._scaleX = d3.scaleLinear()
            .domain([minX, maxX])
            .range([0, this.vizWidth]);
        this._scaleY = d3.scaleLinear()
            .domain([minY, maxY])
            .range([this.vizHeight, 0]);
    }
    swapSvgVisibility() {
        this.svgSelect.classed('noDisp', this.inFacetMode);
        this.svgFacetSelect.classed('noDisp', !this.inFacetMode);
        if (this.inFacetMode && this.dataSuperset) {
            this.resetTempConditionFilter();
        }
        else {
            let applyButton = document.getElementById('conditionFilterApplyButton');
            if (applyButton) {
                DevlibTSUtil_1.DevlibTSUtil.hide(applyButton);
            }
        }
    }
    updatePaths() {
        if (this.inAverageMode) {
            if (this.inFacetMode) {
                this.updateFacetPaths();
            }
            else {
                this.updateAveragePaths();
                this.drawAxis();
            }
        }
        else {
            this.updateAllPaths();
        }
    }
    updateAllPaths() {
        let line = d3.line()
            .x((d, i) => { return this.scaleX(d.get(this.xKey)); })
            .y((d) => { return this.scaleY(d.get(this.yKey)); })
            .defined(d => d.inBrush);
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight);
        canvasContext.strokeStyle = 'black';
        canvasContext.lineWidth = 1;
        canvasContext.globalAlpha = 0.25;
        canvasContext.lineJoin = 'round';
        for (let curve of this.data.curveList) {
            const path = new Path2D(line(curve.pointList));
            canvasContext.stroke(path);
        }
        this.clearLabels();
    }
    updateAveragePaths() {
        let lineAvg = d3.line()
            .x(d => this.scaleX(d[0]))
            .y(d => this.scaleY(d[1]));
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight);
        canvasContext.lineJoin = 'round';
        let labelData = [];
        for (let i = this.facetList.length - 1; i >= 0; i--) {
            canvasContext.globalAlpha = 0.85;
            canvasContext.lineWidth = 2;
            let facet = this.facetList[i];
            canvasContext.strokeStyle = GroupByWidget_1.GroupByWidget.getColor(facet.name, this.colorLookup);
            let dataPoints = facet.data.getAverageCurve(this.yKey, false, this.smoothCurves);
            if (dataPoints.length !== 0) {
                if (this.data.brushApplied) {
                    canvasContext.save();
                    // canvasContext.setLineDash([2, 3]);
                    canvasContext.globalAlpha *= 0.8;
                    canvasContext.lineWidth = 1;
                }
                const path = new Path2D(lineAvg(dataPoints));
                canvasContext.stroke(path);
            }
            let lastPoint = dataPoints[dataPoints.length - 1];
            canvasContext.restore();
            if (this.data.brushApplied) {
                let filteredDataPoints = facet.data.getAverageCurve(this.yKey, true, this.smoothCurves);
                if (filteredDataPoints.length !== 0) {
                    const path = new Path2D(lineAvg(filteredDataPoints));
                    canvasContext.stroke(path);
                }
                lastPoint = filteredDataPoints[filteredDataPoints.length - 1];
            }
            if (typeof (lastPoint) === 'undefined') {
                lastPoint = null;
            }
            labelData.unshift([facet.name.join('___'), lastPoint]);
        }
        this.drawLabels(labelData);
        // this.updateCurrentFrameIndicator();
    }
    updateCurrentFrameIndicator(frameId) {
        if (this.inAverageMode && !this.inFacetMode && typeof (frameId) !== 'undefined') {
            this.currentFrameIndicator.selectAll('line')
                .data([42])
                .join('line')
                .attr('x1', this.scaleX(frameId))
                .attr('x2', this.scaleX(frameId))
                .attr('y1', this.scaleY.range()[0])
                .attr('y2', this.scaleY.range()[1])
                .attr('stroke', 'black')
                .classed('currentFrameLine', true);
        }
        else {
            this.currentFrameIndicator.selectAll('line').remove();
        }
    }
    updateFacetPaths() {
        const margin = {
            top: 64,
            left: 120,
            right: 20,
            bottom: 48
        };
        const defaultFacets = this.data.defaultFacets;
        const defaultFacetsFull = this.fullData.defaultFacets;
        const defaultAxisTicks = this.fullData.defaultFacetAxisTicks;
        const wCount = defaultAxisTicks.xAxisTicks.length;
        const lCount = defaultAxisTicks.yAxisTicks.length;
        let miniWidth = (this.width - margin.left - margin.right) / wCount;
        let miniHeight = (this.height - margin.top - margin.bottom) / lCount;
        let miniSize = Math.min(miniWidth, miniHeight);
        const miniPadding = Math.round(0.08 * miniSize);
        miniSize -= 2 * miniPadding;
        const vizWidth = wCount * miniSize + (wCount - 1) * miniPadding;
        const vizHeight = lCount * miniSize + (lCount - 1) * miniPadding;
        this.addApplyButton(d3.select(this.container));
        this.mainGroupFacetSelect
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        let rowSelect = this.mainGroupFacetSelect.selectAll('g.row')
            .data(defaultAxisTicks.yAxisTicks)
            .join('g')
            .classed('row', true)
            .attr('transform', (_, i) => `translate(0, ${i * (miniSize + miniPadding)})`);
        this._miniCellSelect = rowSelect.selectAll('g.miniCell')
            .data(d => defaultAxisTicks.xAxisTicks.map(label => [d, label]))
            .join('g')
            .classed('miniCell', true)
            .on('click', (d) => {
            var _a, _b;
            if (this.allConditionsTrue()) {
                this.setAllConditionsFalse();
            }
            let oldVal = (_a = this.tempConditionFilterState.get(d[0])) === null || _a === void 0 ? void 0 : _a.get(d[1]);
            (_b = this.tempConditionFilterState.get(d[0])) === null || _b === void 0 ? void 0 : _b.set(d[1], !oldVal);
            this.updateConditionFilterSelection();
        })
            .attr('transform', (_, i) => `translate(${i * (miniSize + miniPadding)}, 0)`);
        this.updateConditionFilterSelection();
        let frameExtent = this.data.getMinMax('Frame ID');
        const framePad = 1;
        const scaleX = d3.scaleLinear()
            .domain(frameExtent)
            .range([framePad, miniSize - framePad]);
        let [minMass, maxMass] = this.getExtentOfGrowthCurves(defaultFacets);
        let [minMassFull, maxMassFull] = this.getExtentOfGrowthCurves(defaultFacetsFull, true);
        minMass = Math.min(minMass, minMassFull);
        maxMass = Math.max(maxMass, maxMassFull);
        const scaleY = d3.scaleLinear()
            .domain([minMass, maxMass])
            .range([miniSize - framePad, framePad]);
        let lineAvg = d3.line()
            .x(d => scaleX(d[0]))
            .y(d => scaleY(d[1]));
        this.miniCellSelect.selectAll('.miniExemplarArea')
            .data(d => [d])
            .join('path')
            .classed('miniExemplarArea', true)
            .attr('d', d => {
            let pathString = this.getGrowthLine(d, defaultFacets, lineAvg, false, true, minMass);
            if (pathString) {
                return pathString;
            }
            return this.getGrowthLine(d, defaultFacetsFull, lineAvg, true, true, minMass);
        });
        this.miniCellSelect.selectAll('.miniExemplarCurve.allData')
            .data(d => [d])
            .join('path')
            .classed('miniExemplarCurve', true)
            .classed('allData', true)
            .classed('active', !this.data.brushApplied)
            .attr('stroke', d => GroupByWidget_1.GroupByWidget.getColor(d, this.colorLookup))
            .attr('d', d => {
            let pathString = this.getGrowthLine(d, defaultFacets, lineAvg, false, false);
            if (pathString) {
                return pathString;
            }
            return this.getGrowthLine(d, defaultFacetsFull, lineAvg, true, false);
        });
        if (this.data.brushApplied) {
            this.miniCellSelect.selectAll('.miniExemplarCurve.selection')
                .data(d => [d])
                .join('path')
                .classed('miniExemplarCurve', true)
                .classed('selection', true)
                .classed('active', true)
                .attr('stroke', d => GroupByWidget_1.GroupByWidget.getColor(d, this.colorLookup))
                .attr('d', d => {
                return this.getGrowthLine(d, defaultFacets, lineAvg, true, false);
            });
        }
        else {
            this.miniCellSelect.selectAll('.miniExemplarCurve.selection').remove();
        }
        this.miniCellSelect.selectAll('rect')
            .data(d => [d])
            .join('rect')
            .attr('width', miniSize)
            .attr('height', miniSize)
            .classed('miniBox', true)
            .on('mouseenter', function (d) {
            d3.select(this).classed('hovered', true);
        })
            .on('mouseleave', function (d) {
            d3.select(this).classed('hovered', false);
        });
        this.yAxisFacetSelect
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        const maxLabelWidth = 70;
        const labelPadding = 8;
        const mainLabelSize = 20;
        this.yAxisFacetSelect.selectAll('text')
            .data([defaultAxisTicks.axisLabels[0]])
            .join('text')
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'hanging')
            .attr('transform', `translate(${-maxLabelWidth - labelPadding - mainLabelSize}, ${vizHeight / 2}) rotate(-90)`)
            .classed('mediumText', true)
            .text(d => d);
        this.yAxisFacetSelect.selectAll('foreignObject')
            .data(defaultAxisTicks.yAxisTicks)
            .join('foreignObject')
            .attr('width', maxLabelWidth)
            .attr('height', miniSize)
            .attr('transform', (d, i) => `translate(${-maxLabelWidth - labelPadding}, ${i * (miniSize + miniPadding)})`)
            .selectAll('div')
            .data(d => [d])
            .join('xhtml:div')
            .attr('style', `height: ${miniSize}px;`)
            .classed('y', true)
            .classed('axisButtonContainer', true)
            .selectAll('button')
            .data(d => [d])
            .join('button')
            .classed('basicIconButton', true)
            .attr('style', `max-width: ${maxLabelWidth}px; min-width: ${maxLabelWidth}px;`)
            .attr('title', d => d)
            .on('click', (d) => {
            if (this.allConditionsTrue()) {
                this.setAllConditionsFalse();
            }
            let rowMap = this.tempConditionFilterState.get(d);
            let newValue = !Array(...rowMap.values()).every(x => x);
            for (let key of rowMap.keys()) {
                rowMap.set(key, newValue);
            }
            this.updateConditionFilterSelection();
        })
            .on('mouseenter', (label, i) => {
            this.miniCellSelect
                .selectAll('rect')
                .data(d => [d])
                .classed('hovered', d => {
                let [l1, _l2] = d;
                return l1 === label;
            });
        })
            .on('mouseleave', () => this.miniCellSelect.selectAll('rect').classed('hovered', false))
            .text(d => d);
        const maxLabelHeight = 36;
        this.xAxisFacetSelect
            .attr('transform', `translate(${margin.left}, ${margin.top + vizHeight})`);
        this.xAxisFacetSelect.selectAll('text')
            .data([defaultAxisTicks.axisLabels[1]])
            .join('text')
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'hanging')
            .attr('transform', `translate(${vizWidth / 2}, ${maxLabelHeight + 2 * labelPadding})`)
            .classed('mediumText', true)
            .text(d => d);
        this.xAxisFacetSelect.selectAll('foreignObject')
            .data(defaultAxisTicks.xAxisTicks)
            .join('foreignObject')
            .attr('width', miniSize)
            .attr('height', maxLabelHeight)
            .attr('transform', (d, i) => `translate(${i * (miniSize + miniPadding)}, ${labelPadding})`)
            .selectAll('div')
            .data(d => [d])
            .join('xhtml:div')
            .classed('x', true)
            .classed('axisButtonContainer', true)
            .selectAll('button')
            .data(d => [d])
            .join('button')
            .classed('basicIconButton', true)
            .attr('style', `max-width: ${miniSize}px; min-width: ${miniSize}px; height: ${maxLabelHeight}px`)
            .attr('title', d => d)
            .on('click', (d) => {
            if (this.allConditionsTrue()) {
                this.setAllConditionsFalse();
            }
            const rowList = Array(...this.tempConditionFilterState.values());
            const colValues = rowList.map(m => m.get(d));
            const newValue = !colValues.every(x => x);
            for (let map of rowList) {
                map.set(d, newValue);
            }
            this.updateConditionFilterSelection();
        })
            .on('mouseenter', (label, i) => {
            this.miniCellSelect
                .selectAll('rect')
                .data(d => [d])
                .classed('hovered', d => {
                let [_l1, l2] = d;
                return l2 === label;
            });
        })
            .on('mouseleave', () => this.miniCellSelect.selectAll('rect').classed('hovered', false))
            .text(d => d);
        // add all button
        this.yAxisFacetSelect.append('foreignObject')
            .attr('width', maxLabelWidth)
            .attr('height', maxLabelHeight)
            .attr('transform', `translate(${-maxLabelWidth - labelPadding}, ${vizHeight + labelPadding})`)
            .append('xhtml:div')
            .classed('x', true)
            .classed('axisButtonContainer', true)
            .append('button')
            .classed('basicIconButton', true)
            .attr('style', `max-width: ${maxLabelWidth}px; min-width: ${maxLabelWidth}px; height: ${maxLabelHeight}px`)
            .attr('title', 'Select all conditions')
            .text('All')
            .on('click', () => {
            if (this.allConditionsTrue()) {
                this.setAllConditionsFalse();
            }
            else {
                this.setAllConditionsTrue();
            }
            this.updateConditionFilterSelection();
        })
            .on('mouseenter', () => this.miniCellSelect.selectAll('rect').classed('hovered', true))
            .on('mouseleave', () => this.miniCellSelect.selectAll('rect').classed('hovered', false));
    }
    getGrowthLine(label, facets, lineFunc, selection, makeAreaPath, minYValue) {
        let [drugLabel, concLabel] = label;
        if (!facets.has(drugLabel)) {
            return ''; // empty when no data
        }
        let row = facets.get(drugLabel);
        if (!row.has(concLabel)) {
            return '';
        }
        let data = row.get(concLabel);
        let avergeGrowthLine = [...data.getAverageCurve(this.yKey, selection, this.smoothCurves)];
        if (avergeGrowthLine.length === 0) {
            return '';
        }
        if (makeAreaPath) {
            let first = avergeGrowthLine[0];
            avergeGrowthLine.unshift([first[0], minYValue]);
            let last = avergeGrowthLine[avergeGrowthLine.length - 1];
            avergeGrowthLine.push([last[0], minYValue]);
            // avergeGrowthLine.push([first[0], minYValue]);
        }
        return lineFunc(avergeGrowthLine);
    }
    getExtentOfGrowthCurves(facets, filteredOnly = false) {
        let minMass = Infinity;
        let maxMass = -Infinity;
        for (let map of facets.values()) {
            for (let data of map.values()) {
                let thisMin;
                let thisMax;
                if (filteredOnly) {
                    thisMin = Infinity;
                    thisMax = -Infinity;
                }
                else {
                    const allDataPoints = data.getAverageCurve(this.yKey, false, this.smoothCurves);
                    thisMin = d3.min(allDataPoints, d => d[1]);
                    thisMax = d3.max(allDataPoints, d => d[1]);
                }
                let dataPoints = data.getAverageCurve(this.yKey, true, this.smoothCurves);
                const shouldCheckFiltered = (filteredOnly || this.data.brushApplied) && dataPoints.length > 0;
                if (shouldCheckFiltered) {
                    thisMin = Math.min(thisMin, d3.min(dataPoints, d => d[1]));
                }
                minMass = Math.min(thisMin, minMass);
                if (shouldCheckFiltered) {
                    thisMax = Math.max(thisMax, d3.max(dataPoints, d => d[1]));
                }
                maxMass = Math.max(thisMax, maxMass);
            }
        }
        return [minMass, maxMass];
    }
    addApplyButton(container) {
        let buttonSelect = container
            .selectAll('div.applyButtonContainer')
            .data([42])
            .join('div')
            .classed('applyButtonContainer', true)
            .selectAll('button')
            .data([42])
            .join('button')
            .attr('id', 'conditionFilterApplyButton')
            .text('Apply Filter')
            .classed('devlibButton', true)
            .classed('big', true)
            .on('click', () => {
            this.copyTempConditionsToModel();
            DevlibTSUtil_1.DevlibTSUtil.hide(document.getElementById('conditionFilterApplyButton'));
            document.dispatchEvent(new CustomEvent(DataEvents_1.DataEvents.applyNewFilter));
        });
        DevlibTSUtil_1.DevlibTSUtil.hide(document.getElementById('conditionFilterApplyButton'));
    }
    updateConditionFilterSelection() {
        this.miniCellSelect.classed('inFilter', d => {
            if (!this.tempConditionFilterState.has(d[0])) {
                return false;
            }
            let letRowFilters = this.tempConditionFilterState.get(d[0]);
            if (this.tempConditionFilterState.has(d[1])) {
                return false;
            }
            return letRowFilters.get(d[1]);
        });
        let applyButton = document.getElementById('conditionFilterApplyButton');
        if (this.tempConditionsDifferent()) {
            DevlibTSUtil_1.DevlibTSUtil.show(applyButton);
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.hide(applyButton);
        }
    }
    resetTempConditionFilter() {
        for (let [key, value] of this.dataSuperset.conditionFilterState.entries()) {
            this.tempConditionFilterState.set(key, new Map(value));
        }
    }
    allConditionsTrue() {
        for (let map of this.tempConditionFilterState.values()) {
            for (let val of map.values()) {
                if (!val) {
                    return false;
                }
            }
        }
        return true;
    }
    setAllConditionsFalse() {
        for (let map of this.tempConditionFilterState.values()) {
            for (let key of map.keys()) {
                map.set(key, false);
            }
        }
    }
    setAllConditionsTrue() {
        for (let map of this.tempConditionFilterState.values()) {
            for (let key of map.keys()) {
                map.set(key, true);
            }
        }
    }
    tempConditionsDifferent() {
        var _a;
        for (let key1 of this.tempConditionFilterState.keys()) {
            let innerKeyVals = this.tempConditionFilterState.get(key1).entries();
            for (let [key2, val] of innerKeyVals) {
                if (val !== ((_a = this.fullData.conditionFilterState.get(key1)) === null || _a === void 0 ? void 0 : _a.get(key2))) {
                    return true;
                }
            }
        }
        return false;
    }
    copyTempConditionsToModel() {
        var _a;
        for (let key1 of this.tempConditionFilterState.keys()) {
            let innerKeyVals = this.tempConditionFilterState.get(key1).entries();
            for (let [key2, val] of innerKeyVals) {
                (_a = this.fullData.conditionFilterState.get(key1)) === null || _a === void 0 ? void 0 : _a.set(key2, val);
            }
        }
    }
    drawFacetContent() {
        if (this.inAverageMode) {
            this.swapSvgVisibility();
            this.updatePaths();
        }
        else {
            super.drawFacetContent();
        }
    }
    drawLabels(labelData) {
        const indexedPoints = labelData.map((d, i) => [d[0], d[1], i]);
        const validPoints = indexedPoints.filter((x, i) => x[1] !== null);
        const pixelSpacePoints = validPoints.map(d => [this.scaleX(d[1][0]), this.scaleY(d[1][1]), d[2]]);
        this.averageCurveLabelContainer.selectAll('circle')
            .data(pixelSpacePoints)
            .join('circle')
            .attr('cx', d => d[0])
            .attr('cy', d => d[1])
            .attr('r', 3)
            .attr('fill', d => GroupByWidget_1.GroupByWidget.getColor(labelData[d[2]][0].split('___'), this.colorLookup));
        const radius = d3.scaleLinear()
            .domain([5, 50])
            .range([9, 2])
            .clamp(true)(labelData.length);
        const forceNodes = pixelSpacePoints.map(d => { return { x: d[0], y: d[1] }; });
        this._forceSimulation = d3.forceSimulation(forceNodes)
            .force('contraintX', alpha => {
            for (let i = 0; i < forceNodes.length; i++) {
                // make x position a hard constraint
                forceNodes[i].x = pixelSpacePoints[i][0];
            }
        })
            .force('repel', d3.forceCollide().radius(radius))
            .force('attractY', d3.forceY().y(d => {
            return pixelSpacePoints[d.index][1];
        }))
            .on('tick', () => {
            console.log('tick');
        });
        this.forceSimulation.stop();
        this.forceSimulation.tick(1000);
        const fontSize = d3.scaleLinear()
            .domain([5, 30])
            .range([12, 7])
            .clamp(true)(labelData.length);
        const horizontalPad = 12;
        this.averageCurveLabelContainer.selectAll('text')
            .data(forceNodes)
            .join('text')
            .attr('transform', d => `translate(${d.x + horizontalPad}, ${d.y})`)
            .attr('alignment-baseline', 'central')
            .text((d, i) => labelData[i][0].replace('___', ' '))
            .attr('style', `font-size: ${fontSize}pt;`)
            .attr('stroke', (d, i) => GroupByWidget_1.GroupByWidget.getColor(labelData[pixelSpacePoints[i][2]][0].split('___'), this.colorLookup))
            .attr('fill', (d, i) => GroupByWidget_1.GroupByWidget.getColor(labelData[pixelSpacePoints[i][2]][0].split('___'), this.colorLookup));
    }
    clearLabels() {
        this.averageCurveLabelContainer.html(null);
    }
    drawAxis() {
        this.xAxisGroupSelect
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight})`)
            .call(d3.axisBottom(this.scaleX).ticks(5));
        this.yAxisGroupSelect
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .call(d3.axisLeft(this.scaleY).ticks(5));
    }
    drawLegend() {
        this.drawAverageLegend();
        this.drawFacetLegend();
    }
    drawAverageLegend() {
        const lineWidth = 24;
        const textOffset = 4;
        const selectedTextWidth = 55; // approximate
        const betweenPad = 20;
        this.averageLegendSelect.append('line')
            .attr('x1', 0)
            .attr('x2', lineWidth)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke-width', 2)
            .attr('stroke', 'black')
            .attr('opacity', 0.85);
        this.averageLegendSelect.append('circle')
            .attr('cx', lineWidth)
            .attr('cy', 0)
            .attr('r', 3)
            .attr('fill', 'black')
            .attr('opacity', 0.85);
        this.averageLegendSelect.append('text')
            .attr('alignment-baseline', 'middle')
            .attr('transform', `translate(${lineWidth + textOffset},0)`)
            .classed('smallText', true)
            .text('Selected');
        this.averageLegendSelect.append('line')
            .attr('x1', textOffset + selectedTextWidth + betweenPad + lineWidth)
            .attr('x2', textOffset + selectedTextWidth + betweenPad + 2 * lineWidth)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke-width', 1)
            .attr('stroke', 'black')
            .attr('opacity', 0.8);
        this.averageLegendSelect.append('text')
            .attr('alignment-baseline', 'middle')
            .attr('transform', `translate(${2 * lineWidth + 2 * textOffset + selectedTextWidth + betweenPad},0)`)
            .classed('smallText', true)
            .text('All');
    }
    drawFacetLegend() {
        const lineWidth = 24;
        const textOffset = 4;
        const selectedTextWidth = 55; // approximate
        const betweenPad = 20;
        this.facetLegendSelect.append('line')
            .attr('x1', 0)
            .attr('x2', lineWidth)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke-width', 2)
            .attr('stroke', 'black');
        this.facetLegendSelect.append('text')
            .attr('alignment-baseline', 'middle')
            .attr('transform', `translate(${lineWidth + textOffset},0)`)
            .classed('smallText', true)
            .text('Selected');
        this.facetLegendSelect.append('rect')
            .attr('x', textOffset + selectedTextWidth + betweenPad + lineWidth)
            .attr('y', 0)
            .attr('width', lineWidth)
            .attr('height', lineWidth / 2)
            .attr('stroke', 'none')
            .attr('fill', 'rgb(236, 236, 236)');
        this.facetLegendSelect.append('line')
            .attr('x1', textOffset + selectedTextWidth + betweenPad + lineWidth)
            .attr('x2', textOffset + selectedTextWidth + betweenPad + 2 * lineWidth)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke-width', 1)
            .attr('stroke', 'black')
            .attr('opacity', 0.6);
        this.facetLegendSelect.append('text')
            .attr('alignment-baseline', 'middle')
            .attr('transform', `translate(${2 * lineWidth + 2 * textOffset + selectedTextWidth + betweenPad},0)`)
            .classed('smallText', true)
            .text('All');
    }
    showLabel() {
        this.xLabelTextSelect
            .text(this.xKey)
            .classed('noDisp', false);
        this.yLabelTextSelect
            .text(this.yKey)
            .classed('noDisp', false);
    }
    OnResize() {
        if (this.data) {
            this.svgSelect.attr('width', this.width);
            this.svgSelect.attr('height', this.height);
            this.svgFacetSelect.attr('width', this.width);
            this.svgFacetSelect.attr('height', this.height);
            this.averageLegendSelect.attr('transform', `translate(${this.margin.left / 2}, ${this.margin.top + this.vizHeight + 44})`);
            this.facetLegendSelect.attr('transform', `translate(${this.margin.left / 2}, ${this.margin.top + this.vizHeight + 44})`);
            this.canvasContainer
                .attr('width', this.vizWidth)
                .attr('height', this.vizHeight);
            d3.select(this.canvasElement)
                .attr('width', this.vizWidth)
                .attr('height', this.vizHeight);
            this.updateScales();
            this.updatePaths();
            this.positionLabels();
            this.drawAxis();
        }
        this.resizeBrush();
    }
    resizeBrush() {
        this.initBrush();
        if (this.lastYValueBrushBound == null || this.lastXValueBrushBound == null) {
            return;
        }
        let left = this.scaleX(this.lastXValueBrushBound[0]);
        let right = this.scaleX(this.lastXValueBrushBound[1]);
        let top = this.scaleY(this.lastYValueBrushBound[1]);
        let bottom = this.scaleY(this.lastYValueBrushBound[0]);
        this.brushGroupSelect.call(this.brush.move, [[left, top], [right, bottom]]);
    }
    brushHandler() {
        const selection = d3.event.selection;
        if (typeof selection === "undefined" || selection === null) {
            this.data.removeCurveBrush(this.ComponentId);
            this._lastXValueBrushBound = null;
            this._lastYValueBrushBound = null;
            return;
        }
        let [[left, top], [right, bottom]] = selection;
        let minX = this.scaleX.invert(left);
        let maxX = this.scaleX.invert(right);
        this._lastXValueBrushBound = [minX, maxX];
        let xValueFilter = {
            key: this.xKey,
            bound: this.lastXValueBrushBound
        };
        let minY = this.scaleY.invert(bottom);
        let maxY = this.scaleY.invert(top);
        this._lastYValueBrushBound = [minY, maxY];
        let yValueFilter = {
            key: this.yKey,
            bound: this.lastYValueBrushBound
        };
        this.data.addCurveBrush(this.ComponentId, [xValueFilter, yValueFilter]);
    }
    OnBrushChange() {
        for (let facet of this.facetList) {
            facet.data._averageFilteredCurveCache.clear();
        }
        if (this.inAverageMode) {
            this.updateScales();
        }
        this.updatePaths();
    }
}
exports.Plot2dPathsWidget = Plot2dPathsWidget;

},{"../DataModel/DataEvents":104,"../devlib/DevlibTSUtil":116,"./BaseWidget":84,"./GroupByWidget":86,"./OptionSelect":92,"d3":42}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
class RichTooltip {
    constructor(waitToShow = 350, waitToHide = 200) {
        this._waitToShow = waitToShow;
        this._waitToHide = waitToHide;
        this._container = document.createElement('div');
        DevlibTSUtil_1.DevlibTSUtil.hide(this.container);
        document.body.appendChild(this.container);
        this.container.classList.add('richTooltip');
        this._showTimerRunning = false;
        this._hideTimerRunning = false;
        this.container.addEventListener('mouseleave', () => {
            this.Hide();
        });
        this.container.addEventListener('mouseenter', () => {
            if (this.hideTimer && this.hideTimerRunning) {
                this.hideTimer.stop();
                this._hideTimerRunning = false;
            }
        });
        this._hideTimerRunning = false;
        this._showTimerRunning = false;
        this._hideCallback = () => {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.container);
            // shouldn't need this, but I was running into a problem where stop timer was getting stuck in a loop.
            // this appears to fix it.
            this.hideTimer.stop();
            this._hideTimerRunning = false;
        };
    }
    get waitToShow() {
        return this._waitToShow;
    }
    get waitToHide() {
        return this._waitToHide;
    }
    get container() {
        return this._container;
    }
    get showTimerRunning() {
        return this._showTimerRunning;
    }
    get showTimer() {
        return this._showTimer;
    }
    get hideTimer() {
        return this._hideTimer;
    }
    get hideTimerRunning() {
        return this._hideTimerRunning;
    }
    get hideCallback() {
        return this._hideCallback;
    }
    Show(htmlString, pageX, pageY, waitOverride) {
        const callbackFunc = () => this.drawTooltip(htmlString, pageX, pageY);
        if (this.showTimerRunning) {
            this.showTimer.stop();
        }
        let delay;
        if (typeof waitOverride !== 'undefined') {
            delay = waitOverride;
        }
        else {
            delay = this.waitToShow;
        }
        this._showTimer = d3.timeout(callbackFunc, delay);
        this._showTimerRunning = true;
        if (this.hideTimerRunning) {
            this.hideTimer.stop();
            this._hideTimerRunning = false;
        }
    }
    drawTooltip(htmlString, pageX, pageY) {
        this._showTimerRunning = false;
        this.container.innerHTML = htmlString;
        // need to display as hidden to get width
        this.container.style.visibility = 'hidden';
        DevlibTSUtil_1.DevlibTSUtil.show(this.container);
        let boundRect = this.container.getBoundingClientRect();
        let containerRect = document.body.getBoundingClientRect();
        // Priority for placement is right, below, left, above
        const offset = 20; // space between label and position
        const edgeMargin = 10; // whitespace required between label and edge of document.
        const pad = offset + edgeMargin;
        let spaceRight = containerRect.right - pageX;
        let spaceBelow = containerRect.bottom - pageY;
        let spaceLeft = containerRect.width - spaceRight;
        let spaceAbove = containerRect.height - spaceBelow;
        let w = boundRect.width;
        let h = boundRect.height;
        let w2 = w / 2.0;
        let h2 = h / 2.0;
        let [top, left] = [0, 0];
        if (spaceRight >= w + pad && spaceAbove >= h2 + edgeMargin && spaceBelow >= h2 + edgeMargin) {
            [top, left] = this.positionRight(pageX, pageY, boundRect, offset);
        }
        else if (spaceBelow >= h + pad && spaceRight >= h2 + edgeMargin && spaceLeft >= h2 + edgeMargin) {
            [top, left] = this.positionBelow(pageX, pageY, boundRect, offset);
        }
        else if (spaceLeft >= w + pad && spaceAbove >= h2 + edgeMargin && spaceBelow >= h2 + edgeMargin) {
            [top, left] = this.positionLeft(pageX, pageY, boundRect, offset);
        }
        else {
            [top, left] = this.positionAbove(pageX, pageY, boundRect, offset);
            // TODO This can still run into problems if the x and y are at corners, and this point get's reached.
        }
        this.container.style.top = top + 'px';
        this.container.style.left = left + 'px';
        this.container.style.visibility = 'visible';
    }
    positionRight(pageX, pageY, boundRect, offset) {
        let top = pageY - boundRect.height / 2.0;
        let left = pageX + offset;
        return [top, left];
    }
    positionBelow(pageX, pageY, boundRect, offset) {
        let top = pageY + offset;
        let left = pageX - boundRect.width / 2.0;
        return [top, left];
    }
    positionLeft(pageX, pageY, boundRect, offset) {
        let top = pageY - boundRect.height / 2.0;
        let left = pageX - offset - boundRect.width;
        return [top, left];
    }
    positionAbove(pageX, pageY, boundRect, offset) {
        let top = pageY - offset - boundRect.height;
        let left = pageX - boundRect.width / 2.0;
        return [top, left];
    }
    Hide(waitOverride) {
        if (this.showTimerRunning) {
            this.showTimer.stop();
            this._showTimerRunning = false;
        }
        if (this.hideTimer && this.hideTimerRunning) {
            return;
        }
        else {
            let delay;
            if (typeof waitOverride !== 'undefined') {
                delay = waitOverride;
            }
            else {
                delay = this.waitToHide;
            }
            this._hideTimer = d3.timeout(this.hideCallback, delay);
        }
        this._hideTimerRunning = true;
    }
    static createLabelValueListContent(labelValueList) {
        let innerContainer = document.createElement('div');
        innerContainer.classList.add('tooltipInnerContainer');
        d3.select(innerContainer).selectAll('p')
            .data(labelValueList)
            .join('p')
            .html(d => {
            if (d[1]) {
                return d[0] + ': <b>' + d[1] + '</b>';
            }
            return '<i>' + d[0] + '</i>';
        })
            .classed('tooltipDisplayRow', true);
        return innerContainer.outerHTML;
    }
}
exports.RichTooltip = RichTooltip;

},{"../devlib/DevlibTSUtil":116,"d3":42}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const BaseWidget_1 = require("./BaseWidget");
class ScatterPlotWidget extends BaseWidget_1.BaseWidget {
    constructor(container, xKey, yKey, canBrush = true, isClone = false) {
        super(container, true, canBrush);
        this._xKey = xKey;
        this._yKey = yKey;
        this._isClone = isClone;
        this.setLabel();
    }
    Clone(container) {
        const canBrush = false;
        return new ScatterPlotWidget(container, this.xKey, this.yKey, canBrush, true);
    }
    initProps(props) {
        super.initProps();
        this._canBrush = props[0];
    }
    get isClone() {
        return this._isClone;
    }
    get xKey() {
        return this._xKey;
    }
    get yKey() {
        return this._yKey;
    }
    get svgSelect() {
        return this._svgSelect;
    }
    get mainGroupSelect() {
        return this._mainGroupSelect;
    }
    get canvasElement() {
        return this._canvasElement;
    }
    get canBrush() {
        return this._canBrush;
    }
    get brushGroupSelect() {
        return this._brushGroupSelect;
    }
    get xAxisGroupSelect() {
        return this._xAxisGroupSelect;
    }
    get xLabelTextSelect() {
        return this._xLabelTextSelect;
    }
    get yAxisGroupSelect() {
        return this._yAxisGroupSelect;
    }
    get yLabelTextSelect() {
        return this._yLabelTextSelect;
    }
    get scaleX() {
        return this._scaleX;
    }
    get scaleY() {
        return this._scaleY;
    }
    get yAxisPadding() {
        return this._yAxisPadding;
    }
    get brush() {
        return this._brush;
    }
    setMargin() {
        this._margin = {
            top: 8,
            right: 8,
            bottom: 56,
            left: 80
        };
    }
    init() {
        this._svgSelect = d3.select(this.container).append("svg")
            .attr("width", this.width)
            .attr("height", this.height);
        this._mainGroupSelect = this.svgSelect.append("g")
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`);
        this._canvasElement = this.mainGroupSelect
            .append('foreignObject')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight)
            .append('xhtml:canvas')
            .attr('width', this.vizWidth)
            .attr('height', this.vizHeight)
            .node();
        if (this.canBrush) {
            this._brushGroupSelect = this.svgSelect.append("g")
                .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
                .classed("brushContainer", true);
            this._brush = d3.brush()
                .extent([[0, 0], [this.vizWidth, this.vizHeight]])
                .on("end", () => { this.brushHandler(); });
            this.brushGroupSelect.call(this.brush);
        }
        this._yAxisPadding = 20;
        this._xAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top + this.vizHeight})`)
            .classed("labelColor", true);
        this._yAxisGroupSelect = this.svgSelect.append('g')
            .attr('transform', `translate(${this.margin.left}, ${this.margin.top})`)
            .classed("labelColor", true);
    }
    setLabel() {
        const bufferForAxis = 32;
        this._xLabelTextSelect = this.svgSelect.append('text')
            .attr('transform', `translate(${this.margin.left + this.vizWidth / 2}, ${this.margin.top + this.vizHeight + bufferForAxis})`)
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .text(this.xKey);
        let transX = this.margin.left - bufferForAxis - this.yAxisPadding;
        let transY = this.margin.top + this.vizHeight / 2;
        let transformText;
        if (this.yKey.length === 1) {
            transformText = `translate(${transX}, ${transY})`;
        }
        else {
            transformText = `rotate(-90) translate(${-transY}, ${transX})`;
        }
        this._yLabelTextSelect = this.svgSelect.append('text')
            .attr('transform', transformText)
            .classed('axisLabel', true)
            .classed('labelColor', true)
            .text(this.yKey);
    }
    OnDataChange() {
        this.updateScales();
        this.drawPoints();
        this.drawAxis();
    }
    drawPoints() {
        let validPoints = this.data.Array.filter((point) => {
            return !isNaN(point.get(this.xKey))
                && !isNaN(point.get(this.yKey))
                && point.inBrush;
        });
        const canvasContext = this.canvasElement.getContext('2d');
        canvasContext.clearRect(0, 0, this.vizWidth, this.vizHeight);
        canvasContext.fillStyle = 'black';
        for (let i = 0; i < validPoints.length; i++) {
            let point = validPoints[i];
            let x = this.scaleX(point.get(this.xKey));
            let y = this.scaleY(point.get(this.yKey));
            canvasContext.beginPath();
            const radius = 0.5;
            canvasContext.arc(x, y, radius, 0, 2 * Math.PI);
            canvasContext.fill();
        }
    }
    drawFacetedData(facetList) {
        this.drawFacetedDataDefault(facetList, "300px", "300px");
    }
    updateScales() {
        let data;
        if (this.isClone) {
            data = this.fullData;
        }
        else {
            data = this.data;
        }
        let minMaxX = data.getMinMax(this.xKey);
        this._scaleX = d3.scaleLinear()
            .domain(minMaxX)
            .range([0, this.vizWidth]);
        let minMaxY = data.getMinMax(this.yKey);
        this._scaleY = d3.scaleLinear()
            .domain(minMaxY)
            .range([this.vizHeight, 0]);
    }
    drawAxis() {
        this.xAxisGroupSelect
            .call(d3.axisBottom(this.scaleX).ticks(5));
        this.yAxisGroupSelect
            .call(d3.axisLeft(this.scaleY).ticks(5));
    }
    OnResize() {
        // resize is handled by css / HTML
    }
    brushHandler() {
        const selection = d3.event.selection;
        if (typeof selection === "undefined" || selection === null) {
            this.data.removeBrush(this.ComponentId);
            return;
        }
        let [[left, top], [right, bottom]] = selection;
        let minX = this.scaleX.invert(left);
        let maxX = this.scaleX.invert(right);
        let xValueFilter = {
            key: this.xKey,
            bound: [minX, maxX]
        };
        let minY = this.scaleY.invert(bottom);
        let maxY = this.scaleY.invert(top);
        let yValueFilter = {
            key: this.yKey,
            bound: [minY, maxY]
        };
        this.data.addBrush(this.ComponentId, xValueFilter, yValueFilter);
    }
    OnBrushChange() {
        if (this.container.classList.contains("noDisp")) {
            return;
        }
        // hide dynamically
        this.drawPoints();
    }
}
exports.ScatterPlotWidget = ScatterPlotWidget;

},{"./BaseWidget":84,"d3":42}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibTSUtil_1 = require("../devlib/DevlibTSUtil");
const BaseWidget_1 = require("./BaseWidget");
const DataEvents_1 = require("../DataModel/DataEvents");
const idb_1 = require("idb");
class Toolbar extends BaseWidget_1.BaseWidget {
    constructor(container) {
        super(container);
    }
    get uploadFileButtonWrapper() {
        return this._uploadFileButtonWrapper;
    }
    get toolbarElements() {
        return this._toolbarElements;
    }
    get wrapperDiv() {
        return this._wrapperDiv;
    }
    get modalPopupDiv() {
        return this._modalPopupDiv;
    }
    get modalBooleans() {
        return this._modalBooleans;
    }
    get yKey() {
        return this._yKey;
    }
    get dataStore() {
        return this._dataStore;
    }
    initToolbarElements() {
        this._toolbarElements = [
            {
                type: 'optionSelect',
                iconKeys: ['bars', 'stream', 'clone'],
                defaultIndex: 0,
                callback: async (state) => {
                    let modeChangeEvent;
                    switch (state) {
                        case 0:
                            modeChangeEvent = new CustomEvent('modeChange', { detail: {
                                    inCondensedMode: true,
                                    inExemplarMode: true
                                } });
                            break;
                        case 1:
                            modeChangeEvent = new CustomEvent('modeChange', { detail: {
                                    inCondensedMode: false,
                                    inExemplarMode: true
                                } });
                            break;
                        case 2:
                            modeChangeEvent = new CustomEvent('modeChange', { detail: {
                                    inCondensedMode: false,
                                    inExemplarMode: false
                                } });
                            break;
                        default:
                            break;
                    }
                    DevlibTSUtil_1.DevlibTSUtil.launchSpinner();
                    await DevlibTSUtil_1.DevlibTSUtil.makeAsync(() => document.dispatchEvent(modeChangeEvent));
                },
                tooltips: ['Switch to Condensed Mode', 'Switch to Expanded Mode', 'Switch to Frame Mode']
            },
            {
                type: 'popupButton',
                iconKey: 'home',
                callback: (state) => this.onHouseClick(state),
                tooltip: 'Return to overview screen'
            },
            {
                type: 'popupButton',
                iconKey: 'filter',
                callback: (state) => this.onDataFilterClick(state),
                tooltip: 'View and modify data filters'
            },
            {
                type: 'popupButton',
                iconKey: 'trash',
                callback: (state) => this.onGarbageClick(state),
                tooltip: 'Delete cached data'
            },
            {
                type: 'toggleButton',
                iconKeys: ['chart-line', 'bacon'],
                callback: (state) => this.onBaconClick(state),
                tooltips: ['Click to show raw data in line charts.', 'Click to smooth line charts with median filter.']
            }
        ];
    }
    init() {
        this._wrapperDiv = document.createElement("div");
        this.wrapperDiv.classList.add("wrapperDiv");
        this.container.appendChild(this.wrapperDiv);
        this._yKey = 'Mass_norm';
        this._modalBooleans = [];
        this.initToolbarElements();
        this.drawToolbarElements();
        this.initModalPopup();
        document.addEventListener('averageCurveKeyChange', (e) => {
            this._yKey = e.detail.yKey;
        });
        idb_1.openDB('loon-db').then(dataStore => this._dataStore = dataStore);
    }
    drawToolbarElements() {
        for (let toolbarElement of this.toolbarElements) {
            if (toolbarElement.type === 'single') {
                let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKey, toolbarElement.callback);
                button.title = toolbarElement.tooltip;
                button.classList.add('big');
                this.wrapperDiv.append(button);
            }
            else if (toolbarElement.type === 'popupButton') {
                const thisIndex = this.modalBooleans.length;
                this.modalBooleans.push(false);
                let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKey, null);
                button.title = toolbarElement.tooltip;
                button.classList.add('big');
                this.wrapperDiv.append(button);
                button.onclick = () => this.toggleModalButton(thisIndex, toolbarElement);
            }
            else if (toolbarElement.type === 'toggleButton') {
                let buttonTrue = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKeys[0], null);
                buttonTrue.title = toolbarElement.tooltips[0];
                buttonTrue.classList.add('big');
                this.wrapperDiv.append(buttonTrue);
                let buttonFalse = DevlibTSUtil_1.DevlibTSUtil.getIconButton(toolbarElement.iconKeys[1], null);
                buttonFalse.title = toolbarElement.tooltips[1];
                buttonFalse.classList.add('big');
                this.wrapperDiv.append(buttonFalse);
                DevlibTSUtil_1.DevlibTSUtil.hide(buttonFalse);
                buttonTrue.onclick = () => {
                    DevlibTSUtil_1.DevlibTSUtil.hide(buttonTrue);
                    DevlibTSUtil_1.DevlibTSUtil.show(buttonFalse);
                    toolbarElement.callback(true);
                };
                buttonFalse.onclick = () => {
                    DevlibTSUtil_1.DevlibTSUtil.show(buttonTrue);
                    DevlibTSUtil_1.DevlibTSUtil.hide(buttonFalse);
                    toolbarElement.callback(false);
                };
            }
            else if (toolbarElement.type === 'optionSelect') {
                let grouperDiv = document.createElement('div');
                grouperDiv.classList.add('optionSelectGrouperDiv');
                let buttonList = [];
                for (let i = 0; i < toolbarElement.iconKeys.length; i++) {
                    let iconKey = toolbarElement.iconKeys[i];
                    let button = DevlibTSUtil_1.DevlibTSUtil.getIconButton(iconKey, null);
                    button.title = toolbarElement.tooltips[i];
                    button.classList.add('big');
                    if (i === toolbarElement.defaultIndex) {
                        button.classList.add('selected');
                    }
                    buttonList.push(button);
                    grouperDiv.append(button);
                }
                const removeSelected = () => {
                    for (let button of buttonList) {
                        button.classList.remove('selected');
                    }
                };
                for (let i = 0; i < buttonList.length; i++) {
                    let button = buttonList[i];
                    button.onclick = () => {
                        removeSelected();
                        button.classList.add('selected');
                        toolbarElement.callback(i);
                    };
                }
                document.addEventListener('changeModeSelect', (e) => {
                    removeSelected();
                    buttonList[e.detail].classList.add('selected');
                });
                this.wrapperDiv.append(grouperDiv);
            }
        }
    }
    toggleModalButton(buttonIndex, toolbarElement) {
        if (buttonIndex !== -1 && this.modalBooleans[buttonIndex]) {
            this.modalBooleans[buttonIndex] = false;
        }
        else {
            for (let i = 0; i < this.modalBooleans.length; i++) {
                this.modalBooleans[i] = false;
            }
            if (buttonIndex !== -1) {
                this.modalBooleans[buttonIndex] = true;
            }
        }
        const show = this.modalBooleans[buttonIndex];
        if (toolbarElement) {
            toolbarElement.callback({ shown: show, index: buttonIndex });
        }
        if (show) {
            DevlibTSUtil_1.DevlibTSUtil.show(this.modalPopupDiv);
        }
        else {
            DevlibTSUtil_1.DevlibTSUtil.hide(this.modalPopupDiv);
        }
    }
    initModalPopup() {
        this._modalPopupDiv = document.createElement("div");
        this.modalPopupDiv.classList.add("toolbarPopup");
        DevlibTSUtil_1.DevlibTSUtil.hide(this.modalPopupDiv);
        this.container.appendChild(this.modalPopupDiv);
    }
    getOffsetFromIndex(index) {
        let button = this.wrapperDiv.querySelectorAll(':scope > .basicIconButton')[index];
        return button.getBoundingClientRect().top;
    }
    onDataFilterClick(state) {
        this.modalPopupDiv.innerHTML = null;
        if (!state.shown) {
            return;
        }
        let outer = d3.select(this.modalPopupDiv);
        outer.classed('narrow', false);
        // outer.node().style.flexDirection = 'column';
        // outer.node().style.alignItems = 'flex-start';
        outer.node().style.top = this.getOffsetFromIndex(state.index) + 'px';
        let contentDiv = outer.append('div')
            .attr('style', 'display: flex; width: 100%');
        const selectionDiv = contentDiv.append('div');
        const convertDiv = contentDiv.append('div');
        const filterDiv = contentDiv.append('div');
        outer.append('div')
            .attr('style', 'display: flex; width: 100%; flex-direction: column; align-items: flex-end;')
            .append('button')
            .classed('devlibButton', true)
            .classed('big', true)
            .on('click', () => {
            this.toggleModalButton(state.index);
        })
            .text('Close');
        this.displayFilters(selectionDiv, 'Current Selection', 'The currently highlighted selection contains data that meet all of the following conditions.', this.data.GetAllFilters(), false, state.index);
        let buttonElement = DevlibTSUtil_1.DevlibTSUtil.getIconButton('long-arrow-alt-right', () => this.triggerSelectionToFilterEvent(state.index), 'Convert ');
        convertDiv.attr('style', 'align-self: center;').node().appendChild(buttonElement);
        this.displayFilters(filterDiv, 'Current Filters', 'Only show tracks that meet all of the following conditions.', this.fullData.GetAllFilters(), true, state.index);
    }
    displayFilters(containerSelect, title, description, filterList, isFilter, index) {
        containerSelect.classed('filterDisplayContainer', true)
            .append('div')
            .text(title)
            .classed('largeText', true)
            .append('div')
            .text(description)
            .classed('smallText', true);
        let filterSelection = containerSelect.append('ul').classed('mediumText', true).selectAll('li')
            .data(filterList)
            .join('li');
        filterSelection.filter(d => d.type === 'cell')
            .html(d => {
            let f = d.filter;
            let low = f.bound[0].toPrecision(5);
            let high = f.bound[1].toPrecision(5);
            if (isFilter) {
                return `Tracks where <b>${f.key}</b> is in range [${low}, ${high}] at least once.`;
            }
            else {
                return `Cell instances where <b>${f.key}</b> is in range [${low}, ${high}]`;
            }
        });
        filterSelection.filter(d => d.type === 'track')
            .html(d => {
            let f = d.filter;
            let low = f.bound[0].toPrecision(5);
            let high = f.bound[1].toPrecision(5);
            return `Tracks with <b>${f.key}</b> in range [${low}, ${high}]`;
        });
        filterSelection.filter(d => d.type === 'curve')
            .html(d => {
            let f1 = d.filter[0];
            let low1 = f1.bound[0].toPrecision(5);
            let high1 = f1.bound[1].toPrecision(5);
            let f2 = d.filter[1];
            let low2 = f2.bound[0].toPrecision(5);
            let high2 = f2.bound[1].toPrecision(5);
            let displayString = 'Tracks where ';
            displayString += `<b>${f1.key}</b> is in range [${low1}, ${high1}] and `;
            displayString += `<b>${f2.key}</b> is in range [${low2}, ${high2}]`;
            displayString += ' at least once.';
            return displayString;
        });
        if (isFilter) {
            filterSelection.append('button')
                .classed('basicIconButton', true)
                .on('click', d => {
                if (d.type === 'curve') {
                    this.fullData.removeCurveBrush(d.filterKey);
                }
                else if (d.type === 'track') {
                    this.fullData.curveCollection.removeBrush(d.filterKey);
                }
                else if (d.type === 'cell') {
                    this.fullData.removeBrush(d.filterKey);
                }
                document.dispatchEvent(new CustomEvent(DataEvents_1.DataEvents.applyNewFilter));
                this.onDataFilterClick({ shown: true, index: index });
            })
                .html('<i class="fas fa-minus"></i>');
        }
    }
    triggerSelectionToFilterEvent(index) {
        document.dispatchEvent(new CustomEvent(DataEvents_1.DataEvents.selectionToFilter));
        this.onDataFilterClick({ shown: true, index: index });
    }
    onHouseClick(state) {
        this.modalPopupDiv.innerHTML = null;
        if (!state.shown) {
            return;
        }
        let outer = d3.select(this.modalPopupDiv);
        outer.classed('narrow', true);
        // outer.node().style.flexDirection = 'column';
        // outer.node().style.alignItems = 'center';
        outer.node().style.top = this.getOffsetFromIndex(state.index) + 'px';
        outer.append('div')
            .classed('largeText', true)
            .text('Return to overview page?');
        let buttonDiv = outer.append('div')
            .attr('style', 'display: flex; flex-direction: row');
        buttonDiv.append('button')
            .classed('devlibButton', true)
            .text('Navigate Home')
            .on('click', () => location.href = '/overview');
        buttonDiv.append('button')
            .classed('devlibButton', true)
            .text('Stay Here')
            .on('click', () => this.toggleModalButton(state.index));
    }
    onGarbageClick(state) {
        this.modalPopupDiv.innerHTML = null;
        if (!state.shown) {
            return;
        }
        let outer = d3.select(this.modalPopupDiv);
        outer.classed('narrow', true);
        // outer.node().style.flexDirection = 'column';
        // outer.node().style.alignItems = 'center';
        outer.node().style.top = this.getOffsetFromIndex(state.index) + 'px';
        outer.append('div')
            .classed('largeText', true)
            .text('Delete Cache?');
        outer.append('div')
            .classed('mediumText', true)
            .text('Delete cache if your data has been updated since the last cache time. Otherwise, leave the cache as is to improve loading times.');
        outer.append('button')
            .classed('devlibButton', true)
            .text('Delete Entire Cache')
            .on('click', () => this.clearIDBCache('all'));
        const buttonGrouper = outer.append('div')
            .attr('style', 'display: flex; flex-direction: row');
        buttonGrouper.append('button')
            .classed('devlibButton', true)
            .text('Delete Cached Tracks')
            .on('click', () => this.clearIDBCache('tracks'));
        buttonGrouper.append('button')
            .classed('devlibButton', true)
            .text('Delete Cached Images')
            .on('click', () => this.clearIDBCache('images'));
    }
    async clearIDBCache(database) {
        if (this.dataStore) {
            const key = this.data.Specification.googleDriveId;
            if (database === 'tracks' || database === 'all') {
                this.dataStore.delete('tracks', key);
            }
            if (database === 'images' || database === 'all') {
                let keys = await this.dataStore.getAllKeys('images');
                for (let imgKey of keys) {
                    if (imgKey.toString().includes(key)) {
                        this.dataStore.delete('images', imgKey);
                    }
                }
            }
        }
        this.toggleModalButton(-1);
    }
    onBaconClick(state) {
        const smoothCurveEvent = new CustomEvent('smoothCurveChange', { detail: !state });
        document.dispatchEvent(smoothCurveEvent);
    }
    OnResize() {
        // do nothing
    }
    OnDataChange() {
        // not relevant for this class
    }
    Clone(container) {
        // not relevant for this class
        return null;
    }
}
exports.Toolbar = Toolbar;

},{"../DataModel/DataEvents":104,"../devlib/DevlibTSUtil":116,"./BaseWidget":84,"d3":42,"idb":43}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollectionIterator_1 = require("./CurveCollectionIterator");
const PointCollection_1 = require("./PointCollection");
const CurveListFactory_1 = require("./CurveListFactory");
class CurveCollection extends PointCollection_1.PointCollection {
    constructor(curveList, spec) {
        super();
        this._length = curveList.curveList.length;
        this._curveList = curveList;
        this.Specification = spec;
    }
    CreateFilteredCurveList() {
        throw new Error('Method not implemented.');
    }
    ApplyDefaultFilters() {
        throw new Error('Method not implemented.');
    }
    get curveList() {
        return this._curveList;
    }
    OnBrushChange() { }
    getFacetList(locationMap) {
        let facetList = CurveListFactory_1.CurveListFactory.CreateFacetedDatasets(this.curveList, locationMap);
        for (let facet of facetList) {
            facet.data = facet.data.curveCollection;
        }
        return facetList;
    }
    [Symbol.iterator]() {
        return new CurveCollectionIterator_1.CurveCollectionIterator(this.curveList);
    }
}
exports.CurveCollection = CurveCollection;

},{"./CurveCollectionIterator":98,"./CurveListFactory":101,"./PointCollection":111}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CurveCollectionIterator {
    constructor(curveList) {
        this._index = 0;
        this._curveList = curveList;
    }
    get index() {
        return this._index;
    }
    get curveList() {
        return this._curveList;
    }
    next() {
        let curve = this.curveList.curveList[this.index];
        let isDone = this.index >= this.curveList.curveList.length;
        ++this._index;
        let iterResult = {
            value: curve,
            done: isDone
        };
        return iterResult;
    }
}
exports.CurveCollectionIterator = CurveCollectionIterator;

},{}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class CurveIterator {
    constructor(pointList) {
        this._index = 0;
        this._pointList = pointList;
    }
    get index() {
        return this._index;
    }
    get pointList() {
        return this._pointList;
    }
    next() {
        let point = this.pointList[this.index];
        let isDone = this.index >= this.pointList.length;
        ++this._index;
        let iterResult = {
            value: point,
            done: isDone
        };
        return iterResult;
    }
}
exports.CurveIterator = CurveIterator;

},{}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const PointCollection_1 = require("./PointCollection");
const CurveListIterator_1 = require("./CurveListIterator");
const CurveCollection_1 = require("./CurveCollection");
const CurveListFactory_1 = require("./CurveListFactory");
const d3 = require("d3");
class CurveList extends PointCollection_1.PointCollection {
    constructor(curveList, spec) {
        super();
        this._curveList = curveList;
        this._length = 0;
        let i = 0;
        this._curveLookup = new Map();
        for (let curve of this.curveList) {
            this.curveLookup.set(curve.id, curve);
            this._length += curve.length;
            for (let point of curve) {
                this[i] = point;
                ++i;
            }
        }
        this._minMaxMap = new Map();
        this._inverseLocationMap = new Map();
        this._averageFilteredCurveCache = new Map();
        this._averageCurveCache = new Map();
        this._locationFrameSegmentLookup = new Map();
        const locationSet = new Set();
        for (let i = 0; i < this.length; i++) {
            let point = this[i];
            let loc = point.get('Location ID');
            locationSet.add(loc);
            if (!this._locationFrameSegmentLookup.has(loc)) {
                this._locationFrameSegmentLookup.set(loc, new Map());
            }
            const locMap = this._locationFrameSegmentLookup.get(loc);
            let frame = point.get('Frame ID');
            if (!locMap.has(frame)) {
                locMap.set(frame, new Map());
            }
            const segMap = locMap.get(frame);
            let segmentLabel = point.get('segmentLabel');
            segMap.set(segmentLabel, [point, i + 1]);
        }
        this._locationList = Array.from(locationSet);
        this.locationList.sort(DevlibAlgo_1.DevlibAlgo.sortAscend);
        this._curveCollection = new CurveCollection_1.CurveCollection(this, spec);
        this._curveBrushList = new Map();
        this.Specification = spec;
        this._conditionFilterState = new Map();
        for (let yKey of this.defaultFacetAxisTicks.yAxisTicks) {
            let thisMap = new Map();
            for (let xKey of this.defaultFacetAxisTicks.xAxisTicks) {
                thisMap.set(xKey, true);
            }
            this.conditionFilterState.set(yKey, thisMap);
        }
    }
    get curveList() {
        return this._curveList;
    }
    get curveLookup() {
        return this._curveLookup;
    }
    get curveCollection() {
        return this._curveCollection;
    }
    set curveCollection(v) {
        this._curveCollection = v;
    }
    get inputKey() {
        return this._inputKey;
    }
    get minMaxMap() {
        if (this._minMaxMap.size === 0) {
            this.updateMinMaxMap();
        }
        return this._minMaxMap;
    }
    get inverseLocationMap() {
        if (this._inverseLocationMap.size === 0) {
            this.generateInverseLocationMap();
        }
        return this._inverseLocationMap;
    }
    getAverageCurve(avgKey, filteredOnly = false, smoothed = false) {
        let cacheKey = avgKey;
        if (smoothed) {
            cacheKey = cacheKey + '-smoothed-out-real-nice-now';
        }
        let cache;
        if (filteredOnly) {
            cache = this._averageFilteredCurveCache;
        }
        else {
            cache = this._averageCurveCache;
        }
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        let sumCountMap = new Map();
        for (let point of this) {
            if (filteredOnly && !point.inBrush) {
                continue;
            }
            let frame = point.get('Frame ID');
            let mass = point.get(avgKey);
            let [sum, count] = sumCountMap.has(frame) ? sumCountMap.get(frame) : [0, 0];
            sumCountMap.set(frame, [sum + mass, count + 1]);
        }
        let frameList = Array.from(sumCountMap.keys()).sort((a, b) => a - b);
        let avgCurve = frameList.map(frame => {
            let [sum, count] = sumCountMap.get(frame);
            return [frame, sum / count];
        });
        if (smoothed) {
            avgCurve = CurveList.medianFilter(avgCurve);
        }
        cache.set(cacheKey, avgCurve);
        return avgCurve;
    }
    static medianFilter(points, window = 3) {
        const smoothedPoints = points.map((value, index) => {
            const [x, y] = value;
            const start = Math.max(0, index - window);
            const end = Math.min(points.length, index + window + 1);
            const slice = points.slice(start, end);
            let newY = d3.median(slice, d => d[1]);
            return [x, newY];
        });
        return smoothedPoints;
    }
    get defaultFacetAxisTicks() {
        if (this._defaultFacetAxisTicks) {
            return this._defaultFacetAxisTicks;
        }
        let facetOptions = this.GetFacetOptions();
        let firstFacetOption = facetOptions[0];
        let secondFacetOption = facetOptions[1];
        const yKeys = Object.keys(this.Specification.locationMaps[firstFacetOption.name]);
        const xKeys = Object.keys(this.Specification.locationMaps[secondFacetOption.name]);
        let axisLabels = [firstFacetOption.name, secondFacetOption.name];
        let returnObject = {
            xAxisTicks: xKeys,
            yAxisTicks: yKeys,
            axisLabels: axisLabels
        };
        this._defaultFacetAxisTicks = returnObject;
        return returnObject;
    }
    get defaultFacets() {
        if (this._defaultFacets) {
            return this._defaultFacets;
        }
        const drugIdx = 0;
        const concIdx = 1;
        let facetOptions = this.GetFacetOptions();
        let firstFacetOption = facetOptions[drugIdx];
        let firstFacets = firstFacetOption.GetFacets();
        let nestedFacetMap = new Map();
        for (let { name: categoryName, data: data } of firstFacets) {
            let facetOption = data.GetFacetOptions()[concIdx];
            let subFacets = facetOption.GetFacets();
            let thisDict = new Map();
            for (let subFacet of subFacets) {
                thisDict.set(subFacet.name[0], subFacet.data);
            }
            nestedFacetMap.set(categoryName[0], thisDict);
        }
        this._defaultFacets = nestedFacetMap;
        return nestedFacetMap;
    }
    clearDefaultFacetCache() {
        for (let map of this.defaultFacets.values()) {
            for (let curveList of map.values()) {
                curveList._averageFilteredCurveCache.clear();
            }
        }
    }
    get locationList() {
        return this._locationList;
    }
    CreateFilteredCurveList() {
        let filteredCurveArray = this.curveList.filter(curve => curve.inBrush);
        return new CurveList(filteredCurveArray, this.Specification);
    }
    ApplyDefaultFilters() {
        const trackLengthKey = 'Track Length';
        const [_, maxLength] = this.curveCollection.getMinMax(trackLengthKey);
        const filter = {
            key: trackLengthKey,
            bound: [maxLength / 2, maxLength]
        };
        // default to every other secondary filter. e.g. every other concentration
        for (let i = 1; i < this.defaultFacetAxisTicks.xAxisTicks.length; i += 2) {
            const xKey = this.defaultFacetAxisTicks.xAxisTicks[i];
            for (let yKey of this.defaultFacetAxisTicks.yAxisTicks) {
                this.conditionFilterState.get(yKey).set(xKey, false);
            }
        }
        this.curveCollection.addBrushNoUpdate('default', filter);
    }
    GetAllFilters() {
        let dataFilters = [];
        // curve filters
        for (let [key, filters] of this.curveBrushList.entries()) {
            dataFilters.push({
                type: 'curve',
                filterKey: key,
                filter: filters
            });
        }
        // cell filters
        for (let [key, filterMap] of this.brushList.entries()) {
            for (let [attributeKey, extent] of filterMap.entries()) {
                dataFilters.push({
                    type: 'cell',
                    filterKey: key,
                    filter: {
                        key: attributeKey,
                        bound: extent
                    }
                });
            }
        }
        // track filters
        for (let [key, filterMap] of this.curveCollection.brushList.entries()) {
            for (let [attributeKey, extent] of filterMap.entries()) {
                dataFilters.push({
                    type: 'track',
                    filterKey: key,
                    filter: {
                        key: attributeKey,
                        bound: extent
                    }
                });
            }
        }
        return dataFilters;
    }
    ConsumeFilters(otherCurveList) {
        // curve filters
        for (let [key, filters] of otherCurveList.curveBrushList.entries()) {
            this.curveBrushList.set(key + Date.now(), filters);
        }
        // cell filters
        for (let [key, filterMap] of otherCurveList.brushList.entries()) {
            let timedKey = key + Date.now();
            for (let [attributeKey, extent] of filterMap.entries()) {
                this.addBrushNoUpdate(timedKey, {
                    key: attributeKey,
                    bound: extent
                });
            }
        }
        // track filters
        for (let [key, filterMap] of otherCurveList.curveCollection.brushList.entries()) {
            let timedKey = key + Date.now();
            for (let [attributeKey, extent] of filterMap.entries()) {
                this.curveCollection.addBrushNoUpdate(timedKey, {
                    key: attributeKey,
                    bound: extent
                });
            }
        }
    }
    ApplyNewFilter() {
        this.OnBrushChange();
        const inFilterLocations = this.generateInFilterLocations();
        for (let curve of this.curveList) {
            const firstPoint = curve.pointList[0];
            const location = firstPoint.get('Location ID');
            if (!inFilterLocations.has(location)) {
                curve.inBrush = false;
            }
        }
    }
    generateInFilterLocations() {
        const inFilterSet = new Set();
        const [label1, label2] = this.defaultFacetAxisTicks.axisLabels;
        for (let key1 of this.conditionFilterState.keys()) {
            let numberRangeList1 = this.Specification.locationMaps[label1][key1];
            let numberSet1 = CurveList.numberRangeListToSet(numberRangeList1);
            let rowMap = this.conditionFilterState.get(key1);
            for (let [key2, value] of rowMap.entries()) {
                if (value) {
                    let numberRangeList2 = this.Specification.locationMaps[label2][key2];
                    let numberSet2 = CurveList.numberRangeListToSet(numberRangeList2);
                    let intersection = [...numberSet1].filter(x => numberSet2.has(x));
                    for (let val of intersection) {
                        inFilterSet.add(val);
                    }
                }
            }
        }
        return inFilterSet;
    }
    static numberRangeListToSet(numberRangeList) {
        const numberSet = new Set();
        for (let [low, high] of numberRangeList) {
            for (let i = low; i <= high; i++) {
                numberSet.add(i);
            }
        }
        return numberSet;
    }
    GetCellsAtFrame(locationId, frameId) {
        if (this._locationFrameSegmentLookup.has(locationId)) {
            const frameMap = this._locationFrameSegmentLookup.get(locationId);
            if (frameMap.has(frameId)) {
                const segMap = frameMap.get(frameId);
                const tuplelist = segMap.values();
                let pointList = [];
                for (let [point, _] of tuplelist) {
                    pointList.push(point);
                }
                return pointList;
            }
        }
        return [];
    }
    GetCellFromLabel(locationId, frameId, segmentLabel) {
        if (this._locationFrameSegmentLookup.has(locationId)) {
            const frameMap = this._locationFrameSegmentLookup.get(locationId);
            if (frameMap.has(frameId)) {
                const segMap = frameMap.get(frameId);
                if (segMap.has(segmentLabel)) {
                    return segMap.get(segmentLabel);
                }
            }
        }
        return [null, null];
    }
    get brushApplied() {
        return this._brushApplied;
    }
    set brushApplied(v) {
        this._brushApplied = v;
    }
    get curveBrushList() {
        return this._curveBrushList;
    }
    get conditionFilterState() {
        return this._conditionFilterState;
    }
    getFacetList(locationMap) {
        return CurveListFactory_1.CurveListFactory.CreateFacetedDatasets(this, locationMap);
    }
    OnBrushChange() {
        this.clearDefaultFacetCache();
        this._averageFilteredCurveCache.clear();
        for (let curve of this.curveList) {
            curve.inBrush = true;
            for (let point of curve.pointList) {
                point.inBrush = true;
            }
        }
        // sets filter values at point level
        const pointBrushApplied = this.SetBrushValues();
        // set track to false if all the points in a track are also false
        for (let curve of this.curveList) {
            let allPointsHidden = true;
            for (let point of curve.pointList) {
                if (point.inBrush) {
                    allPointsHidden = false;
                    break;
                }
            }
            if (allPointsHidden) {
                curve.inBrush = false;
            }
        }
        // sets filter values at track level
        const curveCollectionBrushApplied = this.curveCollection.SetBrushValues();
        const curveBrushApplied = this.setCurveBrushValues();
        this._brushApplied = pointBrushApplied || curveBrushApplied || curveCollectionBrushApplied;
    }
    setCurveBrushValues() {
        let brushApplied = false;
        for (let curve of this.curveList) {
            let allPointsOutOfBrush = true;
            for (let point of curve.pointList) {
                if (this.isPointInCurveBrushList(point)) {
                    allPointsOutOfBrush = false;
                    break;
                }
            }
            if (allPointsOutOfBrush) {
                curve.inBrush = false;
                brushApplied = true;
            }
        }
        return brushApplied;
    }
    isPointInCurveBrushList(point) {
        for (let valueFilterList of this.curveBrushList.values()) {
            for (let valueFilter of valueFilterList) {
                if (!PointCollection_1.PointCollection.IsInBrush(point, valueFilter)) {
                    return false;
                }
            }
        }
        return true;
    }
    updateMinMaxMap() {
        for (let curve of this.curveList) {
            for (let point of curve.pointList) {
                for (let [key, value] of point.valueMap) {
                    let currentVal = this._minMaxMap.get(key);
                    let pointVal = point.get(key);
                    if (typeof currentVal === "undefined") {
                        this._minMaxMap.set(key, [pointVal, pointVal]);
                        continue;
                    }
                    let [c1, c2] = currentVal;
                    let newVal = [Math.min(c1, pointVal), Math.max(c2, pointVal)];
                    this._minMaxMap.set(key, newVal);
                }
            }
        }
    }
    generateInverseLocationMap() {
        for (let categoryName of Object.keys(this.Specification.locationMaps)) {
            const conditionBreakdown = this.Specification.locationMaps[categoryName];
            for (let conditionName of Object.keys(conditionBreakdown)) {
                const numberRangeList = conditionBreakdown[conditionName];
                for (let [low, high] of numberRangeList) {
                    for (let i = low; i <= high; i++) {
                        if (!this._inverseLocationMap.has(i)) {
                            this._inverseLocationMap.set(i, []);
                        }
                        this._inverseLocationMap.get(i).push(conditionName);
                    }
                }
            }
        }
    }
    initValue(key, value) {
        for (let curve of this.curveList) {
            curve.addValue(key, value);
        }
    }
    isKeySet(key) {
        for (let curve of this.curveList) {
            let value = curve.get(key);
            if (typeof value === "undefined") {
                return false;
            }
        }
        return true;
    }
    setInputKey(key) {
        this._inputKey = key;
        for (let curve of this.curveList) {
            curve.sort(key);
        }
    }
    removeCurveBrush(brushKey) {
        this.curveBrushList.delete(brushKey);
        this.updateBrush();
    }
    addCurveBrush(brushKey, filters) {
        this.curveBrushList.set(brushKey, filters);
        this.updateBrush();
    }
    sort(key, ascend = true) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.sortOnProperty((curve) => {
            return curve.get(key);
        }, ascend);
        this.curveList.sort(sortFunction);
    }
    getPointsAtInput(inputValue) {
        let pointList = [];
        for (let curve of this.curveList) {
            let point = curve.getPoint(inputValue);
            // console.log(point);
            if (point) {
                pointList.push(point);
            }
        }
        return pointList;
    }
    calculateDepth(depthKey, valueKey) {
        if (this.isKeySet(depthKey)) {
            // depth is already set
            return;
        }
        this.initValue(depthKey, 0);
        const allBands = CurveList.getAllPossible2Bands(this.curveList);
        for (let band of allBands) {
            for (let curve of this.curveList) {
                const depthContribution = this.getDepthContribution(curve, band, valueKey);
                const oldDepth = curve.get(depthKey);
                curve.addValue(depthKey, oldDepth + depthContribution);
            }
        }
        // todo - normalize
    }
    getDepthContribution(curve, [b1, b2], valueKey) {
        let depth = 0;
        for (let i = 0; i < curve.pointList.length; i++) {
            let point = curve.pointList[i];
            const t = point.get(this.inputKey);
            let thisVal = point.get(valueKey);
            let b1Val = b1.getPointValue(t, valueKey);
            let b2Val = b2.getPointValue(t, valueKey);
            let minVal = Math.min(b1Val, b2Val);
            let maxVal = Math.max(b1Val, b2Val);
            if (minVal <= thisVal && thisVal <= maxVal) {
                const weight = curve.getPointWeight(i);
                depth += weight;
            }
        }
        return depth;
    }
    static getAllPossible2Bands(list) {
        const bandList = [];
        for (let i = 0; i < list.length; i++) {
            for (let j = i + 1; j < list.length; j++) {
                let b = [list[i], list[j]];
                bandList.push(b);
            }
        }
        return bandList;
    }
    [Symbol.iterator]() {
        return new CurveListIterator_1.CurveListIterator(this.curveList);
    }
}
exports.CurveList = CurveList;

},{"../devlib/DevlibAlgo":114,"./CurveCollection":97,"./CurveListFactory":101,"./CurveListIterator":102,"./PointCollection":111,"d3":42}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const DevlibMath_1 = require("../devlib/DevlibMath");
const CurveList_1 = require("./CurveList");
const CurveND_1 = require("./CurveND");
const PointND_1 = require("./PointND");
class CurveListFactory {
    static CreateFacetedDatasets(fullData, locationMap) {
        let locToCat = new Map();
        for (let key of Object.keys(locationMap)) {
            let valueList = locationMap[key];
            if (valueList.length === 0) {
                throw new Error('LocationMap valueList should have at least one entry');
            }
            if (typeof valueList[0] === 'string') {
                // todo work for locationmaptemaplate type
            }
            else {
                for (let [low, high] of valueList) {
                    for (let i = +low; i <= +high; i++) {
                        locToCat.set(i, key);
                    }
                }
            }
        }
        let pointMap = new Map();
        for (let curve of fullData.curveList) {
            let firstPoint = curve.pointList[0];
            let location = firstPoint.get('Location ID');
            let category = locToCat.get(location);
            if (!pointMap.has(category)) {
                pointMap.set(category, []);
            }
            pointMap.get(category).push(curve);
        }
        let facetList = [];
        for (let [cat, listOfCurves] of pointMap) {
            let curveList = new CurveList_1.CurveList(listOfCurves, fullData.Specification);
            let facet = {
                name: [cat],
                data: curveList
            };
            facetList.push(facet);
        }
        return facetList;
    }
    static CreateCurveListFromCSVObject(csvObject, derivedTrackDataFunctions, derivedPointDataFunctions, dataSpec, idkey = "id", tKeyOptions = ["Time (h)"]) {
        console.log(csvObject);
        const curveList = [];
        let tKey = null;
        for (let keyOption of tKeyOptions) {
            if (csvObject.columns.includes(keyOption)) {
                tKey = keyOption;
                break;
            }
        }
        if (tKey == null) {
            throw new Error("Dataset does not contain any tKey column. Allowed Keys: " + tKeyOptions.toString());
        }
        let pojoList = d3.nest()
            .key(d => d[idkey])
            .rollup((rows) => {
            const values = {};
            const points = [];
            for (let row of rows) {
                const tValue = row[tKey];
                if (!DevlibMath_1.DevlibMath.isNumber(tValue)) {
                    for (let key in row) {
                        if (key === idkey || key === tKey) {
                            continue;
                        }
                        const value = row[key];
                        if (!DevlibMath_1.DevlibMath.isNumber) {
                            continue;
                        }
                        values[tValue] = +value;
                        break;
                    }
                    continue;
                }
                const point = {};
                for (let key in row) {
                    if (key === idkey) {
                        continue;
                    }
                    point[key] = +row[key];
                }
                points.push(point);
            }
            values.points = points;
            CurveListFactory.calculateDerivedPointValues(values, derivedPointDataFunctions);
            CurveListFactory.calculateDerivedTrackValues(values, derivedTrackDataFunctions);
            return values;
        })
            .entries(csvObject);
        for (let plainCurve of pojoList) {
            let numericKey = +plainCurve.key;
            // js formats the number as '123.0', Instead I want '123'
            const curve = new CurveND_1.CurveND(numericKey.toString());
            for (let key in plainCurve.value) {
                let value = plainCurve.value[key];
                if (typeof value === "number") {
                    curve.addValue(key, value);
                    continue;
                }
                for (let pojoPoint of value) {
                    const point = new PointND_1.PointND(pojoPoint);
                    curve.addPoint(point);
                }
            }
            curveList.push(curve);
        }
        // console.log(curveList);
        const curveListObj = new CurveList_1.CurveList(curveList, dataSpec);
        curveListObj.setInputKey(tKey);
        return curveListObj;
    }
    static calculateDerivedTrackValues(values, derivedTrackDataFunctions) {
        let points = values.points;
        for (let [attrNameList, func] of derivedTrackDataFunctions) {
            let valueList = func(points);
            if (valueList === null) {
                continue;
            }
            for (let i = 0; i < attrNameList.length; i++) {
                let attrName = attrNameList[i];
                let val = valueList[i];
                values[attrName] = val;
            }
        }
    }
    static calculateDerivedPointValues(values, derivedPointDataFunctions) {
        let points = values.points;
        for (let [attrNameList, func] of derivedPointDataFunctions) {
            let valueListOfLists = func(points);
            if (valueListOfLists === null) {
                continue;
            }
            for (let i = 0; i < attrNameList.length; i++) {
                let attrName = attrNameList[i];
                let valueList = valueListOfLists[i];
                for (let j = 0; j < points.length; j++) {
                    points[j][attrName] = valueList[j];
                }
            }
        }
    }
}
exports.CurveListFactory = CurveListFactory;

},{"../devlib/DevlibMath":115,"./CurveList":100,"./CurveND":103,"./PointND":112,"d3":42}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CurveIterator_1 = require("./CurveIterator");
class CurveListIterator {
    constructor(curveList) {
        this._curveList = curveList;
        this.updateCurveIterator(0);
    }
    get index() {
        return this._index;
    }
    get curveList() {
        return this._curveList;
    }
    get currentCurveIterator() {
        return this._currentCurveIterator;
    }
    next() {
        let nextResult = this.currentCurveIterator.next();
        if (!nextResult.done) {
            return nextResult;
        }
        let newIndex = this.index + 1;
        if (newIndex >= this.curveList.length) {
            return {
                done: true,
                value: undefined
            };
        }
        this.updateCurveIterator(newIndex);
        return this.next();
    }
    updateCurveIterator(newIndex) {
        this._index = newIndex;
        let nextCurve = this.curveList[newIndex];
        if (nextCurve) {
            this._currentCurveIterator = new CurveIterator_1.CurveIterator(nextCurve.pointList);
        }
    }
}
exports.CurveListIterator = CurveListIterator;

},{"./CurveIterator":99}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PointND_1 = require("./PointND");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
const PointCollection_1 = require("./PointCollection");
const CurveIterator_1 = require("./CurveIterator");
class CurveND extends PointCollection_1.PointCollection {
    constructor(id) {
        super();
        this._id = id;
        this._valueMap = new Map();
        this._pointList = [];
        this._inBrush = true;
    }
    CreateFilteredCurveList() {
        throw new Error('Method not implemented.');
    }
    ApplyDefaultFilters() {
        throw new Error('Method not implemented.');
    }
    get id() {
        return this._id;
    }
    get inputKey() {
        return this._inputKey;
    }
    get valueMap() {
        return this._valueMap;
    }
    get pointList() {
        return this._pointList;
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
        for (let point of this.pointList) {
            point.inBrush = v;
        }
    }
    getFacetList() {
        throw new Error('Not Implemented.');
    }
    OnBrushChange() { }
    ConsumeFilters(AppData) { }
    ;
    ApplyNewFilter() { }
    ;
    addValue(key, value) {
        this.valueMap.set(key, value);
    }
    get(key) {
        return this.valueMap.get(key);
    }
    // finds the value of the property with given key. Will interpolate.
    getPointValue(inputValue, outputKey) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(inputValue, (point) => {
            return point.get(this.inputKey);
        });
        let pointIndex;
        pointIndex = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(this.pointList, sortFunction);
        if (typeof pointIndex === "number") {
            return this.pointList[pointIndex].get(outputKey);
        }
        const [idx1, idx2] = pointIndex;
        if (idx1 === undefined || idx2 === undefined) {
            // out of bounds
            return undefined;
        }
        const point1 = this.pointList[idx1];
        const point2 = this.pointList[idx2];
        const val1 = point1.get(outputKey);
        const val2 = point2.get(outputKey);
        const t1 = point1.get(this.inputKey);
        const t2 = point2.get(this.inputKey);
        const tDiff = t2 - t1;
        const portion = (inputValue - t1) / tDiff;
        const valDiff = val2 - val1;
        return val1 + valDiff * portion;
    }
    // finds point at given input time. Will construct a new point and interpolate all values if it is between points
    getPoint(inputValue) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.compareProperty(inputValue, (point) => {
            return point.get(this.inputKey);
        });
        let pointIndex;
        pointIndex = DevlibAlgo_1.DevlibAlgo.BinarySearchIndex(this.pointList, sortFunction);
        if (typeof pointIndex === "number") {
            return this.pointList[pointIndex];
        }
        const [idx1, idx2] = pointIndex;
        if (idx1 === undefined || idx2 === undefined) {
            // out of bounds
            return undefined;
        }
        const point1 = this.pointList[idx1];
        const point2 = this.pointList[idx2];
        const t1 = point1.get(this.inputKey);
        const t2 = point2.get(this.inputKey);
        const tDiff = t2 - t1;
        const portion = (inputValue - t1) / tDiff;
        let interpolatedPoint = new PointND_1.PointND();
        interpolatedPoint.addValue(this.inputKey, inputValue);
        for (let [key, value] of point1.valueMap) {
            let val1 = point1.get(key);
            let val2 = point2.get(key);
            let valDiff = val2 - val1;
            interpolatedPoint.addValue(key, val1 + valDiff * portion);
        }
        interpolatedPoint.inBrush = point1.inBrush && point2.inBrush;
        return interpolatedPoint;
    }
    getPointWeight(pointIndex) {
        const idxLeft = Math.max(pointIndex - 1, 0);
        const idxRight = Math.min(pointIndex + 1, this.pointList.length - 1);
        const tLeft = this.pointList[idxLeft].get(this.inputKey);
        const tRight = this.pointList[idxRight].get(this.inputKey);
        return (tRight - tLeft) / 2;
    }
    addPoint(point) {
        point.parent = this;
        this._pointList.push(point);
        this[this.length] = point;
        ++this._length;
    }
    sort(key) {
        let sortFunction = DevlibAlgo_1.DevlibAlgo.sortOnProperty((point) => {
            return point.get(key);
        });
        this.pointList.sort(sortFunction);
        this._inputKey = key;
    }
    [Symbol.iterator]() {
        return new CurveIterator_1.CurveIterator(this.pointList);
    }
}
exports.CurveND = CurveND;

},{"../devlib/DevlibAlgo":114,"./CurveIterator":99,"./PointCollection":111,"./PointND":112}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DataEvents;
(function (DataEvents) {
    DataEvents["brushChange"] = "brushChange";
    DataEvents["selectionToFilter"] = "selectionToFilter";
    DataEvents["applyNewFilter"] = "applyNewFilter";
})(DataEvents = exports.DataEvents || (exports.DataEvents = {}));

},{}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DerivedPointValueFunctions {
    static GetFunctionList() {
        let functionList = [];
        functionList.push([['Mass_norm'], (pointList) => this.normAttr('Mass (pg)', pointList, false)]);
        functionList.push([['Time_norm'], (pointList) => this.normAttr('Time (h)', pointList)]);
        return functionList;
    }
    static normAttr(attrKey, pointList, zeroNorm = true) {
        let newValues = [];
        if (pointList.length === 0) {
            return [newValues];
        }
        const firstVal = pointList[0][attrKey];
        for (let point of pointList) {
            let oldVal = point[attrKey];
            if (zeroNorm) {
                newValues.push(oldVal - firstVal);
            }
            else {
                newValues.push(oldVal / firstVal);
            }
        }
        return [newValues];
    }
}
exports.DerivedPointValueFunctions = DerivedPointValueFunctions;

},{}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DerivedTrackValueFunctions {
    static GetFunctionList() {
        let functionList = [];
        functionList.push([['Track Length'], this.trackLength]);
        for (let toAverage of ['Mass (pg)', 'shape factor', 'Mass_norm', 'Mean Intensity', 'Area']) {
            functionList.push([['Avg. ' + toAverage], (pointList) => this.averageAttribute(pointList, toAverage)]);
        }
        functionList.push([['Growth Rate', 'Intercept', 'Initial Mass', 'Exponential Growth Constant', 'r_squared'], this.growthRateStats]);
        return functionList;
    }
    static trackLength(pointList) {
        let firstTime = pointList[0]['Time (h)'];
        let lastTime = pointList[pointList.length - 1]['Time (h)'];
        return [lastTime - firstTime];
    }
    static averageAttribute(pointList, attributeKey) {
        const firstPoint = pointList[0];
        if (!Object.keys(firstPoint).includes(attributeKey)) {
            return null;
        }
        let total = 0;
        for (let point of pointList) {
            total += point[attributeKey];
        }
        return [total / pointList.length];
    }
    // private static averageMass(pointList: StringToNumberObj[]): [number]
    // {
    //     let totalMass = 0;
    //     for (let point of pointList)
    //     {
    //         totalMass += point['Mass (pg)'];
    //     }
    //     return [totalMass / pointList.length];
    // }
    // private static averageShapeFactor(pointList: StringToNumberObj[]): [number]
    // {
    //     let totalShapeFactor = 0;
    //     for (let point of pointList)
    //     {
    //         totalShapeFactor += point['shape factor'];
    //     }
    //     return [totalShapeFactor / pointList.length];
    // }
    static growthRateStats(pointList) {
        // Referenced math
        // https://en.wikipedia.org/wiki/Ordinary_least_squares#Simple_linear_regression_model
        let sumX = 0;
        let sumY = 0;
        let sumYY = 0;
        let sumXY = 0;
        let sumXX = 0;
        let N = pointList.length;
        if (N === 1) {
            return [NaN, NaN, NaN, NaN, NaN]; // calculating the slope of one point is actually point...less
        }
        for (let point of pointList) {
            let x = point['Time (h)'];
            let y = point['Mass (pg)'];
            sumX += x;
            sumY += y;
            sumYY += y * y;
            sumXY += x * y;
            sumXX += x * x;
        }
        let N_inv = 1 / N;
        let covariance = sumXY - N_inv * sumX * sumY;
        let variance = sumXX - N_inv * sumX * sumX;
        let slope = covariance / variance;
        let intercept = N_inv * (sumY - slope * sumX);
        let initialMass = pointList[0]['Time (h)'] * slope + intercept;
        let exponentialGrowthConstant = slope / initialMass;
        // r_squared equation from here
        // https://en.wikipedia.org/wiki/Simple_linear_regression#Fitting_the_regression_line
        let r_top = (N_inv * sumXY - N_inv * sumX * N_inv * sumY);
        let r_bot = Math.sqrt((N_inv * sumXX - N_inv * sumX * N_inv * sumX) * (N_inv * sumYY - N_inv * sumY * N_inv * sumY));
        let r_squared = Math.pow((r_top / r_bot), 2);
        return [slope, intercept, initialMass, exponentialGrowthConstant, r_squared];
    }
}
exports.DerivedTrackValueFunctions = DerivedTrackValueFunctions;

},{}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ImageFrame {
    constructor(frameId) {
        this._frameId = frameId;
        this._inBrush = true;
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
    }
    get inBrushCount() {
        return this._inBrushCount;
    }
    set inBrushCount(v) {
        this._inBrushCount = v;
    }
    get totalCount() {
        return this._totalCount;
    }
    set totalCount(v) {
        this._totalCount = v;
    }
    get inBrushPercent() {
        if (this.totalCount === 0) {
            return 0;
        }
        return this.inBrushCount / this.totalCount;
    }
    get frameId() {
        return this._frameId;
    }
}
exports.ImageFrame = ImageFrame;

},{}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ImageFrame_1 = require("./ImageFrame");
const DevlibAlgo_1 = require("../devlib/DevlibAlgo");
class ImageLocation {
    constructor(locationId) {
        this._locationId = locationId;
        this._inBrush = true;
        this._frameList = [];
        this._frameLookup = new Map();
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
    }
    get inBrushCount() {
        return this._inBrushCount;
    }
    set inBrushCount(v) {
        this._inBrushCount = v;
    }
    get totalCount() {
        return this._totalCount;
    }
    set totalCount(v) {
        this._totalCount = v;
    }
    get inBrushPercent() {
        return this.inBrushCount / this.totalCount;
    }
    get locationId() {
        return this._locationId;
    }
    get frameList() {
        return this._frameList;
    }
    get frameLookup() {
        return this._frameLookup;
    }
    addFrame(frameId) {
        if (this.frameLookup.has(frameId)) {
            return;
        }
        let newFrame = new ImageFrame_1.ImageFrame(frameId);
        this.frameList.push(newFrame);
        this.frameLookup.set(frameId, newFrame);
    }
    sortFrames() {
        this.frameList.sort(DevlibAlgo_1.DevlibAlgo.sortOnProperty((frame) => frame.frameId));
    }
}
exports.ImageLocation = ImageLocation;

},{"../devlib/DevlibAlgo":114,"./ImageFrame":107}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ImageLocation_1 = require("./ImageLocation");
class ImageMetaData {
    constructor() {
        this._locationList = [];
        this._locationLookup = new Map();
    }
    get locationList() {
        return this._locationList;
    }
    get locationLookup() {
        return this._locationLookup;
    }
    get locationIdKey() {
        return this._locationIdKey;
    }
    get frameIdKey() {
        return this._frameIdKey;
    }
    getBrushedLocations() {
        return this.locationList.filter(loc => loc.inBrush).map(loc => loc.locationId);
    }
    getBrushedImageCount() {
        let count = 0;
        for (let loc of this.locationList) {
            count += loc.frameList.filter(frame => frame.inBrush).length;
        }
        return count;
    }
    updateInBrushProp(pointList) {
        this.resetAllToFalse();
        for (let point of pointList) {
            let locId = point.get(this.locationIdKey);
            let frameId = point.get(this.frameIdKey);
            let location = this.locationLookup.get(locId);
            let frame = location.frameLookup.get(frameId);
            location.totalCount++;
            frame.totalCount++;
            if (point.inBrush) {
                location.inBrushCount++;
                location.inBrush = true;
                frame.inBrushCount++;
                frame.inBrush = true;
            }
        }
    }
    resetAllToFalse() {
        for (let loc of this.locationList) {
            loc.inBrush = false;
            loc.inBrushCount = 0;
            loc.totalCount = 0;
            for (let frame of loc.frameList) {
                frame.inBrush = false;
                frame.inBrushCount = 0;
                frame.totalCount = 0;
            }
        }
    }
    static fromPointCollection(pointList, locationIdKey = 'Location ID', frameIdKey = 'Frame ID') {
        let imgMetaData = new ImageMetaData();
        imgMetaData._locationIdKey = locationIdKey;
        imgMetaData._frameIdKey = frameIdKey;
        for (let point of pointList) {
            let locId = point.get(locationIdKey);
            let frameId = point.get(frameIdKey);
            let imageLocation;
            if (imgMetaData.locationLookup.has(locId)) {
                imageLocation = imgMetaData.locationLookup.get(locId);
            }
            else {
                imageLocation = new ImageLocation_1.ImageLocation(locId);
                imgMetaData.locationList.push(imageLocation);
                imgMetaData.locationLookup.set(locId, imageLocation);
            }
            imageLocation.addFrame(frameId);
        }
        for (let imageLocation of imgMetaData.locationList) {
            imageLocation.sortFrames();
        }
        imgMetaData.updateInBrushProp(pointList);
        return imgMetaData;
    }
}
exports.ImageMetaData = ImageMetaData;

},{"./ImageLocation":108}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const idb_1 = require("idb");
const protobufjs_1 = require("protobufjs");
class ImageStackDataRequest {
    constructor(driveId) {
        this._driveId = driveId;
        this._metaDataLoaded = false;
        const metaDataFilename = `/data/${driveId}/imageMetaData.json`;
        idb_1.openDB('loon-db').then(async (dataStore) => {
            this._dataStore = dataStore;
            let store = this.dataStore.transaction('images', 'readonly').objectStore('images');
            let data = await store.get(metaDataFilename);
            if (data) {
                this.initImageMetaData(data);
                return;
            }
            d3.json(metaDataFilename).then(data => {
                this.initImageMetaData(data);
                this.dataStore.put('images', data, metaDataFilename);
            });
        });
        this._blobArray = [];
        this._labelArray = [];
        this._maxBlobCount = 100;
        this._nextBlobIndex = 0;
        this._nextLabelIndex = 0;
        this._maxLabelCount = 100;
    }
    initImageMetaData(data) {
        this._tileWidth = data.tileWidth;
        this._tileHeight = data.tileHeight;
        this._numberOfColumns = data.numberOfColumns;
        this._tilesPerFile = data.tilesPerFile;
        this._metaDataLoaded = true;
        if (data.scaleFactor) {
            this._scaleFactor = data.scaleFactor;
        }
        else {
            this._scaleFactor = 1;
        }
    }
    get metaDataLoaded() {
        return this._metaDataLoaded;
    }
    get driveId() {
        return this._driveId;
    }
    get tileWidth() {
        return this._tileWidth;
    }
    get tileHeight() {
        return this._tileHeight;
    }
    get numberOfColumns() {
        return this._numberOfColumns;
    }
    get tilesPerFile() {
        return this._tilesPerFile;
    }
    get maxBlobCount() {
        return this._maxBlobCount;
    }
    get maxLabelCount() {
        return this._maxLabelCount;
    }
    get scaleFactor() {
        return this._scaleFactor;
    }
    get blobArray() {
        return this._blobArray;
    }
    get nextBlobIndex() {
        return this._nextBlobIndex;
    }
    get labelArray() {
        return this._labelArray;
    }
    get nextLabelIndex() {
        return this._nextLabelIndex;
    }
    get dataStore() {
        return this._dataStore;
    }
    async getImage(location, frameIndex, callback) {
        if (!this.metaDataLoaded) {
            setTimeout(() => {
                this.getImage(location, frameIndex, callback);
            }, 50); // todo fallback
            return;
        }
        let [top, left] = this.getTileTopLeft(frameIndex);
        let bundleIndex = Math.floor(frameIndex / this.tilesPerFile);
        let key = [location, bundleIndex].join('-');
        let cachedElement = this.blobArray.find(d => d[1] === key);
        if (cachedElement) {
            this.runWithCachedImage(key, top, left, callback);
            return;
        }
        const imgUrl = `/data/${this.driveId}/img_${location}_${bundleIndex}.jpg`;
        const thisIndex = this.nextBlobIndex;
        this.blobArray[thisIndex] = [null, key, null];
        this._nextBlobIndex = (this.nextBlobIndex + 1) % this.maxBlobCount;
        if (this.dataStore) {
            // try and get from data store
            let store = this.dataStore.transaction('images', 'readonly').objectStore('images');
            let blob = await store.get(imgUrl);
            if (blob) {
                let url = window.URL.createObjectURL(blob);
                this.blobArray[thisIndex] = [blob, key, url];
                callback(top, left, blob, url);
                return;
            }
        }
        let xhr = new XMLHttpRequest();
        xhr.responseType = 'blob';
        xhr.onload = () => {
            let blob = xhr.response;
            if (this.dataStore) {
                this.dataStore.put('images', blob, imgUrl);
            }
            let url = window.URL.createObjectURL(blob);
            this.blobArray[thisIndex] = [blob, key, url];
            callback(top, left, blob, url);
        };
        xhr.onerror = (e) => {
            console.warn('Error Fetching: ' + imgUrl);
            console.warn(e);
        };
        xhr.open('GET', imgUrl);
        xhr.send();
        return;
    }
    runWithCachedImage(key, top, left, callback) {
        let cachedElement = this.blobArray.find(d => d[1] === key);
        if (cachedElement[0]) {
            callback(top, left, cachedElement[0], cachedElement[2]);
        }
        else {
            // loading, try again later
            setTimeout(() => {
                this.runWithCachedImage(key, top, left, callback);
            }, 50);
        }
    }
    getImagePromise(location, frameIndex) {
        return new Promise((resolve, reject) => {
            try {
                this.getImage(location, frameIndex, (top, left, blob, imageUrl) => {
                    resolve([top, left, blob, imageUrl]);
                });
            }
            catch (error) {
                console.error(error);
                reject();
            }
        });
    }
    getTileTopLeft(frameIndex) {
        const left = (frameIndex % this.numberOfColumns) * this.tileWidth;
        let top = Math.floor((frameIndex % this.tilesPerFile) / this.numberOfColumns) * this.tileHeight;
        return [top, left];
    }
    getLabel(location, frameIndex, callback) {
        if (!this.metaDataLoaded) {
            setTimeout(() => {
                this.getLabel(location, frameIndex, callback);
            }, 50); // todo fallback
            return;
        }
        // let [top, left] = this.getTileTopLeft(frameIndex);
        let firstIndex = (frameIndex % this.tilesPerFile) * this.tileHeight;
        let bundleIndex = Math.floor(frameIndex / this.tilesPerFile);
        let key = [location, bundleIndex].join('-');
        let cachedElement = this.labelArray.find(d => d[1] === key);
        if (cachedElement) {
            // todo - similar runWithCached logic
            this.runWithCachedLabel(key, firstIndex, callback);
            return;
        }
        const thisIndex = this.nextLabelIndex;
        this._nextLabelIndex = (this.nextLabelIndex + 1) % this.maxBlobCount;
        this.labelArray[thisIndex] = [null, key];
        const labelUrl = `/data/${this.driveId}/label_${location}_${bundleIndex}.pb`;
        protobufjs_1.load("/static/protoDefs/RLE.proto", async (err, root) => {
            if (err) {
                throw err;
            }
            // Obtain a message type
            let ImageLabelsMessage = root.lookupType("imageLabels.ImageLabels");
            let buffer;
            if (this.dataStore) {
                let store = this.dataStore.transaction('images', 'readonly').objectStore('images');
                buffer = await store.get(labelUrl);
            }
            if (!buffer) {
                buffer = await d3.buffer(labelUrl);
                await this.dataStore.put('images', buffer, labelUrl);
            }
            // Decode an Uint8Array (browser) or Buffer (node) to a message
            let message = ImageLabelsMessage.decode(new Uint8Array(buffer));
            this.labelArray[thisIndex] = [message, key];
            console.log(message);
            callback(message, firstIndex);
        });
        return;
    }
    runWithCachedLabel(key, firstIndex, callback) {
        let cachedElement = this.labelArray.find(d => d[1] === key);
        if (cachedElement[0]) {
            callback(cachedElement[0], firstIndex);
        }
        else {
            // loading, try again later
            setTimeout(() => {
                this.runWithCachedLabel(key, firstIndex, callback);
            }, 50);
        }
    }
    getLabelPromise(location, frameIndex) {
        return new Promise((resolve, reject) => {
            this.getLabel(location, frameIndex, (rowData, firstIndex) => {
                resolve([rowData, firstIndex]);
            });
        });
    }
    static getLabelValue(rowIdx, colIdx, rowArray) {
        // if this is a bottleneck, this could be improved with quicksearch.
        let row = rowArray.rowList[rowIdx];
        for (let labelRun of row.row) {
            if (labelRun.start <= colIdx && colIdx < labelRun.start + labelRun.length) {
                return labelRun.label;
            }
        }
        return 0;
    }
}
exports.ImageStackDataRequest = ImageStackDataRequest;

},{"d3":42,"idb":43,"protobufjs":46}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DataEvents_1 = require("./DataEvents");
class PointCollection {
    constructor(pointList = []) {
        this._attributeList = [];
        this._length = pointList.length;
        this._Array = pointList;
        this._minMaxCache = new Map();
        this._brushList = new Map();
    }
    get Specification() {
        return this._Specification;
    }
    set Specification(v) {
        this._Specification = v;
    }
    get sourceKey() {
        return this._sourceKey;
    }
    set sourceKey(v) {
        this._sourceKey = v;
    }
    get postfixKey() {
        return this._postfixKey;
    }
    set postfixKey(v) {
        this._postfixKey = v;
    }
    get length() {
        return this._length;
    }
    get attributeList() {
        if (this._attributeList.length === 0) {
            this.initAttributeList();
        }
        return this._attributeList;
    }
    get Array() {
        if (this._Array.length === 0) {
            this._Array = Array.from(this);
        }
        return this._Array;
    }
    get minMaxCache() {
        return this._minMaxCache;
    }
    get brushList() {
        return this._brushList;
    }
    GetFacetOptions() {
        if (!this.Specification.locationMaps) {
            return [];
        }
        let facetOptionList = [];
        for (let key of Object.keys(this.Specification.locationMaps)) {
            let locationMap = this.Specification.locationMaps[key];
            let facetOption = {
                name: key,
                GetFacets: () => { return this.getFacetList(locationMap); }
            };
            facetOptionList.push(facetOption);
        }
        return facetOptionList;
    }
    initAttributeList() {
        let pointList = [...this];
        if (pointList.length > 0) {
            let point = pointList[0];
            for (let key of point.valueMap.keys()) {
                this._attributeList.push(key);
            }
        }
    }
    getMinMax(key) {
        if (this.minMaxCache.has(key)) {
            return this.minMaxCache.get(key);
        }
        let minN = Infinity;
        let maxN = -Infinity;
        for (let point of this) {
            let val = point.valueMap.get(key);
            if (val < minN) {
                minN = val;
            }
            if (val > maxN) {
                maxN = val;
            }
        }
        this.minMaxCache.set(key, [minN, maxN]);
        return [minN, maxN];
    }
    addBrush(brushKey, ...filters) {
        this.addBrushNoUpdate(brushKey, ...filters);
        this.updateBrush();
    }
    addBrushNoUpdate(brushKey, ...filters) {
        if (!this.brushList.has(brushKey)) {
            this.brushList.set(brushKey, new Map());
        }
        let thisMap = this.brushList.get(brushKey);
        for (let filter of filters) {
            thisMap.set(filter.key, filter.bound);
        }
        return;
    }
    removeBrush(brushKey) {
        this.brushList.delete(brushKey);
        this.updateBrush();
    }
    SetBrushValues() {
        let brushApplied = false;
        for (let point of this) {
            for (let valueFilterMap of this.brushList.values()) {
                for (let [key, bound] of valueFilterMap) {
                    let valueFilter = {
                        key: key,
                        bound: bound
                    };
                    if (!PointCollection.IsInBrush(point, valueFilter)) {
                        point.inBrush = false;
                        brushApplied = true;
                    }
                }
            }
        }
        return brushApplied;
    }
    static IsInBrush(point, valueFilter) {
        let v = point.get(valueFilter.key);
        let [low, high] = valueFilter.bound;
        return low <= v && v <= high && !isNaN(v);
    }
    updateBrush() {
        let event = new Event(DataEvents_1.DataEvents.brushChange);
        document.dispatchEvent(event);
    }
}
exports.PointCollection = PointCollection;

},{"./DataEvents":104}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PointND {
    constructor(pojo) {
        this._valueMap = new Map();
        for (let key in pojo) {
            const m = +pojo[key];
            this._valueMap.set(key, m);
        }
        this._inBrush = true;
        this._parent = null;
    }
    get valueMap() {
        return this._valueMap;
    }
    get inBrush() {
        return this._inBrush;
    }
    set inBrush(v) {
        this._inBrush = v;
    }
    get parent() {
        return this._parent;
    }
    set parent(v) {
        this._parent = v;
    }
    addValue(key, value) {
        this.valueMap.set(key, value);
    }
    get(key) {
        return this.valueMap.get(key);
    }
}
exports.PointND = PointND;

},{}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
class LayoutFramework {
    constructor(container, includeBorders = true) {
        this._container = container;
        this._includeBorders = includeBorders;
    }
    get container() {
        return this._container;
    }
    get includeBorders() {
        return this._includeBorders;
    }
    InitializeLayout(frame) {
        let elementToComponentType = new Map();
        this.addFrame(this.container, frame, elementToComponentType, true);
        return elementToComponentType;
    }
    addFrame(container, frame, lookup, skipThisBorder) {
        container.classList.add("frame");
        if (this.includeBorders && !skipThisBorder) {
            container.classList.add('with-border');
        }
        let dirClass;
        let dirPostFix;
        if (frame.direction === types_1.Direction.column) {
            dirClass = "dir-col";
            dirPostFix = "width";
        }
        else if (frame.direction === types_1.Direction.row) {
            dirClass = "dir-row";
            dirPostFix = "height";
        }
        container.classList.add(dirClass);
        let inlineStyle = "";
        if (typeof frame.minSize !== "undefined") {
            inlineStyle += `min-${dirPostFix}: ${frame.minSize}; `;
        }
        if (typeof frame.maxSize !== "undefined") {
            inlineStyle += `max-${dirPostFix}: ${frame.maxSize}; `;
        }
        if (frame.wrap) {
            inlineStyle += 'flex-wrap: wrap; ';
        }
        if (frame.overflowScroll) {
            inlineStyle += 'overflow: auto; ';
        }
        if (typeof frame.fraction === "undefined") {
            frame.fraction = 1;
        }
        inlineStyle += `flex-grow: ${frame.fraction}; `;
        container.setAttribute("style", inlineStyle);
        if (frame.inside instanceof Array) {
            let lastChildFrame = frame.inside[frame.inside.length - 1];
            for (let childFrame of frame.inside) {
                let childContainer = document.createElement("div");
                container.appendChild(childContainer);
                let isLastChild = childFrame === lastChildFrame;
                this.addFrame(childContainer, childFrame, lookup, isLastChild);
            }
        }
        else {
            lookup.set(container, frame.inside);
        }
    }
}
exports.LayoutFramework = LayoutFramework;

},{"./types":118}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DevlibAlgo {
    static BinarySearchIndex(list, compareFunction) {
        if (list.length === 0) {
            return [undefined, undefined];
        }
        let firstElement = list[0];
        let compareResult = compareFunction(firstElement);
        if (compareResult > 0) {
            return [undefined, 0];
        }
        let lastElement = list[list.length - 1];
        compareResult = compareFunction(lastElement);
        if (compareResult < 0) {
            return [list.length - 1, undefined];
        }
        return DevlibAlgo.BinarySearchRecurse(list, compareFunction, 0, list.length - 1);
    }
    static BinarySearchRecurse(list, compareFunction, idx1, idx2) {
        if (Math.abs(idx1 - idx2) === 1) {
            return [idx1, idx2];
        }
        // if (idx1 === idx2)
        // {
        // 	return [undefined, undefined]
        // }
        let midIndex = Math.floor((idx1 + idx2) / 2);
        let element = list[midIndex];
        let compareResult = compareFunction(element);
        if (compareResult === 0) {
            return midIndex;
        }
        else if (compareResult > 0) {
            return DevlibAlgo.BinarySearchRecurse(list, compareFunction, idx1, midIndex);
        }
        else if (compareResult < 0) {
            return DevlibAlgo.BinarySearchRecurse(list, compareFunction, midIndex, idx2);
        }
    }
    static compareProperty(num, propertyAccessor) {
        return (a) => {
            const aVal = propertyAccessor(a);
            return DevlibAlgo.compareValues(aVal, num);
        };
    }
    static sortOnProperty(propertyAccessor, ascend = true) {
        return (a, b) => {
            const aVal = propertyAccessor(a);
            const bVal = propertyAccessor(b);
            if (ascend) {
                return DevlibAlgo.sortAscend(aVal, bVal);
            }
            else {
                return DevlibAlgo.sortDescend(aVal, bVal);
            }
        };
    }
    static sortAscend(aVal, bVal) {
        return DevlibAlgo.compareValues(aVal, bVal);
    }
    static sortDescend(aVal, bVal) {
        return DevlibAlgo.compareValues(bVal, aVal);
    }
    static compareValues(a, b) {
        let diff = a - b;
        if (Math.abs(diff) > 0) {
            diff /= Math.abs(diff);
        }
        return diff;
    }
}
exports.DevlibAlgo = DevlibAlgo;

},{}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DevlibMath {
    static sumN(...numbers) {
        return numbers.reduce((a, b) => a + b);
    }
    static sum(arr) {
        return DevlibMath.sumN(...arr);
    }
    static averageN(...numbers) {
        const sum = DevlibMath.sum(numbers);
        return sum / numbers.length;
    }
    static average(arr) {
        return DevlibMath.averageN(...arr);
    }
    static meanSquaredError(numbers, v) {
        const squaredErrors = numbers.map((a) => Math.pow(a - v, 2));
        return DevlibMath.average(squaredErrors);
    }
    static varianceN(...numbers) {
        let avg = DevlibMath.average(numbers);
        return DevlibMath.meanSquaredError(numbers, avg);
    }
    static variance(numbers) {
        return DevlibMath.varianceN(...numbers);
    }
    // returns a number in the range [min, max] inclusive on both ends.
    static randomInt(min, max) {
        return Math.floor(Math.random() * (max + 1));
    }
    static nChooseTwo(n) {
        return n * (n - 1) / 2.0;
    }
    static isNumber(text) {
        if (text === "") {
            return false;
        }
        return !isNaN(Number(text));
    }
    static clamp(val, [minVal, maxVal]) {
        return Math.min(Math.max(val, minVal), maxVal);
    }
}
exports.DevlibMath = DevlibMath;

},{}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class DevlibTSUtil {
    static async asyncSetTimeout(f, milliDelay) {
        return new Promise((resolve) => {
            setTimeout(() => {
                f();
                resolve();
            }, milliDelay);
        });
    }
    static async makeAsync(f) {
        return DevlibTSUtil.asyncSetTimeout(f, 0);
    }
    static getIconButton(iconKey, callback, text) {
        let btn = document.createElement('button');
        btn.classList.add('basicIconButton');
        let icon = DevlibTSUtil.getFontAwesomeIcon(iconKey);
        if (text) {
            if (!text.endsWith(' ')) {
                text += ' ';
            }
            btn.append(text);
            btn.classList.add('withText');
        }
        btn.appendChild(icon);
        btn.onclick = callback;
        return btn;
    }
    static getFontAwesomeIcon(iconKey) {
        // <i class="fas fa-{icon}"></i>
        let icon = document.createElement("i");
        icon.classList.add('fas');
        icon.classList.add('fa-' + iconKey);
        return icon;
    }
    static show(element) {
        element.classList.remove('noDisp');
    }
    static hide(element) {
        element.classList.add('noDisp');
    }
    static launchSpinner() {
        const outerId = 'loadingSpinnerContainer';
        if (!DevlibTSUtil.spinnerInDom()) {
            let outer = document.createElement('div');
            outer.classList.add('spinnerOuter');
            outer.id = outerId;
            let imgDiv = document.createElement('div');
            imgDiv.classList.add('spinnerWrapper');
            let inner = document.createElement('img');
            inner.classList.add('spinner');
            inner.src = '/spinner.gif';
            imgDiv.appendChild(inner);
            outer.appendChild(imgDiv);
            let attribution = document.createElement('a');
            attribution.classList.add('attributionLink');
            attribution.href = 'https://loading.io/asset/442473';
            attribution.innerText = "icon 'Double Ring' from loading.io";
            outer.appendChild(attribution);
            document.body.appendChild(outer);
        }
        if (!DevlibTSUtil.spinnerSpinning()) {
            DevlibTSUtil.show(document.getElementById(outerId));
        }
    }
    static stopSpinner() {
        let spinner = document.getElementById('loadingSpinnerContainer');
        if (spinner) {
            DevlibTSUtil.hide(spinner);
        }
    }
    static spinnerInDom() {
        return document.getElementById('loadingSpinnerContainer') !== null;
    }
    static spinnerSpinning() {
        let outer = document.getElementById('loadingSpinnerContainer');
        if (outer && !outer.classList.contains('noDisp')) {
            return true;
        }
        return false;
    }
}
exports.DevlibTSUtil = DevlibTSUtil;

},{}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
const CurveListFactory_1 = require("../src/DataModel/CurveListFactory");
const DerivedTrackValueFunctions_1 = require("../src/DataModel/DerivedTrackValueFunctions");
const DerivedPointValueFunctions_1 = require("../src/DataModel/DerivedPointValueFunctions");
const App_1 = require("./App");
let metaContainer = document.querySelector('#metaContainer');
let derivedTrackDataFunctions = DerivedTrackValueFunctions_1.DerivedTrackValueFunctions.GetFunctionList();
let derivedPointDataFunctions = DerivedPointValueFunctions_1.DerivedPointValueFunctions.GetFunctionList();
let app = new App_1.App(metaContainer, CurveListFactory_1.CurveListFactory.CreateCurveListFromCSVObject, derivedTrackDataFunctions, derivedPointDataFunctions);
window.onresize = () => app.OnWindowResize();
d3.json('/static/layouts/defaultLayout.json').then(async (data) => {
    await app.InitDataStore();
    app.InitializeLayout(data);
    const datasetId = metaContainer.dataset.dataset;
    app.LoadDataset(datasetId);
});

},{"../src/DataModel/CurveListFactory":101,"../src/DataModel/DerivedPointValueFunctions":105,"../src/DataModel/DerivedTrackValueFunctions":106,"./App":82,"d3":42}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Direction;
(function (Direction) {
    Direction["row"] = "row";
    Direction["column"] = "col";
})(Direction = exports.Direction || (exports.Direction = {}));
var ComponentType;
(function (ComponentType) {
    ComponentType["Toolbar"] = "Toolbar";
    ComponentType["Plot2dPathsWidget"] = "Plot2dPathsWidget";
    ComponentType["MetricDistributionWidget"] = "MetricDistributionWidget";
    ComponentType["ImageSelectionWidget"] = "ImageSelectionWidget";
    ComponentType["ImageStackWidget"] = "ImageStackWidget";
    ComponentType["DetailedDistribution"] = "DetailedDistribution";
})(ComponentType = exports.ComponentType || (exports.ComponentType = {}));
var MetricDistributionSubComponentTypes;
(function (MetricDistributionSubComponentTypes) {
    MetricDistributionSubComponentTypes["BasisSelect"] = "BasisSelect";
    MetricDistributionSubComponentTypes["ScatterplotSelect"] = "ScatterplotSelect";
    MetricDistributionSubComponentTypes["DistributionPlot"] = "DistributionPlot";
    MetricDistributionSubComponentTypes["Scatterplot"] = "Scatterplot";
    MetricDistributionSubComponentTypes["Title"] = "Title";
})(MetricDistributionSubComponentTypes = exports.MetricDistributionSubComponentTypes || (exports.MetricDistributionSubComponentTypes = {}));
var MetricDistributionCollectionLevel;
(function (MetricDistributionCollectionLevel) {
    MetricDistributionCollectionLevel["Point"] = "Point";
    MetricDistributionCollectionLevel["Curve"] = "Curve";
})(MetricDistributionCollectionLevel = exports.MetricDistributionCollectionLevel || (exports.MetricDistributionCollectionLevel = {}));

},{}]},{},[117])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9jb2RlZ2VuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mZXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3BhdGgvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2QzLWFycmF5L2Rpc3QvZDMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvZDMtYXhpcy9kaXN0L2QzLWF4aXMuanMiLCJub2RlX21vZHVsZXMvZDMtYnJ1c2gvZGlzdC9kMy1icnVzaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1jaG9yZC9kaXN0L2QzLWNob3JkLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbGxlY3Rpb24vZGlzdC9kMy1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLWNvbG9yL2Rpc3QvZDMtY29sb3IuanMiLCJub2RlX21vZHVsZXMvZDMtY29udG91ci9kaXN0L2QzLWNvbnRvdXIuanMiLCJub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvZGlzdC9kMy1kaXNwYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kcmFnL2Rpc3QvZDMtZHJhZy5qcyIsIm5vZGVfbW9kdWxlcy9kMy1kc3YvZGlzdC9kMy1kc3YuanMiLCJub2RlX21vZHVsZXMvZDMtZWFzZS9kaXN0L2QzLWVhc2UuanMiLCJub2RlX21vZHVsZXMvZDMtZmV0Y2gvZGlzdC9kMy1mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1mb3JjZS9kaXN0L2QzLWZvcmNlLmpzIiwibm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9kaXN0L2QzLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy1nZW8vZGlzdC9kMy1nZW8uanMiLCJub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzIiwibm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL2Rpc3QvZDMtaW50ZXJwb2xhdGUuanMiLCJub2RlX21vZHVsZXMvZDMtcGF0aC9kaXN0L2QzLXBhdGguanMiLCJub2RlX21vZHVsZXMvZDMtcG9seWdvbi9kaXN0L2QzLXBvbHlnb24uanMiLCJub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvZGlzdC9kMy1xdWFkdHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy1yYW5kb20vZGlzdC9kMy1yYW5kb20uanMiLCJub2RlX21vZHVsZXMvZDMtc2NhbGUtY2hyb21hdGljL2Rpc3QvZDMtc2NhbGUtY2hyb21hdGljLmpzIiwibm9kZV9tb2R1bGVzL2QzLXNjYWxlL2Rpc3QvZDMtc2NhbGUuanMiLCJub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2Rpc3QvZDMtc2VsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXNoYXBlL2Rpc3QvZDMtc2hhcGUuanMiLCJub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvZGlzdC9kMy10aW1lLWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lL2Rpc3QvZDMtdGltZS5qcyIsIm5vZGVfbW9kdWxlcy9kMy10aW1lci9kaXN0L2QzLXRpbWVyLmpzIiwibm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vZGlzdC9kMy10cmFuc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2QzLXZvcm9ub2kvZGlzdC9kMy12b3Jvbm9pLmpzIiwibm9kZV9tb2R1bGVzL2QzLXpvb20vZGlzdC9kMy16b29tLmpzIiwibm9kZV9tb2R1bGVzL2QzL2Rpc3QvZDMubm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9pZGIvYnVpbGQvY2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lkYi9idWlsZC9janMvd3JhcC1pZGItdmFsdWUuanMiLCJub2RlX21vZHVsZXMvbnVtYmVyLXRvLXdvcmRzL251bWJlclRvV29yZHMubWluLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbnZlcnRlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW51bS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9maWVsZC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1saWdodC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21hcGZpZWxkLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21lc3NhZ2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL25hbWVzcGFjZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb25lb2YuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvc2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90b2tlbml6ZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JhcHBlcnMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QuanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcXVpY2tzZWxlY3QuanMvc3JjL3F1aWNrU2VsZWN0LmpzIiwic3RhdGljL3NjcmlwdC9zcmMvQXBwLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9CYXNlQ29tcG9uZW50LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9CYXNlV2lkZ2V0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9EZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvR3JvdXBCeVdpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvSGlzdG9ncmFtV2lkZ2V0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9JbWFnZVNlbGVjdGlvbldpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvSW1hZ2VTdGFja1dpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvSW1hZ2VUcmFja1dpZGdldC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9PcHRpb25TZWxlY3QudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL1Bsb3QyZFBhdGhzV2lkZ2V0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvQ29tcG9uZW50cy9SaWNoVG9vbHRpcC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0NvbXBvbmVudHMvU2NhdHRlclBsb3RXaWRnZXQudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9Db21wb25lbnRzL1Rvb2xiYXIudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvQ3VydmVDb2xsZWN0aW9uLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlQ29sbGVjdGlvbkl0ZXJhdG9yLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlSXRlcmF0b3IudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvQ3VydmVMaXN0LnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0N1cnZlTGlzdEZhY3RvcnkudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvQ3VydmVMaXN0SXRlcmF0b3IudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvQ3VydmVORC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9EYXRhRXZlbnRzLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0Rlcml2ZWRQb2ludFZhbHVlRnVuY3Rpb25zLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0Rlcml2ZWRUcmFja1ZhbHVlRnVuY3Rpb25zLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0ltYWdlRnJhbWUudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvSW1hZ2VMb2NhdGlvbi50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9JbWFnZU1ldGFEYXRhLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvRGF0YU1vZGVsL0ltYWdlU3RhY2tEYXRhUmVxdWVzdC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0RhdGFNb2RlbC9Qb2ludENvbGxlY3Rpb24udHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9EYXRhTW9kZWwvUG9pbnRORC50cyIsInN0YXRpYy9zY3JpcHQvc3JjL0xheW91dEZyYW1ld29yay50cyIsInN0YXRpYy9zY3JpcHQvc3JjL2RldmxpYi9EZXZsaWJBbGdvLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvZGV2bGliL0RldmxpYk1hdGgudHMiLCJzdGF0aWMvc2NyaXB0L3NyYy9kZXZsaWIvRGV2bGliVFNVdGlsLnRzIiwic3RhdGljL3NjcmlwdC9zcmMvbWFpbi50cyIsInN0YXRpYy9zY3JpcHQvc3JjL3R5cGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ptQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGpHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxd0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25hQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2gzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDditCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ254QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2tCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QyxLQUFLLEVBQUUsSUFBUyxFQUFFLEVBQUU7SUFFbkUsTUFBTSxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDMUIsR0FBRyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLE1BQU0sU0FBUyxHQUFXLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ3hELEdBQUcsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUM7Ozs7O0FDWkgsSUFBWSxTQUdYO0FBSEQsV0FBWSxTQUFTO0lBQ3BCLHdCQUFXLENBQUE7SUFDWCwyQkFBYyxDQUFBO0FBQ2YsQ0FBQyxFQUhXLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBR3BCO0FBT0QsSUFBWSxhQU9YO0FBUEQsV0FBWSxhQUFhO0lBQ3hCLG9DQUFtQixDQUFBO0lBQ25CLHdEQUF1QyxDQUFBO0lBQ3ZDLHNFQUFxRCxDQUFBO0lBQ3JELDhEQUE2QyxDQUFBO0lBQzdDLHNEQUFxQyxDQUFBO0lBQ3JDLDhEQUE2QyxDQUFBO0FBQzlDLENBQUMsRUFQVyxhQUFhLEdBQWIscUJBQWEsS0FBYixxQkFBYSxRQU94QjtBQU1ELElBQVksbUNBTVg7QUFORCxXQUFZLG1DQUFtQztJQUM5QyxrRUFBMkIsQ0FBQTtJQUMzQiw4RUFBdUMsQ0FBQTtJQUN2Qyw0RUFBcUMsQ0FBQTtJQUNyQyxrRUFBMkIsQ0FBQTtJQUMzQixzREFBZSxDQUFBO0FBQ2hCLENBQUMsRUFOVyxtQ0FBbUMsR0FBbkMsMkNBQW1DLEtBQW5DLDJDQUFtQyxRQU05QztBQUVELElBQVksaUNBR1g7QUFIRCxXQUFZLGlDQUFpQztJQUM1QyxvREFBZSxDQUFBO0lBQ2Ysb0RBQWUsQ0FBQTtBQUNoQixDQUFDLEVBSFcsaUNBQWlDLEdBQWpDLHlDQUFpQyxLQUFqQyx5Q0FBaUMsUUFHNUMiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGNvZGVnZW47XHJcblxyXG4vKipcclxuICogQmVnaW5zIGdlbmVyYXRpbmcgYSBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZnVuY3Rpb25QYXJhbXMgRnVuY3Rpb24gcGFyYW1ldGVyIG5hbWVzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZnVuY3Rpb25OYW1lXSBGdW5jdGlvbiBuYW1lIGlmIG5vdCBhbm9ueW1vdXNcclxuICogQHJldHVybnMge0NvZGVnZW59IEFwcGVuZGVyIHRoYXQgYXBwZW5kcyBjb2RlIHRvIHRoZSBmdW5jdGlvbidzIGJvZHlcclxuICovXHJcbmZ1bmN0aW9uIGNvZGVnZW4oZnVuY3Rpb25QYXJhbXMsIGZ1bmN0aW9uTmFtZSkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHR5cGVvZiBmdW5jdGlvblBhcmFtcyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uUGFyYW1zO1xyXG4gICAgICAgIGZ1bmN0aW9uUGFyYW1zID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBib2R5ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIGNvZGUgdG8gdGhlIGZ1bmN0aW9uJ3MgYm9keSBvciBmaW5pc2hlcyBnZW5lcmF0aW9uLlxyXG4gICAgICogQHR5cGVkZWYgQ29kZWdlblxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtmb3JtYXRTdHJpbmdPclNjb3BlXSBGb3JtYXQgc3RyaW5nIG9yLCB0byBmaW5pc2ggdGhlIGZ1bmN0aW9uLCBhbiBvYmplY3Qgb2YgYWRkaXRpb25hbCBzY29wZSB2YXJpYWJsZXMsIGlmIGFueVxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBbZm9ybWF0UGFyYW1zXSBGb3JtYXQgcGFyYW1ldGVyc1xyXG4gICAgICogQHJldHVybnMge0NvZGVnZW58RnVuY3Rpb259IEl0c2VsZiBvciB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlmIGZpbmlzaGVkXHJcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgZm9ybWF0IHBhcmFtZXRlciBjb3VudHMgZG8gbm90IG1hdGNoXHJcbiAgICAgKi9cclxuXHJcbiAgICBmdW5jdGlvbiBDb2RlZ2VuKGZvcm1hdFN0cmluZ09yU2NvcGUpIHtcclxuICAgICAgICAvLyBub3RlIHRoYXQgZXhwbGljaXQgYXJyYXkgaGFuZGxpbmcgYmVsb3cgbWFrZXMgdGhpcyB+NTAlIGZhc3RlclxyXG5cclxuICAgICAgICAvLyBmaW5pc2ggdGhlIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXRTdHJpbmdPclNjb3BlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoY29kZWdlbi52ZXJib3NlKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb2RlZ2VuOiBcIiArIHNvdXJjZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICBzb3VyY2UgPSBcInJldHVybiBcIiArIHNvdXJjZTtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdFN0cmluZ09yU2NvcGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY29wZUtleXMgICA9IE9iamVjdC5rZXlzKGZvcm1hdFN0cmluZ09yU2NvcGUpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlUGFyYW1zID0gbmV3IEFycmF5KHNjb3BlS2V5cy5sZW5ndGggKyAxKSxcclxuICAgICAgICAgICAgICAgICAgICBzY29wZVZhbHVlcyA9IG5ldyBBcnJheShzY29wZUtleXMubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICBzY29wZU9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2NvcGVPZmZzZXQgPCBzY29wZUtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVQYXJhbXNbc2NvcGVPZmZzZXRdID0gc2NvcGVLZXlzW3Njb3BlT2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZVZhbHVlc1tzY29wZU9mZnNldF0gPSBmb3JtYXRTdHJpbmdPclNjb3BlW3Njb3BlS2V5c1tzY29wZU9mZnNldCsrXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzY29wZVBhcmFtc1tzY29wZU9mZnNldF0gPSBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24uYXBwbHkobnVsbCwgc2NvcGVQYXJhbXMpLmFwcGx5KG51bGwsIHNjb3BlVmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihzb3VyY2UpKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBhcHBlbmQgdG8gYm9keVxyXG4gICAgICAgIHZhciBmb3JtYXRQYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICBmb3JtYXRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHdoaWxlIChmb3JtYXRPZmZzZXQgPCBmb3JtYXRQYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICBmb3JtYXRQYXJhbXNbZm9ybWF0T2Zmc2V0XSA9IGFyZ3VtZW50c1srK2Zvcm1hdE9mZnNldF07XHJcbiAgICAgICAgZm9ybWF0T2Zmc2V0ID0gMDtcclxuICAgICAgICBmb3JtYXRTdHJpbmdPclNjb3BlID0gZm9ybWF0U3RyaW5nT3JTY29wZS5yZXBsYWNlKC8lKFslZGZpanNdKS9nLCBmdW5jdGlvbiByZXBsYWNlKCQwLCAkMSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBmb3JtYXRQYXJhbXNbZm9ybWF0T2Zmc2V0KytdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKCQxKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZFwiOiBjYXNlIFwiZlwiOiByZXR1cm4gU3RyaW5nKE51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImlcIjogcmV0dXJuIFN0cmluZyhNYXRoLmZsb29yKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwialwiOiByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNcIjogcmV0dXJuIFN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiJVwiO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChmb3JtYXRPZmZzZXQgIT09IGZvcm1hdFBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwicGFyYW1ldGVyIGNvdW50IG1pc21hdGNoXCIpO1xyXG4gICAgICAgIGJvZHkucHVzaChmb3JtYXRTdHJpbmdPclNjb3BlKTtcclxuICAgICAgICByZXR1cm4gQ29kZWdlbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZyhmdW5jdGlvbk5hbWVPdmVycmlkZSkge1xyXG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uIFwiICsgKGZ1bmN0aW9uTmFtZU92ZXJyaWRlIHx8IGZ1bmN0aW9uTmFtZSB8fCBcIlwiKSArIFwiKFwiICsgKGZ1bmN0aW9uUGFyYW1zICYmIGZ1bmN0aW9uUGFyYW1zLmpvaW4oXCIsXCIpIHx8IFwiXCIpICsgXCIpe1xcbiAgXCIgKyBib2R5LmpvaW4oXCJcXG4gIFwiKSArIFwiXFxufVwiO1xyXG4gICAgfVxyXG5cclxuICAgIENvZGVnZW4udG9TdHJpbmcgPSB0b1N0cmluZztcclxuICAgIHJldHVybiBDb2RlZ2VuO1xyXG59XHJcblxyXG4vKipcclxuICogQmVnaW5zIGdlbmVyYXRpbmcgYSBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGZ1bmN0aW9uIGNvZGVnZW5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtmdW5jdGlvbk5hbWVdIEZ1bmN0aW9uIG5hbWUgaWYgbm90IGFub255bW91c1xyXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQXBwZW5kZXIgdGhhdCBhcHBlbmRzIGNvZGUgdG8gdGhlIGZ1bmN0aW9uJ3MgYm9keVxyXG4gKiBAdmFyaWF0aW9uIDJcclxuICovXHJcblxyXG4vKipcclxuICogV2hlbiBzZXQgdG8gYHRydWVgLCBjb2RlZ2VuIHdpbGwgbG9nIGdlbmVyYXRlZCBjb2RlIHRvIGNvbnNvbGUuIFVzZWZ1bCBmb3IgZGVidWdnaW5nLlxyXG4gKiBAbmFtZSB1dGlsLmNvZGVnZW4udmVyYm9zZVxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICovXHJcbmNvZGVnZW4udmVyYm9zZSA9IGZhbHNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gZmV0Y2g7XHJcblxyXG52YXIgYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKSxcclxuICAgIGlucXVpcmUgICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xyXG5cclxudmFyIGZzID0gaW5xdWlyZShcImZzXCIpO1xyXG5cclxuLyoqXHJcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5mZXRjaH0uXHJcbiAqIEB0eXBlZGVmIEZldGNoQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRlbnRzXSBGaWxlIGNvbnRlbnRzLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuZmV0Y2h9LlxyXG4gKiBAdHlwZWRlZiBGZXRjaE9wdGlvbnNcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbYmluYXJ5PWZhbHNlXSBXaGV0aGVyIGV4cGVjdGluZyBhIGJpbmFyeSByZXNwb25zZVxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt4aHI9ZmFsc2VdIElmIGB0cnVlYCwgZm9yY2VzIHRoZSB1c2Ugb2YgWE1MSHR0cFJlcXVlc3RcclxuICovXHJcblxyXG4vKipcclxuICogRmV0Y2hlcyB0aGUgY29udGVudHMgb2YgYSBmaWxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgRmlsZSBwYXRoIG9yIHVybFxyXG4gKiBAcGFyYW0ge0ZldGNoT3B0aW9uc30gb3B0aW9ucyBGZXRjaCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7RmV0Y2hDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcbmZ1bmN0aW9uIGZldGNoKGZpbGVuYW1lLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XHJcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgfSBlbHNlIGlmICghb3B0aW9ucylcclxuICAgICAgICBvcHRpb25zID0ge307XHJcblxyXG4gICAgaWYgKCFjYWxsYmFjaylcclxuICAgICAgICByZXR1cm4gYXNQcm9taXNlKGZldGNoLCB0aGlzLCBmaWxlbmFtZSwgb3B0aW9ucyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXHJcblxyXG4gICAgLy8gaWYgYSBub2RlLWxpa2UgZmlsZXN5c3RlbSBpcyBwcmVzZW50LCB0cnkgaXQgZmlyc3QgYnV0IGZhbGwgYmFjayB0byBYSFIgaWYgbm90aGluZyBpcyBmb3VuZC5cclxuICAgIGlmICghb3B0aW9ucy54aHIgJiYgZnMgJiYgZnMucmVhZEZpbGUpXHJcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCBmdW5jdGlvbiBmZXRjaFJlYWRGaWxlQ2FsbGJhY2soZXJyLCBjb250ZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyICYmIHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgPyBmZXRjaC54aHIoZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgICAgICAgOiBlcnJcclxuICAgICAgICAgICAgICAgID8gY2FsbGJhY2soZXJyKVxyXG4gICAgICAgICAgICAgICAgOiBjYWxsYmFjayhudWxsLCBvcHRpb25zLmJpbmFyeSA/IGNvbnRlbnRzIDogY29udGVudHMudG9TdHJpbmcoXCJ1dGY4XCIpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvLyB1c2UgdGhlIFhIUiB2ZXJzaW9uIG90aGVyd2lzZS5cclxuICAgIHJldHVybiBmZXRjaC54aHIoZmlsZW5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZldGNoZXMgdGhlIGNvbnRlbnRzIG9mIGEgZmlsZS5cclxuICogQG5hbWUgdXRpbC5mZXRjaFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggRmlsZSBwYXRoIG9yIHVybFxyXG4gKiBAcGFyYW0ge0ZldGNoQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEB2YXJpYXRpb24gMlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBGZXRjaGVzIHRoZSBjb250ZW50cyBvZiBhIGZpbGUuXHJcbiAqIEBuYW1lIHV0aWwuZmV0Y2hcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEZpbGUgcGF0aCBvciB1cmxcclxuICogQHBhcmFtIHtGZXRjaE9wdGlvbnN9IFtvcHRpb25zXSBGZXRjaCBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3xVaW50OEFycmF5Pn0gUHJvbWlzZVxyXG4gKiBAdmFyaWF0aW9uIDNcclxuICovXHJcblxyXG4vKiovXHJcbmZldGNoLnhociA9IGZ1bmN0aW9uIGZldGNoX3hocihmaWxlbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgLyogd29ya3MgZXZlcnl3aGVyZSAqLyA9IGZ1bmN0aW9uIGZldGNoT25SZWFkeVN0YXRlQ2hhbmdlKCkge1xyXG5cclxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpXHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIC8vIGxvY2FsIGNvcnMgc2VjdXJpdHkgZXJyb3JzIHJldHVybiBzdGF0dXMgMCAvIGVtcHR5IHN0cmluZywgdG9vLiBhZmFpayB0aGlzIGNhbm5vdCBiZVxyXG4gICAgICAgIC8vIHJlbGlhYmx5IGRpc3Rpbmd1aXNoZWQgZnJvbSBhbiBhY3R1YWxseSBlbXB0eSBmaWxlIGZvciBzZWN1cml0eSByZWFzb25zLiBmZWVsIGZyZWVcclxuICAgICAgICAvLyB0byBzZW5kIGEgcHVsbCByZXF1ZXN0IGlmIHlvdSBhcmUgYXdhcmUgb2YgYSBzb2x1dGlvbi5cclxuICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMCAmJiB4aHIuc3RhdHVzICE9PSAyMDApXHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvcihcInN0YXR1cyBcIiArIHhoci5zdGF0dXMpKTtcclxuXHJcbiAgICAgICAgLy8gaWYgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQsIG1ha2Ugc3VyZSB0aGF0IHNvbWUgc29ydCBvZiBhcnJheSBpcyByZXR1cm5lZCwgZXZlbiBpZlxyXG4gICAgICAgIC8vIEFycmF5QnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZC4gdGhlIGJpbmFyeSBzdHJpbmcgZmFsbGJhY2ssIGhvd2V2ZXIsIGlzIHVuc2FmZS5cclxuICAgICAgICBpZiAob3B0aW9ucy5iaW5hcnkpIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHhoci5yZXNwb25zZTtcclxuICAgICAgICAgICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKHhoci5yZXNwb25zZVRleHQuY2hhckNvZGVBdChpKSAmIDI1NSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSA6IGJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgIH07XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuYmluYXJ5KSB7XHJcbiAgICAgICAgLy8gcmVmOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvU2VuZGluZ19hbmRfUmVjZWl2aW5nX0JpbmFyeV9EYXRhI1JlY2VpdmluZ19iaW5hcnlfZGF0YV9pbl9vbGRlcl9icm93c2Vyc1xyXG4gICAgICAgIGlmIChcIm92ZXJyaWRlTWltZVR5cGVcIiBpbiB4aHIpXHJcbiAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiKTtcclxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgfVxyXG5cclxuICAgIHhoci5vcGVuKFwiR0VUXCIsIGZpbGVuYW1lKTtcclxuICAgIHhoci5zZW5kKCk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIG9ubHkgaWYgYXZhaWxhYmxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBNb2R1bGUgdG8gcmVxdWlyZVxyXG4gKiBAcmV0dXJucyB7P09iamVjdH0gUmVxdWlyZWQgbW9kdWxlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGVtcHR5LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBwYXRoIG1vZHVsZSB0byByZXNvbHZlIFVuaXgsIFdpbmRvd3MgYW5kIFVSTCBwYXRocyBhbGlrZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHBhdGggPSBleHBvcnRzO1xyXG5cclxudmFyIGlzQWJzb2x1dGUgPVxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBwYXRoIGlzIGFic29sdXRlLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBwYXRoIGlzIGFic29sdXRlXHJcbiAqL1xyXG5wYXRoLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcclxuICAgIHJldHVybiAvXig/OlxcL3xcXHcrOikvLnRlc3QocGF0aCk7XHJcbn07XHJcblxyXG52YXIgbm9ybWFsaXplID1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZXMgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBOb3JtYWxpemVkIHBhdGhcclxuICovXHJcbnBhdGgubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcclxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpXHJcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcclxuICAgIHZhciBwYXJ0cyAgICA9IHBhdGguc3BsaXQoXCIvXCIpLFxyXG4gICAgICAgIGFic29sdXRlID0gaXNBYnNvbHV0ZShwYXRoKSxcclxuICAgICAgICBwcmVmaXggICA9IFwiXCI7XHJcbiAgICBpZiAoYWJzb2x1dGUpXHJcbiAgICAgICAgcHJlZml4ID0gcGFydHMuc2hpZnQoKSArIFwiL1wiO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7KSB7XHJcbiAgICAgICAgaWYgKHBhcnRzW2ldID09PSBcIi4uXCIpIHtcclxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHBhcnRzW2kgLSAxXSAhPT0gXCIuLlwiKVxyXG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKC0taSwgMik7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFic29sdXRlKVxyXG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXSA9PT0gXCIuXCIpXHJcbiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICsraTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcmVmaXggKyBwYXJ0cy5qb2luKFwiL1wiKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlcyB0aGUgc3BlY2lmaWVkIGluY2x1ZGUgcGF0aCBhZ2FpbnN0IHRoZSBzcGVjaWZpZWQgb3JpZ2luIHBhdGguXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5QYXRoIFBhdGggdG8gdGhlIG9yaWdpbiBmaWxlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbmNsdWRlUGF0aCBJbmNsdWRlIHBhdGggcmVsYXRpdmUgdG8gb3JpZ2luIHBhdGhcclxuICogQHBhcmFtIHtib29sZWFufSBbYWxyZWFkeU5vcm1hbGl6ZWQ9ZmFsc2VdIGB0cnVlYCBpZiBib3RoIHBhdGhzIGFyZSBhbHJlYWR5IGtub3duIHRvIGJlIG5vcm1hbGl6ZWRcclxuICogQHJldHVybnMge3N0cmluZ30gUGF0aCB0byB0aGUgaW5jbHVkZSBmaWxlXHJcbiAqL1xyXG5wYXRoLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKG9yaWdpblBhdGgsIGluY2x1ZGVQYXRoLCBhbHJlYWR5Tm9ybWFsaXplZCkge1xyXG4gICAgaWYgKCFhbHJlYWR5Tm9ybWFsaXplZClcclxuICAgICAgICBpbmNsdWRlUGF0aCA9IG5vcm1hbGl6ZShpbmNsdWRlUGF0aCk7XHJcbiAgICBpZiAoaXNBYnNvbHV0ZShpbmNsdWRlUGF0aCkpXHJcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVQYXRoO1xyXG4gICAgaWYgKCFhbHJlYWR5Tm9ybWFsaXplZClcclxuICAgICAgICBvcmlnaW5QYXRoID0gbm9ybWFsaXplKG9yaWdpblBhdGgpO1xyXG4gICAgcmV0dXJuIChvcmlnaW5QYXRoID0gb3JpZ2luUGF0aC5yZXBsYWNlKC8oPzpcXC98XilbXi9dKyQvLCBcIlwiKSkubGVuZ3RoID8gbm9ybWFsaXplKG9yaWdpblBhdGggKyBcIi9cIiArIGluY2x1ZGVQYXRoKSA6IGluY2x1ZGVQYXRoO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgVVRGOCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0ZjggPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFVURjggYnl0ZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG51dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIGxlbiA9IDAsXHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOClcclxuICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXHJcbiAgICAgICAgICAgIGxlbiArPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhGQzAwKSA9PT0gMHhEODAwICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBsZW4gKz0gNDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgbGVuICs9IDM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIFVURjggYnl0ZXMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcclxuICovXHJcbnV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdLFxyXG4gICAgICAgIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgaWYgKHQgPCAxMjgpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcclxuICAgICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweEQ4MDAgKyAodCA+PiAxMCk7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweERDMDAgKyAodCAmIDEwMjMpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcgYXMgVVRGOCBieXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlcyB3cml0dGVuXHJcbiAqL1xyXG51dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgYzEsIC8vIGNoYXJhY3RlciAxXHJcbiAgICAgICAgYzI7IC8vIGNoYXJhY3RlciAyXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgICAgICB8IDE5MjtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgYzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNGRikgPDwgMTApICsgKGMyICYgMHgwM0ZGKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggICAgICB8IDI0MDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgICAgICB8IDIyNDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1hcnJheS8gdjEuMi40IENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IGEgPj0gYiA/IDAgOiBOYU47XG59XG5cbmZ1bmN0aW9uIGJpc2VjdG9yKGNvbXBhcmUpIHtcbiAgaWYgKGNvbXBhcmUubGVuZ3RoID09PSAxKSBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihjb21wYXJlKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvO1xuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDtcbiAgICAgICAgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIHgpIHtcbiAgICByZXR1cm4gYXNjZW5kaW5nKGYoZCksIHgpO1xuICB9O1xufVxuXG52YXIgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbnZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbnZhciBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5cbmZ1bmN0aW9uIHBhaXJzKGFycmF5LCBmKSB7XG4gIGlmIChmID09IG51bGwpIGYgPSBwYWlyO1xuICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIHBhaXJzW2ldID0gZihwLCBwID0gYXJyYXlbKytpXSk7XG4gIHJldHVybiBwYWlycztcbn1cblxuZnVuY3Rpb24gcGFpcihhLCBiKSB7XG4gIHJldHVybiBbYSwgYl07XG59XG5cbmZ1bmN0aW9uIGNyb3NzKHZhbHVlczAsIHZhbHVlczEsIHJlZHVjZSkge1xuICB2YXIgbjAgPSB2YWx1ZXMwLmxlbmd0aCxcbiAgICAgIG4xID0gdmFsdWVzMS5sZW5ndGgsXG4gICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobjAgKiBuMSksXG4gICAgICBpMCxcbiAgICAgIGkxLFxuICAgICAgaSxcbiAgICAgIHZhbHVlMDtcblxuICBpZiAocmVkdWNlID09IG51bGwpIHJlZHVjZSA9IHBhaXI7XG5cbiAgZm9yIChpMCA9IGkgPSAwOyBpMCA8IG4wOyArK2kwKSB7XG4gICAgZm9yICh2YWx1ZTAgPSB2YWx1ZXMwW2kwXSwgaTEgPSAwOyBpMSA8IG4xOyArK2kxLCArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHJlZHVjZSh2YWx1ZTAsIHZhbHVlczFbaTFdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufVxuXG5mdW5jdGlvbiB2YXJpYW5jZSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgbSA9IDAsXG4gICAgICBpID0gLTEsXG4gICAgICBtZWFuID0gMCxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVsdGEsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xuICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrbTtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkge1xuICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrbTtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG0gPiAxKSByZXR1cm4gc3VtIC8gKG0gLSAxKTtcbn1cblxuZnVuY3Rpb24gZGV2aWF0aW9uKGFycmF5LCBmKSB7XG4gIHZhciB2ID0gdmFyaWFuY2UoYXJyYXksIGYpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59XG5cbmZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW4sXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cblxudmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcbnZhciBtYXAgPSBhcnJheS5tYXA7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiByYW5nZShzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG5cbnZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZnVuY3Rpb24gdGlja3Moc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgc3RhcnQgPSBNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5mbG9vcihzdG9wIC8gc3RlcCk7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdG9wIC0gc3RhcnQgKyAxKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0ICsgaSkgKiBzdGVwO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAqIHN0ZXApO1xuICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAqIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RhcnQgLSBzdG9wICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCAtIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5mdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXApIC8gTWF0aC5MTjEwKSxcbiAgICAgIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlcik7XG4gIHJldHVybiBwb3dlciA+PSAwXG4gICAgICA/IChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpICogTWF0aC5wb3coMTAsIHBvd2VyKVxuICAgICAgOiAtTWF0aC5wb3coMTAsIC1wb3dlcikgLyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKTtcbn1cblxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xuICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG59XG5cbmZ1bmN0aW9uIHN0dXJnZXModmFsdWVzKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMikgKyAxO1xufVxuXG5mdW5jdGlvbiBoaXN0b2dyYW0oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgdGhyZXNob2xkID0gc3R1cmdlcztcblxuICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIHgsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciB4eiA9IGRvbWFpbih2YWx1ZXMpLFxuICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICB4MSA9IHh6WzFdLFxuICAgICAgICB0eiA9IHRocmVzaG9sZCh2YWx1ZXMsIHgwLCB4MSk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XG4gICAgICB0eiA9IHJhbmdlKE1hdGguY2VpbCh4MCAvIHR6KSAqIHR6LCB4MSwgdHopOyAvLyBleGNsdXNpdmVcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYW55IHRocmVzaG9sZHMgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIHZhciBtID0gdHoubGVuZ3RoO1xuICAgIHdoaWxlICh0elswXSA8PSB4MCkgdHouc2hpZnQoKSwgLS1tO1xuICAgIHdoaWxlICh0elttIC0gMV0gPiB4MSkgdHoucG9wKCksIC0tbTtcblxuICAgIHZhciBiaW5zID0gbmV3IEFycmF5KG0gKyAxKSxcbiAgICAgICAgYmluO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBiaW5zLlxuICAgIGZvciAoaSA9IDA7IGkgPD0gbTsgKytpKSB7XG4gICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICBiaW4ueDAgPSBpID4gMCA/IHR6W2kgLSAxXSA6IHgwO1xuICAgICAgYmluLngxID0gaSA8IG0gPyB0eltpXSA6IHgxO1xuICAgIH1cblxuICAgIC8vIEFzc2lnbiBkYXRhIHRvIGJpbnMgYnkgdmFsdWUsIGlnbm9yaW5nIGFueSBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgIGlmICh4MCA8PSB4ICYmIHggPD0geDEpIHtcbiAgICAgICAgYmluc1tiaXNlY3RSaWdodCh0eiwgeCwgMCwgbSldLnB1c2goZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbnM7XG4gIH1cblxuICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdmFsdWU7XG4gIH07XG5cbiAgaGlzdG9ncmFtLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtfWzBdLCBfWzFdXSksIGhpc3RvZ3JhbSkgOiBkb21haW47XG4gIH07XG5cbiAgaGlzdG9ncmFtLnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQoc2xpY2UuY2FsbChfKSkgOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHRocmVzaG9sZDtcbiAgfTtcblxuICByZXR1cm4gaGlzdG9ncmFtO1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZSh2YWx1ZXMsIHAsIHZhbHVlb2YpIHtcbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkgdmFsdWVvZiA9IG51bWJlcjtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn1cblxuZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMiAqIChxdWFudGlsZSh2YWx1ZXMsIDAuNzUpIC0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59XG5cbmZ1bmN0aW9uIHNjb3R0KHZhbHVlcywgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbn1cblxuZnVuY3Rpb24gbWF4KHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1heDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59XG5cbmZ1bmN0aW9uIG1lYW4odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSBuLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkgc3VtICs9IHZhbHVlO1xuICAgICAgZWxzZSAtLW07XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkgc3VtICs9IHZhbHVlO1xuICAgICAgZWxzZSAtLW07XG4gICAgfVxuICB9XG5cbiAgaWYgKG0pIHJldHVybiBzdW0gLyBtO1xufVxuXG5mdW5jdGlvbiBtZWRpYW4odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbnVtYmVycyA9IFtdO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVhbnRpbGUobnVtYmVycy5zb3J0KGFzY2VuZGluZyksIDAuNSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKGFycmF5cykge1xuICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICBtLFxuICAgICAgaSA9IC0xLFxuICAgICAgaiA9IDAsXG4gICAgICBtZXJnZWQsXG4gICAgICBhcnJheTtcblxuICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn1cblxuZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1pbjtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiBtaW4gPiB2YWx1ZSkge1xuICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIHBlcm11dGUoYXJyYXksIGluZGV4ZXMpIHtcbiAgdmFyIGkgPSBpbmRleGVzLmxlbmd0aCwgcGVybXV0ZXMgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHBlcm11dGVzW2ldID0gYXJyYXlbaW5kZXhlc1tpXV07XG4gIHJldHVybiBwZXJtdXRlcztcbn1cblxuZnVuY3Rpb24gc2Nhbih2YWx1ZXMsIGNvbXBhcmUpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIHhpLFxuICAgICAgeGogPSB2YWx1ZXNbal07XG5cbiAgaWYgKGNvbXBhcmUgPT0gbnVsbCkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGlmIChjb21wYXJlKHhpID0gdmFsdWVzW2ldLCB4aikgPCAwIHx8IGNvbXBhcmUoeGosIHhqKSAhPT0gMCkge1xuICAgICAgeGogPSB4aSwgaiA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG59XG5cbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXksIGkwLCBpMSkge1xuICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W20gKyBpMF07XG4gICAgYXJyYXlbbSArIGkwXSA9IGFycmF5W2kgKyBpMF07XG4gICAgYXJyYXlbaSArIGkwXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlc1tpXSkgc3VtICs9IHZhbHVlOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc3Bvc2U7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChkKSB7XG4gIHJldHVybiBkLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gemlwKCkge1xuICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydHMuYmlzZWN0ID0gYmlzZWN0UmlnaHQ7XG5leHBvcnRzLmJpc2VjdFJpZ2h0ID0gYmlzZWN0UmlnaHQ7XG5leHBvcnRzLmJpc2VjdExlZnQgPSBiaXNlY3RMZWZ0O1xuZXhwb3J0cy5hc2NlbmRpbmcgPSBhc2NlbmRpbmc7XG5leHBvcnRzLmJpc2VjdG9yID0gYmlzZWN0b3I7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nO1xuZXhwb3J0cy5kZXZpYXRpb24gPSBkZXZpYXRpb247XG5leHBvcnRzLmV4dGVudCA9IGV4dGVudDtcbmV4cG9ydHMuaGlzdG9ncmFtID0gaGlzdG9ncmFtO1xuZXhwb3J0cy50aHJlc2hvbGRGcmVlZG1hbkRpYWNvbmlzID0gZnJlZWRtYW5EaWFjb25pcztcbmV4cG9ydHMudGhyZXNob2xkU2NvdHQgPSBzY290dDtcbmV4cG9ydHMudGhyZXNob2xkU3R1cmdlcyA9IHN0dXJnZXM7XG5leHBvcnRzLm1heCA9IG1heDtcbmV4cG9ydHMubWVhbiA9IG1lYW47XG5leHBvcnRzLm1lZGlhbiA9IG1lZGlhbjtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5wYWlycyA9IHBhaXJzO1xuZXhwb3J0cy5wZXJtdXRlID0gcGVybXV0ZTtcbmV4cG9ydHMucXVhbnRpbGUgPSBxdWFudGlsZTtcbmV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbmV4cG9ydHMuc2NhbiA9IHNjYW47XG5leHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuZXhwb3J0cy5zdW0gPSBzdW07XG5leHBvcnRzLnRpY2tzID0gdGlja3M7XG5leHBvcnRzLnRpY2tJbmNyZW1lbnQgPSB0aWNrSW5jcmVtZW50O1xuZXhwb3J0cy50aWNrU3RlcCA9IHRpY2tTdGVwO1xuZXhwb3J0cy50cmFuc3Bvc2UgPSB0cmFuc3Bvc2U7XG5leHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG5leHBvcnRzLnppcCA9IHppcDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYXhpcy8gdjEuMC4xMiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuXG52YXIgdG9wID0gMSxcbiAgICByaWdodCA9IDIsXG4gICAgYm90dG9tID0gMyxcbiAgICBsZWZ0ID0gNCxcbiAgICBlcHNpbG9uID0gMWUtNjtcblxuZnVuY3Rpb24gdHJhbnNsYXRlWCh4KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZShcIiArICh4ICsgMC41KSArIFwiLDApXCI7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZVkoeSkge1xuICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArICh5ICsgMC41KSArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoc2NhbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gK3NjYWxlKGQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjZW50ZXIoc2NhbGUpIHtcbiAgdmFyIG9mZnNldCA9IE1hdGgubWF4KDAsIHNjYWxlLmJhbmR3aWR0aCgpIC0gMSkgLyAyOyAvLyBBZGp1c3QgZm9yIDAuNXB4IG9mZnNldC5cbiAgaWYgKHNjYWxlLnJvdW5kKCkpIG9mZnNldCA9IE1hdGgucm91bmQob2Zmc2V0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gK3NjYWxlKGQpICsgb2Zmc2V0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnRlcmluZygpIHtcbiAgcmV0dXJuICF0aGlzLl9fYXhpcztcbn1cblxuZnVuY3Rpb24gYXhpcyhvcmllbnQsIHNjYWxlKSB7XG4gIHZhciB0aWNrQXJndW1lbnRzID0gW10sXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXQgPSBudWxsLFxuICAgICAgdGlja1NpemVJbm5lciA9IDYsXG4gICAgICB0aWNrU2l6ZU91dGVyID0gNixcbiAgICAgIHRpY2tQYWRkaW5nID0gMyxcbiAgICAgIGsgPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGxlZnQgPyAtMSA6IDEsXG4gICAgICB4ID0gb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PT0gcmlnaHQgPyBcInhcIiA6IFwieVwiLFxuICAgICAgdHJhbnNmb3JtID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBib3R0b20gPyB0cmFuc2xhdGVYIDogdHJhbnNsYXRlWTtcblxuICBmdW5jdGlvbiBheGlzKGNvbnRleHQpIHtcbiAgICB2YXIgdmFsdWVzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpIDogdGlja1ZhbHVlcyxcbiAgICAgICAgZm9ybWF0ID0gdGlja0Zvcm1hdCA9PSBudWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IGlkZW50aXR5KSA6IHRpY2tGb3JtYXQsXG4gICAgICAgIHNwYWNpbmcgPSBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCAwKSArIHRpY2tQYWRkaW5nLFxuICAgICAgICByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgIHJhbmdlMCA9ICtyYW5nZVswXSArIDAuNSxcbiAgICAgICAgcmFuZ2UxID0gK3JhbmdlW3JhbmdlLmxlbmd0aCAtIDFdICsgMC41LFxuICAgICAgICBwb3NpdGlvbiA9IChzY2FsZS5iYW5kd2lkdGggPyBjZW50ZXIgOiBudW1iZXIpKHNjYWxlLmNvcHkoKSksXG4gICAgICAgIHNlbGVjdGlvbiA9IGNvbnRleHQuc2VsZWN0aW9uID8gY29udGV4dC5zZWxlY3Rpb24oKSA6IGNvbnRleHQsXG4gICAgICAgIHBhdGggPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFtudWxsXSksXG4gICAgICAgIHRpY2sgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh2YWx1ZXMsIHNjYWxlKS5vcmRlcigpLFxuICAgICAgICB0aWNrRXhpdCA9IHRpY2suZXhpdCgpLFxuICAgICAgICB0aWNrRW50ZXIgPSB0aWNrLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLFxuICAgICAgICBsaW5lID0gdGljay5zZWxlY3QoXCJsaW5lXCIpLFxuICAgICAgICB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpO1xuXG4gICAgcGF0aCA9IHBhdGgubWVyZ2UocGF0aC5lbnRlcigpLmluc2VydChcInBhdGhcIiwgXCIudGlja1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiY3VycmVudENvbG9yXCIpKTtcblxuICAgIHRpY2sgPSB0aWNrLm1lcmdlKHRpY2tFbnRlcik7XG5cbiAgICBsaW5lID0gbGluZS5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImN1cnJlbnRDb2xvclwiKVxuICAgICAgICAuYXR0cih4ICsgXCIyXCIsIGsgKiB0aWNrU2l6ZUlubmVyKSk7XG5cbiAgICB0ZXh0ID0gdGV4dC5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCJjdXJyZW50Q29sb3JcIilcbiAgICAgICAgLmF0dHIoeCwgayAqIHNwYWNpbmcpXG4gICAgICAgIC5hdHRyKFwiZHlcIiwgb3JpZW50ID09PSB0b3AgPyBcIjBlbVwiIDogb3JpZW50ID09PSBib3R0b20gPyBcIjAuNzFlbVwiIDogXCIwLjMyZW1cIikpO1xuXG4gICAgaWYgKGNvbnRleHQgIT09IHNlbGVjdGlvbikge1xuICAgICAgcGF0aCA9IHBhdGgudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIHRpY2sgPSB0aWNrLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICBsaW5lID0gbGluZS50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGV4dCA9IHRleHQudHJhbnNpdGlvbihjb250ZXh0KTtcblxuICAgICAgdGlja0V4aXQgPSB0aWNrRXhpdC50cmFuc2l0aW9uKGNvbnRleHQpXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGVwc2lsb24pXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gaXNGaW5pdGUoZCA9IHBvc2l0aW9uKGQpKSA/IHRyYW5zZm9ybShkKSA6IHRoaXMuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpOyB9KTtcblxuICAgICAgdGlja0VudGVyXG4gICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGVwc2lsb24pXG4gICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyB2YXIgcCA9IHRoaXMucGFyZW50Tm9kZS5fX2F4aXM7IHJldHVybiB0cmFuc2Zvcm0ocCAmJiBpc0Zpbml0ZShwID0gcChkKSkgPyBwIDogcG9zaXRpb24oZCkpOyB9KTtcbiAgICB9XG5cbiAgICB0aWNrRXhpdC5yZW1vdmUoKTtcblxuICAgIHBhdGhcbiAgICAgICAgLmF0dHIoXCJkXCIsIG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT0gcmlnaHRcbiAgICAgICAgICAgID8gKHRpY2tTaXplT3V0ZXIgPyBcIk1cIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCIsXCIgKyByYW5nZTAgKyBcIkgwLjVWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyIDogXCJNMC41LFwiICsgcmFuZ2UwICsgXCJWXCIgKyByYW5nZTEpXG4gICAgICAgICAgICA6ICh0aWNrU2l6ZU91dGVyID8gXCJNXCIgKyByYW5nZTAgKyBcIixcIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCJWMC41SFwiICsgcmFuZ2UxICsgXCJWXCIgKyBrICogdGlja1NpemVPdXRlciA6IFwiTVwiICsgcmFuZ2UwICsgXCIsMC41SFwiICsgcmFuZ2UxKSk7XG5cbiAgICB0aWNrXG4gICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCAxKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc2Zvcm0ocG9zaXRpb24oZCkpOyB9KTtcblxuICAgIGxpbmVcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcik7XG5cbiAgICB0ZXh0XG4gICAgICAgIC5hdHRyKHgsIGsgKiBzcGFjaW5nKVxuICAgICAgICAudGV4dChmb3JtYXQpO1xuXG4gICAgc2VsZWN0aW9uLmZpbHRlcihlbnRlcmluZylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcImZvbnQtc2l6ZVwiLCAxMClcbiAgICAgICAgLmF0dHIoXCJmb250LWZhbWlseVwiLCBcInNhbnMtc2VyaWZcIilcbiAgICAgICAgLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBvcmllbnQgPT09IHJpZ2h0ID8gXCJzdGFydFwiIDogb3JpZW50ID09PSBsZWZ0ID8gXCJlbmRcIiA6IFwibWlkZGxlXCIpO1xuXG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkgeyB0aGlzLl9fYXhpcyA9IHBvc2l0aW9uOyB9KTtcbiAgfVxuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGUgPSBfLCBheGlzKSA6IHNjYWxlO1xuICB9O1xuXG4gIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGlja0FyZ3VtZW50cyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tBcmd1bWVudHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0FyZ3VtZW50cyA9IF8gPT0gbnVsbCA/IFtdIDogc2xpY2UuY2FsbChfKSwgYXhpcykgOiB0aWNrQXJndW1lbnRzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tWYWx1ZXMgPSBfID09IG51bGwgPyBudWxsIDogc2xpY2UuY2FsbChfKSwgYXhpcykgOiB0aWNrVmFsdWVzICYmIHRpY2tWYWx1ZXMuc2xpY2UoKTtcbiAgfTtcblxuICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0Zvcm1hdCA9IF8sIGF4aXMpIDogdGlja0Zvcm1hdDtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSB0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVJbm5lcjtcbiAgfTtcblxuICBheGlzLnRpY2tTaXplSW5uZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1NpemVJbm5lciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZU91dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplT3V0ZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZU91dGVyO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1BhZGRpbmcgPSArXywgYXhpcykgOiB0aWNrUGFkZGluZztcbiAgfTtcblxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gYXhpc1RvcChzY2FsZSkge1xuICByZXR1cm4gYXhpcyh0b3AsIHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gYXhpc1JpZ2h0KHNjYWxlKSB7XG4gIHJldHVybiBheGlzKHJpZ2h0LCBzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNCb3R0b20oc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXMoYm90dG9tLCBzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNMZWZ0KHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGxlZnQsIHNjYWxlKTtcbn1cblxuZXhwb3J0cy5heGlzVG9wID0gYXhpc1RvcDtcbmV4cG9ydHMuYXhpc1JpZ2h0ID0gYXhpc1JpZ2h0O1xuZXhwb3J0cy5heGlzQm90dG9tID0gYXhpc0JvdHRvbTtcbmV4cG9ydHMuYXhpc0xlZnQgPSBheGlzTGVmdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYnJ1c2gvIHYxLjEuNSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLWRyYWcnKSwgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtc2VsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLXRyYW5zaXRpb24nKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1kaXNwYXRjaCcsICdkMy1kcmFnJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLXNlbGVjdGlvbicsICdkMy10cmFuc2l0aW9uJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30sIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0Rpc3BhdGNoLCBkM0RyYWcsIGQzSW50ZXJwb2xhdGUsIGQzU2VsZWN0aW9uLCBkM1RyYW5zaXRpb24pIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQnJ1c2hFdmVudCh0YXJnZXQsIHR5cGUsIHNlbGVjdGlvbikge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG5mdW5jdGlvbiBub2V2ZW50KCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxudmFyIE1PREVfRFJBRyA9IHtuYW1lOiBcImRyYWdcIn0sXG4gICAgTU9ERV9TUEFDRSA9IHtuYW1lOiBcInNwYWNlXCJ9LFxuICAgIE1PREVfSEFORExFID0ge25hbWU6IFwiaGFuZGxlXCJ9LFxuICAgIE1PREVfQ0VOVEVSID0ge25hbWU6IFwiY2VudGVyXCJ9O1xuXG5mdW5jdGlvbiBudW1iZXIxKGUpIHtcbiAgcmV0dXJuIFsrZVswXSwgK2VbMV1dO1xufVxuXG5mdW5jdGlvbiBudW1iZXIyKGUpIHtcbiAgcmV0dXJuIFtudW1iZXIxKGVbMF0pLCBudW1iZXIxKGVbMV0pXTtcbn1cblxuZnVuY3Rpb24gdG91Y2hlcihpZGVudGlmaWVyKSB7XG4gIHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICByZXR1cm4gZDNTZWxlY3Rpb24udG91Y2godGFyZ2V0LCBkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzLCBpZGVudGlmaWVyKTtcbiAgfTtcbn1cblxudmFyIFggPSB7XG4gIG5hbWU6IFwieFwiLFxuICBoYW5kbGVzOiBbXCJ3XCIsIFwiZVwiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih4LCBlKSB7IHJldHVybiB4ID09IG51bGwgPyBudWxsIDogW1sreFswXSwgZVswXVsxXV0sIFsreFsxXSwgZVsxXVsxXV1dOyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eSAmJiBbeHlbMF1bMF0sIHh5WzFdWzBdXTsgfVxufTtcblxudmFyIFkgPSB7XG4gIG5hbWU6IFwieVwiLFxuICBoYW5kbGVzOiBbXCJuXCIsIFwic1wiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih5LCBlKSB7IHJldHVybiB5ID09IG51bGwgPyBudWxsIDogW1tlWzBdWzBdLCAreVswXV0sIFtlWzFdWzBdLCAreVsxXV1dOyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eSAmJiBbeHlbMF1bMV0sIHh5WzFdWzFdXTsgfVxufTtcblxudmFyIFhZID0ge1xuICBuYW1lOiBcInh5XCIsXG4gIGhhbmRsZXM6IFtcIm5cIiwgXCJ3XCIsIFwiZVwiLCBcInNcIiwgXCJud1wiLCBcIm5lXCIsIFwic3dcIiwgXCJzZVwiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHkgPT0gbnVsbCA/IG51bGwgOiBudW1iZXIyKHh5KTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHk7IH1cbn07XG5cbnZhciBjdXJzb3JzID0ge1xuICBvdmVybGF5OiBcImNyb3NzaGFpclwiLFxuICBzZWxlY3Rpb246IFwibW92ZVwiLFxuICBuOiBcIm5zLXJlc2l6ZVwiLFxuICBlOiBcImV3LXJlc2l6ZVwiLFxuICBzOiBcIm5zLXJlc2l6ZVwiLFxuICB3OiBcImV3LXJlc2l6ZVwiLFxuICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxuICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICBzdzogXCJuZXN3LXJlc2l6ZVwiXG59O1xuXG52YXIgZmxpcFggPSB7XG4gIGU6IFwid1wiLFxuICB3OiBcImVcIixcbiAgbnc6IFwibmVcIixcbiAgbmU6IFwibndcIixcbiAgc2U6IFwic3dcIixcbiAgc3c6IFwic2VcIlxufTtcblxudmFyIGZsaXBZID0ge1xuICBuOiBcInNcIixcbiAgczogXCJuXCIsXG4gIG53OiBcInN3XCIsXG4gIG5lOiBcInNlXCIsXG4gIHNlOiBcIm5lXCIsXG4gIHN3OiBcIm53XCJcbn07XG5cbnZhciBzaWduc1ggPSB7XG4gIG92ZXJsYXk6ICsxLFxuICBzZWxlY3Rpb246ICsxLFxuICBuOiBudWxsLFxuICBlOiArMSxcbiAgczogbnVsbCxcbiAgdzogLTEsXG4gIG53OiAtMSxcbiAgbmU6ICsxLFxuICBzZTogKzEsXG4gIHN3OiAtMVxufTtcblxudmFyIHNpZ25zWSA9IHtcbiAgb3ZlcmxheTogKzEsXG4gIHNlbGVjdGlvbjogKzEsXG4gIG46IC0xLFxuICBlOiBudWxsLFxuICBzOiArMSxcbiAgdzogbnVsbCxcbiAgbnc6IC0xLFxuICBuZTogLTEsXG4gIHNlOiArMSxcbiAgc3c6ICsxXG59O1xuXG5mdW5jdGlvbiB0eXBlKHQpIHtcbiAgcmV0dXJuIHt0eXBlOiB0fTtcbn1cblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWQzU2VsZWN0aW9uLmV2ZW50LmN0cmxLZXkgJiYgIWQzU2VsZWN0aW9uLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIHN2ZyA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7XG4gIGlmIChzdmcuaGFzQXR0cmlidXRlKFwidmlld0JveFwiKSkge1xuICAgIHN2ZyA9IHN2Zy52aWV3Qm94LmJhc2VWYWw7XG4gICAgcmV0dXJuIFtbc3ZnLngsIHN2Zy55XSwgW3N2Zy54ICsgc3ZnLndpZHRoLCBzdmcueSArIHN2Zy5oZWlnaHRdXTtcbiAgfVxuICByZXR1cm4gW1swLCAwXSwgW3N2Zy53aWR0aC5iYXNlVmFsLnZhbHVlLCBzdmcuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuLy8gTGlrZSBkMy5sb2NhbCwgYnV0IHdpdGggdGhlIG5hbWUg4oCcX19icnVzaOKAnSByYXRoZXIgdGhhbiBhdXRvLWdlbmVyYXRlZC5cbmZ1bmN0aW9uIGxvY2FsKG5vZGUpIHtcbiAgd2hpbGUgKCFub2RlLl9fYnJ1c2gpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gIHJldHVybiBub2RlLl9fYnJ1c2g7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzBdWzBdID09PSBleHRlbnRbMV1bMF1cbiAgICAgIHx8IGV4dGVudFswXVsxXSA9PT0gZXh0ZW50WzFdWzFdO1xufVxuXG5mdW5jdGlvbiBicnVzaFNlbGVjdGlvbihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX19icnVzaDtcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUuZGltLm91dHB1dChzdGF0ZS5zZWxlY3Rpb24pIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYnJ1c2hYKCkge1xuICByZXR1cm4gYnJ1c2gkMShYKTtcbn1cblxuZnVuY3Rpb24gYnJ1c2hZKCkge1xuICByZXR1cm4gYnJ1c2gkMShZKTtcbn1cblxuZnVuY3Rpb24gYnJ1c2goKSB7XG4gIHJldHVybiBicnVzaCQxKFhZKTtcbn1cblxuZnVuY3Rpb24gYnJ1c2gkMShkaW0pIHtcbiAgdmFyIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIGtleXMgPSB0cnVlLFxuICAgICAgbGlzdGVuZXJzID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJlbmRcIiksXG4gICAgICBoYW5kbGVTaXplID0gNixcbiAgICAgIHRvdWNoZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGJydXNoKGdyb3VwKSB7XG4gICAgdmFyIG92ZXJsYXkgPSBncm91cFxuICAgICAgICAucHJvcGVydHkoXCJfX2JydXNoXCIsIGluaXRpYWxpemUpXG4gICAgICAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcbiAgICAgIC5kYXRhKFt0eXBlKFwib3ZlcmxheVwiKV0pO1xuXG4gICAgb3ZlcmxheS5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm92ZXJsYXlcIilcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzLm92ZXJsYXkpXG4gICAgICAubWVyZ2Uob3ZlcmxheSlcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGxvY2FsKHRoaXMpLmV4dGVudDtcbiAgICAgICAgICBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGV4dGVudFswXVswXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGV4dGVudFswXVsxXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0pXG4gICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH0pO1xuXG4gICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKVxuICAgICAgLmRhdGEoW3R5cGUoXCJzZWxlY3Rpb25cIildKVxuICAgICAgLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2VsZWN0aW9uXCIpXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjNzc3XCIpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDAuMylcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjZmZmXCIpXG4gICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwiY3Jpc3BFZGdlc1wiKTtcblxuICAgIHZhciBoYW5kbGUgPSBncm91cC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpXG4gICAgICAuZGF0YShkaW0uaGFuZGxlcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlOyB9KTtcblxuICAgIGhhbmRsZS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBoYW5kbGUuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJoYW5kbGUgaGFuZGxlLS1cIiArIGQudHlwZTsgfSlcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY3Vyc29yc1tkLnR5cGVdOyB9KTtcblxuICAgIGdyb3VwXG4gICAgICAgIC5lYWNoKHJlZHJhdylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi5icnVzaFwiLCBzdGFydGVkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuYnJ1c2hcIiwgc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLmJydXNoIHRvdWNoY2FuY2VsLmJydXNoXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGJydXNoLm1vdmUgPSBmdW5jdGlvbihncm91cCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKGdyb3VwLnNlbGVjdGlvbikge1xuICAgICAgZ3JvdXBcbiAgICAgICAgICAub24oXCJzdGFydC5icnVzaFwiLCBmdW5jdGlvbigpIHsgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCkuc3RhcnQoKTsgfSlcbiAgICAgICAgICAub24oXCJpbnRlcnJ1cHQuYnJ1c2ggZW5kLmJydXNoXCIsIGZ1bmN0aW9uKCkgeyBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykuZW5kKCk7IH0pXG4gICAgICAgICAgLnR3ZWVuKFwiYnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGF0Ll9fYnJ1c2gsXG4gICAgICAgICAgICAgICAgZW1pdCA9IGVtaXR0ZXIodGhhdCwgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24wID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjEgPSBkaW0uaW5wdXQodHlwZW9mIHNlbGVjdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzZWxlY3Rpb24sIHN0YXRlLmV4dGVudCksXG4gICAgICAgICAgICAgICAgaSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGUoc2VsZWN0aW9uMCwgc2VsZWN0aW9uMSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHR3ZWVuKHQpIHtcbiAgICAgICAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gdCA9PT0gMSAmJiBzZWxlY3Rpb24xID09PSBudWxsID8gbnVsbCA6IGkodCk7XG4gICAgICAgICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgICBlbWl0LmJydXNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24wICE9PSBudWxsICYmIHNlbGVjdGlvbjEgIT09IG51bGwgPyB0d2VlbiA6IHR3ZWVuKDEpO1xuICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cFxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGF0Ll9fYnJ1c2gsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMSA9IGRpbS5pbnB1dCh0eXBlb2Ygc2VsZWN0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3Rpb24uYXBwbHkodGhhdCwgYXJncykgOiBzZWxlY3Rpb24sIHN0YXRlLmV4dGVudCksXG4gICAgICAgICAgICAgICAgZW1pdCA9IGVtaXR0ZXIodGhhdCwgYXJncykuYmVmb3Jlc3RhcnQoKTtcblxuICAgICAgICAgICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGF0KTtcbiAgICAgICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjEgPT09IG51bGwgPyBudWxsIDogc2VsZWN0aW9uMTtcbiAgICAgICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgZW1pdC5zdGFydCgpLmJydXNoKCkuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGJydXNoLmNsZWFyID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICBicnVzaC5tb3ZlKGdyb3VwLCBudWxsKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWRyYXcoKSB7XG4gICAgdmFyIGdyb3VwID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLFxuICAgICAgICBzZWxlY3Rpb24gPSBsb2NhbCh0aGlzKS5zZWxlY3Rpb247XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBncm91cC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwieFwiLCBzZWxlY3Rpb25bMF1bMF0pXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIHNlbGVjdGlvblswXVsxXSlcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIHNlbGVjdGlvblsxXVswXSAtIHNlbGVjdGlvblswXVswXSlcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBzZWxlY3Rpb25bMV1bMV0gLSBzZWxlY3Rpb25bMF1bMV0pO1xuXG4gICAgICBncm91cC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGVbZC50eXBlLmxlbmd0aCAtIDFdID09PSBcImVcIiA/IHNlbGVjdGlvblsxXVswXSAtIGhhbmRsZVNpemUgLyAyIDogc2VsZWN0aW9uWzBdWzBdIC0gaGFuZGxlU2l6ZSAvIDI7IH0pXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZVswXSA9PT0gXCJzXCIgPyBzZWxlY3Rpb25bMV1bMV0gLSBoYW5kbGVTaXplIC8gMiA6IHNlbGVjdGlvblswXVsxXSAtIGhhbmRsZVNpemUgLyAyOyB9KVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlID09PSBcIm5cIiB8fCBkLnR5cGUgPT09IFwic1wiID8gc2VsZWN0aW9uWzFdWzBdIC0gc2VsZWN0aW9uWzBdWzBdICsgaGFuZGxlU2l6ZSA6IGhhbmRsZVNpemU7IH0pXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlID09PSBcImVcIiB8fCBkLnR5cGUgPT09IFwid1wiID8gc2VsZWN0aW9uWzFdWzFdIC0gc2VsZWN0aW9uWzBdWzFdICsgaGFuZGxlU2l6ZSA6IGhhbmRsZVNpemU7IH0pO1xuICAgIH1cblxuICAgIGVsc2Uge1xuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvbiwuaGFuZGxlXCIpXG4gICAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgICAuYXR0cihcInhcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcInlcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdHRlcih0aGF0LCBhcmdzLCBjbGVhbikge1xuICAgIHJldHVybiAoIWNsZWFuICYmIHRoYXQuX19icnVzaC5lbWl0dGVyKSB8fCBuZXcgRW1pdHRlcih0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnN0YXRlID0gdGhhdC5fX2JydXNoO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgfVxuXG4gIEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgIGJlZm9yZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB0aGlzLnN0YXRlLmVtaXR0ZXIgPSB0aGlzLCB0aGlzLnN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc3RhcnRpbmcpIHRoaXMuc3RhcnRpbmcgPSBmYWxzZSwgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICBlbHNlIHRoaXMuZW1pdChcImJydXNoXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBicnVzaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoXCJicnVzaFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSBkZWxldGUgdGhpcy5zdGF0ZS5lbWl0dGVyLCB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGQzU2VsZWN0aW9uLmN1c3RvbUV2ZW50KG5ldyBCcnVzaEV2ZW50KGJydXNoLCB0eXBlLCBkaW0ub3V0cHV0KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSksIGxpc3RlbmVycy5hcHBseSwgbGlzdGVuZXJzLCBbdHlwZSwgdGhpcy50aGF0LCB0aGlzLmFyZ3NdKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc3RhcnRlZCgpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgJiYgIWQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMpIHJldHVybjtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG5cbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSBkM1NlbGVjdGlvbi5ldmVudC50YXJnZXQuX19kYXRhX18udHlwZSxcbiAgICAgICAgbW9kZSA9IChrZXlzICYmIGQzU2VsZWN0aW9uLmV2ZW50Lm1ldGFLZXkgPyB0eXBlID0gXCJvdmVybGF5XCIgOiB0eXBlKSA9PT0gXCJzZWxlY3Rpb25cIiA/IE1PREVfRFJBRyA6IChrZXlzICYmIGQzU2VsZWN0aW9uLmV2ZW50LmFsdEtleSA/IE1PREVfQ0VOVEVSIDogTU9ERV9IQU5ETEUpLFxuICAgICAgICBzaWduWCA9IGRpbSA9PT0gWSA/IG51bGwgOiBzaWduc1hbdHlwZV0sXG4gICAgICAgIHNpZ25ZID0gZGltID09PSBYID8gbnVsbCA6IHNpZ25zWVt0eXBlXSxcbiAgICAgICAgc3RhdGUgPSBsb2NhbCh0aGF0KSxcbiAgICAgICAgZXh0ZW50ID0gc3RhdGUuZXh0ZW50LFxuICAgICAgICBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgIFcgPSBleHRlbnRbMF1bMF0sIHcwLCB3MSxcbiAgICAgICAgTiA9IGV4dGVudFswXVsxXSwgbjAsIG4xLFxuICAgICAgICBFID0gZXh0ZW50WzFdWzBdLCBlMCwgZTEsXG4gICAgICAgIFMgPSBleHRlbnRbMV1bMV0sIHMwLCBzMSxcbiAgICAgICAgZHggPSAwLFxuICAgICAgICBkeSA9IDAsXG4gICAgICAgIG1vdmluZyxcbiAgICAgICAgc2hpZnRpbmcgPSBzaWduWCAmJiBzaWduWSAmJiBrZXlzICYmIGQzU2VsZWN0aW9uLmV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICBsb2NrWCxcbiAgICAgICAgbG9ja1ksXG4gICAgICAgIHBvaW50ZXIgPSBkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzID8gdG91Y2hlcihkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5pZGVudGlmaWVyKSA6IGQzU2VsZWN0aW9uLm1vdXNlLFxuICAgICAgICBwb2ludDAgPSBwb2ludGVyKHRoYXQpLFxuICAgICAgICBwb2ludCA9IHBvaW50MCxcbiAgICAgICAgZW1pdCA9IGVtaXR0ZXIodGhhdCwgYXJndW1lbnRzLCB0cnVlKS5iZWZvcmVzdGFydCgpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwib3ZlcmxheVwiKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uKSBtb3ZpbmcgPSB0cnVlO1xuICAgICAgc3RhdGUuc2VsZWN0aW9uID0gc2VsZWN0aW9uID0gW1xuICAgICAgICBbdzAgPSBkaW0gPT09IFkgPyBXIDogcG9pbnQwWzBdLCBuMCA9IGRpbSA9PT0gWCA/IE4gOiBwb2ludDBbMV1dLFxuICAgICAgICBbZTAgPSBkaW0gPT09IFkgPyBFIDogdzAsIHMwID0gZGltID09PSBYID8gUyA6IG4wXVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdzAgPSBzZWxlY3Rpb25bMF1bMF07XG4gICAgICBuMCA9IHNlbGVjdGlvblswXVsxXTtcbiAgICAgIGUwID0gc2VsZWN0aW9uWzFdWzBdO1xuICAgICAgczAgPSBzZWxlY3Rpb25bMV1bMV07XG4gICAgfVxuXG4gICAgdzEgPSB3MDtcbiAgICBuMSA9IG4wO1xuICAgIGUxID0gZTA7XG4gICAgczEgPSBzMDtcblxuICAgIHZhciBncm91cCA9IGQzU2VsZWN0aW9uLnNlbGVjdCh0aGF0KVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblxuICAgIHZhciBvdmVybGF5ID0gZ3JvdXAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlXSk7XG5cbiAgICBpZiAoZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcykge1xuICAgICAgZW1pdC5tb3ZlZCA9IG1vdmVkO1xuICAgICAgZW1pdC5lbmRlZCA9IGVuZGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KVxuICAgICAgICAgIC5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBtb3ZlZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJtb3VzZXVwLmJydXNoXCIsIGVuZGVkLCB0cnVlKTtcbiAgICAgIGlmIChrZXlzKSB2aWV3XG4gICAgICAgICAgLm9uKFwia2V5ZG93bi5icnVzaFwiLCBrZXlkb3duZWQsIHRydWUpXG4gICAgICAgICAgLm9uKFwia2V5dXAuYnJ1c2hcIiwga2V5dXBwZWQsIHRydWUpO1xuXG4gICAgICBkM0RyYWcuZHJhZ0Rpc2FibGUoZDNTZWxlY3Rpb24uZXZlbnQudmlldyk7XG4gICAgfVxuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhhdCk7XG4gICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgZW1pdC5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICB2YXIgcG9pbnQxID0gcG9pbnRlcih0aGF0KTtcbiAgICAgIGlmIChzaGlmdGluZyAmJiAhbG9ja1ggJiYgIWxvY2tZKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhwb2ludDFbMF0gLSBwb2ludFswXSkgPiBNYXRoLmFicyhwb2ludDFbMV0gLSBwb2ludFsxXSkpIGxvY2tZID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBsb2NrWCA9IHRydWU7XG4gICAgICB9XG4gICAgICBwb2ludCA9IHBvaW50MTtcbiAgICAgIG1vdmluZyA9IHRydWU7XG4gICAgICBub2V2ZW50KCk7XG4gICAgICBtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZSgpIHtcbiAgICAgIHZhciB0O1xuXG4gICAgICBkeCA9IHBvaW50WzBdIC0gcG9pbnQwWzBdO1xuICAgICAgZHkgPSBwb2ludFsxXSAtIHBvaW50MFsxXTtcblxuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgTU9ERV9TUEFDRTpcbiAgICAgICAgY2FzZSBNT0RFX0RSQUc6IHtcbiAgICAgICAgICBpZiAoc2lnblgpIGR4ID0gTWF0aC5tYXgoVyAtIHcwLCBNYXRoLm1pbihFIC0gZTAsIGR4KSksIHcxID0gdzAgKyBkeCwgZTEgPSBlMCArIGR4O1xuICAgICAgICAgIGlmIChzaWduWSkgZHkgPSBNYXRoLm1heChOIC0gbjAsIE1hdGgubWluKFMgLSBzMCwgZHkpKSwgbjEgPSBuMCArIGR5LCBzMSA9IHMwICsgZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNT0RFX0hBTkRMRToge1xuICAgICAgICAgIGlmIChzaWduWCA8IDApIGR4ID0gTWF0aC5tYXgoVyAtIHcwLCBNYXRoLm1pbihFIC0gdzAsIGR4KSksIHcxID0gdzAgKyBkeCwgZTEgPSBlMDtcbiAgICAgICAgICBlbHNlIGlmIChzaWduWCA+IDApIGR4ID0gTWF0aC5tYXgoVyAtIGUwLCBNYXRoLm1pbihFIC0gZTAsIGR4KSksIHcxID0gdzAsIGUxID0gZTAgKyBkeDtcbiAgICAgICAgICBpZiAoc2lnblkgPCAwKSBkeSA9IE1hdGgubWF4KE4gLSBuMCwgTWF0aC5taW4oUyAtIG4wLCBkeSkpLCBuMSA9IG4wICsgZHksIHMxID0gczA7XG4gICAgICAgICAgZWxzZSBpZiAoc2lnblkgPiAwKSBkeSA9IE1hdGgubWF4KE4gLSBzMCwgTWF0aC5taW4oUyAtIHMwLCBkeSkpLCBuMSA9IG4wLCBzMSA9IHMwICsgZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNT0RFX0NFTlRFUjoge1xuICAgICAgICAgIGlmIChzaWduWCkgdzEgPSBNYXRoLm1heChXLCBNYXRoLm1pbihFLCB3MCAtIGR4ICogc2lnblgpKSwgZTEgPSBNYXRoLm1heChXLCBNYXRoLm1pbihFLCBlMCArIGR4ICogc2lnblgpKTtcbiAgICAgICAgICBpZiAoc2lnblkpIG4xID0gTWF0aC5tYXgoTiwgTWF0aC5taW4oUywgbjAgLSBkeSAqIHNpZ25ZKSksIHMxID0gTWF0aC5tYXgoTiwgTWF0aC5taW4oUywgczAgKyBkeSAqIHNpZ25ZKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUxIDwgdzEpIHtcbiAgICAgICAgc2lnblggKj0gLTE7XG4gICAgICAgIHQgPSB3MCwgdzAgPSBlMCwgZTAgPSB0O1xuICAgICAgICB0ID0gdzEsIHcxID0gZTEsIGUxID0gdDtcbiAgICAgICAgaWYgKHR5cGUgaW4gZmxpcFgpIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGUgPSBmbGlwWFt0eXBlXV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoczEgPCBuMSkge1xuICAgICAgICBzaWduWSAqPSAtMTtcbiAgICAgICAgdCA9IG4wLCBuMCA9IHMwLCBzMCA9IHQ7XG4gICAgICAgIHQgPSBuMSwgbjEgPSBzMSwgczEgPSB0O1xuICAgICAgICBpZiAodHlwZSBpbiBmbGlwWSkgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZSA9IGZsaXBZW3R5cGVdXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24pIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjsgLy8gTWF5IGJlIHNldCBieSBicnVzaC5tb3ZlIVxuICAgICAgaWYgKGxvY2tYKSB3MSA9IHNlbGVjdGlvblswXVswXSwgZTEgPSBzZWxlY3Rpb25bMV1bMF07XG4gICAgICBpZiAobG9ja1kpIG4xID0gc2VsZWN0aW9uWzBdWzFdLCBzMSA9IHNlbGVjdGlvblsxXVsxXTtcblxuICAgICAgaWYgKHNlbGVjdGlvblswXVswXSAhPT0gdzFcbiAgICAgICAgICB8fCBzZWxlY3Rpb25bMF1bMV0gIT09IG4xXG4gICAgICAgICAgfHwgc2VsZWN0aW9uWzFdWzBdICE9PSBlMVxuICAgICAgICAgIHx8IHNlbGVjdGlvblsxXVsxXSAhPT0gczEpIHtcbiAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gW1t3MSwgbjFdLCBbZTEsIHMxXV07XG4gICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICBlbWl0LmJydXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgICAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgNTAwKTsgLy8gR2hvc3QgY2xpY2tzIGFyZSBkZWxheWVkIVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZDNEcmFnLmRyYWdFbmFibGUoZDNTZWxlY3Rpb24uZXZlbnQudmlldywgbW92aW5nKTtcbiAgICAgICAgdmlldy5vbihcImtleWRvd24uYnJ1c2gga2V5dXAuYnJ1c2ggbW91c2Vtb3ZlLmJydXNoIG1vdXNldXAuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBncm91cC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5vdmVybGF5KTtcbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24pIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjsgLy8gTWF5IGJlIHNldCBieSBicnVzaC5tb3ZlIChvbiBzdGFydCkhXG4gICAgICBpZiAoZW1wdHkoc2VsZWN0aW9uKSkgc3RhdGUuc2VsZWN0aW9uID0gbnVsbCwgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICBlbWl0LmVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleWRvd25lZCgpIHtcbiAgICAgIHN3aXRjaCAoZDNTZWxlY3Rpb24uZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDE2OiB7IC8vIFNISUZUXG4gICAgICAgICAgc2hpZnRpbmcgPSBzaWduWCAmJiBzaWduWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE4OiB7IC8vIEFMVFxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0hBTkRMRSkge1xuICAgICAgICAgICAgaWYgKHNpZ25YKSBlMCA9IGUxIC0gZHggKiBzaWduWCwgdzAgPSB3MSArIGR4ICogc2lnblg7XG4gICAgICAgICAgICBpZiAoc2lnblkpIHMwID0gczEgLSBkeSAqIHNpZ25ZLCBuMCA9IG4xICsgZHkgKiBzaWduWTtcbiAgICAgICAgICAgIG1vZGUgPSBNT0RFX0NFTlRFUjtcbiAgICAgICAgICAgIG1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzMjogeyAvLyBTUEFDRTsgdGFrZXMgcHJpb3JpdHkgb3ZlciBBTFRcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9IQU5ETEUgfHwgbW9kZSA9PT0gTU9ERV9DRU5URVIpIHtcbiAgICAgICAgICAgIGlmIChzaWduWCA8IDApIGUwID0gZTEgLSBkeDsgZWxzZSBpZiAoc2lnblggPiAwKSB3MCA9IHcxIC0gZHg7XG4gICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxIC0gZHk7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMSAtIGR5O1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfU1BBQ0U7XG4gICAgICAgICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICB9XG4gICAgICBub2V2ZW50KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga2V5dXBwZWQoKSB7XG4gICAgICBzd2l0Y2ggKGQzU2VsZWN0aW9uLmV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxuICAgICAgICAgIGlmIChzaGlmdGluZykge1xuICAgICAgICAgICAgbG9ja1ggPSBsb2NrWSA9IHNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTg6IHsgLy8gQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfQ0VOVEVSKSB7XG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XG4gICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxOyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjE7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9IQU5ETEU7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzI6IHsgLy8gU1BBQ0VcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9TUEFDRSkge1xuICAgICAgICAgICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICBpZiAoc2lnblgpIGUwID0gZTEgLSBkeCAqIHNpZ25YLCB3MCA9IHcxICsgZHggKiBzaWduWDtcbiAgICAgICAgICAgICAgaWYgKHNpZ25ZKSBzMCA9IHMxIC0gZHkgKiBzaWduWSwgbjAgPSBuMSArIGR5ICogc2lnblk7XG4gICAgICAgICAgICAgIG1vZGUgPSBNT0RFX0NFTlRFUjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChzaWduWCA8IDApIGUwID0gZTE7IGVsc2UgaWYgKHNpZ25YID4gMCkgdzAgPSB3MTtcbiAgICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xO1xuICAgICAgICAgICAgICBtb2RlID0gTU9ERV9IQU5ETEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlXSk7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIGVtaXR0ZXIodGhpcywgYXJndW1lbnRzKS5tb3ZlZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykuZW5kZWQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fX2JydXNoIHx8IHtzZWxlY3Rpb246IG51bGx9O1xuICAgIHN0YXRlLmV4dGVudCA9IG51bWJlcjIoZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIHN0YXRlLmRpbSA9IGRpbTtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBicnVzaC5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChudW1iZXIyKF8pKSwgYnJ1c2gpIDogZXh0ZW50O1xuICB9O1xuXG4gIGJydXNoLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGJydXNoKSA6IGZpbHRlcjtcbiAgfTtcblxuICBicnVzaC50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBicnVzaCkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgYnJ1c2guaGFuZGxlU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChoYW5kbGVTaXplID0gK18sIGJydXNoKSA6IGhhbmRsZVNpemU7XG4gIH07XG5cbiAgYnJ1c2gua2V5TW9kaWZpZXJzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSAhIV8sIGJydXNoKSA6IGtleXM7XG4gIH07XG5cbiAgYnJ1c2gub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gYnJ1c2ggOiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gYnJ1c2g7XG59XG5cbmV4cG9ydHMuYnJ1c2ggPSBicnVzaDtcbmV4cG9ydHMuYnJ1c2hTZWxlY3Rpb24gPSBicnVzaFNlbGVjdGlvbjtcbmV4cG9ydHMuYnJ1c2hYID0gYnJ1c2hYO1xuZXhwb3J0cy5icnVzaFkgPSBicnVzaFk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY2hvcmQvIHYxLjAuNiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JyksIHJlcXVpcmUoJ2QzLXBhdGgnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1hcnJheScsICdkMy1wYXRoJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzQXJyYXksZDNQYXRoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHBpID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSAvIDI7XG52YXIgdGF1ID0gcGkgKiAyO1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG5mdW5jdGlvbiBjb21wYXJlVmFsdWUoY29tcGFyZSkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlKFxuICAgICAgYS5zb3VyY2UudmFsdWUgKyBhLnRhcmdldC52YWx1ZSxcbiAgICAgIGIuc291cmNlLnZhbHVlICsgYi50YXJnZXQudmFsdWVcbiAgICApO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjaG9yZCgpIHtcbiAgdmFyIHBhZEFuZ2xlID0gMCxcbiAgICAgIHNvcnRHcm91cHMgPSBudWxsLFxuICAgICAgc29ydFN1Ymdyb3VwcyA9IG51bGwsXG4gICAgICBzb3J0Q2hvcmRzID0gbnVsbDtcblxuICBmdW5jdGlvbiBjaG9yZChtYXRyaXgpIHtcbiAgICB2YXIgbiA9IG1hdHJpeC5sZW5ndGgsXG4gICAgICAgIGdyb3VwU3VtcyA9IFtdLFxuICAgICAgICBncm91cEluZGV4ID0gZDNBcnJheS5yYW5nZShuKSxcbiAgICAgICAgc3ViZ3JvdXBJbmRleCA9IFtdLFxuICAgICAgICBjaG9yZHMgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gY2hvcmRzLmdyb3VwcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG4gKiBuKSxcbiAgICAgICAgayxcbiAgICAgICAgeCxcbiAgICAgICAgeDAsXG4gICAgICAgIGR4LFxuICAgICAgICBpLFxuICAgICAgICBqO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3VtLlxuICAgIGsgPSAwLCBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB4ID0gMCwgaiA9IC0xOyB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICB4ICs9IG1hdHJpeFtpXVtqXTtcbiAgICAgIH1cbiAgICAgIGdyb3VwU3Vtcy5wdXNoKHgpO1xuICAgICAgc3ViZ3JvdXBJbmRleC5wdXNoKGQzQXJyYXkucmFuZ2UobikpO1xuICAgICAgayArPSB4O1xuICAgIH1cblxuICAgIC8vIFNvcnQgZ3JvdXBz4oCmXG4gICAgaWYgKHNvcnRHcm91cHMpIGdyb3VwSW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gc29ydEdyb3Vwcyhncm91cFN1bXNbYV0sIGdyb3VwU3Vtc1tiXSk7XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IHN1Ymdyb3Vwc+KAplxuICAgIGlmIChzb3J0U3ViZ3JvdXBzKSBzdWJncm91cEluZGV4LmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRTdWJncm91cHMobWF0cml4W2ldW2FdLCBtYXRyaXhbaV1bYl0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBzdW0gdG8gc2NhbGluZyBmYWN0b3IgZm9yIFswLCAycGldLlxuICAgIC8vIFRPRE8gQWxsb3cgc3RhcnQgYW5kIGVuZCBhbmdsZSB0byBiZSBzcGVjaWZpZWQ/XG4gICAgLy8gVE9ETyBBbGxvdyBwYWRkaW5nIHRvIGJlIHNwZWNpZmllZCBhcyBwZXJjZW50YWdlP1xuICAgIGsgPSBtYXgoMCwgdGF1IC0gcGFkQW5nbGUgKiBuKSAvIGs7XG4gICAgZHggPSBrID8gcGFkQW5nbGUgOiB0YXUgLyBuO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBmb3IgZWFjaCBncm91cCBhbmQgc3ViZ3JvdXAuXG4gICAgLy8gTm90ZTogT3BlcmEgaGFzIGEgYnVnIHJlb3JkZXJpbmcgb2JqZWN0IGxpdGVyYWwgcHJvcGVydGllcyFcbiAgICB4ID0gMCwgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgeDAgPSB4LCBqID0gLTE7IHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgIHZhciBkaSA9IGdyb3VwSW5kZXhbaV0sXG4gICAgICAgICAgICBkaiA9IHN1Ymdyb3VwSW5kZXhbZGldW2pdLFxuICAgICAgICAgICAgdiA9IG1hdHJpeFtkaV1bZGpdLFxuICAgICAgICAgICAgYTAgPSB4LFxuICAgICAgICAgICAgYTEgPSB4ICs9IHYgKiBrO1xuICAgICAgICBzdWJncm91cHNbZGogKiBuICsgZGldID0ge1xuICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICBzdWJpbmRleDogZGosXG4gICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBncm91cHNbZGldID0ge1xuICAgICAgICBpbmRleDogZGksXG4gICAgICAgIHN0YXJ0QW5nbGU6IHgwLFxuICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgdmFsdWU6IGdyb3VwU3Vtc1tkaV1cbiAgICAgIH07XG4gICAgICB4ICs9IGR4O1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGNob3JkcyBmb3IgZWFjaCAobm9uLWVtcHR5KSBzdWJncm91cC1zdWJncm91cCBsaW5rLlxuICAgIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGogPSBpIC0gMTsgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tqICogbiArIGldLFxuICAgICAgICAgICAgdGFyZ2V0ID0gc3ViZ3JvdXBzW2kgKiBuICsgal07XG4gICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgY2hvcmRzLnB1c2goc291cmNlLnZhbHVlIDwgdGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgID8ge3NvdXJjZTogdGFyZ2V0LCB0YXJnZXQ6IHNvdXJjZX1cbiAgICAgICAgICAgICAgOiB7c291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydENob3JkcyA/IGNob3Jkcy5zb3J0KHNvcnRDaG9yZHMpIDogY2hvcmRzO1xuICB9XG5cbiAgY2hvcmQucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSBtYXgoMCwgXyksIGNob3JkKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGNob3JkLnNvcnRHcm91cHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydEdyb3VwcyA9IF8sIGNob3JkKSA6IHNvcnRHcm91cHM7XG4gIH07XG5cbiAgY2hvcmQuc29ydFN1Ymdyb3VwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0U3ViZ3JvdXBzID0gXywgY2hvcmQpIDogc29ydFN1Ymdyb3VwcztcbiAgfTtcblxuICBjaG9yZC5zb3J0Q2hvcmRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IHNvcnRDaG9yZHMgPSBudWxsIDogKHNvcnRDaG9yZHMgPSBjb21wYXJlVmFsdWUoXykpLl8gPSBfLCBjaG9yZCkgOiBzb3J0Q2hvcmRzICYmIHNvcnRDaG9yZHMuXztcbiAgfTtcblxuICByZXR1cm4gY2hvcmQ7XG59XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTb3VyY2UoZCkge1xuICByZXR1cm4gZC5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUYXJnZXQoZCkge1xuICByZXR1cm4gZC50YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSYWRpdXMoZCkge1xuICByZXR1cm4gZC5yYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdGFydEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIHJpYmJvbigpIHtcbiAgdmFyIHNvdXJjZSA9IGRlZmF1bHRTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBkZWZhdWx0VGFyZ2V0LFxuICAgICAgcmFkaXVzID0gZGVmYXVsdFJhZGl1cyxcbiAgICAgIHN0YXJ0QW5nbGUgPSBkZWZhdWx0U3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gZGVmYXVsdEVuZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmliYm9uKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIGFyZ3YgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHMgPSBzb3VyY2UuYXBwbHkodGhpcywgYXJndiksXG4gICAgICAgIHQgPSB0YXJnZXQuYXBwbHkodGhpcywgYXJndiksXG4gICAgICAgIHNyID0gK3JhZGl1cy5hcHBseSh0aGlzLCAoYXJndlswXSA9IHMsIGFyZ3YpKSxcbiAgICAgICAgc2EwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd2KSAtIGhhbGZQaSxcbiAgICAgICAgc2ExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGksXG4gICAgICAgIHN4MCA9IHNyICogY29zKHNhMCksXG4gICAgICAgIHN5MCA9IHNyICogc2luKHNhMCksXG4gICAgICAgIHRyID0gK3JhZGl1cy5hcHBseSh0aGlzLCAoYXJndlswXSA9IHQsIGFyZ3YpKSxcbiAgICAgICAgdGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd2KSAtIGhhbGZQaSxcbiAgICAgICAgdGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGk7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuXG4gICAgY29udGV4dC5tb3ZlVG8oc3gwLCBzeTApO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIHNyLCBzYTAsIHNhMSk7XG4gICAgaWYgKHNhMCAhPT0gdGEwIHx8IHNhMSAhPT0gdGExKSB7IC8vIFRPRE8gc3IgIT09IHRyP1xuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKDAsIDAsIHRyICogY29zKHRhMCksIHRyICogc2luKHRhMCkpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdHIsIHRhMCwgdGExKTtcbiAgICB9XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKDAsIDAsIHN4MCwgc3kwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICByaWJib24ucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCByaWJib24pIDogcmFkaXVzO1xuICB9O1xuXG4gIHJpYmJvbi5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcmliYm9uKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgcmliYm9uLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHJpYmJvbikgOiBlbmRBbmdsZTtcbiAgfTtcblxuICByaWJib24uc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIHJpYmJvbikgOiBzb3VyY2U7XG4gIH07XG5cbiAgcmliYm9uLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0YXJnZXQgPSBfLCByaWJib24pIDogdGFyZ2V0O1xuICB9O1xuXG4gIHJpYmJvbi5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCByaWJib24pIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gcmliYm9uO1xufVxuXG5leHBvcnRzLmNob3JkID0gY2hvcmQ7XG5leHBvcnRzLnJpYmJvbiA9IHJpYmJvbjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY29sbGVjdGlvbi8gdjEuMC43IENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZml4ID0gXCIkXCI7XG5cbmZ1bmN0aW9uIE1hcCgpIHt9XG5cbk1hcC5wcm90b3R5cGUgPSBtYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWFwLFxuICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgdmFsdWVzLnB1c2godGhpc1twcm9wZXJ0eV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG4gIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGVudHJpZXMucHVzaCh7a2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1hcChvYmplY3QsIGYpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXA7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcblxuICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICBvO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXG4gIGVsc2UgaWYgKG9iamVjdCkgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcblxuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBuZXN0KCkge1xuICB2YXIga2V5cyA9IFtdLFxuICAgICAgc29ydEtleXMgPSBbXSxcbiAgICAgIHNvcnRWYWx1ZXMsXG4gICAgICByb2xsdXAsXG4gICAgICBuZXN0O1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpIHtcbiAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGFycmF5LnNvcnQoc29ydFZhbHVlcyk7XG4gICAgICByZXR1cm4gcm9sbHVwICE9IG51bGwgPyByb2xsdXAoYXJyYXkpIDogYXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgICAga2V5VmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZXNCeUtleSA9IG1hcCgpLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyBcIlwiKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24odmFsdWVzLCBrZXkpIHtcbiAgICAgIHNldFJlc3VsdChyZXN1bHQsIGtleSwgYXBwbHkodmFsdWVzLCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyaWVzKG1hcCQkMSwgZGVwdGgpIHtcbiAgICBpZiAoKytkZXB0aCA+IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwJCQxO1xuICAgIHZhciBhcnJheSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoIC0gMV07XG4gICAgaWYgKHJvbGx1cCAhPSBudWxsICYmIGRlcHRoID49IGtleXMubGVuZ3RoKSBhcnJheSA9IG1hcCQkMS5lbnRyaWVzKCk7XG4gICAgZWxzZSBhcnJheSA9IFtdLCBtYXAkJDEuZWFjaChmdW5jdGlvbih2LCBrKSB7IGFycmF5LnB1c2goe2tleTogaywgdmFsdWVzOiBlbnRyaWVzKHYsIGRlcHRoKX0pOyB9KTtcbiAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XG4gIH1cblxuICByZXR1cm4gbmVzdCA9IHtcbiAgICBvYmplY3Q6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlT2JqZWN0LCBzZXRPYmplY3QpOyB9LFxuICAgIG1hcDogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCk7IH0sXG4gICAgZW50cmllczogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGVudHJpZXMoYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKSwgMCk7IH0sXG4gICAga2V5OiBmdW5jdGlvbihkKSB7IGtleXMucHVzaChkKTsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydEtleXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydFZhbHVlczogZnVuY3Rpb24ob3JkZXIpIHsgc29ydFZhbHVlcyA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcbiAgICByb2xsdXA6IGZ1bmN0aW9uKGYpIHsgcm9sbHVwID0gZjsgcmV0dXJuIG5lc3Q7IH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0KCkge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIHNldE9iamVjdChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFwKCkge1xuICByZXR1cm4gbWFwKCk7XG59XG5cbmZ1bmN0aW9uIHNldE1hcChtYXAkJDEsIGtleSwgdmFsdWUpIHtcbiAgbWFwJCQxLnNldChrZXksIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gU2V0KCkge31cblxudmFyIHByb3RvID0gbWFwLnByb3RvdHlwZTtcblxuU2V0LnByb3RvdHlwZSA9IHNldC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTZXQsXG4gIGhhczogcHJvdG8uaGFzLFxuICBhZGQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFsdWUgKz0gXCJcIjtcbiAgICB0aGlzW3ByZWZpeCArIHZhbHVlXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IHByb3RvLnJlbW92ZSxcbiAgY2xlYXI6IHByb3RvLmNsZWFyLFxuICB2YWx1ZXM6IHByb3RvLmtleXMsXG4gIHNpemU6IHByb3RvLnNpemUsXG4gIGVtcHR5OiBwcm90by5lbXB0eSxcbiAgZWFjaDogcHJvdG8uZWFjaFxufTtcblxuZnVuY3Rpb24gc2V0KG9iamVjdCwgZikge1xuICB2YXIgc2V0ID0gbmV3IFNldDtcblxuICAvLyBDb3B5IGNvbnN0cnVjdG9yLlxuICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU2V0KSBvYmplY3QuZWFjaChmdW5jdGlvbih2YWx1ZSkgeyBzZXQuYWRkKHZhbHVlKTsgfSk7XG5cbiAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaXTigJlzIGFuIGFycmF5LlxuICBlbHNlIGlmIChvYmplY3QpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gb2JqZWN0Lmxlbmd0aDtcbiAgICBpZiAoZiA9PSBudWxsKSB3aGlsZSAoKytpIDwgbikgc2V0LmFkZChvYmplY3RbaV0pO1xuICAgIGVsc2Ugd2hpbGUgKCsraSA8IG4pIHNldC5hZGQoZihvYmplY3RbaV0sIGksIG9iamVjdCkpO1xuICB9XG5cbiAgcmV0dXJuIHNldDtcbn1cblxuZnVuY3Rpb24ga2V5cyhtYXApIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiB2YWx1ZXMobWFwKSB7XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICByZXR1cm4gdmFsdWVzO1xufVxuXG5mdW5jdGlvbiBlbnRyaWVzKG1hcCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe2tleToga2V5LCB2YWx1ZTogbWFwW2tleV19KTtcbiAgcmV0dXJuIGVudHJpZXM7XG59XG5cbmV4cG9ydHMubmVzdCA9IG5lc3Q7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5rZXlzID0ga2V5cztcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZXhwb3J0cy5lbnRyaWVzID0gZW50cmllcztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY29sb3IvIHYxLjQuMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmluZShjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBDb2xvcigpIHt9XG5cbnZhciBkYXJrZXIgPSAwLjc7XG52YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZUksIHJlSSwgcmVJXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlSSwgcmVJLCByZUksIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xcXFxcKFwiICsgW3JlTiwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsYVxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5OiBmdW5jdGlvbihjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyBuZXcgUmdiKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gbmV3IFJnYigobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5mdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBcIiNcIiArIGhleCh0aGlzLnIpICsgaGV4KHRoaXMuZykgKyBoZXgodGhpcy5iKTtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gIHJldHVybiAoYSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwiKVxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5yKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmIpIHx8IDApKVxuICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5mdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGZvcm1hdEhzbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJoc2woXCIgOiBcImhzbGEoXCIpXG4gICAgICAgICsgKHRoaXMuaCB8fCAwKSArIFwiLCBcIlxuICAgICAgICArICh0aGlzLnMgfHwgMCkgKiAxMDAgKyBcIiUsIFwiXG4gICAgICAgICsgKHRoaXMubCB8fCAwKSAqIDEwMCArIFwiJVwiXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuXG52YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XG52YXIgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIGh0dHBzOi8vb2JzZXJ2YWJsZWhxLmNvbS9AbWJvc3RvY2svbGFiLWFuZC1yZ2JcbnZhciBLID0gMTgsXG4gICAgWG4gPSAwLjk2NDIyLFxuICAgIFluID0gMSxcbiAgICBabiA9IDAuODI1MjEsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MTtcblxuZnVuY3Rpb24gbGFiQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgTGFiKSByZXR1cm4gbmV3IExhYihvLmwsIG8uYSwgby5iLCBvLm9wYWNpdHkpO1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIGhjbDJsYWIobyk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSByZ2IybHJnYihvLnIpLFxuICAgICAgZyA9IHJnYjJscmdiKG8uZyksXG4gICAgICBiID0gcmdiMmxyZ2Ioby5iKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIyMjUwNDUgKiByICsgMC43MTY4Nzg2ICogZyArIDAuMDYwNjE2OSAqIGIpIC8gWW4pLCB4LCB6O1xuICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB4ID0geiA9IHk7IGVsc2Uge1xuICAgIHggPSB4eXoybGFiKCgwLjQzNjA3NDcgKiByICsgMC4zODUwNjQ5ICogZyArIDAuMTQzMDgwNCAqIGIpIC8gWG4pO1xuICAgIHogPSB4eXoybGFiKCgwLjAxMzkzMjIgKiByICsgMC4wOTcxMDQ1ICogZyArIDAuNzE0MTczMyAqIGIpIC8gWm4pO1xuICB9XG4gIHJldHVybiBuZXcgTGFiKDExNiAqIHkgLSAxNiwgNTAwICogKHggLSB5KSwgMjAwICogKHkgLSB6KSwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gZ3JheShsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBuZXcgTGFiKGwsIDAsIDAsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gbGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBsYWJDb252ZXJ0KGwpIDogbmV3IExhYihsLCBhLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCA8IG8ubCAmJiBvLmwgPCAxMDAgPyAwIDogTmFOLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiByYWQyZGVnO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBoY2wybGFiKG8pIHtcbiAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBvLmggKiBkZWcycmFkO1xuICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaGNsMmxhYih0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuXG52YXIgQSA9IC0wLjE0ODYxLFxuICAgIEIgPSArMS43ODI3NyxcbiAgICBDID0gLTAuMjkyMjcsXG4gICAgRCA9IC0wLjkwNjQ5LFxuICAgIEUgPSArMS45NzI5NCxcbiAgICBFRCA9IEUgKiBELFxuICAgIEVCID0gRSAqIEIsXG4gICAgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXhDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpLFxuICAgICAgYmwgPSBiIC0gbCxcbiAgICAgIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCxcbiAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpLCAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIHJhZDJkZWcgLSAxMjAgOiBOYU47XG4gIHJldHVybiBuZXcgQ3ViZWhlbGl4KGggPCAwID8gaCArIDM2MCA6IGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3ViZWhlbGl4Q29udmVydChoKSA6IG5ldyBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEN1YmVoZWxpeCwgY3ViZWhlbGl4LCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gaXNOYU4odGhpcy5oKSA/IDAgOiAodGhpcy5oICsgMTIwKSAqIGRlZzJyYWQsXG4gICAgICAgIGwgPSArdGhpcy5sLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5leHBvcnRzLmNvbG9yID0gY29sb3I7XG5leHBvcnRzLmN1YmVoZWxpeCA9IGN1YmVoZWxpeDtcbmV4cG9ydHMuZ3JheSA9IGdyYXk7XG5leHBvcnRzLmhjbCA9IGhjbDtcbmV4cG9ydHMuaHNsID0gaHNsO1xuZXhwb3J0cy5sYWIgPSBsYWI7XG5leHBvcnRzLmxjaCA9IGxjaDtcbmV4cG9ydHMucmdiID0gcmdiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNvbnRvdXIvIHYxLjMuMiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtYXJyYXknXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0FycmF5KSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG5mdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAwLCBuID0gcmluZy5sZW5ndGgsIGFyZWEgPSByaW5nW24gLSAxXVsxXSAqIHJpbmdbMF1bMF0gLSByaW5nW24gLSAxXVswXSAqIHJpbmdbMF1bMV07XG4gIHdoaWxlICgrK2kgPCBuKSBhcmVhICs9IHJpbmdbaSAtIDFdWzFdICogcmluZ1tpXVswXSAtIHJpbmdbaSAtIDFdWzBdICogcmluZ1tpXVsxXTtcbiAgcmV0dXJuIGFyZWE7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhyaW5nLCBob2xlKSB7XG4gIHZhciBpID0gLTEsIG4gPSBob2xlLmxlbmd0aCwgYztcbiAgd2hpbGUgKCsraSA8IG4pIGlmIChjID0gcmluZ0NvbnRhaW5zKHJpbmcsIGhvbGVbaV0pKSByZXR1cm4gYztcbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHJpbmdDb250YWlucyhyaW5nLCBwb2ludCkge1xuICB2YXIgeCA9IHBvaW50WzBdLCB5ID0gcG9pbnRbMV0sIGNvbnRhaW5zID0gLTE7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gcmluZy5sZW5ndGgsIGogPSBuIC0gMTsgaSA8IG47IGogPSBpKyspIHtcbiAgICB2YXIgcGkgPSByaW5nW2ldLCB4aSA9IHBpWzBdLCB5aSA9IHBpWzFdLCBwaiA9IHJpbmdbal0sIHhqID0gcGpbMF0sIHlqID0gcGpbMV07XG4gICAgaWYgKHNlZ21lbnRDb250YWlucyhwaSwgcGosIHBvaW50KSkgcmV0dXJuIDA7XG4gICAgaWYgKCgoeWkgPiB5KSAhPT0gKHlqID4geSkpICYmICgoeCA8ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGkpKSkgY29udGFpbnMgPSAtY29udGFpbnM7XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5zO1xufVxuXG5mdW5jdGlvbiBzZWdtZW50Q29udGFpbnMoYSwgYiwgYykge1xuICB2YXIgaTsgcmV0dXJuIGNvbGxpbmVhcihhLCBiLCBjKSAmJiB3aXRoaW4oYVtpID0gKyhhWzBdID09PSBiWzBdKV0sIGNbaV0sIGJbaV0pO1xufVxuXG5mdW5jdGlvbiBjb2xsaW5lYXIoYSwgYiwgYykge1xuICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgPT09IChjWzBdIC0gYVswXSkgKiAoYlsxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiB3aXRoaW4ocCwgcSwgcikge1xuICByZXR1cm4gcCA8PSBxICYmIHEgPD0gciB8fCByIDw9IHEgJiYgcSA8PSBwO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGNhc2VzID0gW1xuICBbXSxcbiAgW1tbMS4wLCAxLjVdLCBbMC41LCAxLjBdXV0sXG4gIFtbWzEuNSwgMS4wXSwgWzEuMCwgMS41XV1dLFxuICBbW1sxLjUsIDEuMF0sIFswLjUsIDEuMF1dXSxcbiAgW1tbMS4wLCAwLjVdLCBbMS41LCAxLjBdXV0sXG4gIFtbWzEuMCwgMS41XSwgWzAuNSwgMS4wXV0sIFtbMS4wLCAwLjVdLCBbMS41LCAxLjBdXV0sXG4gIFtbWzEuMCwgMC41XSwgWzEuMCwgMS41XV1dLFxuICBbW1sxLjAsIDAuNV0sIFswLjUsIDEuMF1dXSxcbiAgW1tbMC41LCAxLjBdLCBbMS4wLCAwLjVdXV0sXG4gIFtbWzEuMCwgMS41XSwgWzEuMCwgMC41XV1dLFxuICBbW1swLjUsIDEuMF0sIFsxLjAsIDAuNV1dLCBbWzEuNSwgMS4wXSwgWzEuMCwgMS41XV1dLFxuICBbW1sxLjUsIDEuMF0sIFsxLjAsIDAuNV1dXSxcbiAgW1tbMC41LCAxLjBdLCBbMS41LCAxLjBdXV0sXG4gIFtbWzEuMCwgMS41XSwgWzEuNSwgMS4wXV1dLFxuICBbW1swLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSxcbiAgW11cbl07XG5cbmZ1bmN0aW9uIGNvbnRvdXJzKCkge1xuICB2YXIgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgdGhyZXNob2xkID0gZDNBcnJheS50aHJlc2hvbGRTdHVyZ2VzLFxuICAgICAgc21vb3RoID0gc21vb3RoTGluZWFyO1xuXG4gIGZ1bmN0aW9uIGNvbnRvdXJzKHZhbHVlcykge1xuICAgIHZhciB0eiA9IHRocmVzaG9sZCh2YWx1ZXMpO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICB2YXIgZG9tYWluID0gZDNBcnJheS5leHRlbnQodmFsdWVzKSwgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bMV07XG4gICAgICB0eiA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIHR6KTtcbiAgICAgIHR6ID0gZDNBcnJheS5yYW5nZShNYXRoLmZsb29yKHN0YXJ0IC8gdHopICogdHosIE1hdGguZmxvb3Ioc3RvcCAvIHR6KSAqIHR6LCB0eik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR6ID0gdHouc2xpY2UoKS5zb3J0KGFzY2VuZGluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR6Lm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvbnRvdXIodmFsdWVzLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBBY2N1bXVsYXRlLCBzbW9vdGggY29udG91ciByaW5ncywgYXNzaWduIGhvbGVzIHRvIGV4dGVyaW9yIHJpbmdzLlxuICAvLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svc2hhcGVmaWxlL2Jsb2IvdjAuNi4yL3NocC9wb2x5Z29uLmpzXG4gIGZ1bmN0aW9uIGNvbnRvdXIodmFsdWVzLCB2YWx1ZSkge1xuICAgIHZhciBwb2x5Z29ucyA9IFtdLFxuICAgICAgICBob2xlcyA9IFtdO1xuXG4gICAgaXNvcmluZ3ModmFsdWVzLCB2YWx1ZSwgZnVuY3Rpb24ocmluZykge1xuICAgICAgc21vb3RoKHJpbmcsIHZhbHVlcywgdmFsdWUpO1xuICAgICAgaWYgKGFyZWEocmluZykgPiAwKSBwb2x5Z29ucy5wdXNoKFtyaW5nXSk7XG4gICAgICBlbHNlIGhvbGVzLnB1c2gocmluZyk7XG4gICAgfSk7XG5cbiAgICBob2xlcy5mb3JFYWNoKGZ1bmN0aW9uKGhvbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoLCBwb2x5Z29uOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChjb250YWlucygocG9seWdvbiA9IHBvbHlnb25zW2ldKVswXSwgaG9sZSkgIT09IC0xKSB7XG4gICAgICAgICAgcG9seWdvbi5wdXNoKGhvbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBjb29yZGluYXRlczogcG9seWdvbnNcbiAgICB9O1xuICB9XG5cbiAgLy8gTWFyY2hpbmcgc3F1YXJlcyB3aXRoIGlzb2xpbmVzIHN0aXRjaGVkIGludG8gcmluZ3MuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90b3BvanNvbi90b3BvanNvbi1jbGllbnQvYmxvYi92My4wLjAvc3JjL3N0aXRjaC5qc1xuICBmdW5jdGlvbiBpc29yaW5ncyh2YWx1ZXMsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBmcmFnbWVudEJ5U3RhcnQgPSBuZXcgQXJyYXksXG4gICAgICAgIGZyYWdtZW50QnlFbmQgPSBuZXcgQXJyYXksXG4gICAgICAgIHgsIHksIHQwLCB0MSwgdDIsIHQzO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0aGUgZmlyc3Qgcm93ICh5ID0gLTEsIHQyID0gdDMgPSAwKS5cbiAgICB4ID0geSA9IC0xO1xuICAgIHQxID0gdmFsdWVzWzBdID49IHZhbHVlO1xuICAgIGNhc2VzW3QxIDw8IDFdLmZvckVhY2goc3RpdGNoKTtcbiAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t4ICsgMV0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MCB8IHQxIDw8IDFdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9XG4gICAgY2FzZXNbdDEgPDwgMF0uZm9yRWFjaChzdGl0Y2gpO1xuXG4gICAgLy8gR2VuZXJhbCBjYXNlIGZvciB0aGUgaW50ZXJtZWRpYXRlIHJvd3MuXG4gICAgd2hpbGUgKCsreSA8IGR5IC0gMSkge1xuICAgICAgeCA9IC0xO1xuICAgICAgdDEgPSB2YWx1ZXNbeSAqIGR4ICsgZHhdID49IHZhbHVlO1xuICAgICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QxIDw8IDEgfCB0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICAgIHQwID0gdDEsIHQxID0gdmFsdWVzW3kgKiBkeCArIGR4ICsgeCArIDFdID49IHZhbHVlO1xuICAgICAgICB0MyA9IHQyLCB0MiA9IHZhbHVlc1t5ICogZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICAgIGNhc2VzW3QwIHwgdDEgPDwgMSB8IHQyIDw8IDIgfCB0MyA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgICB9XG4gICAgICBjYXNlc1t0MSB8IHQyIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBsYXN0IHJvdyAoeSA9IGR5IC0gMSwgdDAgPSB0MSA9IDApLlxuICAgIHggPSAtMTtcbiAgICB0MiA9IHZhbHVlc1t5ICogZHhdID49IHZhbHVlO1xuICAgIGNhc2VzW3QyIDw8IDJdLmZvckVhY2goc3RpdGNoKTtcbiAgICB3aGlsZSAoKyt4IDwgZHggLSAxKSB7XG4gICAgICB0MyA9IHQyLCB0MiA9IHZhbHVlc1t5ICogZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgIH1cbiAgICBjYXNlc1t0MiA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICBmdW5jdGlvbiBzdGl0Y2gobGluZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gW2xpbmVbMF1bMF0gKyB4LCBsaW5lWzBdWzFdICsgeV0sXG4gICAgICAgICAgZW5kID0gW2xpbmVbMV1bMF0gKyB4LCBsaW5lWzFdWzFdICsgeV0sXG4gICAgICAgICAgc3RhcnRJbmRleCA9IGluZGV4KHN0YXJ0KSxcbiAgICAgICAgICBlbmRJbmRleCA9IGluZGV4KGVuZCksXG4gICAgICAgICAgZiwgZztcbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xuICAgICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGYucmluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZy5lbmRdID0ge3N0YXJ0OiBmLnN0YXJ0LCBlbmQ6IGcuZW5kLCByaW5nOiBmLnJpbmcuY29uY2F0KGcucmluZyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kSW5kZXhdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRJbmRleF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xuICAgICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGYucmluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0ge3N0YXJ0OiBnLnN0YXJ0LCBlbmQ6IGYuZW5kLCByaW5nOiBnLnJpbmcuY29uY2F0KGYucmluZyl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICAgIGYucmluZy51bnNoaWZ0KHN0YXJ0KTtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0SW5kZXhdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W3N0YXJ0SW5kZXhdID0gZnJhZ21lbnRCeUVuZFtlbmRJbmRleF0gPSB7c3RhcnQ6IHN0YXJ0SW5kZXgsIGVuZDogZW5kSW5kZXgsIHJpbmc6IFtzdGFydCwgZW5kXX07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5kZXgocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gKiAyICsgcG9pbnRbMV0gKiAoZHggKyAxKSAqIDQ7XG4gIH1cblxuICBmdW5jdGlvbiBzbW9vdGhMaW5lYXIocmluZywgdmFsdWVzLCB2YWx1ZSkge1xuICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgdmFyIHggPSBwb2ludFswXSxcbiAgICAgICAgICB5ID0gcG9pbnRbMV0sXG4gICAgICAgICAgeHQgPSB4IHwgMCxcbiAgICAgICAgICB5dCA9IHkgfCAwLFxuICAgICAgICAgIHYwLFxuICAgICAgICAgIHYxID0gdmFsdWVzW3l0ICogZHggKyB4dF07XG4gICAgICBpZiAoeCA+IDAgJiYgeCA8IGR4ICYmIHh0ID09PSB4KSB7XG4gICAgICAgIHYwID0gdmFsdWVzW3l0ICogZHggKyB4dCAtIDFdO1xuICAgICAgICBwb2ludFswXSA9IHggKyAodmFsdWUgLSB2MCkgLyAodjEgLSB2MCkgLSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoeSA+IDAgJiYgeSA8IGR5ICYmIHl0ID09PSB5KSB7XG4gICAgICAgIHYwID0gdmFsdWVzWyh5dCAtIDEpICogZHggKyB4dF07XG4gICAgICAgIHBvaW50WzFdID0geSArICh2YWx1ZSAtIHYwKSAvICh2MSAtIHYwKSAtIDAuNTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnRvdXJzLmNvbnRvdXIgPSBjb250b3VyO1xuXG4gIGNvbnRvdXJzLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG4gICAgdmFyIF8wID0gTWF0aC5jZWlsKF9bMF0pLCBfMSA9IE1hdGguY2VpbChfWzFdKTtcbiAgICBpZiAoIShfMCA+IDApIHx8ICEoXzEgPiAwKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzaXplXCIpO1xuICAgIHJldHVybiBkeCA9IF8wLCBkeSA9IF8xLCBjb250b3VycztcbiAgfTtcblxuICBjb250b3Vycy50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGNvbnRvdXJzKSA6IHRocmVzaG9sZDtcbiAgfTtcblxuICBjb250b3Vycy5zbW9vdGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc21vb3RoID0gXyA/IHNtb290aExpbmVhciA6IG5vb3AsIGNvbnRvdXJzKSA6IHNtb290aCA9PT0gc21vb3RoTGluZWFyO1xuICB9O1xuXG4gIHJldHVybiBjb250b3Vycztcbn1cblxuLy8gVE9ETyBPcHRpbWl6ZSBlZGdlIGNhc2VzLlxuLy8gVE9ETyBPcHRpbWl6ZSBpbmRleCBjYWxjdWxhdGlvbi5cbi8vIFRPRE8gT3B0aW1pemUgYXJndW1lbnRzLlxuZnVuY3Rpb24gYmx1clgoc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgdmFyIG4gPSBzb3VyY2Uud2lkdGgsXG4gICAgICBtID0gc291cmNlLmhlaWdodCxcbiAgICAgIHcgPSAociA8PCAxKSArIDE7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHNyID0gMDsgaSA8IG4gKyByOyArK2kpIHtcbiAgICAgIGlmIChpIDwgbikge1xuICAgICAgICBzciArPSBzb3VyY2UuZGF0YVtpICsgaiAqIG5dO1xuICAgICAgfVxuICAgICAgaWYgKGkgPj0gcikge1xuICAgICAgICBpZiAoaSA+PSB3KSB7XG4gICAgICAgICAgc3IgLT0gc291cmNlLmRhdGFbaSAtIHcgKyBqICogbl07XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmRhdGFbaSAtIHIgKyBqICogbl0gPSBzciAvIE1hdGgubWluKGkgKyAxLCBuIC0gMSArIHcgLSBpLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETyBPcHRpbWl6ZSBlZGdlIGNhc2VzLlxuLy8gVE9ETyBPcHRpbWl6ZSBpbmRleCBjYWxjdWxhdGlvbi5cbi8vIFRPRE8gT3B0aW1pemUgYXJndW1lbnRzLlxuZnVuY3Rpb24gYmx1clkoc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgdmFyIG4gPSBzb3VyY2Uud2lkdGgsXG4gICAgICBtID0gc291cmNlLmhlaWdodCxcbiAgICAgIHcgPSAociA8PCAxKSArIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIHNyID0gMDsgaiA8IG0gKyByOyArK2opIHtcbiAgICAgIGlmIChqIDwgbSkge1xuICAgICAgICBzciArPSBzb3VyY2UuZGF0YVtpICsgaiAqIG5dO1xuICAgICAgfVxuICAgICAgaWYgKGogPj0gcikge1xuICAgICAgICBpZiAoaiA+PSB3KSB7XG4gICAgICAgICAgc3IgLT0gc291cmNlLmRhdGFbaSArIChqIC0gdykgKiBuXTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZGF0YVtpICsgKGogLSByKSAqIG5dID0gc3IgLyBNYXRoLm1pbihqICsgMSwgbSAtIDEgKyB3IC0gaiwgdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXZWlnaHQoKSB7XG4gIHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBkZW5zaXR5KCkge1xuICB2YXIgeCA9IGRlZmF1bHRYLFxuICAgICAgeSA9IGRlZmF1bHRZLFxuICAgICAgd2VpZ2h0ID0gZGVmYXVsdFdlaWdodCxcbiAgICAgIGR4ID0gOTYwLFxuICAgICAgZHkgPSA1MDAsXG4gICAgICByID0gMjAsIC8vIGJsdXIgcmFkaXVzXG4gICAgICBrID0gMiwgLy8gbG9nMihncmlkIGNlbGwgc2l6ZSlcbiAgICAgIG8gPSByICogMywgLy8gZ3JpZCBvZmZzZXQsIHRvIHBhZCBmb3IgYmx1clxuICAgICAgbiA9IChkeCArIG8gKiAyKSA+PiBrLCAvLyBncmlkIHdpZHRoXG4gICAgICBtID0gKGR5ICsgbyAqIDIpID4+IGssIC8vIGdyaWQgaGVpZ2h0XG4gICAgICB0aHJlc2hvbGQgPSBjb25zdGFudCgyMCk7XG5cbiAgZnVuY3Rpb24gZGVuc2l0eShkYXRhKSB7XG4gICAgdmFyIHZhbHVlczAgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKSxcbiAgICAgICAgdmFsdWVzMSA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIG0pO1xuXG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQsIGksIGRhdGEpIHtcbiAgICAgIHZhciB4aSA9ICgreChkLCBpLCBkYXRhKSArIG8pID4+IGssXG4gICAgICAgICAgeWkgPSAoK3koZCwgaSwgZGF0YSkgKyBvKSA+PiBrLFxuICAgICAgICAgIHdpID0gK3dlaWdodChkLCBpLCBkYXRhKTtcbiAgICAgIGlmICh4aSA+PSAwICYmIHhpIDwgbiAmJiB5aSA+PSAwICYmIHlpIDwgbSkge1xuICAgICAgICB2YWx1ZXMwW3hpICsgeWkgKiBuXSArPSB3aTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE8gT3B0aW1pemUuXG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XG5cbiAgICB2YXIgdHogPSB0aHJlc2hvbGQodmFsdWVzMCk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHZhciBzdG9wID0gZDNBcnJheS5tYXgodmFsdWVzMCk7XG4gICAgICB0eiA9IGQzQXJyYXkudGlja1N0ZXAoMCwgc3RvcCwgdHopO1xuICAgICAgdHogPSBkM0FycmF5LnJhbmdlKDAsIE1hdGguZmxvb3Ioc3RvcCAvIHR6KSAqIHR6LCB0eik7XG4gICAgICB0ei5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250b3VycygpXG4gICAgICAgIC50aHJlc2hvbGRzKHR6KVxuICAgICAgICAuc2l6ZShbbiwgbV0pXG4gICAgICAodmFsdWVzMClcbiAgICAgICAgLm1hcCh0cmFuc2Zvcm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtKGdlb21ldHJ5KSB7XG4gICAgZ2VvbWV0cnkudmFsdWUgKj0gTWF0aC5wb3coMiwgLTIgKiBrKTsgLy8gRGVuc2l0eSBpbiBwb2ludHMgcGVyIHNxdWFyZSBwaXhlbC5cbiAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvbHlnb24pO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBvbHlnb24oY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVJpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUmluZyhjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUG9pbnQpO1xuICB9XG5cbiAgLy8gVE9ETyBPcHRpbWl6ZS5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlc1swXSA9IGNvb3JkaW5hdGVzWzBdICogTWF0aC5wb3coMiwgaykgLSBvO1xuICAgIGNvb3JkaW5hdGVzWzFdID0gY29vcmRpbmF0ZXNbMV0gKiBNYXRoLnBvdygyLCBrKSAtIG87XG4gIH1cblxuICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgbyA9IHIgKiAzO1xuICAgIG4gPSAoZHggKyBvICogMikgPj4gaztcbiAgICBtID0gKGR5ICsgbyAqIDIpID4+IGs7XG4gICAgcmV0dXJuIGRlbnNpdHk7XG4gIH1cblxuICBkZW5zaXR5LnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBkZW5zaXR5KSA6IHg7XG4gIH07XG5cbiAgZGVuc2l0eS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgZGVuc2l0eSkgOiB5O1xuICB9O1xuXG4gIGRlbnNpdHkud2VpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdlaWdodCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBkZW5zaXR5KSA6IHdlaWdodDtcbiAgfTtcblxuICBkZW5zaXR5LnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG4gICAgdmFyIF8wID0gTWF0aC5jZWlsKF9bMF0pLCBfMSA9IE1hdGguY2VpbChfWzFdKTtcbiAgICBpZiAoIShfMCA+PSAwKSAmJiAhKF8wID49IDApKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpemVcIik7XG4gICAgcmV0dXJuIGR4ID0gXzAsIGR5ID0gXzEsIHJlc2l6ZSgpO1xuICB9O1xuXG4gIGRlbnNpdHkuY2VsbFNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gMSA8PCBrO1xuICAgIGlmICghKChfID0gK18pID49IDEpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNlbGwgc2l6ZVwiKTtcbiAgICByZXR1cm4gayA9IE1hdGguZmxvb3IoTWF0aC5sb2coXykgLyBNYXRoLkxOMiksIHJlc2l6ZSgpO1xuICB9O1xuXG4gIGRlbnNpdHkudGhyZXNob2xkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aHJlc2hvbGQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IEFycmF5LmlzQXJyYXkoXykgPyBjb25zdGFudChzbGljZS5jYWxsKF8pKSA6IGNvbnN0YW50KF8pLCBkZW5zaXR5KSA6IHRocmVzaG9sZDtcbiAgfTtcblxuICBkZW5zaXR5LmJhbmR3aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQociAqIChyICsgMSkpO1xuICAgIGlmICghKChfID0gK18pID49IDApKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJhbmR3aWR0aFwiKTtcbiAgICByZXR1cm4gciA9IE1hdGgucm91bmQoKE1hdGguc3FydCg0ICogXyAqIF8gKyAxKSAtIDEpIC8gMiksIHJlc2l6ZSgpO1xuICB9O1xuXG4gIHJldHVybiBkZW5zaXR5O1xufVxuXG5leHBvcnRzLmNvbnRvdXJzID0gY29udG91cnM7XG5leHBvcnRzLmNvbnRvdXJEZW5zaXR5ID0gZGVuc2l0eTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZGlzcGF0Y2gvIHYxLjAuNiBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pIHx8IC9bXFxzLl0vLnRlc3QodCkpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0cy5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRyYWcvIHYxLjIuNSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWRpc3BhdGNoJywgJ2QzLXNlbGVjdGlvbiddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNEaXNwYXRjaCwgZDNTZWxlY3Rpb24pIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gbm9ldmVudCgpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZHJhZyh2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiB5ZXNkcmFnKHZpZXcsIG5vY2xpY2spIHtcbiAgdmFyIHJvb3QgPSB2aWV3LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgIHNlbGVjdGlvbiA9IGQzU2VsZWN0aW9uLnNlbGVjdCh2aWV3KS5vbihcImRyYWdzdGFydC5kcmFnXCIsIG51bGwpO1xuICBpZiAobm9jbGljaykge1xuICAgIHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbm9ldmVudCwgdHJ1ZSk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZWN0aW9uLm9uKFwiY2xpY2suZHJhZ1wiLCBudWxsKTsgfSwgMCk7XG4gIH1cbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdCA9IHJvb3QuX19ub3NlbGVjdDtcbiAgICBkZWxldGUgcm9vdC5fX25vc2VsZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBEcmFnRXZlbnQodGFyZ2V0LCB0eXBlLCBzdWJqZWN0LCBpZCwgYWN0aXZlLCB4LCB5LCBkeCwgZHksIGRpc3BhdGNoKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICB0aGlzLmlkZW50aWZpZXIgPSBpZDtcbiAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZHggPSBkeDtcbiAgdGhpcy5keSA9IGR5O1xuICB0aGlzLl8gPSBkaXNwYXRjaDtcbn1cblxuRHJhZ0V2ZW50LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSB0aGlzLl8ub24uYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdmFsdWUgPT09IHRoaXMuXyA/IHRoaXMgOiB2YWx1ZTtcbn07XG5cbi8vIElnbm9yZSByaWdodC1jbGljaywgc2luY2UgdGhhdCBzaG91bGQgb3BlbiB0aGUgY29udGV4dCBtZW51LlxuZnVuY3Rpb24gZGVmYXVsdEZpbHRlcigpIHtcbiAgcmV0dXJuICFkM1NlbGVjdGlvbi5ldmVudC5jdHJsS2V5ICYmICFkM1NlbGVjdGlvbi5ldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb250YWluZXIoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRTdWJqZWN0KGQpIHtcbiAgcmV0dXJuIGQgPT0gbnVsbCA/IHt4OiBkM1NlbGVjdGlvbi5ldmVudC54LCB5OiBkM1NlbGVjdGlvbi5ldmVudC55fSA6IGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgfHwgKFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGRyYWcoKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcixcbiAgICAgIHN1YmplY3QgPSBkZWZhdWx0U3ViamVjdCxcbiAgICAgIHRvdWNoYWJsZSA9IGRlZmF1bHRUb3VjaGFibGUsXG4gICAgICBnZXN0dXJlcyA9IHt9LFxuICAgICAgbGlzdGVuZXJzID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZHJhZ1wiLCBcImVuZFwiKSxcbiAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICBtb3VzZWRvd254LFxuICAgICAgbW91c2Vkb3dueSxcbiAgICAgIG1vdXNlbW92aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICBjbGlja0Rpc3RhbmNlMiA9IDA7XG5cbiAgZnVuY3Rpb24gZHJhZyhzZWxlY3Rpb24pIHtcbiAgICBzZWxlY3Rpb25cbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZ2VzdHVyZSA9IGJlZm9yZXN0YXJ0KFwibW91c2VcIiwgY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGQzU2VsZWN0aW9uLm1vdXNlLCB0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICghZ2VzdHVyZSkgcmV0dXJuO1xuICAgIGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xuICAgIG5vZHJhZyhkM1NlbGVjdGlvbi5ldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgbW91c2Vtb3ZpbmcgPSBmYWxzZTtcbiAgICBtb3VzZWRvd254ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WTtcbiAgICBnZXN0dXJlKFwic3RhcnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoIW1vdXNlbW92aW5nKSB7XG4gICAgICB2YXIgZHggPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRYIC0gbW91c2Vkb3dueCwgZHkgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuZHJhZyBtb3VzZXVwLmRyYWdcIiwgbnVsbCk7XG4gICAgeWVzZHJhZyhkM1NlbGVjdGlvbi5ldmVudC52aWV3LCBtb3VzZW1vdmluZyk7XG4gICAgbm9ldmVudCgpO1xuICAgIGdlc3R1cmVzLm1vdXNlKFwiZW5kXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlc1tpXS5pZGVudGlmaWVyLCBjLCBkM1NlbGVjdGlvbi50b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub2V2ZW50KCk7XG4gICAgICAgIGdlc3R1cmUoXCJkcmFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCA1MDApOyAvLyBHaG9zdCBjbGlja3MgYXJlIGRlbGF5ZWQhXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcImVuZFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWZvcmVzdGFydChpZCwgY29udGFpbmVyLCBwb2ludCwgdGhhdCwgYXJncykge1xuICAgIHZhciBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIHMsIGR4LCBkeSxcbiAgICAgICAgc3VibGlzdGVuZXJzID0gbGlzdGVuZXJzLmNvcHkoKTtcblxuICAgIGlmICghZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCBcImJlZm9yZXN0YXJ0XCIsIHMsIGlkLCBhY3RpdmUsIHBbMF0sIHBbMV0sIDAsIDAsIHN1Ymxpc3RlbmVycyksIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChkM1NlbGVjdGlvbi5ldmVudC5zdWJqZWN0ID0gcyA9IHN1YmplY3QuYXBwbHkodGhhdCwgYXJncykpID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBkcmFnKSA6IGZpbHRlcjtcbiAgfTtcblxuICBkcmFnLmNvbnRhaW5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250YWluZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBkcmFnKSA6IGNvbnRhaW5lcjtcbiAgfTtcblxuICBkcmFnLnN1YmplY3QgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3ViamVjdCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLnRvdWNoYWJsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0b3VjaGFibGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogdG91Y2hhYmxlO1xuICB9O1xuXG4gIGRyYWcub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gZHJhZyA6IHZhbHVlO1xuICB9O1xuXG4gIGRyYWcuY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgZHJhZykgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiBkcmFnO1xufVxuXG5leHBvcnRzLmRyYWcgPSBkcmFnO1xuZXhwb3J0cy5kcmFnRGlzYWJsZSA9IG5vZHJhZztcbmV4cG9ydHMuZHJhZ0VuYWJsZSA9IHllc2RyYWc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZHN2LyB2MS4yLjAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgRU9MID0ge30sXG4gICAgRU9GID0ge30sXG4gICAgUVVPVEUgPSAzNCxcbiAgICBORVdMSU5FID0gMTAsXG4gICAgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl0gfHwgXFxcIlxcXCJcIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxuZnVuY3Rpb24gcGFkKHZhbHVlLCB3aWR0aCkge1xuICB2YXIgcyA9IHZhbHVlICsgXCJcIiwgbGVuZ3RoID0gcy5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oMCkgKyBzIDogcztcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyKSB7XG4gIHJldHVybiB5ZWFyIDwgMCA/IFwiLVwiICsgcGFkKC15ZWFyLCA2KVxuICAgIDogeWVhciA+IDk5OTkgPyBcIitcIiArIHBhZCh5ZWFyLCA2KVxuICAgIDogcGFkKHllYXIsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgdmFyIGhvdXJzID0gZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgbWludXRlcyA9IGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgICAgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgbWlsbGlzZWNvbmRzID0gZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gXCJJbnZhbGlkIERhdGVcIlxuICAgICAgOiBmb3JtYXRZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDRGF0ZSgpLCAyKVxuICAgICAgKyAobWlsbGlzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiLlwiICsgcGFkKG1pbGxpc2Vjb25kcywgMykgKyBcIlpcIlxuICAgICAgOiBzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiWlwiXG4gICAgICA6IG1pbnV0ZXMgfHwgaG91cnMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiWlwiXG4gICAgICA6IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBkc3YoZGVsaW1pdGVyKSB7XG4gIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5cXHJdXCIpLFxuICAgICAgREVMSU1JVEVSID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xuICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgIH0pO1xuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgIHZhciByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgSSA9IDAsIC8vIGN1cnJlbnQgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgIG4gPSAwLCAvLyBjdXJyZW50IGxpbmUgbnVtYmVyXG4gICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgZW9mID0gTiA8PSAwLCAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPRj9cbiAgICAgICAgZW9sID0gZmFsc2U7IC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgLy8gU3RyaXAgdGhlIHRyYWlsaW5nIG5ld2xpbmUuXG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IE5FV0xJTkUpIC0tTjtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gUkVUVVJOKSAtLU47XG5cbiAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgIGlmIChlb2YpIHJldHVybiBFT0Y7XG4gICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcblxuICAgICAgLy8gVW5lc2NhcGUgcXVvdGVzLlxuICAgICAgdmFyIGksIGogPSBJLCBjO1xuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gUVVPVEUpIHtcbiAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpO1xuICAgICAgICBpZiAoKGkgPSBJKSA+PSBOKSBlb2YgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSAtIDEpLnJlcGxhY2UoL1wiXCIvZywgXCJcXFwiXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmUuXG4gICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBERUxJTUlURVIpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cbiAgICAgIHJldHVybiBlb2YgPSB0cnVlLCB0ZXh0LnNsaWNlKGosIE4pO1xuICAgIH1cblxuICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XG4gICAgICBpZiAoZiAmJiAocm93ID0gZihyb3csIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIFtjb2x1bW5zLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpXS5jb25jYXQocHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZm9ybWF0RGF0ZSh2YWx1ZSlcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHZhbHVlICs9IFwiXCIpID8gXCJcXFwiXCIgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHBhcnNlUm93czogcGFyc2VSb3dzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdEJvZHk6IGZvcm1hdEJvZHksXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93cyxcbiAgICBmb3JtYXRSb3c6IGZvcm1hdFJvdyxcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWVcbiAgfTtcbn1cblxudmFyIGNzdiA9IGRzdihcIixcIik7XG5cbnZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbnZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xudmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG52YXIgY3N2Rm9ybWF0Qm9keSA9IGNzdi5mb3JtYXRCb2R5O1xudmFyIGNzdkZvcm1hdFJvd3MgPSBjc3YuZm9ybWF0Um93cztcbnZhciBjc3ZGb3JtYXRSb3cgPSBjc3YuZm9ybWF0Um93O1xudmFyIGNzdkZvcm1hdFZhbHVlID0gY3N2LmZvcm1hdFZhbHVlO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG52YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG52YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbnZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xudmFyIHRzdkZvcm1hdEJvZHkgPSB0c3YuZm9ybWF0Qm9keTtcbnZhciB0c3ZGb3JtYXRSb3dzID0gdHN2LmZvcm1hdFJvd3M7XG52YXIgdHN2Rm9ybWF0Um93ID0gdHN2LmZvcm1hdFJvdztcbnZhciB0c3ZGb3JtYXRWYWx1ZSA9IHRzdi5mb3JtYXRWYWx1ZTtcblxuZnVuY3Rpb24gYXV0b1R5cGUob2JqZWN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XS50cmltKCksIG51bWJlciwgbTtcbiAgICBpZiAoIXZhbHVlKSB2YWx1ZSA9IG51bGw7XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB2YWx1ZSA9IHRydWU7XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikgdmFsdWUgPSBmYWxzZTtcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJOYU5cIikgdmFsdWUgPSBOYU47XG4gICAgZWxzZSBpZiAoIWlzTmFOKG51bWJlciA9ICt2YWx1ZSkpIHZhbHVlID0gbnVtYmVyO1xuICAgIGVsc2UgaWYgKG0gPSB2YWx1ZS5tYXRjaCgvXihbLStdXFxkezJ9KT9cXGR7NH0oLVxcZHsyfSgtXFxkezJ9KT8pPyhUXFxkezJ9OlxcZHsyfSg6XFxkezJ9KFxcLlxcZHszfSk/KT8oWnxbLStdXFxkezJ9OlxcZHsyfSk/KT8kLykpIHtcbiAgICAgIGlmIChmaXh0eiAmJiAhIW1bNF0gJiYgIW1bN10pIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvLS9nLCBcIi9cIikucmVwbGFjZSgvVC8sIFwiIFwiKTtcbiAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGNvbnRpbnVlO1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWRzdi9pc3N1ZXMvNDVcbnZhciBmaXh0eiA9IG5ldyBEYXRlKFwiMjAxOS0wMS0wMVQwMDowMFwiKS5nZXRIb3VycygpIHx8IG5ldyBEYXRlKFwiMjAxOS0wNy0wMVQwMDowMFwiKS5nZXRIb3VycygpO1xuXG5leHBvcnRzLmF1dG9UeXBlID0gYXV0b1R5cGU7XG5leHBvcnRzLmNzdkZvcm1hdCA9IGNzdkZvcm1hdDtcbmV4cG9ydHMuY3N2Rm9ybWF0Qm9keSA9IGNzdkZvcm1hdEJvZHk7XG5leHBvcnRzLmNzdkZvcm1hdFJvdyA9IGNzdkZvcm1hdFJvdztcbmV4cG9ydHMuY3N2Rm9ybWF0Um93cyA9IGNzdkZvcm1hdFJvd3M7XG5leHBvcnRzLmNzdkZvcm1hdFZhbHVlID0gY3N2Rm9ybWF0VmFsdWU7XG5leHBvcnRzLmNzdlBhcnNlID0gY3N2UGFyc2U7XG5leHBvcnRzLmNzdlBhcnNlUm93cyA9IGNzdlBhcnNlUm93cztcbmV4cG9ydHMuZHN2Rm9ybWF0ID0gZHN2O1xuZXhwb3J0cy50c3ZGb3JtYXQgPSB0c3ZGb3JtYXQ7XG5leHBvcnRzLnRzdkZvcm1hdEJvZHkgPSB0c3ZGb3JtYXRCb2R5O1xuZXhwb3J0cy50c3ZGb3JtYXRSb3cgPSB0c3ZGb3JtYXRSb3c7XG5leHBvcnRzLnRzdkZvcm1hdFJvd3MgPSB0c3ZGb3JtYXRSb3dzO1xuZXhwb3J0cy50c3ZGb3JtYXRWYWx1ZSA9IHRzdkZvcm1hdFZhbHVlO1xuZXhwb3J0cy50c3ZQYXJzZSA9IHRzdlBhcnNlO1xuZXhwb3J0cy50c3ZQYXJzZVJvd3MgPSB0c3ZQYXJzZVJvd3M7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZWFzZS8gdjEuMC42IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuICt0O1xufVxuXG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG5cbnZhciBleHBvbmVudCA9IDM7XG5cbnZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5T3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5T3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcbiAgfVxuXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlPdXQ7XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5SW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgZSkgOiAyIC0gTWF0aC5wb3coMiAtIHQsIGUpKSAvIDI7XG4gIH1cblxuICBwb2x5SW5PdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbk91dDtcbn0pKGV4cG9uZW50KTtcblxudmFyIHBpID0gTWF0aC5QSSxcbiAgICBoYWxmUGkgPSBwaSAvIDI7XG5cbmZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cblxuZnVuY3Rpb24gc2luT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc2luKHQgKiBoYWxmUGkpO1xufVxuXG5mdW5jdGlvbiBzaW5Jbk91dCh0KSB7XG4gIHJldHVybiAoMSAtIE1hdGguY29zKHBpICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gZXhwSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApO1xufVxuXG5mdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpO1xufVxuXG5mdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDIgLSBNYXRoLnBvdygyLCAxMCAtIDEwICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5mdW5jdGlvbiBjaXJjbGVPdXQodCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiBNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSAvIDI7XG59XG5cbnZhciBiMSA9IDQgLyAxMSxcbiAgICBiMiA9IDYgLyAxMSxcbiAgICBiMyA9IDggLyAxMSxcbiAgICBiNCA9IDMgLyA0LFxuICAgIGI1ID0gOSAvIDExLFxuICAgIGI2ID0gMTAgLyAxMSxcbiAgICBiNyA9IDE1IC8gMTYsXG4gICAgYjggPSAyMSAvIDIyLFxuICAgIGI5ID0gNjMgLyA2NCxcbiAgICBiMCA9IDEgLyBiMSAvIGIxO1xuXG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gIHJldHVybiAxIC0gYm91bmNlT3V0KDEgLSB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cblxudmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG5cbnZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG52YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja091dDtcbn0pKG92ZXJzaG9vdCk7XG5cbnZhciBiYWNrSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8IDEgPyB0ICogdCAqICgocyArIDEpICogdCAtIHMpIDogKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKSAvIDI7XG4gIH1cblxuICBiYWNrSW5PdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW5PdXQ7XG59KShvdmVyc2hvb3QpO1xuXG52YXIgdGF1ID0gMiAqIE1hdGguUEksXG4gICAgYW1wbGl0dWRlID0gMSxcbiAgICBwZXJpb2QgPSAwLjM7XG5cbnZhciBlbGFzdGljSW4gPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIDEwICogLS10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbjtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxudmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG52YXIgZWxhc3RpY0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCA9IHQgKiAyIC0gMSkgPCAwXG4gICAgICAgID8gYSAqIE1hdGgucG93KDIsIDEwICogdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcClcbiAgICAgICAgOiAyIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHMgKyB0KSAvIHApKSAvIDI7XG4gIH1cblxuICBlbGFzdGljSW5PdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW5PdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW5PdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbmV4cG9ydHMuZWFzZUJhY2sgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrSW4gPSBiYWNrSW47XG5leHBvcnRzLmVhc2VCYWNrSW5PdXQgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrT3V0ID0gYmFja091dDtcbmV4cG9ydHMuZWFzZUJvdW5jZSA9IGJvdW5jZU91dDtcbmV4cG9ydHMuZWFzZUJvdW5jZUluID0gYm91bmNlSW47XG5leHBvcnRzLmVhc2VCb3VuY2VJbk91dCA9IGJvdW5jZUluT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlT3V0ID0gYm91bmNlT3V0O1xuZXhwb3J0cy5lYXNlQ2lyY2xlID0gY2lyY2xlSW5PdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGVJbiA9IGNpcmNsZUluO1xuZXhwb3J0cy5lYXNlQ2lyY2xlSW5PdXQgPSBjaXJjbGVJbk91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZU91dCA9IGNpcmNsZU91dDtcbmV4cG9ydHMuZWFzZUN1YmljID0gY3ViaWNJbk91dDtcbmV4cG9ydHMuZWFzZUN1YmljSW4gPSBjdWJpY0luO1xuZXhwb3J0cy5lYXNlQ3ViaWNJbk91dCA9IGN1YmljSW5PdXQ7XG5leHBvcnRzLmVhc2VDdWJpY091dCA9IGN1YmljT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpYyA9IGVsYXN0aWNPdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljSW4gPSBlbGFzdGljSW47XG5leHBvcnRzLmVhc2VFbGFzdGljSW5PdXQgPSBlbGFzdGljSW5PdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljT3V0ID0gZWxhc3RpY091dDtcbmV4cG9ydHMuZWFzZUV4cCA9IGV4cEluT3V0O1xuZXhwb3J0cy5lYXNlRXhwSW4gPSBleHBJbjtcbmV4cG9ydHMuZWFzZUV4cEluT3V0ID0gZXhwSW5PdXQ7XG5leHBvcnRzLmVhc2VFeHBPdXQgPSBleHBPdXQ7XG5leHBvcnRzLmVhc2VMaW5lYXIgPSBsaW5lYXI7XG5leHBvcnRzLmVhc2VQb2x5ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlUG9seUluID0gcG9seUluO1xuZXhwb3J0cy5lYXNlUG9seUluT3V0ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlUG9seU91dCA9IHBvbHlPdXQ7XG5leHBvcnRzLmVhc2VRdWFkID0gcXVhZEluT3V0O1xuZXhwb3J0cy5lYXNlUXVhZEluID0gcXVhZEluO1xuZXhwb3J0cy5lYXNlUXVhZEluT3V0ID0gcXVhZEluT3V0O1xuZXhwb3J0cy5lYXNlUXVhZE91dCA9IHF1YWRPdXQ7XG5leHBvcnRzLmVhc2VTaW4gPSBzaW5Jbk91dDtcbmV4cG9ydHMuZWFzZVNpbkluID0gc2luSW47XG5leHBvcnRzLmVhc2VTaW5Jbk91dCA9IHNpbkluT3V0O1xuZXhwb3J0cy5lYXNlU2luT3V0ID0gc2luT3V0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWZldGNoLyB2MS4xLjIgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kc3YnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1kc3YnXSwgZmFjdG9yeSkgOlxuKGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0RzdikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJlc3BvbnNlQmxvYihyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbn1cblxuZnVuY3Rpb24gYmxvYihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VCbG9iKTtcbn1cblxuZnVuY3Rpb24gcmVzcG9uc2VBcnJheUJ1ZmZlcihyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG59XG5cbmZ1bmN0aW9uIGJ1ZmZlcihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VBcnJheUJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIHJlc3BvbnNlVGV4dChyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZnVuY3Rpb24gdGV4dChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VUZXh0KTtcbn1cblxuZnVuY3Rpb24gZHN2UGFyc2UocGFyc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpbml0LCByb3cpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgaW5pdCA9PT0gXCJmdW5jdGlvblwiKSByb3cgPSBpbml0LCBpbml0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICByZXR1cm4gcGFyc2UocmVzcG9uc2UsIHJvdyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRzdihkZWxpbWl0ZXIsIGlucHV0LCBpbml0LCByb3cpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgdmFyIGZvcm1hdCA9IGQzRHN2LmRzdkZvcm1hdChkZWxpbWl0ZXIpO1xuICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgIHJldHVybiBmb3JtYXQucGFyc2UocmVzcG9uc2UsIHJvdyk7XG4gIH0pO1xufVxuXG52YXIgY3N2ID0gZHN2UGFyc2UoZDNEc3YuY3N2UGFyc2UpO1xudmFyIHRzdiA9IGRzdlBhcnNlKGQzRHN2LnRzdlBhcnNlKTtcblxuZnVuY3Rpb24gaW1hZ2UoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5pdCkgaW1hZ2Vba2V5XSA9IGluaXRba2V5XTtcbiAgICBpbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyByZXNvbHZlKGltYWdlKTsgfTtcbiAgICBpbWFnZS5zcmMgPSBpbnB1dDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc3BvbnNlSnNvbihyZXNwb25zZSkge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzICsgXCIgXCIgKyByZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbn1cblxuZnVuY3Rpb24ganNvbihpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIGluaXQpLnRoZW4ocmVzcG9uc2VKc29uKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VyKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpbml0KSAge1xuICAgIHJldHVybiB0ZXh0KGlucHV0LCBpbml0KS50aGVuKGZ1bmN0aW9uKHRleHQkJDEpIHtcbiAgICAgIHJldHVybiAobmV3IERPTVBhcnNlcikucGFyc2VGcm9tU3RyaW5nKHRleHQkJDEsIHR5cGUpO1xuICAgIH0pO1xuICB9O1xufVxuXG52YXIgeG1sID0gcGFyc2VyKFwiYXBwbGljYXRpb24veG1sXCIpO1xuXG52YXIgaHRtbCA9IHBhcnNlcihcInRleHQvaHRtbFwiKTtcblxudmFyIHN2ZyA9IHBhcnNlcihcImltYWdlL3N2Zyt4bWxcIik7XG5cbmV4cG9ydHMuYmxvYiA9IGJsb2I7XG5leHBvcnRzLmJ1ZmZlciA9IGJ1ZmZlcjtcbmV4cG9ydHMuZHN2ID0gZHN2O1xuZXhwb3J0cy5jc3YgPSBjc3Y7XG5leHBvcnRzLnRzdiA9IHRzdjtcbmV4cG9ydHMuaW1hZ2UgPSBpbWFnZTtcbmV4cG9ydHMuanNvbiA9IGpzb247XG5leHBvcnRzLnRleHQgPSB0ZXh0O1xuZXhwb3J0cy54bWwgPSB4bWw7XG5leHBvcnRzLmh0bWwgPSBodG1sO1xuZXhwb3J0cy5zdmcgPSBzdmc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWZvcmNlLyB2MS4yLjEgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1xdWFkdHJlZScpLCByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXRpbWVyJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtcXVhZHRyZWUnLCAnZDMtY29sbGVjdGlvbicsICdkMy1kaXNwYXRjaCcsICdkMy10aW1lciddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzUXVhZHRyZWUsZDNDb2xsZWN0aW9uLGQzRGlzcGF0Y2gsZDNUaW1lcikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNlbnRlcih4LCB5KSB7XG4gIHZhciBub2RlcztcblxuICBpZiAoeCA9PSBudWxsKSB4ID0gMDtcbiAgaWYgKHkgPT0gbnVsbCkgeSA9IDA7XG5cbiAgZnVuY3Rpb24gZm9yY2UoKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHN4ID0gMCxcbiAgICAgICAgc3kgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBzeCArPSBub2RlLngsIHN5ICs9IG5vZGUueTtcbiAgICB9XG5cbiAgICBmb3IgKHN4ID0gc3ggLyBuIC0geCwgc3kgPSBzeSAvIG4gLSB5LCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnggLT0gc3gsIG5vZGUueSAtPSBzeTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArXywgZm9yY2UpIDogeDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSArXywgZm9yY2UpIDogeTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG5mdW5jdGlvbiBqaWdnbGUoKSB7XG4gIHJldHVybiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxZS02O1xufVxuXG5mdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueCArIGQudng7XG59XG5cbmZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55ICsgZC52eTtcbn1cblxuZnVuY3Rpb24gY29sbGlkZShyYWRpdXMpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgcmFkaWksXG4gICAgICBzdHJlbmd0aCA9IDEsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudChyYWRpdXMgPT0gbnVsbCA/IDEgOiArcmFkaXVzKTtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgeGksXG4gICAgICAgIHlpLFxuICAgICAgICByaSxcbiAgICAgICAgcmkyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIHRyZWUgPSBkM1F1YWR0cmVlLnF1YWR0cmVlKG5vZGVzLCB4LCB5KS52aXNpdEFmdGVyKHByZXBhcmUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHJpID0gcmFkaWlbbm9kZS5pbmRleF0sIHJpMiA9IHJpICogcmk7XG4gICAgICAgIHhpID0gbm9kZS54ICsgbm9kZS52eDtcbiAgICAgICAgeWkgPSBub2RlLnkgKyBub2RlLnZ5O1xuICAgICAgICB0cmVlLnZpc2l0KGFwcGx5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgdmFyIGRhdGEgPSBxdWFkLmRhdGEsIHJqID0gcXVhZC5yLCByID0gcmkgKyByajtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmluZGV4ID4gbm9kZS5pbmRleCkge1xuICAgICAgICAgIHZhciB4ID0geGkgLSBkYXRhLnggLSBkYXRhLnZ4LFxuICAgICAgICAgICAgICB5ID0geWkgLSBkYXRhLnkgLSBkYXRhLnZ5LFxuICAgICAgICAgICAgICBsID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgICBpZiAobCA8IHIgKiByKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xuICAgICAgICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUoKSwgbCArPSB5ICogeTtcbiAgICAgICAgICAgIGwgPSAociAtIChsID0gTWF0aC5zcXJ0KGwpKSkgLyBsICogc3RyZW5ndGg7XG4gICAgICAgICAgICBub2RlLnZ4ICs9ICh4ICo9IGwpICogKHIgPSAocmogKj0gcmopIC8gKHJpMiArIHJqKSk7XG4gICAgICAgICAgICBub2RlLnZ5ICs9ICh5ICo9IGwpICogcjtcbiAgICAgICAgICAgIGRhdGEudnggLT0geCAqIChyID0gMSAtIHIpO1xuICAgICAgICAgICAgZGF0YS52eSAtPSB5ICogcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgwID4geGkgKyByIHx8IHgxIDwgeGkgLSByIHx8IHkwID4geWkgKyByIHx8IHkxIDwgeWkgLSByO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmUocXVhZCkge1xuICAgIGlmIChxdWFkLmRhdGEpIHJldHVybiBxdWFkLnIgPSByYWRpaVtxdWFkLmRhdGEuaW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBxdWFkLnIgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAocXVhZFtpXSAmJiBxdWFkW2ldLnIgPiBxdWFkLnIpIHtcbiAgICAgICAgcXVhZC5yID0gcXVhZFtpXS5yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuICAgIHJhZGlpID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgcmFkaWlbbm9kZS5pbmRleF0gPSArcmFkaXVzKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9ICtfLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cblxuZnVuY3Rpb24gaW5kZXgoZCkge1xuICByZXR1cm4gZC5pbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZChub2RlQnlJZCwgbm9kZUlkKSB7XG4gIHZhciBub2RlID0gbm9kZUJ5SWQuZ2V0KG5vZGVJZCk7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBub2RlSWQpO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gbGluayhsaW5rcykge1xuICB2YXIgaWQgPSBpbmRleCxcbiAgICAgIHN0cmVuZ3RoID0gZGVmYXVsdFN0cmVuZ3RoLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgZGlzdGFuY2UgPSBjb25zdGFudCgzMCksXG4gICAgICBkaXN0YW5jZXMsXG4gICAgICBub2RlcyxcbiAgICAgIGNvdW50LFxuICAgICAgYmlhcyxcbiAgICAgIGl0ZXJhdGlvbnMgPSAxO1xuXG4gIGlmIChsaW5rcyA9PSBudWxsKSBsaW5rcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTdHJlbmd0aChsaW5rKSB7XG4gICAgcmV0dXJuIDEgLyBNYXRoLm1pbihjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0sIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGsgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGluaywgc291cmNlLCB0YXJnZXQsIHgsIHksIGwsIGI7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbGluayA9IGxpbmtzW2ldLCBzb3VyY2UgPSBsaW5rLnNvdXJjZSwgdGFyZ2V0ID0gbGluay50YXJnZXQ7XG4gICAgICAgIHggPSB0YXJnZXQueCArIHRhcmdldC52eCAtIHNvdXJjZS54IC0gc291cmNlLnZ4IHx8IGppZ2dsZSgpO1xuICAgICAgICB5ID0gdGFyZ2V0LnkgKyB0YXJnZXQudnkgLSBzb3VyY2UueSAtIHNvdXJjZS52eSB8fCBqaWdnbGUoKTtcbiAgICAgICAgbCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgbCA9IChsIC0gZGlzdGFuY2VzW2ldKSAvIGwgKiBhbHBoYSAqIHN0cmVuZ3Roc1tpXTtcbiAgICAgICAgeCAqPSBsLCB5ICo9IGw7XG4gICAgICAgIHRhcmdldC52eCAtPSB4ICogKGIgPSBiaWFzW2ldKTtcbiAgICAgICAgdGFyZ2V0LnZ5IC09IHkgKiBiO1xuICAgICAgICBzb3VyY2UudnggKz0geCAqIChiID0gMSAtIGIpO1xuICAgICAgICBzb3VyY2UudnkgKz0geSAqIGI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgbSA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgbm9kZUJ5SWQgPSBkM0NvbGxlY3Rpb24ubWFwKG5vZGVzLCBpZCksXG4gICAgICAgIGxpbms7XG5cbiAgICBmb3IgKGkgPSAwLCBjb3VudCA9IG5ldyBBcnJheShuKTsgaSA8IG07ICsraSkge1xuICAgICAgbGluayA9IGxpbmtzW2ldLCBsaW5rLmluZGV4ID0gaTtcbiAgICAgIGlmICh0eXBlb2YgbGluay5zb3VyY2UgIT09IFwib2JqZWN0XCIpIGxpbmsuc291cmNlID0gZmluZChub2RlQnlJZCwgbGluay5zb3VyY2UpO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rLnRhcmdldCAhPT0gXCJvYmplY3RcIikgbGluay50YXJnZXQgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnRhcmdldCk7XG4gICAgICBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gPSAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdIHx8IDApICsgMTtcbiAgICAgIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSA9IChjb3VudFtsaW5rLnRhcmdldC5pbmRleF0gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGJpYXMgPSBuZXcgQXJyYXkobSk7IGkgPCBtOyArK2kpIHtcbiAgICAgIGxpbmsgPSBsaW5rc1tpXSwgYmlhc1tpXSA9IGNvdW50W2xpbmsuc291cmNlLmluZGV4XSAvIChjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gKyBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0pO1xuICAgIH1cblxuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShtKSwgaW5pdGlhbGl6ZVN0cmVuZ3RoKCk7XG4gICAgZGlzdGFuY2VzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplRGlzdGFuY2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVTdHJlbmd0aCgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gK3N0cmVuZ3RoKGxpbmtzW2ldLCBpLCBsaW5rcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZURpc3RhbmNlKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBkaXN0YW5jZXNbaV0gPSArZGlzdGFuY2UobGlua3NbaV0sIGksIGxpbmtzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UubGlua3MgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGlua3MgPSBfLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IGxpbmtzO1xuICB9O1xuXG4gIGZvcmNlLmlkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gXywgZm9yY2UpIDogaWQ7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZVN0cmVuZ3RoKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemVEaXN0YW5jZSgpLCBmb3JjZSkgOiBkaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG5cbmZ1bmN0aW9uIHgkMShkKSB7XG4gIHJldHVybiBkLng7XG59XG5cbmZ1bmN0aW9uIHkkMShkKSB7XG4gIHJldHVybiBkLnk7XG59XG5cbnZhciBpbml0aWFsUmFkaXVzID0gMTAsXG4gICAgaW5pdGlhbEFuZ2xlID0gTWF0aC5QSSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcblxuZnVuY3Rpb24gc2ltdWxhdGlvbihub2Rlcykge1xuICB2YXIgc2ltdWxhdGlvbixcbiAgICAgIGFscGhhID0gMSxcbiAgICAgIGFscGhhTWluID0gMC4wMDEsXG4gICAgICBhbHBoYURlY2F5ID0gMSAtIE1hdGgucG93KGFscGhhTWluLCAxIC8gMzAwKSxcbiAgICAgIGFscGhhVGFyZ2V0ID0gMCxcbiAgICAgIHZlbG9jaXR5RGVjYXkgPSAwLjYsXG4gICAgICBmb3JjZXMgPSBkM0NvbGxlY3Rpb24ubWFwKCksXG4gICAgICBzdGVwcGVyID0gZDNUaW1lci50aW1lcihzdGVwKSxcbiAgICAgIGV2ZW50ID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInRpY2tcIiwgXCJlbmRcIik7XG5cbiAgaWYgKG5vZGVzID09IG51bGwpIG5vZGVzID0gW107XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICB0aWNrKCk7XG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XG4gICAgaWYgKGFscGhhIDwgYWxwaGFNaW4pIHtcbiAgICAgIHN0ZXBwZXIuc3RvcCgpO1xuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcblxuICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAxO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGFscGhhICs9IChhbHBoYVRhcmdldCAtIGFscGhhKSAqIGFscGhhRGVjYXk7XG5cbiAgICAgIGZvcmNlcy5lYWNoKGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICBmb3JjZShhbHBoYSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmZ4ID09IG51bGwpIG5vZGUueCArPSBub2RlLnZ4ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS54ID0gbm9kZS5meCwgbm9kZS52eCA9IDA7XG4gICAgICAgIGlmIChub2RlLmZ5ID09IG51bGwpIG5vZGUueSArPSBub2RlLnZ5ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS55ID0gbm9kZS5meSwgbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbXVsYXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZXMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS5pbmRleCA9IGk7XG4gICAgICBpZiAobm9kZS5meCAhPSBudWxsKSBub2RlLnggPSBub2RlLmZ4O1xuICAgICAgaWYgKG5vZGUuZnkgIT0gbnVsbCkgbm9kZS55ID0gbm9kZS5meTtcbiAgICAgIGlmIChpc05hTihub2RlLngpIHx8IGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGluaXRpYWxSYWRpdXMgKiBNYXRoLnNxcnQoaSksIGFuZ2xlID0gaSAqIGluaXRpYWxBbmdsZTtcbiAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYU4obm9kZS52eCkgfHwgaXNOYU4obm9kZS52eSkpIHtcbiAgICAgICAgbm9kZS52eCA9IG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xuICAgIGlmIChmb3JjZS5pbml0aWFsaXplKSBmb3JjZS5pbml0aWFsaXplKG5vZGVzKTtcbiAgICByZXR1cm4gZm9yY2U7XG4gIH1cblxuICBpbml0aWFsaXplTm9kZXMoKTtcblxuICByZXR1cm4gc2ltdWxhdGlvbiA9IHtcbiAgICB0aWNrOiB0aWNrLFxuXG4gICAgcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5yZXN0YXJ0KHN0ZXApLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnN0b3AoKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgbm9kZXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVzID0gXywgaW5pdGlhbGl6ZU5vZGVzKCksIGZvcmNlcy5lYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogbm9kZXM7XG4gICAgfSxcblxuICAgIGFscGhhOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhO1xuICAgIH0sXG5cbiAgICBhbHBoYU1pbjogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFNaW4gPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYU1pbjtcbiAgICB9LFxuXG4gICAgYWxwaGFEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFEZWNheSA9ICtfLCBzaW11bGF0aW9uKSA6ICthbHBoYURlY2F5O1xuICAgIH0sXG5cbiAgICBhbHBoYVRhcmdldDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFUYXJnZXQgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYVRhcmdldDtcbiAgICB9LFxuXG4gICAgdmVsb2NpdHlEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmVsb2NpdHlEZWNheSA9IDEgLSBfLCBzaW11bGF0aW9uKSA6IDEgLSB2ZWxvY2l0eURlY2F5O1xuICAgIH0sXG5cbiAgICBmb3JjZTogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKChfID09IG51bGwgPyBmb3JjZXMucmVtb3ZlKG5hbWUpIDogZm9yY2VzLnNldChuYW1lLCBpbml0aWFsaXplRm9yY2UoXykpKSwgc2ltdWxhdGlvbikgOiBmb3JjZXMuZ2V0KG5hbWUpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5LFxuICAgICAgICAgIGQyLFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgY2xvc2VzdDtcblxuICAgICAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgICAgIGVsc2UgcmFkaXVzICo9IHJhZGl1cztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGR4ID0geCAtIG5vZGUueDtcbiAgICAgICAgZHkgPSB5IC0gbm9kZS55O1xuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZDIgPCByYWRpdXMpIGNsb3Nlc3QgPSBub2RlLCByYWRpdXMgPSBkMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoZXZlbnQub24obmFtZSwgXyksIHNpbXVsYXRpb24pIDogZXZlbnQub24obmFtZSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYW55Qm9keSgpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgbm9kZSxcbiAgICAgIGFscGhhLFxuICAgICAgc3RyZW5ndGggPSBjb25zdGFudCgtMzApLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgZGlzdGFuY2VNaW4yID0gMSxcbiAgICAgIGRpc3RhbmNlTWF4MiA9IEluZmluaXR5LFxuICAgICAgdGhldGEyID0gMC44MTtcblxuICBmdW5jdGlvbiBmb3JjZShfKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIHRyZWUgPSBkM1F1YWR0cmVlLnF1YWR0cmVlKG5vZGVzLCB4JDEsIHkkMSkudmlzaXRBZnRlcihhY2N1bXVsYXRlKTtcbiAgICBmb3IgKGFscGhhID0gXywgaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgdHJlZS52aXNpdChhcHBseSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCBzdHJlbmd0aHNbbm9kZS5pbmRleF0gPSArc3RyZW5ndGgobm9kZSwgaSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjdW11bGF0ZShxdWFkKSB7XG4gICAgdmFyIHN0cmVuZ3RoID0gMCwgcSwgYywgd2VpZ2h0ID0gMCwgeCwgeSwgaTtcblxuICAgIC8vIEZvciBpbnRlcm5hbCBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjaGlsZCBxdWFkcmFudHMuXG4gICAgaWYgKHF1YWQubGVuZ3RoKSB7XG4gICAgICBmb3IgKHggPSB5ID0gaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgaWYgKChxID0gcXVhZFtpXSkgJiYgKGMgPSBNYXRoLmFicyhxLnZhbHVlKSkpIHtcbiAgICAgICAgICBzdHJlbmd0aCArPSBxLnZhbHVlLCB3ZWlnaHQgKz0gYywgeCArPSBjICogcS54LCB5ICs9IGMgKiBxLnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1YWQueCA9IHggLyB3ZWlnaHQ7XG4gICAgICBxdWFkLnkgPSB5IC8gd2VpZ2h0O1xuICAgIH1cblxuICAgIC8vIEZvciBsZWFmIG5vZGVzLCBhY2N1bXVsYXRlIGZvcmNlcyBmcm9tIGNvaW5jaWRlbnQgcXVhZHJhbnRzLlxuICAgIGVsc2Uge1xuICAgICAgcSA9IHF1YWQ7XG4gICAgICBxLnggPSBxLmRhdGEueDtcbiAgICAgIHEueSA9IHEuZGF0YS55O1xuICAgICAgZG8gc3RyZW5ndGggKz0gc3RyZW5ndGhzW3EuZGF0YS5pbmRleF07XG4gICAgICB3aGlsZSAocSA9IHEubmV4dCk7XG4gICAgfVxuXG4gICAgcXVhZC52YWx1ZSA9IHN0cmVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDEsIF8sIHgyKSB7XG4gICAgaWYgKCFxdWFkLnZhbHVlKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciB4ID0gcXVhZC54IC0gbm9kZS54LFxuICAgICAgICB5ID0gcXVhZC55IC0gbm9kZS55LFxuICAgICAgICB3ID0geDIgLSB4MSxcbiAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAvLyBBcHBseSB0aGUgQmFybmVzLUh1dCBhcHByb3hpbWF0aW9uIGlmIHBvc3NpYmxlLlxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxuICAgIGlmICh3ICogdyAvIHRoZXRhMiA8IGwpIHtcbiAgICAgIGlmIChsIDwgZGlzdGFuY2VNYXgyKSB7XG4gICAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKCksIGwgKz0geCAqIHg7XG4gICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKCksIGwgKz0geSAqIHk7XG4gICAgICAgIGlmIChsIDwgZGlzdGFuY2VNaW4yKSBsID0gTWF0aC5zcXJ0KGRpc3RhbmNlTWluMiAqIGwpO1xuICAgICAgICBub2RlLnZ4ICs9IHggKiBxdWFkLnZhbHVlICogYWxwaGEgLyBsO1xuICAgICAgICBub2RlLnZ5ICs9IHkgKiBxdWFkLnZhbHVlICogYWxwaGEgLyBsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIHBvaW50cyBkaXJlY3RseS5cbiAgICBlbHNlIGlmIChxdWFkLmxlbmd0aCB8fCBsID49IGRpc3RhbmNlTWF4MikgcmV0dXJuO1xuXG4gICAgLy8gTGltaXQgZm9yY2VzIGZvciB2ZXJ5IGNsb3NlIG5vZGVzOyByYW5kb21pemUgZGlyZWN0aW9uIGlmIGNvaW5jaWRlbnQuXG4gICAgaWYgKHF1YWQuZGF0YSAhPT0gbm9kZSB8fCBxdWFkLm5leHQpIHtcbiAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKCksIGwgKz0geCAqIHg7XG4gICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZSgpLCBsICs9IHkgKiB5O1xuICAgICAgaWYgKGwgPCBkaXN0YW5jZU1pbjIpIGwgPSBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yICogbCk7XG4gICAgfVxuXG4gICAgZG8gaWYgKHF1YWQuZGF0YSAhPT0gbm9kZSkge1xuICAgICAgdyA9IHN0cmVuZ3Roc1txdWFkLmRhdGEuaW5kZXhdICogYWxwaGEgLyBsO1xuICAgICAgbm9kZS52eCArPSB4ICogdztcbiAgICAgIG5vZGUudnkgKz0geSAqIHc7XG4gICAgfSB3aGlsZSAocXVhZCA9IHF1YWQubmV4dCk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5kaXN0YW5jZU1pbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZU1pbjIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KGRpc3RhbmNlTWluMik7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNYXggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNYXgyID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1heDIpO1xuICB9O1xuXG4gIGZvcmNlLnRoZXRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoZXRhMiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQodGhldGEyKTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG5cbmZ1bmN0aW9uIHJhZGlhbChyYWRpdXMsIHgsIHkpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgcmFkaXVzZXM7XG5cbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQoK3JhZGl1cyk7XG4gIGlmICh4ID09IG51bGwpIHggPSAwO1xuICBpZiAoeSA9PSBudWxsKSB5ID0gMDtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldLFxuICAgICAgICAgIGR4ID0gbm9kZS54IC0geCB8fCAxZS02LFxuICAgICAgICAgIGR5ID0gbm9kZS55IC0geSB8fCAxZS02LFxuICAgICAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpLFxuICAgICAgICAgIGsgPSAocmFkaXVzZXNbaV0gLSByKSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhIC8gcjtcbiAgICAgIG5vZGUudnggKz0gZHggKiBrO1xuICAgICAgbm9kZS52eSArPSBkeSAqIGs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHJhZGl1c2VzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHJhZGl1c2VzW2ldID0gK3JhZGl1cyhub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4ocmFkaXVzZXNbaV0pID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfLCBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9ICtfLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9ICtfLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cblxuZnVuY3Rpb24geCQyKHgpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeHo7XG5cbiAgaWYgKHR5cGVvZiB4ICE9PSBcImZ1bmN0aW9uXCIpIHggPSBjb25zdGFudCh4ID09IG51bGwgPyAwIDogK3gpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eCArPSAoeHpbaV0gLSBub2RlLngpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHh6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHh6W2ldID0gK3gobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeDtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG5cbmZ1bmN0aW9uIHkkMih5KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHl6O1xuXG4gIGlmICh0eXBlb2YgeSAhPT0gXCJmdW5jdGlvblwiKSB5ID0gY29uc3RhbnQoeSA9PSBudWxsID8gMCA6ICt5KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnkgKz0gKHl6W2ldIC0gbm9kZS55KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB5eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih5eltpXSA9ICt5KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuXG5leHBvcnRzLmZvcmNlQ2VudGVyID0gY2VudGVyO1xuZXhwb3J0cy5mb3JjZUNvbGxpZGUgPSBjb2xsaWRlO1xuZXhwb3J0cy5mb3JjZUxpbmsgPSBsaW5rO1xuZXhwb3J0cy5mb3JjZU1hbnlCb2R5ID0gbWFueUJvZHk7XG5leHBvcnRzLmZvcmNlUmFkaWFsID0gcmFkaWFsO1xuZXhwb3J0cy5mb3JjZVNpbXVsYXRpb24gPSBzaW11bGF0aW9uO1xuZXhwb3J0cy5mb3JjZVggPSB4JDI7XG5leHBvcnRzLmZvcmNlWSA9IHkkMjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZm9ybWF0LyB2MS40LjMgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxuZnVuY3Rpb24gZm9ybWF0RGVjaW1hbCh4LCBwKSB7XG4gIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgcmV0dXJuIFtcbiAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICt4LnNsaWNlKGkgKyAxKVxuICBdO1xufVxuXG5mdW5jdGlvbiBleHBvbmVudCh4KSB7XG4gIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbChNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRHcm91cChncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXROdW1lcmFscyhudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gW1tmaWxsXWFsaWduXVtzaWduXVtzeW1ib2xdWzBdW3dpZHRoXVssXVsucHJlY2lzaW9uXVt+XVt0eXBlXVxudmFyIHJlID0gL14oPzooLik/KFs8Pj1eXSkpPyhbK1xcLSggXSk/KFskI10pPygwKT8oXFxkKyk/KCwpPyhcXC5cXGQrKT8ofik/KFthLXolXSk/JC9pO1xuXG5mdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcbiAgdmFyIG1hdGNoO1xuICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcih7XG4gICAgZmlsbDogbWF0Y2hbMV0sXG4gICAgYWxpZ246IG1hdGNoWzJdLFxuICAgIHNpZ246IG1hdGNoWzNdLFxuICAgIHN5bWJvbDogbWF0Y2hbNF0sXG4gICAgemVybzogbWF0Y2hbNV0sXG4gICAgd2lkdGg6IG1hdGNoWzZdLFxuICAgIGNvbW1hOiBtYXRjaFs3XSxcbiAgICBwcmVjaXNpb246IG1hdGNoWzhdICYmIG1hdGNoWzhdLnNsaWNlKDEpLFxuICAgIHRyaW06IG1hdGNoWzldLFxuICAgIHR5cGU6IG1hdGNoWzEwXVxuICB9KTtcbn1cblxuZm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZSA9IEZvcm1hdFNwZWNpZmllci5wcm90b3R5cGU7IC8vIGluc3RhbmNlb2ZcblxuZnVuY3Rpb24gRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICB0aGlzLmZpbGwgPSBzcGVjaWZpZXIuZmlsbCA9PT0gdW5kZWZpbmVkID8gXCIgXCIgOiBzcGVjaWZpZXIuZmlsbCArIFwiXCI7XG4gIHRoaXMuYWxpZ24gPSBzcGVjaWZpZXIuYWxpZ24gPT09IHVuZGVmaW5lZCA/IFwiPlwiIDogc3BlY2lmaWVyLmFsaWduICsgXCJcIjtcbiAgdGhpcy5zaWduID0gc3BlY2lmaWVyLnNpZ24gPT09IHVuZGVmaW5lZCA/IFwiLVwiIDogc3BlY2lmaWVyLnNpZ24gKyBcIlwiO1xuICB0aGlzLnN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBzcGVjaWZpZXIuc3ltYm9sICsgXCJcIjtcbiAgdGhpcy56ZXJvID0gISFzcGVjaWZpZXIuemVybztcbiAgdGhpcy53aWR0aCA9IHNwZWNpZmllci53aWR0aCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci53aWR0aDtcbiAgdGhpcy5jb21tYSA9ICEhc3BlY2lmaWVyLmNvbW1hO1xuICB0aGlzLnByZWNpc2lvbiA9IHNwZWNpZmllci5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6ICtzcGVjaWZpZXIucHJlY2lzaW9uO1xuICB0aGlzLnRyaW0gPSAhIXNwZWNpZmllci50cmltO1xuICB0aGlzLnR5cGUgPSBzcGVjaWZpZXIudHlwZSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci50eXBlICsgXCJcIjtcbn1cblxuRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5maWxsXG4gICAgICArIHRoaXMuYWxpZ25cbiAgICAgICsgdGhpcy5zaWduXG4gICAgICArIHRoaXMuc3ltYm9sXG4gICAgICArICh0aGlzLnplcm8gPyBcIjBcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLndpZHRoID09PSB1bmRlZmluZWQgPyBcIlwiIDogTWF0aC5tYXgoMSwgdGhpcy53aWR0aCB8IDApKVxuICAgICAgKyAodGhpcy5jb21tYSA/IFwiLFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMucHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCIuXCIgKyBNYXRoLm1heCgwLCB0aGlzLnByZWNpc2lvbiB8IDApKVxuICAgICAgKyAodGhpcy50cmltID8gXCJ+XCIgOiBcIlwiKVxuICAgICAgKyB0aGlzLnR5cGU7XG59O1xuXG4vLyBUcmltcyBpbnNpZ25pZmljYW50IHplcm9zLCBlLmcuLCByZXBsYWNlcyAxLjIwMDBrIHdpdGggMS4yay5cbmZ1bmN0aW9uIGZvcm1hdFRyaW0ocykge1xuICBvdXQ6IGZvciAodmFyIG4gPSBzLmxlbmd0aCwgaSA9IDEsIGkwID0gLTEsIGkxOyBpIDwgbjsgKytpKSB7XG4gICAgc3dpdGNoIChzW2ldKSB7XG4gICAgICBjYXNlIFwiLlwiOiBpMCA9IGkxID0gaTsgYnJlYWs7XG4gICAgICBjYXNlIFwiMFwiOiBpZiAoaTAgPT09IDApIGkwID0gaTsgaTEgPSBpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IGlmICghK3NbaV0pIGJyZWFrIG91dDsgaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkwID4gMCA/IHMuc2xpY2UoMCwgaTApICsgcy5zbGljZShpMSArIDEpIDogcztcbn1cblxudmFyIHByZWZpeEV4cG9uZW50O1xuXG5mdW5jdGlvbiBmb3JtYXRQcmVmaXhBdXRvKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsKHgsIE1hdGgubWF4KDAsIHAgKyBpIC0gMSkpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJvdW5kZWQoeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWwoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdO1xuICByZXR1cm4gZXhwb25lbnQgPCAwID8gXCIwLlwiICsgbmV3IEFycmF5KC1leHBvbmVudCkuam9pbihcIjBcIikgKyBjb2VmZmljaWVudFxuICAgICAgOiBjb2VmZmljaWVudC5sZW5ndGggPiBleHBvbmVudCArIDEgPyBjb2VmZmljaWVudC5zbGljZSgwLCBleHBvbmVudCArIDEpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShleHBvbmVudCArIDEpXG4gICAgICA6IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGV4cG9uZW50IC0gY29lZmZpY2llbnQubGVuZ3RoICsgMikuam9pbihcIjBcIik7XG59XG5cbnZhciBmb3JtYXRUeXBlcyA9IHtcbiAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxufTtcblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxudmFyIG1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAsXG4gICAgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBncm91cCA9IGxvY2FsZS5ncm91cGluZyA9PT0gdW5kZWZpbmVkIHx8IGxvY2FsZS50aG91c2FuZHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0R3JvdXAobWFwLmNhbGwobG9jYWxlLmdyb3VwaW5nLCBOdW1iZXIpLCBsb2NhbGUudGhvdXNhbmRzICsgXCJcIiksXG4gICAgICBjdXJyZW5jeVByZWZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVswXSArIFwiXCIsXG4gICAgICBjdXJyZW5jeVN1ZmZpeCA9IGxvY2FsZS5jdXJyZW5jeSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGxvY2FsZS5jdXJyZW5jeVsxXSArIFwiXCIsXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwgPT09IHVuZGVmaW5lZCA/IFwiLlwiIDogbG9jYWxlLmRlY2ltYWwgKyBcIlwiLFxuICAgICAgbnVtZXJhbHMgPSBsb2NhbGUubnVtZXJhbHMgPT09IHVuZGVmaW5lZCA/IGlkZW50aXR5IDogZm9ybWF0TnVtZXJhbHMobWFwLmNhbGwobG9jYWxlLm51bWVyYWxzLCBTdHJpbmcpKSxcbiAgICAgIHBlcmNlbnQgPSBsb2NhbGUucGVyY2VudCA9PT0gdW5kZWZpbmVkID8gXCIlXCIgOiBsb2NhbGUucGVyY2VudCArIFwiXCIsXG4gICAgICBtaW51cyA9IGxvY2FsZS5taW51cyA9PT0gdW5kZWZpbmVkID8gXCItXCIgOiBsb2NhbGUubWludXMgKyBcIlwiLFxuICAgICAgbmFuID0gbG9jYWxlLm5hbiA9PT0gdW5kZWZpbmVkID8gXCJOYU5cIiA6IGxvY2FsZS5uYW4gKyBcIlwiO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcbiAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICB0cmltID0gc3BlY2lmaWVyLnRyaW0sXG4gICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIFRoZSBcIlwiIHR5cGUsIGFuZCBhbnkgaW52YWxpZCB0eXBlLCBpcyBhbiBhbGlhcyBmb3IgXCIuMTJ+Z1wiLlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgcHJlY2lzaW9uID09PSB1bmRlZmluZWQgJiYgKHByZWNpc2lvbiA9IDEyKSwgdHJpbSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVByZWZpeCA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5U3VmZml4IDogL1slcF0vLnRlc3QodHlwZSkgPyBwZXJjZW50IDogXCJcIjtcblxuICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICBtYXliZVN1ZmZpeCA9IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IDZcbiAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXgsXG4gICAgICAgICAgaSwgbiwgYztcblxuICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMDtcbiAgICAgICAgdmFsdWUgPSBpc05hTih2YWx1ZSkgPyBuYW4gOiBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gZHVyaW5nIGZvcm1hdHRpbmcsIHRyZWF0IGFzIHBvc2l0aXZlLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDApIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBtaW51cykgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuXG4gICAgICAgIHZhbHVlU3VmZml4ID0gKHR5cGUgPT09IFwic1wiID8gcHJlZml4ZXNbOCArIHByZWZpeEV4cG9uZW50IC8gM10gOiBcIlwiKSArIHZhbHVlU3VmZml4ICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI9XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJeXCI6IHZhbHVlID0gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHZhbHVlID0gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudW1lcmFscyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgdmFyIGYgPSBuZXdGb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzLFxuICAgICAgICBrID0gTWF0aC5wb3coMTAsIC1lKSxcbiAgICAgICAgcHJlZml4ID0gcHJlZml4ZXNbOCArIGUgLyAzXTtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmKGsgKiB2YWx1ZSkgKyBwcmVmaXg7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBuZXdGb3JtYXQsXG4gICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgfTtcbn1cblxudmFyIGxvY2FsZTtcblxuZGVmYXVsdExvY2FsZSh7XG4gIGRlY2ltYWw6IFwiLlwiLFxuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXSxcbiAgbWludXM6IFwiLVwiXG59KTtcblxuZnVuY3Rpb24gZGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIGxvY2FsZSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBleHBvcnRzLmZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gIHJldHVybiBsb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHByZWNpc2lvbkZpeGVkKHN0ZXApIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufVxuXG5mdW5jdGlvbiBwcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cblxuZnVuY3Rpb24gcHJlY2lzaW9uUm91bmQoc3RlcCwgbWF4KSB7XG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbn1cblxuZXhwb3J0cy5Gb3JtYXRTcGVjaWZpZXIgPSBGb3JtYXRTcGVjaWZpZXI7XG5leHBvcnRzLmZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuZXhwb3J0cy5mb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGU7XG5leHBvcnRzLmZvcm1hdFNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcjtcbmV4cG9ydHMucHJlY2lzaW9uRml4ZWQgPSBwcmVjaXNpb25GaXhlZDtcbmV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuZXhwb3J0cy5wcmVjaXNpb25Sb3VuZCA9IHByZWNpc2lvblJvdW5kO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWdlby8gdjEuMTEuOSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtYXJyYXknXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0FycmF5KSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQWRkcyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHdpdGggdHdpY2UgdGhlIG5vcm1hbCBwcmVjaXNpb24uXG4vLyBSZWZlcmVuY2U6IEouIFIuIFNoZXdjaHVrLCBBZGFwdGl2ZSBQcmVjaXNpb24gRmxvYXRpbmctUG9pbnQgQXJpdGhtZXRpYyBhbmRcbi8vIEZhc3QgUm9idXN0IEdlb21ldHJpYyBQcmVkaWNhdGVzLCBEaXNjcmV0ZSAmIENvbXB1dGF0aW9uYWwgR2VvbWV0cnkgMTgoMylcbi8vIDMwNeKAkzM2MyAoMTk5NykuXG4vLyBDb2RlIGFkYXB0ZWQgZnJvbSBHZW9ncmFwaGljTGliIGJ5IENoYXJsZXMgRi4gRi4gS2FybmV5LFxuLy8gaHR0cDovL2dlb2dyYXBoaWNsaWIuc291cmNlZm9yZ2UubmV0L1xuXG5mdW5jdGlvbiBhZGRlcigpIHtcbiAgcmV0dXJuIG5ldyBBZGRlcjtcbn1cblxuZnVuY3Rpb24gQWRkZXIoKSB7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuQWRkZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQWRkZXIsXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnMgPSAvLyByb3VuZGVkIHZhbHVlXG4gICAgdGhpcy50ID0gMDsgLy8gZXhhY3QgZXJyb3JcbiAgfSxcbiAgYWRkOiBmdW5jdGlvbih5KSB7XG4gICAgYWRkKHRlbXAsIHksIHRoaXMudCk7XG4gICAgYWRkKHRoaXMsIHRlbXAucywgdGhpcy5zKTtcbiAgICBpZiAodGhpcy5zKSB0aGlzLnQgKz0gdGVtcC50O1xuICAgIGVsc2UgdGhpcy5zID0gdGVtcC50O1xuICB9LFxuICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG59O1xuXG52YXIgdGVtcCA9IG5ldyBBZGRlcjtcblxuZnVuY3Rpb24gYWRkKGFkZGVyLCBhLCBiKSB7XG4gIHZhciB4ID0gYWRkZXIucyA9IGEgKyBiLFxuICAgICAgYnYgPSB4IC0gYSxcbiAgICAgIGF2ID0geCAtIGJ2O1xuICBhZGRlci50ID0gKGEgLSBhdikgKyAoYiAtIGJ2KTtcbn1cblxudmFyIGVwc2lsb24gPSAxZS02O1xudmFyIGVwc2lsb24yID0gMWUtMTI7XG52YXIgcGkgPSBNYXRoLlBJO1xudmFyIGhhbGZQaSA9IHBpIC8gMjtcbnZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG52YXIgdGF1ID0gcGkgKiAyO1xuXG52YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xudmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGF0YW4gPSBNYXRoLmF0YW47XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZXhwID0gTWF0aC5leHA7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIHRhbiA9IE1hdGgudGFuO1xuXG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xufVxuXG5mdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICBzdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn1cblxudmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9LFxuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn07XG5cbnZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW0uc3BoZXJlKCk7XG4gIH0sXG4gIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0pO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICBzdHJlYW0ubGluZUVuZCgpO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBzdHJlYW0pIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAxKTtcbiAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbn1cblxuZnVuY3Rpb24gZ2VvU3RyZWFtKG9iamVjdCwgc3RyZWFtKSB7XG4gIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBhcmVhUmluZ1N1bSA9IGFkZGVyKCk7XG5cbnZhciBhcmVhU3VtID0gYWRkZXIoKSxcbiAgICBsYW1iZGEwMCxcbiAgICBwaGkwMCxcbiAgICBsYW1iZGEwLFxuICAgIGNvc1BoaTAsXG4gICAgc2luUGhpMDtcblxudmFyIGFyZWFTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVJpbmdTdW0ucmVzZXQoKTtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQ7XG4gICAgYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhUmluZyA9ICthcmVhUmluZ1N1bTtcbiAgICBhcmVhU3VtLmFkZChhcmVhUmluZyA8IDAgPyB0YXUgKyBhcmVhUmluZyA6IGFyZWFSaW5nKTtcbiAgICB0aGlzLmxpbmVTdGFydCA9IHRoaXMubGluZUVuZCA9IHRoaXMucG9pbnQgPSBub29wO1xuICB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdW0uYWRkKHRhdSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZWFSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gYXJlYVJpbmdFbmQoKSB7XG4gIGFyZWFQb2ludChsYW1iZGEwMCwgcGhpMDApO1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50O1xuICBsYW1iZGEwMCA9IGxhbWJkYSwgcGhpMDAgPSBwaGk7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgbGFtYmRhMCA9IGxhbWJkYSwgY29zUGhpMCA9IGNvcyhwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpKSwgc2luUGhpMCA9IHNpbihwaGkpO1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpOyAvLyBoYWxmIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGZyb20gc291dGggcG9sZVxuXG4gIC8vIFNwaGVyaWNhbCBleGNlc3MgRSBmb3IgYSBzcGhlcmljYWwgdHJpYW5nbGUgd2l0aCB2ZXJ0aWNlczogc291dGggcG9sZSxcbiAgLy8gcHJldmlvdXMgcG9pbnQsIGN1cnJlbnQgcG9pbnQuICBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcbiAgLy8gdGhlb3JlbS4gIFNlZSBUb2RodW50ZXIsIFNwaGVyaWNhbCBUcmlnLiAoMTg3MSksIFNlYy4gMTAzLCBFcS4gKDIpLlxuICB2YXIgZExhbWJkYSA9IGxhbWJkYSAtIGxhbWJkYTAsXG4gICAgICBzZExhbWJkYSA9IGRMYW1iZGEgPj0gMCA/IDEgOiAtMSxcbiAgICAgIGFkTGFtYmRhID0gc2RMYW1iZGEgKiBkTGFtYmRhLFxuICAgICAgY29zUGhpID0gY29zKHBoaSksXG4gICAgICBzaW5QaGkgPSBzaW4ocGhpKSxcbiAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpLFxuICAgICAgdSA9IGNvc1BoaTAgKiBjb3NQaGkgKyBrICogY29zKGFkTGFtYmRhKSxcbiAgICAgIHYgPSBrICogc2RMYW1iZGEgKiBzaW4oYWRMYW1iZGEpO1xuICBhcmVhUmluZ1N1bS5hZGQoYXRhbjIodiwgdSkpO1xuXG4gIC8vIEFkdmFuY2UgdGhlIHByZXZpb3VzIHBvaW50cy5cbiAgbGFtYmRhMCA9IGxhbWJkYSwgY29zUGhpMCA9IGNvc1BoaSwgc2luUGhpMCA9IHNpblBoaTtcbn1cblxuZnVuY3Rpb24gYXJlYShvYmplY3QpIHtcbiAgYXJlYVN1bS5yZXNldCgpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBhcmVhU3RyZWFtKTtcbiAgcmV0dXJuIGFyZWFTdW0gKiAyO1xufVxuXG5mdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gIHJldHVybiBbYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBhc2luKGNhcnRlc2lhblsyXSldO1xufVxuXG5mdW5jdGlvbiBjYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gIHZhciBsYW1iZGEgPSBzcGhlcmljYWxbMF0sIHBoaSA9IHNwaGVyaWNhbFsxXSwgY29zUGhpID0gY29zKHBoaSk7XG4gIHJldHVybiBbY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKV07XG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhbkRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gYVxuZnVuY3Rpb24gY2FydGVzaWFuQWRkSW5QbGFjZShhLCBiKSB7XG4gIGFbMF0gKz0gYlswXSwgYVsxXSArPSBiWzFdLCBhWzJdICs9IGJbMl07XG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xufVxuXG4vLyBUT0RPIHJldHVybiBkXG5mdW5jdGlvbiBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGQpIHtcbiAgdmFyIGwgPSBzcXJ0KGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV0gKyBkWzJdICogZFsyXSk7XG4gIGRbMF0gLz0gbCwgZFsxXSAvPSBsLCBkWzJdIC89IGw7XG59XG5cbnZhciBsYW1iZGEwJDEsIHBoaTAsIGxhbWJkYTEsIHBoaTEsIC8vIGJvdW5kc1xuICAgIGxhbWJkYTIsIC8vIHByZXZpb3VzIGxhbWJkYS1jb29yZGluYXRlXG4gICAgbGFtYmRhMDAkMSwgcGhpMDAkMSwgLy8gZmlyc3QgcG9pbnRcbiAgICBwMCwgLy8gcHJldmlvdXMgM0QgcG9pbnRcbiAgICBkZWx0YVN1bSA9IGFkZGVyKCksXG4gICAgcmFuZ2VzLFxuICAgIHJhbmdlO1xuXG52YXIgYm91bmRzU3RyZWFtID0ge1xuICBwb2ludDogYm91bmRzUG9pbnQsXG4gIGxpbmVTdGFydDogYm91bmRzTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBib3VuZHNMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1JpbmdQb2ludDtcbiAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzUmluZ1N0YXJ0O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzUmluZ0VuZDtcbiAgICBkZWx0YVN1bS5yZXNldCgpO1xuICAgIGFyZWFTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNMaW5lU3RhcnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNMaW5lRW5kO1xuICAgIGlmIChhcmVhUmluZ1N1bSA8IDApIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gICAgZWxzZSBpZiAoZGVsdGFTdW0gPiBlcHNpbG9uKSBwaGkxID0gOTA7XG4gICAgZWxzZSBpZiAoZGVsdGFTdW0gPCAtZXBzaWxvbikgcGhpMCA9IC05MDtcbiAgICByYW5nZVswXSA9IGxhbWJkYTAkMSwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJvdW5kc1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG59XG5cbmZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICB2YXIgcCA9IGNhcnRlc2lhbihbbGFtYmRhICogcmFkaWFucywgcGhpICogcmFkaWFuc10pO1xuICBpZiAocDApIHtcbiAgICB2YXIgbm9ybWFsID0gY2FydGVzaWFuQ3Jvc3MocDAsIHApLFxuICAgICAgICBlcXVhdG9yaWFsID0gW25vcm1hbFsxXSwgLW5vcm1hbFswXSwgMF0sXG4gICAgICAgIGluZmxlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhlcXVhdG9yaWFsLCBub3JtYWwpO1xuICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW5mbGVjdGlvbik7XG4gICAgaW5mbGVjdGlvbiA9IHNwaGVyaWNhbChpbmZsZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyLFxuICAgICAgICBzaWduID0gZGVsdGEgPiAwID8gMSA6IC0xLFxuICAgICAgICBsYW1iZGFpID0gaW5mbGVjdGlvblswXSAqIGRlZ3JlZXMgKiBzaWduLFxuICAgICAgICBwaGlpLFxuICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnMoZGVsdGEpID4gMTgwO1xuICAgIGlmIChhbnRpbWVyaWRpYW4gXiAoc2lnbiAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduICogbGFtYmRhKSkge1xuICAgICAgcGhpaSA9IGluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgaWYgKHBoaWkgPiBwaGkxKSBwaGkxID0gcGhpaTtcbiAgICB9IGVsc2UgaWYgKGxhbWJkYWkgPSAobGFtYmRhaSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzaWduICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24gKiBsYW1iZGEpKSB7XG4gICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgaWYgKHBoaWkgPCBwaGkwKSBwaGkwID0gcGhpaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gICAgICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbiAgICB9XG4gICAgaWYgKGFudGltZXJpZGlhbikge1xuICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTIpIHtcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxhbWJkYTEgPj0gbGFtYmRhMCQxKSB7XG4gICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEwJDEpIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTEpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMikge1xuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEwJDEsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSkgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICB9XG4gIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xuICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbiAgcDAgPSBwLCBsYW1iZGEyID0gbGFtYmRhO1xufVxuXG5mdW5jdGlvbiBib3VuZHNMaW5lU3RhcnQoKSB7XG4gIGJvdW5kc1N0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbn1cblxuZnVuY3Rpb24gYm91bmRzTGluZUVuZCgpIHtcbiAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gIHAwID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGlmIChwMCkge1xuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTI7XG4gICAgZGVsdGFTdW0uYWRkKGFicyhkZWx0YSkgPiAxODAgPyBkZWx0YSArIChkZWx0YSA+IDAgPyAzNjAgOiAtMzYwKSA6IGRlbHRhKTtcbiAgfSBlbHNlIHtcbiAgICBsYW1iZGEwMCQxID0gbGFtYmRhLCBwaGkwMCQxID0gcGhpO1xuICB9XG4gIGFyZWFTdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICBsaW5lUG9pbnQobGFtYmRhLCBwaGkpO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ubGluZVN0YXJ0KCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdFbmQoKSB7XG4gIGJvdW5kc1JpbmdQb2ludChsYW1iZGEwMCQxLCBwaGkwMCQxKTtcbiAgYXJlYVN0cmVhbS5saW5lRW5kKCk7XG4gIGlmIChhYnMoZGVsdGFTdW0pID4gZXBzaWxvbikgbGFtYmRhMCQxID0gLShsYW1iZGExID0gMTgwKTtcbiAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgcDAgPSBudWxsO1xufVxuXG4vLyBGaW5kcyB0aGUgbGVmdC1yaWdodCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsb25naXR1ZGVzLlxuLy8gVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgKGxhbWJkYTEgLSBsYW1iZGEwICsgMzYwwrApICUgMzYwwrAsIGV4Y2VwdCB0aGF0IHdlIHdhbnRcbi8vIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIMKxMTgwwrAgdG8gYmUgMzYwwrAuXG5mdW5jdGlvbiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSB7XG4gIHJldHVybiAobGFtYmRhMSAtPSBsYW1iZGEwKSA8IDAgPyBsYW1iZGExICsgMzYwIDogbGFtYmRhMTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VDb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdO1xufVxuXG5mdW5jdGlvbiByYW5nZUNvbnRhaW5zKHJhbmdlLCB4KSB7XG4gIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG59XG5cbmZ1bmN0aW9uIGJvdW5kcyhmZWF0dXJlKSB7XG4gIHZhciBpLCBuLCBhLCBiLCBtZXJnZWQsIGRlbHRhTWF4LCBkZWx0YTtcblxuICBwaGkxID0gbGFtYmRhMSA9IC0obGFtYmRhMCQxID0gcGhpMCA9IEluZmluaXR5KTtcbiAgcmFuZ2VzID0gW107XG4gIGdlb1N0cmVhbShmZWF0dXJlLCBib3VuZHNTdHJlYW0pO1xuXG4gIC8vIEZpcnN0LCBzb3J0IHJhbmdlcyBieSB0aGVpciBtaW5pbXVtIGxvbmdpdHVkZXMuXG4gIGlmIChuID0gcmFuZ2VzLmxlbmd0aCkge1xuICAgIHJhbmdlcy5zb3J0KHJhbmdlQ29tcGFyZSk7XG5cbiAgICAvLyBUaGVuLCBtZXJnZSBhbnkgcmFuZ2VzIHRoYXQgb3ZlcmxhcC5cbiAgICBmb3IgKGkgPSAxLCBhID0gcmFuZ2VzWzBdLCBtZXJnZWQgPSBbYV07IGkgPCBuOyArK2kpIHtcbiAgICAgIGIgPSByYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2VDb250YWlucyhhLCBiWzBdKSB8fCByYW5nZUNvbnRhaW5zKGEsIGJbMV0pKSB7XG4gICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzFdID0gYlsxXTtcbiAgICAgICAgaWYgKGFuZ2xlKGJbMF0sIGFbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMF0gPSBiWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIGZpbmQgdGhlIGxhcmdlc3QgZ2FwIGJldHdlZW4gdGhlIG1lcmdlZCByYW5nZXMuXG4gICAgLy8gVGhlIGZpbmFsIGJvdW5kaW5nIGJveCB3aWxsIGJlIHRoZSBpbnZlcnNlIG9mIHRoaXMgZ2FwLlxuICAgIGZvciAoZGVsdGFNYXggPSAtSW5maW5pdHksIG4gPSBtZXJnZWQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBtZXJnZWRbbl07IGkgPD0gbjsgYSA9IGIsICsraSkge1xuICAgICAgYiA9IG1lcmdlZFtpXTtcbiAgICAgIGlmICgoZGVsdGEgPSBhbmdsZShhWzFdLCBiWzBdKSkgPiBkZWx0YU1heCkgZGVsdGFNYXggPSBkZWx0YSwgbGFtYmRhMCQxID0gYlswXSwgbGFtYmRhMSA9IGFbMV07XG4gICAgfVxuICB9XG5cbiAgcmFuZ2VzID0gcmFuZ2UgPSBudWxsO1xuXG4gIHJldHVybiBsYW1iZGEwJDEgPT09IEluZmluaXR5IHx8IHBoaTAgPT09IEluZmluaXR5XG4gICAgICA/IFtbTmFOLCBOYU5dLCBbTmFOLCBOYU5dXVxuICAgICAgOiBbW2xhbWJkYTAkMSwgcGhpMF0sIFtsYW1iZGExLCBwaGkxXV07XG59XG5cbnZhciBXMCwgVzEsXG4gICAgWDAsIFkwLCBaMCxcbiAgICBYMSwgWTEsIFoxLFxuICAgIFgyLCBZMiwgWjIsXG4gICAgbGFtYmRhMDAkMiwgcGhpMDAkMiwgLy8gZmlyc3QgcG9pbnRcbiAgICB4MCwgeTAsIHowOyAvLyBwcmV2aW91cyBwb2ludFxuXG52YXIgY2VudHJvaWRTdHJlYW0gPSB7XG4gIHNwaGVyZTogbm9vcCxcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9XG59O1xuXG4vLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKGNvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgsIHksIHopIHtcbiAgKytXMDtcbiAgWDAgKz0gKHggLSBYMCkgLyBXMDtcbiAgWTAgKz0gKHkgLSBZMCkgLyBXMDtcbiAgWjAgKz0gKHogLSBaMCkgLyBXMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludDtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwJDIsIHBoaTAwJDIpO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhMDAkMiA9IGxhbWJkYSwgcGhpMDAkMiA9IHBoaTtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50O1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gIHowID0gc2luKHBoaSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgY3ggPSB5MCAqIHogLSB6MCAqIHksXG4gICAgICBjeSA9IHowICogeCAtIHgwICogeixcbiAgICAgIGN6ID0geDAgKiB5IC0geTAgKiB4LFxuICAgICAgbSA9IHNxcnQoY3ggKiBjeCArIGN5ICogY3kgKyBjeiAqIGN6KSxcbiAgICAgIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXG4gICAgICB2ID0gbSAmJiAtdyAvIG07IC8vIGFyZWEgd2VpZ2h0IG11bHRpcGxpZXJcbiAgWDIgKz0gdiAqIGN4O1xuICBZMiArPSB2ICogY3k7XG4gIFoyICs9IHYgKiBjejtcbiAgVzEgKz0gdztcbiAgWDEgKz0gdyAqICh4MCArICh4MCA9IHgpKTtcbiAgWTEgKz0gdyAqICh5MCArICh5MCA9IHkpKTtcbiAgWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWQob2JqZWN0KSB7XG4gIFcwID0gVzEgPVxuICBYMCA9IFkwID0gWjAgPVxuICBYMSA9IFkxID0gWjEgPVxuICBYMiA9IFkyID0gWjIgPSAwO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBjZW50cm9pZFN0cmVhbSk7XG5cbiAgdmFyIHggPSBYMixcbiAgICAgIHkgPSBZMixcbiAgICAgIHogPSBaMixcbiAgICAgIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG5cbiAgLy8gSWYgdGhlIGFyZWEtd2VpZ2h0ZWQgY2NlbnRyb2lkIGlzIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIGxlbmd0aC13ZWlnaHRlZCBjY2VudHJvaWQuXG4gIGlmIChtIDwgZXBzaWxvbjIpIHtcbiAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIGhhcyB6ZXJvIGxlbmd0aCwgZmFsbCBiYWNrIHRvIGFyaXRobWV0aWMgbWVhbiBvZiBwb2ludCB2ZWN0b3JzLlxuICAgIGlmIChXMSA8IGVwc2lsb24pIHggPSBYMCwgeSA9IFkwLCB6ID0gWjA7XG4gICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcbiAgICAvLyBJZiB0aGUgZmVhdHVyZSBzdGlsbCBoYXMgYW4gdW5kZWZpbmVkIGNjZW50cm9pZCwgdGhlbiByZXR1cm4uXG4gICAgaWYgKG0gPCBlcHNpbG9uMikgcmV0dXJuIFtOYU4sIE5hTl07XG4gIH1cblxuICByZXR1cm4gW2F0YW4yKHksIHgpICogZGVncmVlcywgYXNpbih6IC8gc3FydChtKSkgKiBkZWdyZWVzXTtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2UoYSwgYikge1xuXG4gIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgfVxuXG4gIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZTtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25JZGVudGl0eShsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2FicyhsYW1iZGEpID4gcGkgPyBsYW1iZGEgKyBNYXRoLnJvdW5kKC1sYW1iZGEgLyB0YXUpICogdGF1IDogbGFtYmRhLCBwaGldO1xufVxuXG5yb3RhdGlvbklkZW50aXR5LmludmVydCA9IHJvdGF0aW9uSWRlbnRpdHk7XG5cbmZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHJldHVybiAoZGVsdGFMYW1iZGEgJT0gdGF1KSA/IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gY29tcG9zZShyb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSksIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpKVxuICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxuICAgIDogKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKVxuICAgIDogcm90YXRpb25JZGVudGl0eSk7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICByZXR1cm4gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gbGFtYmRhICs9IGRlbHRhTGFtYmRhLCBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHZhciByb3RhdGlvbiA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSk7XG4gIHJvdGF0aW9uLmludmVydCA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYSgtZGVsdGFMYW1iZGEpO1xuICByZXR1cm4gcm90YXRpb247XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgdmFyIGNvc0RlbHRhUGhpID0gY29zKGRlbHRhUGhpKSxcbiAgICAgIHNpbkRlbHRhUGhpID0gc2luKGRlbHRhUGhpKSxcbiAgICAgIGNvc0RlbHRhR2FtbWEgPSBjb3MoZGVsdGFHYW1tYSksXG4gICAgICBzaW5EZWx0YUdhbW1hID0gc2luKGRlbHRhR2FtbWEpO1xuXG4gIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhUGhpICsgeCAqIHNpbkRlbHRhUGhpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSAtIGsgKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgLSB6ICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFHYW1tYSArIHkgKiBzaW5EZWx0YUdhbW1hKVxuICAgIF07XG4gIH1cblxuICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YUdhbW1hIC0geSAqIHNpbkRlbHRhR2FtbWE7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hICsgeiAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSArIGsgKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YVBoaSAtIHggKiBzaW5EZWx0YVBoaSlcbiAgICBdO1xuICB9O1xuXG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gcm90YXRpb24ocm90YXRlKSB7XG4gIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMocm90YXRlWzBdICogcmFkaWFucywgcm90YXRlWzFdICogcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiByYWRpYW5zIDogMCk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlKGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUuaW52ZXJ0KGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG5cbi8vIEdlbmVyYXRlcyBhIGNpcmNsZSBjZW50ZXJlZCBhdCBbMMKwLCAwwrBdLCB3aXRoIGEgZ2l2ZW4gcmFkaXVzIGFuZCBwcmVjaXNpb24uXG5mdW5jdGlvbiBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIHQwLCB0MSkge1xuICBpZiAoIWRlbHRhKSByZXR1cm47XG4gIHZhciBjb3NSYWRpdXMgPSBjb3MocmFkaXVzKSxcbiAgICAgIHNpblJhZGl1cyA9IHNpbihyYWRpdXMpLFxuICAgICAgc3RlcCA9IGRpcmVjdGlvbiAqIGRlbHRhO1xuICBpZiAodDAgPT0gbnVsbCkge1xuICAgIHQwID0gcmFkaXVzICsgZGlyZWN0aW9uICogdGF1O1xuICAgIHQxID0gcmFkaXVzIC0gc3RlcCAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdDAgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MCk7XG4gICAgdDEgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MSk7XG4gICAgaWYgKGRpcmVjdGlvbiA+IDAgPyB0MCA8IHQxIDogdDAgPiB0MSkgdDAgKz0gZGlyZWN0aW9uICogdGF1O1xuICB9XG4gIGZvciAodmFyIHBvaW50LCB0ID0gdDA7IGRpcmVjdGlvbiA+IDAgPyB0ID4gdDEgOiB0IDwgdDE7IHQgLT0gc3RlcCkge1xuICAgIHBvaW50ID0gc3BoZXJpY2FsKFtjb3NSYWRpdXMsIC1zaW5SYWRpdXMgKiBjb3ModCksIC1zaW5SYWRpdXMgKiBzaW4odCldKTtcbiAgICBzdHJlYW0ucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBzaWduZWQgYW5nbGUgb2YgYSBjYXJ0ZXNpYW4gcG9pbnQgcmVsYXRpdmUgdG8gW2Nvc1JhZGl1cywgMCwgMF0uXG5mdW5jdGlvbiBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCBwb2ludCkge1xuICBwb2ludCA9IGNhcnRlc2lhbihwb2ludCksIHBvaW50WzBdIC09IGNvc1JhZGl1cztcbiAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShwb2ludCk7XG4gIHZhciByYWRpdXMgPSBhY29zKC1wb2ludFsxXSk7XG4gIHJldHVybiAoKC1wb2ludFsyXSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzKSArIHRhdSAtIGVwc2lsb24pICUgdGF1O1xufVxuXG5mdW5jdGlvbiBjaXJjbGUoKSB7XG4gIHZhciBjZW50ZXIgPSBjb25zdGFudChbMCwgMF0pLFxuICAgICAgcmFkaXVzID0gY29uc3RhbnQoOTApLFxuICAgICAgcHJlY2lzaW9uID0gY29uc3RhbnQoNiksXG4gICAgICByaW5nLFxuICAgICAgcm90YXRlLFxuICAgICAgc3RyZWFtID0ge3BvaW50OiBwb2ludH07XG5cbiAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICB4WzBdICo9IGRlZ3JlZXMsIHhbMV0gKj0gZGVncmVlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICB2YXIgYyA9IGNlbnRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByID0gcmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zLFxuICAgICAgICBwID0gcHJlY2lzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiByYWRpYW5zO1xuICAgIHJpbmcgPSBbXTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKC1jWzBdICogcmFkaWFucywgLWNbMV0gKiByYWRpYW5zLCAwKS5pbnZlcnQ7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgciwgcCwgMSk7XG4gICAgYyA9IHt0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IFtyaW5nXX07XG4gICAgcmluZyA9IHJvdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBjaXJjbGUuY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoWytfWzBdLCArX1sxXV0pLCBjaXJjbGUpIDogY2VudGVyO1xuICB9O1xuXG4gIGNpcmNsZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjaXNpb24gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHByZWNpc2lvbjtcbiAgfTtcblxuICByZXR1cm4gY2lyY2xlO1xufVxuXG5mdW5jdGlvbiBjbGlwQnVmZmVyKCkge1xuICB2YXIgbGluZXMgPSBbXSxcbiAgICAgIGxpbmU7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGxpbmUucHVzaChbeCwgeV0pO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgcmVqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgfSxcbiAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxpbmVzO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvaW50RXF1YWwoYSwgYikge1xuICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24gJiYgYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb247XG59XG5cbmZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgdGhpcy54ID0gcG9pbnQ7XG4gIHRoaXMueiA9IHBvaW50cztcbiAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXG4gIHRoaXMuZSA9IGVudHJ5OyAvLyBpcyBhbiBlbnRyeT9cbiAgdGhpcy52ID0gZmFsc2U7IC8vIHZpc2l0ZWRcbiAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXG59XG5cbi8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxuLy8gaW50byBpdHMgdmlzaWJsZSBsaW5lIHNlZ21lbnRzLCBhbmQgcmVqb2lucyB0aGUgc2VnbWVudHMgYnkgaW50ZXJwb2xhdGluZ1xuLy8gYWxvbmcgdGhlIGNsaXAgZWRnZS5cbmZ1bmN0aW9uIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBzdWJqZWN0ID0gW10sXG4gICAgICBjbGlwID0gW10sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIG9mIGEgc2VnbWVudCBhcmUgY29pbmNpZGVudCwgdGhlbiB0cmVhdCBhcyBhXG4gICAgLy8gY2xvc2VkIHJpbmcuIFRPRE8gaWYgYWxsIHJpbmdzIGFyZSBjbG9zZWQsIHRoZW4gdGhlIHdpbmRpbmcgb3JkZXIgb2YgdGhlXG4gICAgLy8gZXh0ZXJpb3IgcmluZyBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBudWxsLCB4LCB0cnVlKSk7XG4gIH0pO1xuXG4gIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcblxuICBjbGlwLnNvcnQoY29tcGFyZUludGVyc2VjdGlvbik7XG4gIGxpbmsoc3ViamVjdCk7XG4gIGxpbmsoY2xpcCk7XG5cbiAgZm9yIChpID0gMCwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY2xpcFtpXS5lID0gc3RhcnRJbnNpZGUgPSAhc3RhcnRJbnNpZGU7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLFxuICAgICAgcG9pbnRzLFxuICAgICAgcG9pbnQ7XG5cbiAgd2hpbGUgKDEpIHtcbiAgICAvLyBGaW5kIGZpcnN0IHVudmlzaXRlZCBpbnRlcnNlY3Rpb24uXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoY3VycmVudC52KSBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydCkgcmV0dXJuO1xuICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgZG8ge1xuICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgIGZvciAoaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaW5rKGFycmF5KSB7XG4gIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBhID0gYXJyYXlbMF0sXG4gICAgICBiO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEubiA9IGIgPSBhcnJheVtpXTtcbiAgICBiLnAgPSBhO1xuICAgIGEgPSBiO1xuICB9XG4gIGEubiA9IGIgPSBhcnJheVswXTtcbiAgYi5wID0gYTtcbn1cblxudmFyIHN1bSA9IGFkZGVyKCk7XG5cbmZ1bmN0aW9uIGxvbmdpdHVkZShwb2ludCkge1xuICBpZiAoYWJzKHBvaW50WzBdKSA8PSBwaSlcbiAgICByZXR1cm4gcG9pbnRbMF07XG4gIGVsc2VcbiAgICByZXR1cm4gc2lnbihwb2ludFswXSkgKiAoKGFicyhwb2ludFswXSkgKyBwaSkgJSB0YXUgLSBwaSk7XG59XG5cbmZ1bmN0aW9uIHBvbHlnb25Db250YWlucyhwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbGFtYmRhID0gbG9uZ2l0dWRlKHBvaW50KSxcbiAgICAgIHBoaSA9IHBvaW50WzFdLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sXG4gICAgICBhbmdsZSA9IDAsXG4gICAgICB3aW5kaW5nID0gMDtcblxuICBzdW0ucmVzZXQoKTtcblxuICBpZiAoc2luUGhpID09PSAxKSBwaGkgPSBoYWxmUGkgKyBlcHNpbG9uO1xuICBlbHNlIGlmIChzaW5QaGkgPT09IC0xKSBwaGkgPSAtaGFsZlBpIC0gZXBzaWxvbjtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEobSA9IChyaW5nID0gcG9seWdvbltpXSkubGVuZ3RoKSkgY29udGludWU7XG4gICAgdmFyIHJpbmcsXG4gICAgICAgIG0sXG4gICAgICAgIHBvaW50MCA9IHJpbmdbbSAtIDFdLFxuICAgICAgICBsYW1iZGEwID0gbG9uZ2l0dWRlKHBvaW50MCksXG4gICAgICAgIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICBzaW5QaGkwID0gc2luKHBoaTApLFxuICAgICAgICBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2osIGxhbWJkYTAgPSBsYW1iZGExLCBzaW5QaGkwID0gc2luUGhpMSwgY29zUGhpMCA9IGNvc1BoaTEsIHBvaW50MCA9IHBvaW50MSkge1xuICAgICAgdmFyIHBvaW50MSA9IHJpbmdbal0sXG4gICAgICAgICAgbGFtYmRhMSA9IGxvbmdpdHVkZShwb2ludDEpLFxuICAgICAgICAgIHBoaTEgPSBwb2ludDFbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICAgIHNpblBoaTEgPSBzaW4ocGhpMSksXG4gICAgICAgICAgY29zUGhpMSA9IGNvcyhwaGkxKSxcbiAgICAgICAgICBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICAgIHNpZ24gPSBkZWx0YSA+PSAwID8gMSA6IC0xLFxuICAgICAgICAgIGFic0RlbHRhID0gc2lnbiAqIGRlbHRhLFxuICAgICAgICAgIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGksXG4gICAgICAgICAgayA9IHNpblBoaTAgKiBzaW5QaGkxO1xuXG4gICAgICBzdW0uYWRkKGF0YW4yKGsgKiBzaWduICogc2luKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zKGFic0RlbHRhKSkpO1xuICAgICAgYW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZGVsdGEgKyBzaWduICogdGF1IDogZGVsdGE7XG5cbiAgICAgIC8vIEFyZSB0aGUgbG9uZ2l0dWRlcyBlaXRoZXIgc2lkZSBvZiB0aGUgcG9pbnTigJlzIG1lcmlkaWFuIChsYW1iZGEpLFxuICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XG4gICAgICBpZiAoYW50aW1lcmlkaWFuIF4gbGFtYmRhMCA+PSBsYW1iZGEgXiBsYW1iZGExID49IGxhbWJkYSkge1xuICAgICAgICB2YXIgYXJjID0gY2FydGVzaWFuQ3Jvc3MoY2FydGVzaWFuKHBvaW50MCksIGNhcnRlc2lhbihwb2ludDEpKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShhcmMpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3Mobm9ybWFsLCBhcmMpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGludGVyc2VjdGlvbik7XG4gICAgICAgIHZhciBwaGlBcmMgPSAoYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IC0xIDogMSkgKiBhc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgIGlmIChwaGkgPiBwaGlBcmMgfHwgcGhpID09PSBwaGlBcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QsIGRldGVybWluZSB3aGV0aGVyIHRoZSBTb3V0aCBwb2xlIGlzIGluc2lkZSBvciBvdXRzaWRlOlxuICAvL1xuICAvLyBJdCBpcyBpbnNpZGUgaWY6XG4gIC8vICogdGhlIHBvbHlnb24gd2luZHMgYXJvdW5kIGl0IGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAgLy8gKiB0aGUgcG9seWdvbiBkb2VzIG5vdCAoY3VtdWxhdGl2ZWx5KSB3aW5kIGFyb3VuZCBpdCwgYnV0IGhhcyBhIG5lZ2F0aXZlXG4gIC8vICAgKGNvdW50ZXItY2xvY2t3aXNlKSBhcmVhLlxuICAvL1xuICAvLyBTZWNvbmQsIGNvdW50IHRoZSAoc2lnbmVkKSBudW1iZXIgb2YgdGltZXMgYSBzZWdtZW50IGNyb3NzZXMgYSBsYW1iZGFcbiAgLy8gZnJvbSB0aGUgcG9pbnQgdG8gdGhlIFNvdXRoIHBvbGUuICBJZiBpdCBpcyB6ZXJvLCB0aGVuIHRoZSBwb2ludCBpcyB0aGVcbiAgLy8gc2FtZSBzaWRlIGFzIHRoZSBTb3V0aCBwb2xlLlxuXG4gIHJldHVybiAoYW5nbGUgPCAtZXBzaWxvbiB8fCBhbmdsZSA8IGVwc2lsb24gJiYgc3VtIDwgLWVwc2lsb24pIF4gKHdpbmRpbmcgJiAxKTtcbn1cblxuZnVuY3Rpb24gY2xpcChwb2ludFZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc3RhcnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNpbmspIHtcbiAgICB2YXIgbGluZSA9IGNsaXBMaW5lKHNpbmspLFxuICAgICAgICByaW5nQnVmZmVyID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICByaW5nU2luayA9IGNsaXBMaW5lKHJpbmdCdWZmZXIpLFxuICAgICAgICBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcmluZztcblxuICAgIHZhciBjbGlwID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc2VnbWVudHMgPSBkM0FycmF5Lm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHN0YXJ0KTtcbiAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHNpbmspO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgaWYgKHBvaW50VmlzaWJsZShsYW1iZGEsIHBoaSkpIHNpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50TGluZShsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50UmluZyhsYW1iZGEsIHBoaSkge1xuICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgcmluZ1NpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIHJpbmdTaW5rLmxpbmVTdGFydCgpO1xuICAgICAgcmluZyA9IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICBwb2ludFJpbmcocmluZ1swXVswXSwgcmluZ1swXVsxXSk7XG4gICAgICByaW5nU2luay5saW5lRW5kKCk7XG5cbiAgICAgIHZhciBjbGVhbiA9IHJpbmdTaW5rLmNsZWFuKCksXG4gICAgICAgICAgcmluZ1NlZ21lbnRzID0gcmluZ0J1ZmZlci5yZXN1bHQoKSxcbiAgICAgICAgICBpLCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aCwgbSxcbiAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgIHBvaW50O1xuXG4gICAgICByaW5nLnBvcCgpO1xuICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgcmluZyA9IG51bGw7XG5cbiAgICAgIGlmICghbikgcmV0dXJuO1xuXG4gICAgICAvLyBObyBpbnRlcnNlY3Rpb25zLlxuICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHNpbmsucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXG4gICAgICAvLyBUT0RPIHJldXNlIHJpbmdCdWZmZXIucmVqb2luKCk/XG4gICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG5cbiAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcih2YWxpZFNlZ21lbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbn1cblxuLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4vLyBhbmQgY2lyY2xlIGNsaXBwaW5nLCB0aGUgc2FtZSBjb21wYXJpc29uIGlzIHVzZWQuXG5mdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBhWzFdKVxuICAgICAgIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGJbMV0pO1xufVxuXG52YXIgY2xpcEFudGltZXJpZGlhbiA9IGNsaXAoXG4gIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgY2xpcEFudGltZXJpZGlhbkxpbmUsXG4gIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSxcbiAgWy1waSwgLWhhbGZQaV1cbik7XG5cbi8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXM6IDAgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zIG9yIHRoZSBsaW5lIHdhcyBlbXB0eTsgMSAtIG5vIGludGVyc2VjdGlvbnM7IDIgLSB0aGVyZSB3ZXJlXG4vLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5MaW5lKHN0cmVhbSkge1xuICB2YXIgbGFtYmRhMCA9IE5hTixcbiAgICAgIHBoaTAgPSBOYU4sXG4gICAgICBzaWduMCA9IE5hTixcbiAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgY2xlYW4gPSAxO1xuICAgIH0sXG4gICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYTEsIHBoaTEpIHtcbiAgICAgIHZhciBzaWduMSA9IGxhbWJkYTEgPiAwID8gcGkgOiAtcGksXG4gICAgICAgICAgZGVsdGEgPSBhYnMobGFtYmRhMSAtIGxhbWJkYTApO1xuICAgICAgaWYgKGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24pIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChzaWduMCAhPT0gc2lnbjEgJiYgZGVsdGEgPj0gcGkpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uKSBsYW1iZGEwIC09IHNpZ24wICogZXBzaWxvbjsgLy8gaGFuZGxlIGRlZ2VuZXJhY2llc1xuICAgICAgICBpZiAoYWJzKGxhbWJkYTEgLSBzaWduMSkgPCBlcHNpbG9uKSBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbjtcbiAgICAgICAgcGhpMCA9IGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAgPSBsYW1iZGExLCBwaGkwID0gcGhpMSk7XG4gICAgICBzaWduMCA9IHNpZ24xO1xuICAgIH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgbGFtYmRhMCA9IHBoaTAgPSBOYU47XG4gICAgfSxcbiAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMiAtIGNsZWFuOyAvLyBpZiBpbnRlcnNlY3Rpb25zLCByZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QobGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSkge1xuICB2YXIgY29zUGhpMCxcbiAgICAgIGNvc1BoaTEsXG4gICAgICBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbihsYW1iZGEwIC0gbGFtYmRhMSk7XG4gIHJldHVybiBhYnMoc2luTGFtYmRhMExhbWJkYTEpID4gZXBzaWxvblxuICAgICAgPyBhdGFuKChzaW4ocGhpMCkgKiAoY29zUGhpMSA9IGNvcyhwaGkxKSkgKiBzaW4obGFtYmRhMSlcbiAgICAgICAgICAtIHNpbihwaGkxKSAqIChjb3NQaGkwID0gY29zKHBoaTApKSAqIHNpbihsYW1iZGEwKSlcbiAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgdmFyIHBoaTtcbiAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIDApO1xuICAgIHN0cmVhbS5wb2ludChwaSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIDApO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGxhbWJkYSA9IGZyb21bMF0gPCB0b1swXSA/IHBpIDogLXBpO1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XG4gICAgc3RyZWFtLnBvaW50KC1sYW1iZGEsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQ2lyY2xlKHJhZGl1cykge1xuICB2YXIgY3IgPSBjb3MocmFkaXVzKSxcbiAgICAgIGRlbHRhID0gNiAqIHJhZGlhbnMsXG4gICAgICBzbWFsbFJhZGl1cyA9IGNyID4gMCxcbiAgICAgIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gZXBzaWxvbjsgLy8gVE9ETyBvcHRpbWlzZSBmb3IgdGhpcyBjb21tb24gY2FzZVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgZnJvbSwgdG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZShsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBjb3MobGFtYmRhKSAqIGNvcyhwaGkpID4gY3I7XG4gIH1cblxuICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cbiAgLy8gY2xpcHBpbmc6IDAgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm9cbiAgLy8gaW50ZXJzZWN0aW9ucyAyIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoc3RyZWFtKSB7XG4gICAgdmFyIHBvaW50MCwgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwLCAvLyB2aXNpYmlsaXR5IG9mIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwMCwgLy8gdmlzaWJpbGl0eSBvZiBmaXJzdCBwb2ludFxuICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICBjbGVhbiA9IDE7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwb2ludDEgPSBbbGFtYmRhLCBwaGldLFxuICAgICAgICAgICAgcG9pbnQyLFxuICAgICAgICAgICAgdiA9IHZpc2libGUobGFtYmRhLCBwaGkpLFxuICAgICAgICAgICAgYyA9IHNtYWxsUmFkaXVzXG4gICAgICAgICAgICAgID8gdiA/IDAgOiBjb2RlKGxhbWJkYSwgcGhpKVxuICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkgOiAtcGkpLCBwaGkpIDogMDtcbiAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgLy8gSGFuZGxlIGRlZ2VuZXJhY2llcy5cbiAgICAgICAgLy8gVE9ETyBpZ25vcmUgaWYgbm90IGNsaXBwaW5nIHBvbHlnb25zLlxuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgIGlmICghcG9pbnQyIHx8IHBvaW50RXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IHBvaW50RXF1YWwocG9pbnQxLCBwb2ludDIpKSB7XG4gICAgICAgICAgICBwb2ludDFbMF0gKz0gZXBzaWxvbjtcbiAgICAgICAgICAgIHBvaW50MVsxXSArPSBlcHNpbG9uO1xuICAgICAgICAgICAgdiA9IHZpc2libGUocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIC8vIG91dHNpZGUgZ29pbmcgaW5cbiAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNpZGUgZ29pbmcgb3V0XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MjtcbiAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAvLyBJZiB0aGUgY29kZXMgZm9yIHR3byBwb2ludHMgYXJlIGRpZmZlcmVudCwgb3IgYXJlIGJvdGggemVybyxcbiAgICAgICAgICAvLyBhbmQgdGhlcmUgdGhpcyBzZWdtZW50IGludGVyc2VjdHMgd2l0aCB0aGUgc21hbGwgY2lyY2xlLlxuICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBwb2ludDAgPSBwb2ludDEsIHYwID0gdiwgYzAgPSBjO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodjApIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICB9LFxuICAgICAgLy8gUmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIGlmIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBhbmQgbGFzdCBwb2ludHMgd2VyZSB2aXNpYmxlLlxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2xlYW4gfCAoKHYwMCAmJiB2MCkgPDwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXG4gIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICB2YXIgcGEgPSBjYXJ0ZXNpYW4oYSksXG4gICAgICAgIHBiID0gY2FydGVzaWFuKGIpO1xuXG4gICAgLy8gV2UgaGF2ZSB0d28gcGxhbmVzLCBuMS5wID0gZDEgYW5kIG4yLnAgPSBkMi5cbiAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBsaW5lIHAodCkgPSBjMSBuMSArIGMyIG4yICsgdCAobjEg4qivIG4yKS5cbiAgICB2YXIgbjEgPSBbMSwgMCwgMF0sIC8vIG5vcm1hbFxuICAgICAgICBuMiA9IGNhcnRlc2lhbkNyb3NzKHBhLCBwYiksXG4gICAgICAgIG4ybjIgPSBjYXJ0ZXNpYW5Eb3QobjIsIG4yKSxcbiAgICAgICAgbjFuMiA9IG4yWzBdLCAvLyBjYXJ0ZXNpYW5Eb3QobjEsIG4yKSxcbiAgICAgICAgZGV0ZXJtaW5hbnQgPSBuMm4yIC0gbjFuMiAqIG4xbjI7XG5cbiAgICAvLyBUd28gcG9sYXIgcG9pbnRzLlxuICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG5cbiAgICB2YXIgYzEgPSAgY3IgKiBuMm4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIGMyID0gLWNyICogbjFuMiAvIGRldGVybWluYW50LFxuICAgICAgICBuMXhuMiA9IGNhcnRlc2lhbkNyb3NzKG4xLCBuMiksXG4gICAgICAgIEEgPSBjYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLFxuICAgICAgICBCID0gY2FydGVzaWFuU2NhbGUobjIsIGMyKTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKEEsIEIpO1xuXG4gICAgLy8gU29sdmUgfHAodCl8XjIgPSAxLlxuICAgIHZhciB1ID0gbjF4bjIsXG4gICAgICAgIHcgPSBjYXJ0ZXNpYW5Eb3QoQSwgdSksXG4gICAgICAgIHV1ID0gY2FydGVzaWFuRG90KHUsIHUpLFxuICAgICAgICB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG5cbiAgICBpZiAodDIgPCAwKSByZXR1cm47XG5cbiAgICB2YXIgdCA9IHNxcnQodDIpLFxuICAgICAgICBxID0gY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShxLCBBKTtcbiAgICBxID0gc3BoZXJpY2FsKHEpO1xuXG4gICAgaWYgKCF0d28pIHJldHVybiBxO1xuXG4gICAgLy8gVHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAgdmFyIGxhbWJkYTAgPSBhWzBdLFxuICAgICAgICBsYW1iZGExID0gYlswXSxcbiAgICAgICAgcGhpMCA9IGFbMV0sXG4gICAgICAgIHBoaTEgPSBiWzFdLFxuICAgICAgICB6O1xuXG4gICAgaWYgKGxhbWJkYTEgPCBsYW1iZGEwKSB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xuXG4gICAgdmFyIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbixcbiAgICAgICAgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb247XG5cbiAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKSB6ID0gcGhpMCwgcGhpMCA9IHBoaTEsIHBoaTEgPSB6O1xuXG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgZmlyc3QgcG9pbnQgaXMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGlmIChtZXJpZGlhblxuICAgICAgICA/IHBvbGFyXG4gICAgICAgICAgPyBwaGkwICsgcGhpMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gbGFtYmRhMCkgPCBlcHNpbG9uID8gcGhpMCA6IHBoaTEpXG4gICAgICAgICAgOiBwaGkwIDw9IHFbMV0gJiYgcVsxXSA8PSBwaGkxXG4gICAgICAgIDogZGVsdGEgPiBwaSBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xuICAgICAgdmFyIHExID0gY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGVzIGEgNC1iaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCByZWxhdGl2ZSB0b1xuICAvLyB0aGUgc21hbGwgY2lyY2xlJ3MgYm91bmRpbmcgYm94LlxuICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpIC0gcmFkaXVzLFxuICAgICAgICBjb2RlID0gMDtcbiAgICBpZiAobGFtYmRhIDwgLXIpIGNvZGUgfD0gMTsgLy8gbGVmdFxuICAgIGVsc2UgaWYgKGxhbWJkYSA+IHIpIGNvZGUgfD0gMjsgLy8gcmlnaHRcbiAgICBpZiAocGhpIDwgLXIpIGNvZGUgfD0gNDsgLy8gYmVsb3dcbiAgICBlbHNlIGlmIChwaGkgPiByKSBjb2RlIHw9IDg7IC8vIGFib3ZlXG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cblxuICByZXR1cm4gY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWzAsIC1yYWRpdXNdIDogWy1waSwgcmFkaXVzIC0gcGldKTtcbn1cblxuZnVuY3Rpb24gY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIHQwID0gMCxcbiAgICAgIHQxID0gMSxcbiAgICAgIGR4ID0gYnggLSBheCxcbiAgICAgIGR5ID0gYnkgLSBheSxcbiAgICAgIHI7XG5cbiAgciA9IHgwIC0gYXg7XG4gIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB4MSAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICByID0geTAgLSBheTtcbiAgaWYgKCFkeSAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHkxIC0gYXk7XG4gIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIGlmICh0MCA+IDApIGFbMF0gPSBheCArIHQwICogZHgsIGFbMV0gPSBheSArIHQwICogZHk7XG4gIGlmICh0MSA8IDEpIGJbMF0gPSBheCArIHQxICogZHgsIGJbMV0gPSBheSArIHQxICogZHk7XG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgY2xpcE1heCA9IDFlOSwgY2xpcE1pbiA9IC1jbGlwTWF4O1xuXG4vLyBUT0RPIFVzZSBkMy1wb2x5Z29u4oCZcyBwb2x5Z29uQ29udGFpbnMgaGVyZSBmb3IgdGhlIHJpbmcgY2hlY2s/XG4vLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cblxuZnVuY3Rpb24gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkge1xuXG4gIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgaWYgKGZyb20gPT0gbnVsbFxuICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICB8fCBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIDwgMCBeIGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIGRvIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyOyAvLyBhYnMocFsxXSAtIHkxKSA8IGVwc2lsb25cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlUG9pbnQoYS54LCBiLngpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVBvaW50KGEsIGIpIHtcbiAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksXG4gICAgICAgIGNiID0gY29ybmVyKGIsIDEpO1xuICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgIDogY2EgPT09IDAgPyBiWzFdIC0gYVsxXVxuICAgICAgICA6IGNhID09PSAxID8gYVswXSAtIGJbMF1cbiAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgIDogYlswXSAtIGFbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSxcbiAgICAgICAgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcG9seWdvbixcbiAgICAgICAgcmluZyxcbiAgICAgICAgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgeF8sIHlfLCB2XywgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGNsZWFuO1xuXG4gICAgdmFyIGNsaXBTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgIHBvbHlnb25FbmQ6IHBvbHlnb25FbmRcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgaWYgKHZpc2libGUoeCwgeSkpIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgIGEwID0gYjAsIGExID0gYjEsIHBvaW50ID0gcmluZ1tqXSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTtcbiAgICAgICAgICBpZiAoYTEgPD0geTEpIHsgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKSArK3dpbmRpbmc7IH1cbiAgICAgICAgICBlbHNlIHsgaWYgKGIxIDw9IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA8IChiMSAtIGExKSAqICh4MCAtIGEwKSkgLS13aW5kaW5nOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gQnVmZmVyIGdlb21ldHJ5IHdpdGhpbiBhIHBvbHlnb24gYW5kIHRoZW4gY2xpcCBpdCBlbiBtYXNzZS5cbiAgICBmdW5jdGlvbiBwb2x5Z29uU3RhcnQoKSB7XG4gICAgICBhY3RpdmVTdHJlYW0gPSBidWZmZXJTdHJlYW0sIHNlZ21lbnRzID0gW10sIHBvbHlnb24gPSBbXSwgY2xlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XG4gICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uSW5zaWRlKCksXG4gICAgICAgICAgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSxcbiAgICAgICAgICB2aXNpYmxlID0gKHNlZ21lbnRzID0gZDNBcnJheS5tZXJnZShzZWdtZW50cykpLmxlbmd0aDtcbiAgICAgIGlmIChjbGVhbkluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgaWYgKGNsZWFuSW5zaWRlKSB7XG4gICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgdl8gPSBmYWxzZTtcbiAgICAgIHhfID0geV8gPSBOYU47XG4gICAgfVxuXG4gICAgLy8gVE9ETyByYXRoZXIgdGhhbiBzcGVjaWFsLWNhc2UgcG9seWdvbnMsIHNpbXBseSBoYW5kbGUgdGhlbSBzZXBhcmF0ZWx5LlxuICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcbiAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJTdHJlYW0ucmVqb2luKCk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcbiAgICAgIH1cbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIGlmICh2XykgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgdmFyIHYgPSB2aXNpYmxlKHgsIHkpO1xuICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbeCwgeV0pO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgJiYgdl8pIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSBbeF8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4XykpLCB5XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHlfKSldLFxuICAgICAgICAgICAgICBiID0gW3ggPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4KSksIHkgPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5KSldO1xuICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICBpZiAoIXYpIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBTdHJlYW07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4dGVudCgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHkwID0gMCxcbiAgICAgIHgxID0gOTYwLFxuICAgICAgeTEgPSA1MDAsXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtLFxuICAgICAgY2xpcDtcblxuICByZXR1cm4gY2xpcCA9IHtcbiAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gY2xpcFJlY3RhbmdsZSh4MCwgeTAsIHgxLCB5MSkoY2FjaGVTdHJlYW0gPSBzdHJlYW0pO1xuICAgIH0sXG4gICAgZXh0ZW50OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdLCBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbCwgY2xpcCkgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsZW5ndGhTdW0gPSBhZGRlcigpLFxuICAgIGxhbWJkYTAkMixcbiAgICBzaW5QaGkwJDEsXG4gICAgY29zUGhpMCQxO1xuXG52YXIgbGVuZ3RoU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AsXG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IGxlbmd0aExpbmVTdGFydCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBub29wLFxuICBwb2x5Z29uRW5kOiBub29wXG59O1xuXG5mdW5jdGlvbiBsZW5ndGhMaW5lU3RhcnQoKSB7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3Q7XG4gIGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbGVuZ3RoTGluZUVuZDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoTGluZUVuZCgpIHtcbiAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoU3RyZWFtLmxpbmVFbmQgPSBub29wO1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW4ocGhpKSwgY29zUGhpMCQxID0gY29zKHBoaSk7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBzaW5QaGkgPSBzaW4ocGhpKSxcbiAgICAgIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgZGVsdGEgPSBhYnMobGFtYmRhIC0gbGFtYmRhMCQyKSxcbiAgICAgIGNvc0RlbHRhID0gY29zKGRlbHRhKSxcbiAgICAgIHNpbkRlbHRhID0gc2luKGRlbHRhKSxcbiAgICAgIHggPSBjb3NQaGkgKiBzaW5EZWx0YSxcbiAgICAgIHkgPSBjb3NQaGkwJDEgKiBzaW5QaGkgLSBzaW5QaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YSxcbiAgICAgIHogPSBzaW5QaGkwJDEgKiBzaW5QaGkgKyBjb3NQaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YTtcbiAgbGVuZ3RoU3VtLmFkZChhdGFuMihzcXJ0KHggKiB4ICsgeSAqIHkpLCB6KSk7XG4gIGxhbWJkYTAkMiA9IGxhbWJkYSwgc2luUGhpMCQxID0gc2luUGhpLCBjb3NQaGkwJDEgPSBjb3NQaGk7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aChvYmplY3QpIHtcbiAgbGVuZ3RoU3VtLnJlc2V0KCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIGxlbmd0aFN0cmVhbSk7XG4gIHJldHVybiArbGVuZ3RoU3VtO1xufVxuXG52YXIgY29vcmRpbmF0ZXMgPSBbbnVsbCwgbnVsbF0sXG4gICAgb2JqZWN0ID0ge3R5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXN9O1xuXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIGNvb3JkaW5hdGVzWzBdID0gYTtcbiAgY29vcmRpbmF0ZXNbMV0gPSBiO1xuICByZXR1cm4gbGVuZ3RoKG9iamVjdCk7XG59XG5cbnZhciBjb250YWluc09iamVjdFR5cGUgPSB7XG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcbiAgICByZXR1cm4gY29udGFpbnNHZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHBvaW50KTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKGNvbnRhaW5zR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY29udGFpbnNHZW9tZXRyeVR5cGUgPSB7XG4gIFNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zUG9pbnQob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKGNvbnRhaW5zUG9pbnQoY29vcmRpbmF0ZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgfSxcbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0xpbmUoY29vcmRpbmF0ZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc1BvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgcG9pbnQpIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKGNvbnRhaW5zR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgcG9pbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNvbnRhaW5zR2VvbWV0cnkoZ2VvbWV0cnksIHBvaW50KSB7XG4gIHJldHVybiBnZW9tZXRyeSAmJiBjb250YWluc0dlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKVxuICAgICAgPyBjb250YWluc0dlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgcG9pbnQpXG4gICAgICA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb250YWluc1BvaW50KGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICByZXR1cm4gZGlzdGFuY2UoY29vcmRpbmF0ZXMsIHBvaW50KSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICB2YXIgYW8sIGJvLCBhYjtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBibyA9IGRpc3RhbmNlKGNvb3JkaW5hdGVzW2ldLCBwb2ludCk7XG4gICAgaWYgKGJvID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGFiID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIGNvb3JkaW5hdGVzW2kgLSAxXSk7XG4gICAgICBpZiAoXG4gICAgICAgIGFiID4gMCAmJlxuICAgICAgICBhbyA8PSBhYiAmJlxuICAgICAgICBibyA8PSBhYiAmJlxuICAgICAgICAoYW8gKyBibyAtIGFiKSAqICgxIC0gTWF0aC5wb3coKGFvIC0gYm8pIC8gYWIsIDIpKSA8IGVwc2lsb24yICogYWJcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGFvID0gYm87XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb250YWluc1BvbHlnb24oY29vcmRpbmF0ZXMsIHBvaW50KSB7XG4gIHJldHVybiAhIXBvbHlnb25Db250YWlucyhjb29yZGluYXRlcy5tYXAocmluZ1JhZGlhbnMpLCBwb2ludFJhZGlhbnMocG9pbnQpKTtcbn1cblxuZnVuY3Rpb24gcmluZ1JhZGlhbnMocmluZykge1xuICByZXR1cm4gcmluZyA9IHJpbmcubWFwKHBvaW50UmFkaWFucyksIHJpbmcucG9wKCksIHJpbmc7XG59XG5cbmZ1bmN0aW9uIHBvaW50UmFkaWFucyhwb2ludCkge1xuICByZXR1cm4gW3BvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zXTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMob2JqZWN0LCBwb2ludCkge1xuICByZXR1cm4gKG9iamVjdCAmJiBjb250YWluc09iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpXG4gICAgICA/IGNvbnRhaW5zT2JqZWN0VHlwZVtvYmplY3QudHlwZV1cbiAgICAgIDogY29udGFpbnNHZW9tZXRyeSkob2JqZWN0LCBwb2ludCk7XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICB2YXIgeSA9IGQzQXJyYXkucmFuZ2UoeTAsIHkxIC0gZXBzaWxvbiwgZHkpLmNvbmNhdCh5MSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5mdW5jdGlvbiBncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgdmFyIHggPSBkM0FycmF5LnJhbmdlKHgwLCB4MSAtIGVwc2lsb24sIGR4KS5jb25jYXQoeDEpO1xuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICB2YXIgeDEsIHgwLCBYMSwgWDAsXG4gICAgICB5MSwgeTAsIFkxLCBZMCxcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxuICAgICAgeCwgeSwgWCwgWSxcbiAgICAgIHByZWNpc2lvbiA9IDIuNTtcblxuICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKX07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICByZXR1cm4gZDNBcnJheS5yYW5nZShjZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpXG4gICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKVxuICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgLmNvbmNhdChkM0FycmF5LnJhbmdlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uOyB9KS5tYXAoeSkpO1xuICB9XG5cbiAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7IHJldHVybiB7dHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307IH0pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgWChYMCkuY29uY2F0KFxuICAgICAgICBZKFkxKS5zbGljZSgxKSxcbiAgICAgICAgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLFxuICAgICAgICBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXG4gICAgICBdXG4gICAgfTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWFqb3IoXykuZXh0ZW50TWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbWDAsIFkwXSwgW1gxLCBZMV1dO1xuICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1ham9yKF8pLnN0ZXBNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtEWCwgRFldO1xuICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICBwcmVjaXNpb24gPSArXztcbiAgICB4ID0gZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICB5ID0gZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgWCA9IGdyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgWSA9IGdyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgcmV0dXJuIGdyYXRpY3VsZVxuICAgICAgLmV4dGVudE1ham9yKFtbLTE4MCwgLTkwICsgZXBzaWxvbl0sIFsxODAsIDkwIC0gZXBzaWxvbl1dKVxuICAgICAgLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gZXBzaWxvbl0sIFsxODAsIDgwICsgZXBzaWxvbl1dKTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlMTAoKSB7XG4gIHJldHVybiBncmF0aWN1bGUoKSgpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhLCBiKSB7XG4gIHZhciB4MCA9IGFbMF0gKiByYWRpYW5zLFxuICAgICAgeTAgPSBhWzFdICogcmFkaWFucyxcbiAgICAgIHgxID0gYlswXSAqIHJhZGlhbnMsXG4gICAgICB5MSA9IGJbMV0gKiByYWRpYW5zLFxuICAgICAgY3kwID0gY29zKHkwKSxcbiAgICAgIHN5MCA9IHNpbih5MCksXG4gICAgICBjeTEgPSBjb3MoeTEpLFxuICAgICAgc3kxID0gc2luKHkxKSxcbiAgICAgIGt4MCA9IGN5MCAqIGNvcyh4MCksXG4gICAgICBreTAgPSBjeTAgKiBzaW4oeDApLFxuICAgICAga3gxID0gY3kxICogY29zKHgxKSxcbiAgICAgIGt5MSA9IGN5MSAqIHNpbih4MSksXG4gICAgICBkID0gMiAqIGFzaW4oc3FydChoYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGhhdmVyc2luKHgxIC0geDApKSksXG4gICAgICBrID0gc2luKGQpO1xuXG4gIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbih0KSB7XG4gICAgdmFyIEIgPSBzaW4odCAqPSBkKSAvIGssXG4gICAgICAgIEEgPSBzaW4oZCAtIHQpIC8gayxcbiAgICAgICAgeCA9IEEgKiBreDAgKyBCICoga3gxLFxuICAgICAgICB5ID0gQSAqIGt5MCArIEIgKiBreTEsXG4gICAgICAgIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSwgeCkgKiBkZWdyZWVzLFxuICAgICAgYXRhbjIoeiwgc3FydCh4ICogeCArIHkgKiB5KSkgKiBkZWdyZWVzXG4gICAgXTtcbiAgfSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbeDAgKiBkZWdyZWVzLCB5MCAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcblxuICByZXR1cm4gaW50ZXJwb2xhdGU7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbnZhciBhcmVhU3VtJDEgPSBhZGRlcigpLFxuICAgIGFyZWFSaW5nU3VtJDEgPSBhZGRlcigpLFxuICAgIHgwMCxcbiAgICB5MDAsXG4gICAgeDAkMSxcbiAgICB5MCQxO1xuXG52YXIgYXJlYVN0cmVhbSQxID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0kMS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0JDE7XG4gICAgYXJlYVN0cmVhbSQxLmxpbmVFbmQgPSBhcmVhUmluZ0VuZCQxO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtJDEubGluZVN0YXJ0ID0gYXJlYVN0cmVhbSQxLmxpbmVFbmQgPSBhcmVhU3RyZWFtJDEucG9pbnQgPSBub29wO1xuICAgIGFyZWFTdW0kMS5hZGQoYWJzKGFyZWFSaW5nU3VtJDEpKTtcbiAgICBhcmVhUmluZ1N1bSQxLnJlc2V0KCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBhcmVhU3VtJDEgLyAyO1xuICAgIGFyZWFTdW0kMS5yZXNldCgpO1xuICAgIHJldHVybiBhcmVhO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0JDEoKSB7XG4gIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludEZpcnN0JDE7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0JDEoeCwgeSkge1xuICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnQkMTtcbiAgeDAwID0geDAkMSA9IHgsIHkwMCA9IHkwJDEgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQkMSh4LCB5KSB7XG4gIGFyZWFSaW5nU3VtJDEuYWRkKHkwJDEgKiB4IC0geDAkMSAqIHkpO1xuICB4MCQxID0geCwgeTAkMSA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kJDEoKSB7XG4gIGFyZWFQb2ludCQxKHgwMCwgeTAwKTtcbn1cblxudmFyIHgwJDIgPSBJbmZpbml0eSxcbiAgICB5MCQyID0geDAkMixcbiAgICB4MSA9IC14MCQyLFxuICAgIHkxID0geDE7XG5cbnZhciBib3VuZHNTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50JDEsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBub29wLFxuICBwb2x5Z29uRW5kOiBub29wLFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib3VuZHMgPSBbW3gwJDIsIHkwJDJdLCBbeDEsIHkxXV07XG4gICAgeDEgPSB5MSA9IC0oeTAkMiA9IHgwJDIgPSBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQkMSh4LCB5KSB7XG4gIGlmICh4IDwgeDAkMikgeDAkMiA9IHg7XG4gIGlmICh4ID4geDEpIHgxID0geDtcbiAgaWYgKHkgPCB5MCQyKSB5MCQyID0geTtcbiAgaWYgKHkgPiB5MSkgeTEgPSB5O1xufVxuXG4vLyBUT0RPIEVuZm9yY2UgcG9zaXRpdmUgYXJlYSBmb3IgZXh0ZXJpb3IsIG5lZ2F0aXZlIGFyZWEgZm9yIGludGVyaW9yP1xuXG52YXIgWDAkMSA9IDAsXG4gICAgWTAkMSA9IDAsXG4gICAgWjAkMSA9IDAsXG4gICAgWDEkMSA9IDAsXG4gICAgWTEkMSA9IDAsXG4gICAgWjEkMSA9IDAsXG4gICAgWDIkMSA9IDAsXG4gICAgWTIkMSA9IDAsXG4gICAgWjIkMSA9IDAsXG4gICAgeDAwJDEsXG4gICAgeTAwJDEsXG4gICAgeDAkMyxcbiAgICB5MCQzO1xuXG52YXIgY2VudHJvaWRTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQkMSxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCQxLFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQkMSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0JDE7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kJDE7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50JDE7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydCQxO1xuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZCQxO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjZW50cm9pZCA9IFoyJDEgPyBbWDIkMSAvIFoyJDEsIFkyJDEgLyBaMiQxXVxuICAgICAgICA6IFoxJDEgPyBbWDEkMSAvIFoxJDEsIFkxJDEgLyBaMSQxXVxuICAgICAgICA6IFowJDEgPyBbWDAkMSAvIFowJDEsIFkwJDEgLyBaMCQxXVxuICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgWDAkMSA9IFkwJDEgPSBaMCQxID1cbiAgICBYMSQxID0gWTEkMSA9IFoxJDEgPVxuICAgIFgyJDEgPSBZMiQxID0gWjIkMSA9IDA7XG4gICAgcmV0dXJuIGNlbnRyb2lkO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50JDEoeCwgeSkge1xuICBYMCQxICs9IHg7XG4gIFkwJDEgKz0geTtcbiAgKytaMCQxO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCQxKCkge1xuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0TGluZTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0TGluZSh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50TGluZTtcbiAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRMaW5lKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwJDMsIGR5ID0geSAtIHkwJDMsIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgWDEkMSArPSB6ICogKHgwJDMgKyB4KSAvIDI7XG4gIFkxJDEgKz0geiAqICh5MCQzICsgeSkgLyAyO1xuICBaMSQxICs9IHo7XG4gIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQkMSgpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnQkMTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQkMSgpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdFJpbmc7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCQxKCkge1xuICBjZW50cm9pZFBvaW50UmluZyh4MDAkMSwgeTAwJDEpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RSaW5nKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRSaW5nO1xuICBjZW50cm9pZFBvaW50JDEoeDAwJDEgPSB4MCQzID0geCwgeTAwJDEgPSB5MCQzID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRSaW5nKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwJDMsXG4gICAgICBkeSA9IHkgLSB5MCQzLFxuICAgICAgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgWjEkMSArPSB6O1xuXG4gIHogPSB5MCQzICogeCAtIHgwJDMgKiB5O1xuICBYMiQxICs9IHogKiAoeDAkMyArIHgpO1xuICBZMiQxICs9IHogKiAoeTAkMyArIHkpO1xuICBaMiQxICs9IHogKiAzO1xuICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbn1cblxuZnVuY3Rpb24gUGF0aENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUGF0aENvbnRleHQucHJvdG90eXBlID0ge1xuICBfcmFkaXVzOiA0LjUsXG4gIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXM7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4ICsgdGhpcy5fcmFkaXVzLCB5KTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoeCwgeSwgdGhpcy5fcmFkaXVzLCAwLCB0YXUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogbm9vcFxufTtcblxudmFyIGxlbmd0aFN1bSQxID0gYWRkZXIoKSxcbiAgICBsZW5ndGhSaW5nLFxuICAgIHgwMCQyLFxuICAgIHkwMCQyLFxuICAgIHgwJDQsXG4gICAgeTAkNDtcblxudmFyIGxlbmd0aFN0cmVhbSQxID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3QkMTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGxlbmd0aFJpbmcpIGxlbmd0aFBvaW50JDEoeDAwJDIsIHkwMCQyKTtcbiAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtJDE7XG4gICAgbGVuZ3RoU3VtJDEucmVzZXQoKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0JDEoeCwgeSkge1xuICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IGxlbmd0aFBvaW50JDE7XG4gIHgwMCQyID0geDAkNCA9IHgsIHkwMCQyID0geTAkNCA9IHk7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50JDEoeCwgeSkge1xuICB4MCQ0IC09IHgsIHkwJDQgLT0geTtcbiAgbGVuZ3RoU3VtJDEuYWRkKHNxcnQoeDAkNCAqIHgwJDQgKyB5MCQ0ICogeTAkNCkpO1xuICB4MCQ0ID0geCwgeTAkNCA9IHk7XG59XG5cbmZ1bmN0aW9uIFBhdGhTdHJpbmcoKSB7XG4gIHRoaXMuX3N0cmluZyA9IFtdO1xufVxuXG5QYXRoU3RyaW5nLnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBfY2lyY2xlOiBjaXJjbGUkMSg0LjUpLFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIGlmICgoXyA9ICtfKSAhPT0gdGhpcy5fcmFkaXVzKSB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzLl9jaXJjbGUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX3N0cmluZy5wdXNoKFwiWlwiKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX2NpcmNsZSA9PSBudWxsKSB0aGlzLl9jaXJjbGUgPSBjaXJjbGUkMSh0aGlzLl9yYWRpdXMpO1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3N0cmluZy5qb2luKFwiXCIpO1xuICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNpcmNsZSQxKHJhZGl1cykge1xuICByZXR1cm4gXCJtMCxcIiArIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzXG4gICAgICArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1c1xuICAgICAgKyBcInpcIjtcbn1cblxuZnVuY3Rpb24gaW5kZXgocHJvamVjdGlvbiwgY29udGV4dCkge1xuICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsXG4gICAgICBwcm9qZWN0aW9uU3RyZWFtLFxuICAgICAgY29udGV4dFN0cmVhbTtcblxuICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNvbnRleHRTdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gIH1cblxuICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGFyZWFTdHJlYW0kMSkpO1xuICAgIHJldHVybiBhcmVhU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShsZW5ndGhTdHJlYW0kMSkpO1xuICAgIHJldHVybiBsZW5ndGhTdHJlYW0kMS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICByZXR1cm4gYm91bmRzU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY2VudHJvaWRTdHJlYW0kMSkpO1xuICAgIHJldHVybiBjZW50cm9pZFN0cmVhbSQxLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSkgOiAocHJvamVjdGlvbiA9IF8pLnN0cmVhbSwgcGF0aCkgOiBwcm9qZWN0aW9uO1xuICB9O1xuXG4gIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHRTdHJlYW0gPSBfID09IG51bGwgPyAoY29udGV4dCA9IG51bGwsIG5ldyBQYXRoU3RyaW5nKSA6IG5ldyBQYXRoQ29udGV4dChjb250ZXh0ID0gXyk7XG4gICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKHByb2plY3Rpb24pLmNvbnRleHQoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbn07XG5cbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xuICB2YXIgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgcHJvamVjdGlvbi5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSQxKSk7XG4gIGZpdEJvdW5kcyhib3VuZHNTdHJlYW0kMS5yZXN1bHQoKSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cbmZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcbiAgICAgICAgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSxcbiAgICAgICAgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gK3dpZHRoLFxuICAgICAgICBrID0gdyAvIChiWzFdWzBdIC0gYlswXVswXSksXG4gICAgICAgIHggPSAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSAtayAqIGJbMF1bMV07XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciBoID0gK2hlaWdodCxcbiAgICAgICAgayA9IGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pLFxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxuICAgICAgICB5ID0gKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbnZhciBtYXhEZXB0aCA9IDE2LCAvLyBtYXhpbXVtIGRlcHRoIG9mIHN1YmRpdmlzaW9uXG4gICAgY29zTWluRGlzdGFuY2UgPSBjb3MoMzAgKiByYWRpYW5zKTsgLy8gY29zKG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSlcblxuZnVuY3Rpb24gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSB7XG4gIHJldHVybiArZGVsdGEyID8gcmVzYW1wbGUkMShwcm9qZWN0LCBkZWx0YTIpIDogcmVzYW1wbGVOb25lKHByb2plY3QpO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZU5vbmUocHJvamVjdCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSB7XG5cbiAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICB2YXIgZHggPSB4MSAtIHgwLFxuICAgICAgICBkeSA9IHkxIC0geTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGQyID4gNCAqIGRlbHRhMiAmJiBkZXB0aC0tKSB7XG4gICAgICB2YXIgYSA9IGEwICsgYTEsXG4gICAgICAgICAgYiA9IGIwICsgYjEsXG4gICAgICAgICAgYyA9IGMwICsgYzEsXG4gICAgICAgICAgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSxcbiAgICAgICAgICBwaGkyID0gYXNpbihjIC89IG0pLFxuICAgICAgICAgIGxhbWJkYTIgPSBhYnMoYWJzKGMpIC0gMSkgPCBlcHNpbG9uIHx8IGFicyhsYW1iZGEwIC0gbGFtYmRhMSkgPCBlcHNpbG9uID8gKGxhbWJkYTAgKyBsYW1iZGExKSAvIDIgOiBhdGFuMihiLCBhKSxcbiAgICAgICAgICBwID0gcHJvamVjdChsYW1iZGEyLCBwaGkyKSxcbiAgICAgICAgICB4MiA9IHBbMF0sXG4gICAgICAgICAgeTIgPSBwWzFdLFxuICAgICAgICAgIGR4MiA9IHgyIC0geDAsXG4gICAgICAgICAgZHkyID0geTIgLSB5MCxcbiAgICAgICAgICBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICBpZiAoZHogKiBkeiAvIGQyID4gZGVsdGEyIC8vIHBlcnBlbmRpY3VsYXIgcHJvamVjdGVkIGRpc3RhbmNlXG4gICAgICAgICAgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gMC41KSA+IDAuMyAvLyBtaWRwb2ludCBjbG9zZSB0byBhbiBlbmRcbiAgICAgICAgICB8fCBhMCAqIGExICsgYjAgKiBiMSArIGMwICogYzEgPCBjb3NNaW5EaXN0YW5jZSkgeyAvLyBhbmd1bGFyIGRpc3RhbmNlXG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDIsIHkyLCBsYW1iZGEyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MiwgeTIpO1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIGxhbWJkYTIsIGEsIGIsIGMsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgbGFtYmRhMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICBsYW1iZGEwLCB4MCwgeTAsIGEwLCBiMCwgYzA7IC8vIHByZXZpb3VzIHBvaW50XG5cbiAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvblN0YXJ0KCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IHJpbmdTdGFydDsgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyBzdHJlYW0ucG9seWdvbkVuZCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7IH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgeDAgPSBOYU47XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIHZhciBjID0gY2FydGVzaWFuKFtsYW1iZGEsIHBoaV0pLCBwID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCBsYW1iZGEwID0gbGFtYmRhLCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICBsaW5lU3RhcnQoKTtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lUG9pbnQobGFtYmRhMDAgPSBsYW1iZGEsIHBoaSksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCBsYW1iZGEwMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgIGxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzYW1wbGVTdHJlYW07XG4gIH07XG59XG5cbnZhciB0cmFuc2Zvcm1SYWRpYW5zID0gdHJhbnNmb3JtZXIoe1xuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiByYWRpYW5zLCB5ICogcmFkaWFucyk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Sb3RhdGUocm90YXRlKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciByID0gcm90YXRlKHgsIHkpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLnBvaW50KHJbMF0sIHJbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSkge1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHJldHVybiBbZHggKyBrICogeCwgZHkgLSBrICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyh4IC0gZHgpIC8gaywgKGR5IC0geSkgLyBrXTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgZHgsIGR5LCBhbHBoYSkge1xuICB2YXIgY29zQWxwaGEgPSBjb3MoYWxwaGEpLFxuICAgICAgc2luQWxwaGEgPSBzaW4oYWxwaGEpLFxuICAgICAgYSA9IGNvc0FscGhhICogayxcbiAgICAgIGIgPSBzaW5BbHBoYSAqIGssXG4gICAgICBhaSA9IGNvc0FscGhhIC8gayxcbiAgICAgIGJpID0gc2luQWxwaGEgLyBrLFxuICAgICAgY2kgPSAoc2luQWxwaGEgKiBkeSAtIGNvc0FscGhhICogZHgpIC8gayxcbiAgICAgIGZpID0gKHNpbkFscGhhICogZHggKyBjb3NBbHBoYSAqIGR5KSAvIGs7XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5KSB7XG4gICAgcmV0dXJuIFthICogeCAtIGIgKiB5ICsgZHgsIGR5IC0gYiAqIHggLSBhICogeV07XG4gIH1cbiAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW2FpICogeCAtIGJpICogeSArIGNpLCBmaSAtIGJpICogeCAtIGFpICogeV07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xuICByZXR1cm4gcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24oKSB7IHJldHVybiBwcm9qZWN0OyB9KSgpO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgdmFyIHByb2plY3QsXG4gICAgICBrID0gMTUwLCAvLyBzY2FsZVxuICAgICAgeCA9IDQ4MCwgeSA9IDI1MCwgLy8gdHJhbnNsYXRlXG4gICAgICBsYW1iZGEgPSAwLCBwaGkgPSAwLCAvLyBjZW50ZXJcbiAgICAgIGRlbHRhTGFtYmRhID0gMCwgZGVsdGFQaGkgPSAwLCBkZWx0YUdhbW1hID0gMCwgcm90YXRlLCAvLyBwcmUtcm90YXRlXG4gICAgICBhbHBoYSA9IDAsIC8vIHBvc3Qtcm90YXRlXG4gICAgICB0aGV0YSA9IG51bGwsIHByZWNsaXAgPSBjbGlwQW50aW1lcmlkaWFuLCAvLyBwcmUtY2xpcCBhbmdsZVxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5LCAvLyBwb3N0LWNsaXAgZXh0ZW50XG4gICAgICBkZWx0YTIgPSAwLjUsIC8vIHByZWNpc2lvblxuICAgICAgcHJvamVjdFJlc2FtcGxlLFxuICAgICAgcHJvamVjdFRyYW5zZm9ybSxcbiAgICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0sXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybShwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFucyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICBwb2ludCA9IHByb2plY3RSb3RhdGVUcmFuc2Zvcm0uaW52ZXJ0KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMsIHBvaW50WzFdICogZGVncmVlc107XG4gIH1cblxuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnModHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkocHJlY2xpcChwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9IF8sIHRoZXRhID0gdW5kZWZpbmVkLCByZXNldCgpKSA6IHByZWNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wb3N0Y2xpcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8sIHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgcmVzZXQoKSkgOiBwb3N0Y2xpcDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzO1xuICB9O1xuXG4gIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICB9O1xuXG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgcGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogW2xhbWJkYSAqIGRlZ3JlZXMsIHBoaSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlbHRhTGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhUGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIGRlbHRhR2FtbWEgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogcmFkaWFucyA6IDAsIHJlY2VudGVyKCkpIDogW2RlbHRhTGFtYmRhICogZGVncmVlcywgZGVsdGFQaGkgKiBkZWdyZWVzLCBkZWx0YUdhbW1hICogZGVncmVlc107XG4gIH07XG5cbiAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IGFscGhhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIgPSBfICogXyksIHJlc2V0KCkpIDogc3FydChkZWx0YTIpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWNlbnRlcigpIHtcbiAgICB2YXIgY2VudGVyID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgMCwgMCwgYWxwaGEpLmFwcGx5KG51bGwsIHByb2plY3QobGFtYmRhLCBwaGkpKSxcbiAgICAgICAgdHJhbnNmb3JtID0gKGFscGhhID8gc2NhbGVUcmFuc2xhdGVSb3RhdGUgOiBzY2FsZVRyYW5zbGF0ZSkoaywgeCAtIGNlbnRlclswXSwgeSAtIGNlbnRlclsxXSwgYWxwaGEpO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKTtcbiAgICBwcm9qZWN0VHJhbnNmb3JtID0gY29tcG9zZShwcm9qZWN0LCB0cmFuc2Zvcm0pO1xuICAgIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0gPSBjb21wb3NlKHJvdGF0ZSwgcHJvamVjdFRyYW5zZm9ybSk7XG4gICAgcHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyKTtcbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICByZXR1cm4gcmVjZW50ZXIoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29uaWNQcm9qZWN0aW9uKHByb2plY3RBdCkge1xuICB2YXIgcGhpMCA9IDAsXG4gICAgICBwaGkxID0gcGkgLyAzLFxuICAgICAgbSA9IHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksXG4gICAgICBwID0gbShwaGkwLCBwaGkxKTtcblxuICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0ocGhpMCA9IF9bMF0gKiByYWRpYW5zLCBwaGkxID0gX1sxXSAqIHJhZGlhbnMpIDogW3BoaTAgKiBkZWdyZWVzLCBwaGkxICogZGVncmVlc107XG4gIH07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHBoaTApIHtcbiAgdmFyIGNvc1BoaTAgPSBjb3MocGhpMCk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBbbGFtYmRhICogY29zUGhpMCwgc2luKHBoaSkgLyBjb3NQaGkwXTtcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbeCAvIGNvc1BoaTAsIGFzaW4oeSAqIGNvc1BoaTApXTtcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cblxuZnVuY3Rpb24gY29uaWNFcXVhbEFyZWFSYXcoeTAsIHkxKSB7XG4gIHZhciBzeTAgPSBzaW4oeTApLCBuID0gKHN5MCArIHNpbih5MSkpIC8gMjtcblxuICAvLyBBcmUgdGhlIHBhcmFsbGVscyBzeW1tZXRyaWNhbCBhcm91bmQgdGhlIEVxdWF0b3I/XG4gIGlmIChhYnMobikgPCBlcHNpbG9uKSByZXR1cm4gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcoeTApO1xuXG4gIHZhciBjID0gMSArIHN5MCAqICgyICogbiAtIHN5MCksIHIwID0gc3FydChjKSAvIG47XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgdmFyIHIgPSBzcXJ0KGMgLSAyICogbiAqIHNpbih5KSkgLyBuO1xuICAgIHJldHVybiBbciAqIHNpbih4ICo9IG4pLCByMCAtIHIgKiBjb3MoeCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHIweSA9IHIwIC0geTtcbiAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhyMHkpKSAvIG4gKiBzaWduKHIweSksIGFzaW4oKGMgLSAoeCAqIHggKyByMHkgKiByMHkpICogbiAqIG4pIC8gKDIgKiBuKSldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5mdW5jdGlvbiBjb25pY0VxdWFsQXJlYSgpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWFsQXJlYVJhdylcbiAgICAgIC5zY2FsZSgxNTUuNDI0KVxuICAgICAgLmNlbnRlcihbMCwgMzMuNjQ0Ml0pO1xufVxuXG5mdW5jdGlvbiBhbGJlcnMoKSB7XG4gIHJldHVybiBjb25pY0VxdWFsQXJlYSgpXG4gICAgICAucGFyYWxsZWxzKFsyOS41LCA0NS41XSlcbiAgICAgIC5zY2FsZSgxMDcwKVxuICAgICAgLnRyYW5zbGF0ZShbNDgwLCAyNTBdKVxuICAgICAgLnJvdGF0ZShbOTYsIDBdKVxuICAgICAgLmNlbnRlcihbLTAuNiwgMzguN10pO1xufVxuXG4vLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbi8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuZnVuY3Rpb24gbXVsdGlwbGV4KHN0cmVhbXMpIHtcbiAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5zcGhlcmUoKTsgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTsgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpOyB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7IH1cbiAgfTtcbn1cblxuLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgdGhlIFVuaXRlZCBTdGF0ZXMsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3Jcbi8vIDk2MMOXNTAwLiBUaGUgcHJvamVjdGlvbiBhbHNvIHdvcmtzIHF1aXRlIHdlbGwgYXQgOTYww5c2MDAgaWYgeW91IGNoYW5nZSB0aGVcbi8vIHNjYWxlIHRvIDEyODUgYW5kIGFkanVzdCB0aGUgdHJhbnNsYXRlIGFjY29yZGluZ2x5LiBUaGUgc2V0IG9mIHN0YW5kYXJkXG4vLyBwYXJhbGxlbHMgZm9yIGVhY2ggcmVnaW9uIGNvbWVzIGZyb20gVVNHUywgd2hpY2ggaXMgcHVibGlzaGVkIGhlcmU6XG4vLyBodHRwOi8vZWdzYy51c2dzLmdvdi9pc2IvcHVicy9NYXBQcm9qZWN0aW9ucy9wcm9qZWN0aW9ucy5odG1sI2FsYmVyc1xuZnVuY3Rpb24gYWxiZXJzVXNhKCkge1xuICB2YXIgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbSxcbiAgICAgIGxvd2VyNDggPSBhbGJlcnMoKSwgbG93ZXI0OFBvaW50LFxuICAgICAgYWxhc2thID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBhbGFza2FQb2ludCwgLy8gRVBTRzozMzM4XG4gICAgICBoYXdhaWkgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU3LCAwXSkuY2VudGVyKFstMywgMTkuOV0pLnBhcmFsbGVscyhbOCwgMThdKSwgaGF3YWlpUG9pbnQsIC8vIEVTUkk6MTAyMDA3XG4gICAgICBwb2ludCwgcG9pbnRTdHJlYW0gPSB7cG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH19O1xuXG4gIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAobG93ZXI0OFBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgfHwgKGFsYXNrYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgfHwgKGhhd2FpaVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gIH1cblxuICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSxcbiAgICAgICAgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksXG4gICAgICAgIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssXG4gICAgICAgIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgcmV0dXJuICh5ID49IDAuMTIwICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjQyNSAmJiB4IDwgLTAuMjE0ID8gYWxhc2thXG4gICAgICAgIDogeSA+PSAwLjE2NiAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC4yMTQgJiYgeCA8IC0wLjExNSA/IGhhd2FpaVxuICAgICAgICA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleChbbG93ZXI0OC5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaS5zdHJlYW0oc3RyZWFtKV0pO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICBsb3dlcjQ4LnByZWNpc2lvbihfKSwgYWxhc2thLnByZWNpc2lvbihfKSwgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfTtcblxuICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgIGxvd2VyNDguc2NhbGUoXyksIGFsYXNrYS5zY2FsZShfICogMC4zNSksIGhhd2FpaS5zY2FsZShfKTtcbiAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgfTtcblxuICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuXG4gICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OFxuICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDU1ICogaywgeSAtIDAuMjM4ICoga10sIFt4ICsgMC40NTUgKiBrLCB5ICsgMC4yMzggKiBrXV0pXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuXG4gICAgYWxhc2thUG9pbnQgPSBhbGFza2FcbiAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMzA3ICogaywgeSArIDAuMjAxICoga10pXG4gICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI1ICogayArIGVwc2lsb24sIHkgKyAwLjEyMCAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjIxNCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcblxuICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpXG4gICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjIwNSAqIGssIHkgKyAwLjIxMiAqIGtdKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjIxNCAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xNjYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4xMTUgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KGFsYmVyc1VzYSwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgoYWxiZXJzVXNhLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KGFsYmVyc1VzYSwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBhbGJlcnNVc2E7XG4gIH1cblxuICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xufVxuXG5mdW5jdGlvbiBhemltdXRoYWxSYXcoc2NhbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgY3ggPSBjb3MoeCksXG4gICAgICAgIGN5ID0gY29zKHkpLFxuICAgICAgICBrID0gc2NhbGUoY3ggKiBjeSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGsgKiBjeSAqIHNpbih4KSxcbiAgICAgIGsgKiBzaW4oeSlcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF6aW11dGhhbEludmVydChhbmdsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB6ID0gc3FydCh4ICogeCArIHkgKiB5KSxcbiAgICAgICAgYyA9IGFuZ2xlKHopLFxuICAgICAgICBzYyA9IHNpbihjKSxcbiAgICAgICAgY2MgPSBjb3MoYyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHggKiBzYywgeiAqIGNjKSxcbiAgICAgIGFzaW4oeiAmJiB5ICogc2MgLyB6KVxuICAgIF07XG4gIH1cbn1cblxudmFyIGF6aW11dGhhbEVxdWFsQXJlYVJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbihjeGN5KSB7XG4gIHJldHVybiBzcXJ0KDIgLyAoMSArIGN4Y3kpKTtcbn0pO1xuXG5hemltdXRoYWxFcXVhbEFyZWFSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIDIgKiBhc2luKHogLyAyKTtcbn0pO1xuXG5mdW5jdGlvbiBhemltdXRoYWxFcXVhbEFyZWEoKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWFsQXJlYVJhdylcbiAgICAgIC5zY2FsZSgxMjQuNzUpXG4gICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xufVxuXG52YXIgYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oYykge1xuICByZXR1cm4gKGMgPSBhY29zKGMpKSAmJiBjIC8gc2luKGMpO1xufSk7XG5cbmF6aW11dGhhbEVxdWlkaXN0YW50UmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiB6O1xufSk7XG5cbmZ1bmN0aW9uIGF6aW11dGhhbEVxdWlkaXN0YW50KCkge1xuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVpZGlzdGFudFJhdylcbiAgICAgIC5zY2FsZSg3OS40MTg4KVxuICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbn1cblxuZnVuY3Rpb24gbWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsYW1iZGEsIGxvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSldO1xufVxuXG5tZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbeCwgMiAqIGF0YW4oZXhwKHkpKSAtIGhhbGZQaV07XG59O1xuXG5mdW5jdGlvbiBtZXJjYXRvcigpIHtcbiAgcmV0dXJuIG1lcmNhdG9yUHJvamVjdGlvbihtZXJjYXRvclJhdylcbiAgICAgIC5zY2FsZSg5NjEgLyB0YXUpO1xufVxuXG5mdW5jdGlvbiBtZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICB2YXIgbSA9IHByb2plY3Rpb24ocHJvamVjdCksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHNjYWxlID0gbS5zY2FsZSxcbiAgICAgIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLFxuICAgICAgY2xpcEV4dGVudCA9IG0uY2xpcEV4dGVudCxcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MTsgLy8gY2xpcCBleHRlbnRcblxuICBtLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlKF8pLCByZWNsaXAoKSkgOiBzY2FsZSgpO1xuICB9O1xuXG4gIG0udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZShfKSwgcmVjbGlwKCkpIDogdHJhbnNsYXRlKCk7XG4gIH07XG5cbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyKF8pLCByZWNsaXAoKSkgOiBjZW50ZXIoKTtcbiAgfTtcblxuICBtLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKF8gPT0gbnVsbCA/IHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCA6ICh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSksIHJlY2xpcCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjbGlwKCkge1xuICAgIHZhciBrID0gcGkgKiBzY2FsZSgpLFxuICAgICAgICB0ID0gbShyb3RhdGlvbihtLnJvdGF0ZSgpKS5pbnZlcnQoWzAsIDBdKSk7XG4gICAgcmV0dXJuIGNsaXBFeHRlbnQoeDAgPT0gbnVsbFxuICAgICAgICA/IFtbdFswXSAtIGssIHRbMV0gLSBrXSwgW3RbMF0gKyBrLCB0WzFdICsga11dIDogcHJvamVjdCA9PT0gbWVyY2F0b3JSYXdcbiAgICAgICAgPyBbW01hdGgubWF4KHRbMF0gLSBrLCB4MCksIHkwXSwgW01hdGgubWluKHRbMF0gKyBrLCB4MSksIHkxXV1cbiAgICAgICAgOiBbW3gwLCBNYXRoLm1heCh0WzFdIC0gaywgeTApXSwgW3gxLCBNYXRoLm1pbih0WzFdICsgaywgeTEpXV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlY2xpcCgpO1xufVxuXG5mdW5jdGlvbiB0YW55KHkpIHtcbiAgcmV0dXJuIHRhbigoaGFsZlBpICsgeSkgLyAyKTtcbn1cblxuZnVuY3Rpb24gY29uaWNDb25mb3JtYWxSYXcoeTAsIHkxKSB7XG4gIHZhciBjeTAgPSBjb3MoeTApLFxuICAgICAgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiBsb2coY3kwIC8gY29zKHkxKSkgLyBsb2codGFueSh5MSkgLyB0YW55KHkwKSksXG4gICAgICBmID0gY3kwICogcG93KHRhbnkoeTApLCBuKSAvIG47XG5cbiAgaWYgKCFuKSByZXR1cm4gbWVyY2F0b3JSYXc7XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgaWYgKGYgPiAwKSB7IGlmICh5IDwgLWhhbGZQaSArIGVwc2lsb24pIHkgPSAtaGFsZlBpICsgZXBzaWxvbjsgfVxuICAgIGVsc2UgeyBpZiAoeSA+IGhhbGZQaSAtIGVwc2lsb24pIHkgPSBoYWxmUGkgLSBlcHNpbG9uOyB9XG4gICAgdmFyIHIgPSBmIC8gcG93KHRhbnkoeSksIG4pO1xuICAgIHJldHVybiBbciAqIHNpbihuICogeCksIGYgLSByICogY29zKG4gKiB4KV07XG4gIH1cblxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgZnkgPSBmIC0geSwgciA9IHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZnkgKiBmeSk7XG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZnkpKSAvIG4gKiBzaWduKGZ5KSwgMiAqIGF0YW4ocG93KGYgLyByLCAxIC8gbikpIC0gaGFsZlBpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZnVuY3Rpb24gY29uaWNDb25mb3JtYWwoKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNDb25mb3JtYWxSYXcpXG4gICAgICAuc2NhbGUoMTA5LjUpXG4gICAgICAucGFyYWxsZWxzKFszMCwgMzBdKTtcbn1cblxuZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhLCBwaGldO1xufVxuXG5lcXVpcmVjdGFuZ3VsYXJSYXcuaW52ZXJ0ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuXG5mdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXIoKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGVxdWlyZWN0YW5ndWxhclJhdylcbiAgICAgIC5zY2FsZSgxNTIuNjMpO1xufVxuXG5mdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50UmF3KHkwLCB5MSkge1xuICB2YXIgY3kwID0gY29zKHkwKSxcbiAgICAgIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogKGN5MCAtIGNvcyh5MSkpIC8gKHkxIC0geTApLFxuICAgICAgZyA9IGN5MCAvIG4gKyB5MDtcblxuICBpZiAoYWJzKG4pIDwgZXBzaWxvbikgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclJhdztcblxuICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICB2YXIgZ3kgPSBnIC0geSwgbnggPSBuICogeDtcbiAgICByZXR1cm4gW2d5ICogc2luKG54KSwgZyAtIGd5ICogY29zKG54KV07XG4gIH1cblxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgZ3kgPSBnIC0geTtcbiAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhneSkpIC8gbiAqIHNpZ24oZ3kpLCBnIC0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBneSAqIGd5KV07XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnQoKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVpZGlzdGFudFJhdylcbiAgICAgIC5zY2FsZSgxMzEuMTU0KVxuICAgICAgLmNlbnRlcihbMCwgMTMuOTM4OV0pO1xufVxuXG52YXIgQTEgPSAxLjM0MDI2NCxcbiAgICBBMiA9IC0wLjA4MTEwNixcbiAgICBBMyA9IDAuMDAwODkzLFxuICAgIEE0ID0gMC4wMDM3OTYsXG4gICAgTSA9IHNxcnQoMykgLyAyLFxuICAgIGl0ZXJhdGlvbnMgPSAxMjtcblxuZnVuY3Rpb24gZXF1YWxFYXJ0aFJhdyhsYW1iZGEsIHBoaSkge1xuICB2YXIgbCA9IGFzaW4oTSAqIHNpbihwaGkpKSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gIHJldHVybiBbXG4gICAgbGFtYmRhICogY29zKGwpIC8gKE0gKiAoQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKSkpLFxuICAgIGwgKiAoQTEgKyBBMiAqIGwyICsgbDYgKiAoQTMgKyBBNCAqIGwyKSlcbiAgXTtcbn1cblxuZXF1YWxFYXJ0aFJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBsID0geSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gIGZvciAodmFyIGkgPSAwLCBkZWx0YSwgZnksIGZweTsgaSA8IGl0ZXJhdGlvbnM7ICsraSkge1xuICAgIGZ5ID0gbCAqIChBMSArIEEyICogbDIgKyBsNiAqIChBMyArIEE0ICogbDIpKSAtIHk7XG4gICAgZnB5ID0gQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKTtcbiAgICBsIC09IGRlbHRhID0gZnkgLyBmcHksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICAgIGlmIChhYnMoZGVsdGEpIDwgZXBzaWxvbjIpIGJyZWFrO1xuICB9XG4gIHJldHVybiBbXG4gICAgTSAqIHggKiAoQTEgKyAzICogQTIgKiBsMiArIGw2ICogKDcgKiBBMyArIDkgKiBBNCAqIGwyKSkgLyBjb3MobCksXG4gICAgYXNpbihzaW4obCkgLyBNKVxuICBdO1xufTtcblxuZnVuY3Rpb24gZXF1YWxFYXJ0aCgpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZXF1YWxFYXJ0aFJhdylcbiAgICAgIC5zY2FsZSgxNzcuMTU4KTtcbn1cblxuZnVuY3Rpb24gZ25vbW9uaWNSYXcoeCwgeSkge1xuICB2YXIgY3kgPSBjb3MoeSksIGsgPSBjb3MoeCkgKiBjeTtcbiAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xufVxuXG5nbm9tb25pY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXRhbik7XG5cbmZ1bmN0aW9uIGdub21vbmljKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihnbm9tb25pY1JhdylcbiAgICAgIC5zY2FsZSgxNDQuMDQ5KVxuICAgICAgLmNsaXBBbmdsZSg2MCk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlJDEoa3gsIGt5LCB0eCwgdHkpIHtcbiAgcmV0dXJuIGt4ID09PSAxICYmIGt5ID09PSAxICYmIHR4ID09PSAwICYmIHR5ID09PSAwID8gaWRlbnRpdHkgOiB0cmFuc2Zvcm1lcih7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiBreCArIHR4LCB5ICoga3kgKyB0eSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkkMSgpIHtcbiAgdmFyIGsgPSAxLCB0eCA9IDAsIHR5ID0gMCwgc3ggPSAxLCBzeSA9IDEsIHRyYW5zZm9ybSA9IGlkZW50aXR5LCAvLyBzY2FsZSwgdHJhbnNsYXRlIGFuZCByZWZsZWN0XG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIC8vIGNsaXAgZXh0ZW50XG4gICAgICBwb3N0Y2xpcCA9IGlkZW50aXR5LFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbSxcbiAgICAgIHByb2plY3Rpb247XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICByZXR1cm4gcHJvamVjdGlvbiA9IHtcbiAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gdHJhbnNmb3JtKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSk7XG4gICAgfSxcbiAgICBwb3N0Y2xpcDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gICAgfSxcbiAgICBjbGlwRXh0ZW50OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZSQxKChrID0gK18pICogc3gsIGsgKiBzeSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBrO1xuICAgIH0sXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZSQxKGsgKiBzeCwgayAqIHN5LCB0eCA9ICtfWzBdLCB0eSA9ICtfWzFdKSwgcmVzZXQoKSkgOiBbdHgsIHR5XTtcbiAgICB9LFxuICAgIHJlZmxlY3RYOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZSQxKGsgKiAoc3ggPSBfID8gLTEgOiAxKSwgayAqIHN5LCB0eCwgdHkpLCByZXNldCgpKSA6IHN4IDwgMDtcbiAgICB9LFxuICAgIHJlZmxlY3RZOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZSQxKGsgKiBzeCwgayAqIChzeSA9IF8gPyAtMSA6IDEpLCB0eCwgdHkpLCByZXNldCgpKSA6IHN5IDwgMDtcbiAgICB9LFxuICAgIGZpdEV4dGVudDogZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICAgIH0sXG4gICAgZml0U2l6ZTogZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICAgIH0sXG4gICAgZml0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGZpdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbmF0dXJhbEVhcnRoMVJhdyhsYW1iZGEsIHBoaSkge1xuICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyO1xuICByZXR1cm4gW1xuICAgIGxhbWJkYSAqICgwLjg3MDcgLSAwLjEzMTk3OSAqIHBoaTIgKyBwaGk0ICogKC0wLjAxMzc5MSArIHBoaTQgKiAoMC4wMDM5NzEgKiBwaGkyIC0gMC4wMDE1MjkgKiBwaGk0KSkpLFxuICAgIHBoaSAqICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKyBwaGk0ICogKC0wLjA0NDQ3NSArIDAuMDI4ODc0ICogcGhpMiAtIDAuMDA1OTE2ICogcGhpNCkpKVxuICBdO1xufVxuXG5uYXR1cmFsRWFydGgxUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHBoaSA9IHksIGkgPSAyNSwgZGVsdGE7XG4gIGRvIHtcbiAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyO1xuICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSkgLSB5KSAvXG4gICAgICAgICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKiAzICsgcGhpNCAqICgtMC4wNDQ0NzUgKiA3ICsgMC4wMjg4NzQgKiA5ICogcGhpMiAtIDAuMDA1OTE2ICogMTEgKiBwaGk0KSkpO1xuICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgcmV0dXJuIFtcbiAgICB4IC8gKDAuODcwNyArIChwaGkyID0gcGhpICogcGhpKSAqICgtMC4xMzE5NzkgKyBwaGkyICogKC0wLjAxMzc5MSArIHBoaTIgKiBwaGkyICogcGhpMiAqICgwLjAwMzk3MSAtIDAuMDAxNTI5ICogcGhpMikpKSksXG4gICAgcGhpXG4gIF07XG59O1xuXG5mdW5jdGlvbiBuYXR1cmFsRWFydGgxKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihuYXR1cmFsRWFydGgxUmF3KVxuICAgICAgLnNjYWxlKDE3NS4yOTUpO1xufVxuXG5mdW5jdGlvbiBvcnRob2dyYXBoaWNSYXcoeCwgeSkge1xuICByZXR1cm4gW2Nvcyh5KSAqIHNpbih4KSwgc2luKHkpXTtcbn1cblxub3J0aG9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChhc2luKTtcblxuZnVuY3Rpb24gb3J0aG9ncmFwaGljKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihvcnRob2dyYXBoaWNSYXcpXG4gICAgICAuc2NhbGUoMjQ5LjUpXG4gICAgICAuY2xpcEFuZ2xlKDkwICsgZXBzaWxvbik7XG59XG5cbmZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWNSYXcoeCwgeSkge1xuICB2YXIgY3kgPSBjb3MoeSksIGsgPSAxICsgY29zKHgpICogY3k7XG4gIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbn1cblxuc3RlcmVvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gMiAqIGF0YW4oeik7XG59KTtcblxuZnVuY3Rpb24gc3RlcmVvZ3JhcGhpYygpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oc3RlcmVvZ3JhcGhpY1JhdylcbiAgICAgIC5zY2FsZSgyNTApXG4gICAgICAuY2xpcEFuZ2xlKDE0Mik7XG59XG5cbmZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSksIC1sYW1iZGFdO1xufVxuXG50cmFuc3ZlcnNlTWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gWy15LCAyICogYXRhbihleHAoeCkpIC0gaGFsZlBpXTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvcigpIHtcbiAgdmFyIG0gPSBtZXJjYXRvclByb2plY3Rpb24odHJhbnN2ZXJzZU1lcmNhdG9yUmF3KSxcbiAgICAgIGNlbnRlciA9IG0uY2VudGVyLFxuICAgICAgcm90YXRlID0gbS5yb3RhdGU7XG5cbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjZW50ZXIoWy1fWzFdLCBfWzBdXSkgOiAoXyA9IGNlbnRlcigpLCBbX1sxXSwgLV9bMF1dKTtcbiAgfTtcblxuICBtLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJvdGF0ZShbX1swXSwgX1sxXSwgXy5sZW5ndGggPiAyID8gX1syXSArIDkwIDogOTBdKSA6IChfID0gcm90YXRlKCksIFtfWzBdLCBfWzFdLCBfWzJdIC0gOTBdKTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRlKFswLCAwLCA5MF0pXG4gICAgICAuc2NhbGUoMTU5LjE1NSk7XG59XG5cbmV4cG9ydHMuZ2VvQWxiZXJzID0gYWxiZXJzO1xuZXhwb3J0cy5nZW9BbGJlcnNVc2EgPSBhbGJlcnNVc2E7XG5leHBvcnRzLmdlb0FyZWEgPSBhcmVhO1xuZXhwb3J0cy5nZW9BemltdXRoYWxFcXVhbEFyZWEgPSBhemltdXRoYWxFcXVhbEFyZWE7XG5leHBvcnRzLmdlb0F6aW11dGhhbEVxdWFsQXJlYVJhdyA9IGF6aW11dGhhbEVxdWFsQXJlYVJhdztcbmV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnQgPSBhemltdXRoYWxFcXVpZGlzdGFudDtcbmV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSBhemltdXRoYWxFcXVpZGlzdGFudFJhdztcbmV4cG9ydHMuZ2VvQm91bmRzID0gYm91bmRzO1xuZXhwb3J0cy5nZW9DZW50cm9pZCA9IGNlbnRyb2lkO1xuZXhwb3J0cy5nZW9DaXJjbGUgPSBjaXJjbGU7XG5leHBvcnRzLmdlb0NsaXBBbnRpbWVyaWRpYW4gPSBjbGlwQW50aW1lcmlkaWFuO1xuZXhwb3J0cy5nZW9DbGlwQ2lyY2xlID0gY2xpcENpcmNsZTtcbmV4cG9ydHMuZ2VvQ2xpcEV4dGVudCA9IGV4dGVudDtcbmV4cG9ydHMuZ2VvQ2xpcFJlY3RhbmdsZSA9IGNsaXBSZWN0YW5nbGU7XG5leHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsID0gY29uaWNDb25mb3JtYWw7XG5leHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsUmF3ID0gY29uaWNDb25mb3JtYWxSYXc7XG5leHBvcnRzLmdlb0NvbmljRXF1YWxBcmVhID0gY29uaWNFcXVhbEFyZWE7XG5leHBvcnRzLmdlb0NvbmljRXF1YWxBcmVhUmF3ID0gY29uaWNFcXVhbEFyZWFSYXc7XG5leHBvcnRzLmdlb0NvbmljRXF1aWRpc3RhbnQgPSBjb25pY0VxdWlkaXN0YW50O1xuZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50UmF3ID0gY29uaWNFcXVpZGlzdGFudFJhdztcbmV4cG9ydHMuZ2VvQ29udGFpbnMgPSBjb250YWlucztcbmV4cG9ydHMuZ2VvRGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZ2VvRXF1YWxFYXJ0aCA9IGVxdWFsRWFydGg7XG5leHBvcnRzLmdlb0VxdWFsRWFydGhSYXcgPSBlcXVhbEVhcnRoUmF3O1xuZXhwb3J0cy5nZW9FcXVpcmVjdGFuZ3VsYXIgPSBlcXVpcmVjdGFuZ3VsYXI7XG5leHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhclJhdyA9IGVxdWlyZWN0YW5ndWxhclJhdztcbmV4cG9ydHMuZ2VvR25vbW9uaWMgPSBnbm9tb25pYztcbmV4cG9ydHMuZ2VvR25vbW9uaWNSYXcgPSBnbm9tb25pY1JhdztcbmV4cG9ydHMuZ2VvR3JhdGljdWxlID0gZ3JhdGljdWxlO1xuZXhwb3J0cy5nZW9HcmF0aWN1bGUxMCA9IGdyYXRpY3VsZTEwO1xuZXhwb3J0cy5nZW9JZGVudGl0eSA9IGlkZW50aXR5JDE7XG5leHBvcnRzLmdlb0ludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5leHBvcnRzLmdlb0xlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMuZ2VvTWVyY2F0b3IgPSBtZXJjYXRvcjtcbmV4cG9ydHMuZ2VvTWVyY2F0b3JSYXcgPSBtZXJjYXRvclJhdztcbmV4cG9ydHMuZ2VvTmF0dXJhbEVhcnRoMSA9IG5hdHVyYWxFYXJ0aDE7XG5leHBvcnRzLmdlb05hdHVyYWxFYXJ0aDFSYXcgPSBuYXR1cmFsRWFydGgxUmF3O1xuZXhwb3J0cy5nZW9PcnRob2dyYXBoaWMgPSBvcnRob2dyYXBoaWM7XG5leHBvcnRzLmdlb09ydGhvZ3JhcGhpY1JhdyA9IG9ydGhvZ3JhcGhpY1JhdztcbmV4cG9ydHMuZ2VvUGF0aCA9IGluZGV4O1xuZXhwb3J0cy5nZW9Qcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbmV4cG9ydHMuZ2VvUHJvamVjdGlvbk11dGF0b3IgPSBwcm9qZWN0aW9uTXV0YXRvcjtcbmV4cG9ydHMuZ2VvUm90YXRpb24gPSByb3RhdGlvbjtcbmV4cG9ydHMuZ2VvU3RlcmVvZ3JhcGhpYyA9IHN0ZXJlb2dyYXBoaWM7XG5leHBvcnRzLmdlb1N0ZXJlb2dyYXBoaWNSYXcgPSBzdGVyZW9ncmFwaGljUmF3O1xuZXhwb3J0cy5nZW9TdHJlYW0gPSBnZW9TdHJlYW07XG5leHBvcnRzLmdlb1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbmV4cG9ydHMuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yID0gdHJhbnN2ZXJzZU1lcmNhdG9yO1xuZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3JSYXcgPSB0cmFuc3ZlcnNlTWVyY2F0b3JSYXc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtaGllcmFyY2h5LyB2MS4xLjkgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbn1cblxuZnVuY3Rpb24gbWVhblgoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGNoaWxkcmVuLnJlZHVjZShtZWFuWFJlZHVjZSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIG1lYW5YUmVkdWNlKHgsIGMpIHtcbiAgcmV0dXJuIHggKyBjLng7XG59XG5cbmZ1bmN0aW9uIG1heFkoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIDEgKyBjaGlsZHJlbi5yZWR1Y2UobWF4WVJlZHVjZSwgMCk7XG59XG5cbmZ1bmN0aW9uIG1heFlSZWR1Y2UoeSwgYykge1xuICByZXR1cm4gTWF0aC5tYXgoeSwgYy55KTtcbn1cblxuZnVuY3Rpb24gbGVhZkxlZnQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlblswXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGxlYWZSaWdodChub2RlKSB7XG4gIHZhciBjaGlsZHJlbjtcbiAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgbm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gY2x1c3RlcigpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbixcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIG5vZGVTaXplID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2x1c3Rlcihyb290KSB7XG4gICAgdmFyIHByZXZpb3VzTm9kZSxcbiAgICAgICAgeCA9IDA7XG5cbiAgICAvLyBGaXJzdCB3YWxrLCBjb21wdXRpbmcgdGhlIGluaXRpYWwgeCAmIHkgdmFsdWVzLlxuICAgIHJvb3QuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgbm9kZS54ID0gbWVhblgoY2hpbGRyZW4pO1xuICAgICAgICBub2RlLnkgPSBtYXhZKGNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUueCA9IHByZXZpb3VzTm9kZSA/IHggKz0gc2VwYXJhdGlvbihub2RlLCBwcmV2aW91c05vZGUpIDogMDtcbiAgICAgICAgbm9kZS55ID0gMDtcbiAgICAgICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBsZWZ0ID0gbGVhZkxlZnQocm9vdCksXG4gICAgICAgIHJpZ2h0ID0gbGVhZlJpZ2h0KHJvb3QpLFxuICAgICAgICB4MCA9IGxlZnQueCAtIHNlcGFyYXRpb24obGVmdCwgcmlnaHQpIC8gMixcbiAgICAgICAgeDEgPSByaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyO1xuXG4gICAgLy8gU2Vjb25kIHdhbGssIG5vcm1hbGl6aW5nIHggJiB5IHRvIHRoZSBkZXNpcmVkIHNpemUuXG4gICAgcmV0dXJuIHJvb3QuZWFjaEFmdGVyKG5vZGVTaXplID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBkeDtcbiAgICAgIG5vZGUueSA9IChyb290LnkgLSBub2RlLnkpICogZHk7XG4gICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBkeDtcbiAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIGR5O1xuICAgIH0pO1xuICB9XG5cbiAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCBjbHVzdGVyKSA6IHNlcGFyYXRpb247XG4gIH07XG5cbiAgY2x1c3Rlci5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gZmFsc2UsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gbnVsbCA6IFtkeCwgZHldKTtcbiAgfTtcblxuICBjbHVzdGVyLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gdHJ1ZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBbZHgsIGR5XSA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBjbHVzdGVyO1xufVxuXG5mdW5jdGlvbiBjb3VudChub2RlKSB7XG4gIHZhciBzdW0gPSAwLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKCFpKSBzdW0gPSAxO1xuICBlbHNlIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICBub2RlLnZhbHVlID0gc3VtO1xufVxuXG5mdW5jdGlvbiBub2RlX2NvdW50KCkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xufVxuXG5mdW5jdGlvbiBub2RlX2VhY2goY2FsbGJhY2spIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBjdXJyZW50LCBuZXh0ID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgbjtcbiAgZG8ge1xuICAgIGN1cnJlbnQgPSBuZXh0LnJldmVyc2UoKSwgbmV4dCA9IFtdO1xuICAgIHdoaWxlIChub2RlID0gY3VycmVudC5wb3AoKSkge1xuICAgICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBuZXh0LnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobmV4dC5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbm9kZV9lYWNoQmVmb3JlKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIGNoaWxkcmVuLCBpO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfZWFjaEFmdGVyKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIG5leHQgPSBbXSwgY2hpbGRyZW4sIGksIG47XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBuZXh0LnB1c2gobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhub2RlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbm9kZV9zdW0odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgc3VtID0gK3ZhbHVlKG5vZGUuZGF0YSkgfHwgMCxcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICAgIG5vZGUudmFsdWUgPSBzdW07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub2RlX3NvcnQoY29tcGFyZSkge1xuICByZXR1cm4gdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vZGVfcGF0aChlbmQpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcyxcbiAgICAgIGFuY2VzdG9yID0gbGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSxcbiAgICAgIG5vZGVzID0gW3N0YXJ0XTtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBhbmNlc3Rvcikge1xuICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICAgIG5vZGVzLnB1c2goc3RhcnQpO1xuICB9XG4gIHZhciBrID0gbm9kZXMubGVuZ3RoO1xuICB3aGlsZSAoZW5kICE9PSBhbmNlc3Rvcikge1xuICAgIG5vZGVzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBsZWFzdENvbW1vbkFuY2VzdG9yKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICB2YXIgYU5vZGVzID0gYS5hbmNlc3RvcnMoKSxcbiAgICAgIGJOb2RlcyA9IGIuYW5jZXN0b3JzKCksXG4gICAgICBjID0gbnVsbDtcbiAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBjID0gYTtcbiAgICBhID0gYU5vZGVzLnBvcCgpO1xuICAgIGIgPSBiTm9kZXMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfYW5jZXN0b3JzKCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfZGVzY2VuZGFudHMoKSB7XG4gIHZhciBub2RlcyA9IFtdO1xuICB0aGlzLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIG5vZGVfbGVhdmVzKCkge1xuICB2YXIgbGVhdmVzID0gW107XG4gIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBsZWF2ZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGVhdmVzO1xufVxuXG5mdW5jdGlvbiBub2RlX2xpbmtzKCkge1xuICB2YXIgcm9vdCA9IHRoaXMsIGxpbmtzID0gW107XG4gIHJvb3QuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT09IHJvb3QpIHsgLy8gRG9u4oCZdCBpbmNsdWRlIHRoZSByb2904oCZcyBwYXJlbnQsIGlmIGFueS5cbiAgICAgIGxpbmtzLnB1c2goe3NvdXJjZTogbm9kZS5wYXJlbnQsIHRhcmdldDogbm9kZX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsaW5rcztcbn1cblxuZnVuY3Rpb24gaGllcmFyY2h5KGRhdGEsIGNoaWxkcmVuKSB7XG4gIHZhciByb290ID0gbmV3IE5vZGUoZGF0YSksXG4gICAgICB2YWx1ZWQgPSArZGF0YS52YWx1ZSAmJiAocm9vdC52YWx1ZSA9IGRhdGEudmFsdWUpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVzID0gW3Jvb3RdLFxuICAgICAgY2hpbGQsXG4gICAgICBjaGlsZHMsXG4gICAgICBpLFxuICAgICAgbjtcblxuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkgY2hpbGRyZW4gPSBkZWZhdWx0Q2hpbGRyZW47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmICh2YWx1ZWQpIG5vZGUudmFsdWUgPSArbm9kZS5kYXRhLnZhbHVlO1xuICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4obm9kZS5kYXRhKSkgJiYgKG4gPSBjaGlsZHMubGVuZ3RoKSkge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBOb2RlKGNoaWxkc1tpXSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290LmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIG5vZGVfY29weSgpIHtcbiAgcmV0dXJuIGhpZXJhcmNoeSh0aGlzKS5lYWNoQmVmb3JlKGNvcHlEYXRhKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENoaWxkcmVuKGQpIHtcbiAgcmV0dXJuIGQuY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNvcHlEYXRhKG5vZGUpIHtcbiAgbm9kZS5kYXRhID0gbm9kZS5kYXRhLmRhdGE7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVIZWlnaHQobm9kZSkge1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgZG8gbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG4gIHdoaWxlICgobm9kZSA9IG5vZGUucGFyZW50KSAmJiAobm9kZS5oZWlnaHQgPCArK2hlaWdodCkpO1xufVxuXG5mdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5kZXB0aCA9XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xufVxuXG5Ob2RlLnByb3RvdHlwZSA9IGhpZXJhcmNoeS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBOb2RlLFxuICBjb3VudDogbm9kZV9jb3VudCxcbiAgZWFjaDogbm9kZV9lYWNoLFxuICBlYWNoQWZ0ZXI6IG5vZGVfZWFjaEFmdGVyLFxuICBlYWNoQmVmb3JlOiBub2RlX2VhY2hCZWZvcmUsXG4gIHN1bTogbm9kZV9zdW0sXG4gIHNvcnQ6IG5vZGVfc29ydCxcbiAgcGF0aDogbm9kZV9wYXRoLFxuICBhbmNlc3RvcnM6IG5vZGVfYW5jZXN0b3JzLFxuICBkZXNjZW5kYW50czogbm9kZV9kZXNjZW5kYW50cyxcbiAgbGVhdmVzOiBub2RlX2xlYXZlcyxcbiAgbGlua3M6IG5vZGVfbGlua3MsXG4gIGNvcHk6IG5vZGVfY29weVxufTtcblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gIHZhciBtID0gYXJyYXkubGVuZ3RoLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W21dO1xuICAgIGFycmF5W21dID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlKGNpcmNsZXMpIHtcbiAgdmFyIGkgPSAwLCBuID0gKGNpcmNsZXMgPSBzaHVmZmxlKHNsaWNlLmNhbGwoY2lyY2xlcykpKS5sZW5ndGgsIEIgPSBbXSwgcCwgZTtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBwID0gY2lyY2xlc1tpXTtcbiAgICBpZiAoZSAmJiBlbmNsb3Nlc1dlYWsoZSwgcCkpICsraTtcbiAgICBlbHNlIGUgPSBlbmNsb3NlQmFzaXMoQiA9IGV4dGVuZEJhc2lzKEIsIHApKSwgaSA9IDA7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xuICB2YXIgaSwgajtcblxuICBpZiAoZW5jbG9zZXNXZWFrQWxsKHAsIEIpKSByZXR1cm4gW3BdO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGVuY2xvc2VzTm90KHAsIEJbaV0pXG4gICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCKSkge1xuICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBlbGVtZW50cy5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBCLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcClcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKVxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltqXSwgcCksIEJbaV0pXG4gICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpKSB7XG4gICAgICAgIHJldHVybiBbQltpXSwgQltqXSwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZy5cbiAgdGhyb3cgbmV3IEVycm9yO1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc05vdChhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yICsgMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBlbmNsb3NlQmFzaXMxKEJbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMxKGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLngsXG4gICAgeTogYS55LFxuICAgIHI6IGEuclxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMyKGEsIGIpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgcjIxID0gcjIgLSByMSxcbiAgICAgIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoeDEgKyB4MiArIHgyMSAvIGwgKiByMjEpIC8gMixcbiAgICB5OiAoeTEgKyB5MiArIHkyMSAvIGwgKiByMjEpIC8gMixcbiAgICByOiAobCArIHIxICsgcjIpIC8gMlxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMzKGEsIGIsIGMpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDMgPSBjLngsIHkzID0gYy55LCByMyA9IGMucixcbiAgICAgIGEyID0geDEgLSB4MixcbiAgICAgIGEzID0geDEgLSB4MyxcbiAgICAgIGIyID0geTEgLSB5MixcbiAgICAgIGIzID0geTEgLSB5MyxcbiAgICAgIGMyID0gcjIgLSByMSxcbiAgICAgIGMzID0gcjMgLSByMSxcbiAgICAgIGQxID0geDEgKiB4MSArIHkxICogeTEgLSByMSAqIHIxLFxuICAgICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcbiAgICAgIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsXG4gICAgICBhYiA9IGEzICogYjIgLSBhMiAqIGIzLFxuICAgICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcbiAgICAgIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLFxuICAgICAgeWEgPSAoYTMgKiBkMiAtIGEyICogZDMpIC8gKGFiICogMikgLSB5MSxcbiAgICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxuICAgICAgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSxcbiAgICAgIEIgPSAyICogKHIxICsgeGEgKiB4YiArIHlhICogeWIpLFxuICAgICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcbiAgICAgIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhhICsgeGIgKiByLFxuICAgIHk6IHkxICsgeWEgKyB5YiAqIHIsXG4gICAgcjogclxuICB9O1xufVxuXG5mdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCwgeCwgYTIsXG4gICAgICBkeSA9IGIueSAtIGEueSwgeSwgYjIsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAoZDIpIHtcbiAgICBhMiA9IGEuciArIGMuciwgYTIgKj0gYTI7XG4gICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xuICAgIGlmIChhMiA+IGIyKSB7XG4gICAgICB4ID0gKGQyICsgYjIgLSBhMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBiLnggLSB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBiLnkgLSB4ICogZHkgKyB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoZDIgKyBhMiAtIGIyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBhMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSArIHkgKiBkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYy54ID0gYS54ICsgYy5yO1xuICAgIGMueSA9IGEueTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yICsgYi5yIC0gMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gc2NvcmUobm9kZSkge1xuICB2YXIgYSA9IG5vZGUuXyxcbiAgICAgIGIgPSBub2RlLm5leHQuXyxcbiAgICAgIGFiID0gYS5yICsgYi5yLFxuICAgICAgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLFxuICAgICAgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIE5vZGUkMShjaXJjbGUpIHtcbiAgdGhpcy5fID0gY2lyY2xlO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFja0VuY2xvc2UoY2lyY2xlcykge1xuICBpZiAoIShuID0gY2lyY2xlcy5sZW5ndGgpKSByZXR1cm4gMDtcblxuICB2YXIgYSwgYiwgYywgbiwgYWEsIGNhLCBpLCBqLCBrLCBzaiwgc2s7XG5cbiAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgYSA9IGNpcmNsZXNbMF0sIGEueCA9IDAsIGEueSA9IDA7XG4gIGlmICghKG4gPiAxKSkgcmV0dXJuIGEucjtcblxuICAvLyBQbGFjZSB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgYiA9IGNpcmNsZXNbMV0sIGEueCA9IC1iLnIsIGIueCA9IGEuciwgYi55ID0gMDtcbiAgaWYgKCEobiA+IDIpKSByZXR1cm4gYS5yICsgYi5yO1xuXG4gIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXG4gIHBsYWNlKGIsIGEsIGMgPSBjaXJjbGVzWzJdKTtcblxuICAvLyBJbml0aWFsaXplIHRoZSBmcm9udC1jaGFpbiB1c2luZyB0aGUgZmlyc3QgdGhyZWUgY2lyY2xlcyBhLCBiIGFuZCBjLlxuICBhID0gbmV3IE5vZGUkMShhKSwgYiA9IG5ldyBOb2RlJDEoYiksIGMgPSBuZXcgTm9kZSQxKGMpO1xuICBhLm5leHQgPSBjLnByZXZpb3VzID0gYjtcbiAgYi5uZXh0ID0gYS5wcmV2aW91cyA9IGM7XG4gIGMubmV4dCA9IGIucHJldmlvdXMgPSBhO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGxhY2UgZWFjaCByZW1haW5pbmcgY2lyY2xl4oCmXG4gIHBhY2s6IGZvciAoaSA9IDM7IGkgPCBuOyArK2kpIHtcbiAgICBwbGFjZShhLl8sIGIuXywgYyA9IGNpcmNsZXNbaV0pLCBjID0gbmV3IE5vZGUkMShjKTtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW5nIGNpcmNsZSBvbiB0aGUgZnJvbnQtY2hhaW4sIGlmIGFueS5cbiAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICBqID0gYi5uZXh0LCBrID0gYS5wcmV2aW91cywgc2ogPSBiLl8uciwgc2sgPSBhLl8ucjtcbiAgICBkbyB7XG4gICAgICBpZiAoc2ogPD0gc2spIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoai5fLCBjLl8pKSB7XG4gICAgICAgICAgYiA9IGosIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzaiArPSBqLl8uciwgaiA9IGoubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGsuXywgYy5fKSkge1xuICAgICAgICAgIGEgPSBrLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2sgKz0gay5fLnIsIGsgPSBrLnByZXZpb3VzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG5cbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgYy5wcmV2aW91cyA9IGEsIGMubmV4dCA9IGIsIGEubmV4dCA9IGIucHJldmlvdXMgPSBiID0gYztcblxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cbiAgICBhYSA9IHNjb3JlKGEpO1xuICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIHtcbiAgICAgIGlmICgoY2EgPSBzY29yZShjKSkgPCBhYSkge1xuICAgICAgICBhID0gYywgYWEgPSBjYTtcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IGEubmV4dDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGVuY2xvc2luZyBjaXJjbGUgb2YgdGhlIGZyb250IGNoYWluLlxuICBhID0gW2IuX10sIGMgPSBiOyB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSBhLnB1c2goYy5fKTsgYyA9IGVuY2xvc2UoYSk7XG5cbiAgLy8gVHJhbnNsYXRlIHRoZSBjaXJjbGVzIHRvIHB1dCB0aGUgZW5jbG9zaW5nIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpbi5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYSA9IGNpcmNsZXNbaV0sIGEueCAtPSBjLngsIGEueSAtPSBjLnk7XG5cbiAgcmV0dXJuIGMucjtcbn1cblxuZnVuY3Rpb24gc2libGluZ3MoY2lyY2xlcykge1xuICBwYWNrRW5jbG9zZShjaXJjbGVzKTtcbiAgcmV0dXJuIGNpcmNsZXM7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbmFsKGYpIHtcbiAgcmV0dXJuIGYgPT0gbnVsbCA/IG51bGwgOiByZXF1aXJlZChmKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZWQoZikge1xuICBpZiAodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnRaZXJvKCkge1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSYWRpdXMoZCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpbmRleCgpIHtcbiAgdmFyIHJhZGl1cyA9IG51bGwsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHBhY2socm9vdCkge1xuICAgIHJvb3QueCA9IGR4IC8gMiwgcm9vdC55ID0gZHkgLyAyO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKHJhZGl1cykpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgMC41KSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZCgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKGRlZmF1bHRSYWRpdXMpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKGNvbnN0YW50WmVybywgMSkpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgcm9vdC5yIC8gTWF0aC5taW4oZHgsIGR5KSkpXG4gICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoTWF0aC5taW4oZHgsIGR5KSAvICgyICogcm9vdC5yKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIHBhY2sucmFkaXVzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IG9wdGlvbmFsKHgpLCBwYWNrKSA6IHJhZGl1cztcbiAgfTtcblxuICBwYWNrLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFjaykgOiBbZHgsIGR5XTtcbiAgfTtcblxuICBwYWNrLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCBwYWNrKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhY2s7XG59XG5cbmZ1bmN0aW9uIHJhZGl1c0xlYWYocmFkaXVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLnIgPSBNYXRoLm1heCgwLCArcmFkaXVzKG5vZGUpIHx8IDApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFja0NoaWxkcmVuKHBhZGRpbmcsIGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGRyZW4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIHIgPSBwYWRkaW5nKG5vZGUpICogayB8fCAwLFxuICAgICAgICAgIGU7XG5cbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yICs9IHI7XG4gICAgICBlID0gcGFja0VuY2xvc2UoY2hpbGRyZW4pO1xuICAgICAgaWYgKHIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoaWxkcmVuW2ldLnIgLT0gcjtcbiAgICAgIG5vZGUuciA9IGUgKyByO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlQ2hpbGQoaykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBub2RlLnggPSBwYXJlbnQueCArIGsgKiBub2RlLng7XG4gICAgICBub2RlLnkgPSBwYXJlbnQueSArIGsgKiBub2RlLnk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByb3VuZE5vZGUobm9kZSkge1xuICBub2RlLngwID0gTWF0aC5yb3VuZChub2RlLngwKTtcbiAgbm9kZS55MCA9IE1hdGgucm91bmQobm9kZS55MCk7XG4gIG5vZGUueDEgPSBNYXRoLnJvdW5kKG5vZGUueDEpO1xuICBub2RlLnkxID0gTWF0aC5yb3VuZChub2RlLnkxKTtcbn1cblxuZnVuY3Rpb24gdHJlZW1hcERpY2UocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBub2RlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGsgPSBwYXJlbnQudmFsdWUgJiYgKHgxIC0geDApIC8gcGFyZW50LnZhbHVlO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MTtcbiAgICBub2RlLngwID0geDAsIG5vZGUueDEgPSB4MCArPSBub2RlLnZhbHVlICogaztcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oKSB7XG4gIHZhciBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gMCxcbiAgICAgIHJvdW5kID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKHJvb3QpIHtcbiAgICB2YXIgbiA9IHJvb3QuaGVpZ2h0ICsgMTtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gcGFkZGluZztcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5IC8gbjtcbiAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKGR5LCBuKSk7XG4gICAgaWYgKHJvdW5kKSByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShkeSwgbikge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICB0cmVlbWFwRGljZShub2RlLCBub2RlLngwLCBkeSAqIChub2RlLmRlcHRoICsgMSkgLyBuLCBub2RlLngxLCBkeSAqIChub2RlLmRlcHRoICsgMikgLyBuKTtcbiAgICAgIH1cbiAgICAgIHZhciB4MCA9IG5vZGUueDAsXG4gICAgICAgICAgeTAgPSBub2RlLnkwLFxuICAgICAgICAgIHgxID0gbm9kZS54MSAtIHBhZGRpbmcsXG4gICAgICAgICAgeTEgPSBub2RlLnkxIC0gcGFkZGluZztcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIG5vZGUueDAgPSB4MDtcbiAgICAgIG5vZGUueTAgPSB5MDtcbiAgICAgIG5vZGUueDEgPSB4MTtcbiAgICAgIG5vZGUueTEgPSB5MTtcbiAgICB9O1xuICB9XG5cbiAgcGFydGl0aW9uLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCBwYXJ0aXRpb24pIDogcm91bmQ7XG4gIH07XG5cbiAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFydGl0aW9uKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSAreCwgcGFydGl0aW9uKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhcnRpdGlvbjtcbn1cblxudmFyIGtleVByZWZpeCA9IFwiJFwiLCAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cbiAgICBwcmVyb290ID0ge2RlcHRoOiAtMX0sXG4gICAgYW1iaWd1b3VzID0ge307XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gIHJldHVybiBkLmlkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyZW50SWQoZCkge1xuICByZXR1cm4gZC5wYXJlbnRJZDtcbn1cblxuZnVuY3Rpb24gc3RyYXRpZnkoKSB7XG4gIHZhciBpZCA9IGRlZmF1bHRJZCxcbiAgICAgIHBhcmVudElkID0gZGVmYXVsdFBhcmVudElkO1xuXG4gIGZ1bmN0aW9uIHN0cmF0aWZ5KGRhdGEpIHtcbiAgICB2YXIgZCxcbiAgICAgICAgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICByb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIG5vZGVLZXksXG4gICAgICAgIG5vZGVCeUtleSA9IHt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZCA9IGRhdGFbaV0sIG5vZGUgPSBub2Rlc1tpXSA9IG5ldyBOb2RlKGQpO1xuICAgICAgaWYgKChub2RlSWQgPSBpZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIG5vZGVLZXkgPSBrZXlQcmVmaXggKyAobm9kZS5pZCA9IG5vZGVJZCk7XG4gICAgICAgIG5vZGVCeUtleVtub2RlS2V5XSA9IG5vZGVLZXkgaW4gbm9kZUJ5S2V5ID8gYW1iaWd1b3VzIDogbm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGVJZCA9IHBhcmVudElkKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgaWYgKG5vZGVJZCA9PSBudWxsIHx8ICEobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIGlmIChyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSByb290c1wiKTtcbiAgICAgICAgcm9vdCA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBub2RlQnlLZXlba2V5UHJlZml4ICsgbm9kZUlkXTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHRocm93IG5ldyBFcnJvcihcIm1pc3Npbmc6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gYW1iaWd1b3VzKSB0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXM6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbikgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIGVsc2UgcGFyZW50LmNoaWxkcmVuID0gW25vZGVdO1xuICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJvb3QpIHRocm93IG5ldyBFcnJvcihcIm5vIHJvb3RcIik7XG4gICAgcm9vdC5wYXJlbnQgPSBwcmVyb290O1xuICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7IG5vZGUuZGVwdGggPSBub2RlLnBhcmVudC5kZXB0aCArIDE7IC0tbjsgfSkuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbiAgICByb290LnBhcmVudCA9IG51bGw7XG4gICAgaWYgKG4gPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTtcblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgc3RyYXRpZnkuaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogaWQ7XG4gIH07XG5cbiAgc3RyYXRpZnkucGFyZW50SWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFyZW50SWQgPSByZXF1aXJlZCh4KSwgc3RyYXRpZnkpIDogcGFyZW50SWQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0cmF0aWZ5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbiQxKGEsIGIpIHtcbiAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xufVxuXG4vLyBmdW5jdGlvbiByYWRpYWxTZXBhcmF0aW9uKGEsIGIpIHtcbi8vICAgcmV0dXJuIChhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoO1xuLy8gfVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGxlZnQgY29udG91ciBvZiBhIHN1YnRyZWUgKG9yXG4vLyBzdWJmb3Jlc3QpLiBJdCByZXR1cm5zIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXIuIFRoaXMgc3VjY2Vzc29yIGlzXG4vLyBlaXRoZXIgZ2l2ZW4gYnkgdGhlIGxlZnRtb3N0IGNoaWxkIG9mIHYgb3IgYnkgdGhlIHRocmVhZCBvZiB2LiBUaGUgZnVuY3Rpb25cbi8vIHJldHVybnMgbnVsbCBpZiBhbmQgb25seSBpZiB2IGlzIG9uIHRoZSBoaWdoZXN0IGxldmVsIG9mIGl0cyBzdWJ0cmVlLlxuZnVuY3Rpb24gbmV4dExlZnQodikge1xuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IHYudDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3b3JrcyBhbmFsb2dvdXNseSB0byBuZXh0TGVmdC5cbmZ1bmN0aW9uIG5leHRSaWdodCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogdi50O1xufVxuXG4vLyBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgdysuIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nXG4vLyBwcmVsaW0odyspIGFuZCBtb2QodyspIGJ5IHNoaWZ0LlxuZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICB3cC5jIC09IGNoYW5nZTtcbiAgd3AucyArPSBzaGlmdDtcbiAgd20uYyArPSBjaGFuZ2U7XG4gIHdwLnogKz0gc2hpZnQ7XG4gIHdwLm0gKz0gc2hpZnQ7XG59XG5cbi8vIEFsbCBvdGhlciBzaGlmdHMsIGFwcGxpZWQgdG8gdGhlIHNtYWxsZXIgc3VidHJlZXMgYmV0d2VlbiB3LSBhbmQgdyssIGFyZVxuLy8gcGVyZm9ybWVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIHByZXBhcmUgdGhlIHNoaWZ0cywgd2UgaGF2ZSB0byBhZGp1c3Rcbi8vIGNoYW5nZSh3KyksIHNoaWZ0KHcrKSwgYW5kIGNoYW5nZSh3LSkuXG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgdmFyIHNoaWZ0ID0gMCxcbiAgICAgIGNoYW5nZSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgdztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgIHcueiArPSBzaGlmdDtcbiAgICB3Lm0gKz0gc2hpZnQ7XG4gICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICB9XG59XG5cbi8vIElmIHZpLeKAmXMgYW5jZXN0b3IgaXMgYSBzaWJsaW5nIG9mIHYsIHJldHVybnMgdmkt4oCZcyBhbmNlc3Rvci4gT3RoZXJ3aXNlLFxuLy8gcmV0dXJucyB0aGUgc3BlY2lmaWVkIChkZWZhdWx0KSBhbmNlc3Rvci5cbmZ1bmN0aW9uIG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3Rvcjtcbn1cblxuZnVuY3Rpb24gVHJlZU5vZGUobm9kZSwgaSkge1xuICB0aGlzLl8gPSBub2RlO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLkEgPSBudWxsOyAvLyBkZWZhdWx0IGFuY2VzdG9yXG4gIHRoaXMuYSA9IHRoaXM7IC8vIGFuY2VzdG9yXG4gIHRoaXMueiA9IDA7IC8vIHByZWxpbVxuICB0aGlzLm0gPSAwOyAvLyBtb2RcbiAgdGhpcy5jID0gMDsgLy8gY2hhbmdlXG4gIHRoaXMucyA9IDA7IC8vIHNoaWZ0XG4gIHRoaXMudCA9IG51bGw7IC8vIHRocmVhZFxuICB0aGlzLmkgPSBpOyAvLyBudW1iZXJcbn1cblxuVHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIHRyZWVSb290KHJvb3QpIHtcbiAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUocm9vdCwgMCksXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMgPSBbdHJlZV0sXG4gICAgICBjaGlsZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuXy5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuID0gY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBUcmVlTm9kZShjaGlsZHJlbltpXSwgaSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICh0cmVlLnBhcmVudCA9IG5ldyBUcmVlTm9kZShudWxsLCAwKSkuY2hpbGRyZW4gPSBbdHJlZV07XG4gIHJldHVybiB0cmVlO1xufVxuXG4vLyBOb2RlLWxpbmsgdHJlZSBkaWFncmFtIHVzaW5nIHRoZSBSZWluZ29sZC1UaWxmb3JkIFwidGlkeVwiIGFsZ29yaXRobVxuZnVuY3Rpb24gdHJlZSgpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbiQxLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgbm9kZVNpemUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHRyZWUocm9vdCkge1xuICAgIHZhciB0ID0gdHJlZVJvb3Qocm9vdCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBsYXlvdXQgdXNpbmcgQnVjaGhlaW0gZXQgYWwu4oCZcyBhbGdvcml0aG0uXG4gICAgdC5lYWNoQWZ0ZXIoZmlyc3RXYWxrKSwgdC5wYXJlbnQubSA9IC10Lno7XG4gICAgdC5lYWNoQmVmb3JlKHNlY29uZFdhbGspO1xuXG4gICAgLy8gSWYgYSBmaXhlZCBub2RlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5LlxuICAgIGlmIChub2RlU2l6ZSkgcm9vdC5lYWNoQmVmb3JlKHNpemVOb2RlKTtcblxuICAgIC8vIElmIGEgZml4ZWQgdHJlZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeSBiYXNlZCBvbiB0aGUgZXh0ZW50LlxuICAgIC8vIENvbXB1dGUgdGhlIGxlZnQtbW9zdCwgcmlnaHQtbW9zdCwgYW5kIGRlcHRoLW1vc3Qgbm9kZXMgZm9yIGV4dGVudHMuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVmdCA9IHJvb3QsXG4gICAgICAgICAgcmlnaHQgPSByb290LFxuICAgICAgICAgIGJvdHRvbSA9IHJvb3Q7XG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZS54IDwgbGVmdC54KSBsZWZ0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHZhciBzID0gbGVmdCA9PT0gcmlnaHQgPyAxIDogc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxuICAgICAgICAgIHR4ID0gcyAtIGxlZnQueCxcbiAgICAgICAgICBreCA9IGR4IC8gKHJpZ2h0LnggKyBzICsgdHgpLFxuICAgICAgICAgIGt5ID0gZHkgLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIGZvciB2LiBCZWZvcmUgdGhhdCwgRklSU1QgV0FMSyBpc1xuICAvLyBhcHBsaWVkIHJlY3Vyc2l2ZWx5IHRvIHRoZSBjaGlsZHJlbiBvZiB2LCBhcyB3ZWxsIGFzIHRoZSBmdW5jdGlvblxuICAvLyBBUFBPUlRJT04uIEFmdGVyIHNwYWNpbmcgb3V0IHRoZSBjaGlsZHJlbiBieSBjYWxsaW5nIEVYRUNVVEUgU0hJRlRTLCB0aGVcbiAgLy8gbm9kZSB2IGlzIHBsYWNlZCB0byB0aGUgbWlkcG9pbnQgb2YgaXRzIG91dGVybW9zdCBjaGlsZHJlbi5cbiAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxuICAgICAgICBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLFxuICAgICAgICB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZXhlY3V0ZVNoaWZ0cyh2KTtcbiAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgIHYubSA9IHYueiAtIG1pZHBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3KSB7XG4gICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICB9XG4gICAgdi5wYXJlbnQuQSA9IGFwcG9ydGlvbih2LCB3LCB2LnBhcmVudC5BIHx8IHNpYmxpbmdzWzBdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGFsbCByZWFsIHgtY29vcmRpbmF0ZXMgYnkgc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIHJlY3Vyc2l2ZWx5LlxuICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICB2Ll8ueCA9IHYueiArIHYucGFyZW50Lm07XG4gICAgdi5tICs9IHYucGFyZW50Lm07XG4gIH1cblxuICAvLyBUaGUgY29yZSBvZiB0aGUgYWxnb3JpdGhtLiBIZXJlLCBhIG5ldyBzdWJ0cmVlIGlzIGNvbWJpbmVkIHdpdGggdGhlXG4gIC8vIHByZXZpb3VzIHN1YnRyZWVzLiBUaHJlYWRzIGFyZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSBpbnNpZGUgYW5kIG91dHNpZGVcbiAgLy8gY29udG91cnMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWUgdXAgdG8gdGhlIGhpZ2hlc3QgY29tbW9uIGxldmVsLiBUaGVcbiAgLy8gdmVydGljZXMgdXNlZCBmb3IgdGhlIHRyYXZlcnNhbHMgYXJlIHZpKywgdmktLCB2by0sIGFuZCB2byssIHdoZXJlIHRoZVxuICAvLyBzdXBlcnNjcmlwdCBvIG1lYW5zIG91dHNpZGUgYW5kIGkgbWVhbnMgaW5zaWRlLCB0aGUgc3Vic2NyaXB0IC0gbWVhbnMgbGVmdFxuICAvLyBzdWJ0cmVlIGFuZCArIG1lYW5zIHJpZ2h0IHN1YnRyZWUuIEZvciBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgYWxvbmcgdGhlXG4gIC8vIGNvbnRvdXIsIHdlIHVzZSByZXNwZWN0aXZlIHZhcmlhYmxlcyBzaSssIHNpLSwgc28tLCBhbmQgc28rLiBXaGVuZXZlciB0d29cbiAgLy8gbm9kZXMgb2YgdGhlIGluc2lkZSBjb250b3VycyBjb25mbGljdCwgd2UgY29tcHV0ZSB0aGUgbGVmdCBvbmUgb2YgdGhlXG4gIC8vIGdyZWF0ZXN0IHVuY29tbW9uIGFuY2VzdG9ycyB1c2luZyB0aGUgZnVuY3Rpb24gQU5DRVNUT1IgYW5kIGNhbGwgTU9WRVxuICAvLyBTVUJUUkVFIHRvIHNoaWZ0IHRoZSBzdWJ0cmVlIGFuZCBwcmVwYXJlIHRoZSBzaGlmdHMgb2Ygc21hbGxlciBzdWJ0cmVlcy5cbiAgLy8gRmluYWxseSwgd2UgYWRkIGEgbmV3IHRocmVhZCAoaWYgbmVjZXNzYXJ5KS5cbiAgZnVuY3Rpb24gYXBwb3J0aW9uKHYsIHcsIGFuY2VzdG9yKSB7XG4gICAgaWYgKHcpIHtcbiAgICAgIHZhciB2aXAgPSB2LFxuICAgICAgICAgIHZvcCA9IHYsXG4gICAgICAgICAgdmltID0gdyxcbiAgICAgICAgICB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLFxuICAgICAgICAgIHNpcCA9IHZpcC5tLFxuICAgICAgICAgIHNvcCA9IHZvcC5tLFxuICAgICAgICAgIHNpbSA9IHZpbS5tLFxuICAgICAgICAgIHNvbSA9IHZvbS5tLFxuICAgICAgICAgIHNoaWZ0O1xuICAgICAgd2hpbGUgKHZpbSA9IG5leHRSaWdodCh2aW0pLCB2aXAgPSBuZXh0TGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XG4gICAgICAgIHZvbSA9IG5leHRMZWZ0KHZvbSk7XG4gICAgICAgIHZvcCA9IG5leHRSaWdodCh2b3ApO1xuICAgICAgICB2b3AuYSA9IHY7XG4gICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICAgIG1vdmVTdWJ0cmVlKG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2ltICs9IHZpbS5tO1xuICAgICAgICBzaXAgKz0gdmlwLm07XG4gICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgc29wICs9IHZvcC5tO1xuICAgICAgfVxuICAgICAgaWYgKHZpbSAmJiAhbmV4dFJpZ2h0KHZvcCkpIHtcbiAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgIH1cbiAgICAgIGlmICh2aXAgJiYgIW5leHRMZWZ0KHZvbSkpIHtcbiAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgbm9kZS54ICo9IGR4O1xuICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgfVxuXG4gIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgdHJlZSkgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gdHJlZTtcbn1cblxuZnVuY3Rpb24gdHJlZW1hcFNsaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh5MSAtIHkwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDE7XG4gICAgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn1cblxudmFyIHBoaSA9ICgxICsgTWF0aC5zcXJ0KDUpKSAvIDI7XG5cbmZ1bmN0aW9uIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIHJvd3MgPSBbXSxcbiAgICAgIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgcm93LFxuICAgICAgbm9kZVZhbHVlLFxuICAgICAgaTAgPSAwLFxuICAgICAgaTEgPSAwLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGR4LCBkeSxcbiAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlLFxuICAgICAgc3VtVmFsdWUsXG4gICAgICBtaW5WYWx1ZSxcbiAgICAgIG1heFZhbHVlLFxuICAgICAgbmV3UmF0aW8sXG4gICAgICBtaW5SYXRpbyxcbiAgICAgIGFscGhhLFxuICAgICAgYmV0YTtcblxuICB3aGlsZSAoaTAgPCBuKSB7XG4gICAgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTA7XG5cbiAgICAvLyBGaW5kIHRoZSBuZXh0IG5vbi1lbXB0eSBub2RlLlxuICAgIGRvIHN1bVZhbHVlID0gbm9kZXNbaTErK10udmFsdWU7IHdoaWxlICghc3VtVmFsdWUgJiYgaTEgPCBuKTtcbiAgICBtaW5WYWx1ZSA9IG1heFZhbHVlID0gc3VtVmFsdWU7XG4gICAgYWxwaGEgPSBNYXRoLm1heChkeSAvIGR4LCBkeCAvIGR5KSAvICh2YWx1ZSAqIHJhdGlvKTtcbiAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgIG1pblJhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuXG4gICAgLy8gS2VlcCBhZGRpbmcgbm9kZXMgd2hpbGUgdGhlIGFzcGVjdCByYXRpbyBtYWludGFpbnMgb3IgaW1wcm92ZXMuXG4gICAgZm9yICg7IGkxIDwgbjsgKytpMSkge1xuICAgICAgc3VtVmFsdWUgKz0gbm9kZVZhbHVlID0gbm9kZXNbaTFdLnZhbHVlO1xuICAgICAgaWYgKG5vZGVWYWx1ZSA8IG1pblZhbHVlKSBtaW5WYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPiBtYXhWYWx1ZSkgbWF4VmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgICAgbmV3UmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG4gICAgICBpZiAobmV3UmF0aW8gPiBtaW5SYXRpbykgeyBzdW1WYWx1ZSAtPSBub2RlVmFsdWU7IGJyZWFrOyB9XG4gICAgICBtaW5SYXRpbyA9IG5ld1JhdGlvO1xuICAgIH1cblxuICAgIC8vIFBvc2l0aW9uIGFuZCByZWNvcmQgdGhlIHJvdyBvcmllbnRhdGlvbi5cbiAgICByb3dzLnB1c2gocm93ID0ge3ZhbHVlOiBzdW1WYWx1ZSwgZGljZTogZHggPCBkeSwgY2hpbGRyZW46IG5vZGVzLnNsaWNlKGkwLCBpMSl9KTtcbiAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgdmFsdWUgPyB5MCArPSBkeSAqIHN1bVZhbHVlIC8gdmFsdWUgOiB5MSk7XG4gICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHZhbHVlID8geDAgKz0gZHggKiBzdW1WYWx1ZSAvIHZhbHVlIDogeDEsIHkxKTtcbiAgICB2YWx1ZSAtPSBzdW1WYWx1ZSwgaTAgPSBpMTtcbiAgfVxuXG4gIHJldHVybiByb3dzO1xufVxuXG52YXIgc3F1YXJpZnkgPSAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHNxdWFyaWZ5O1xufSkocGhpKTtcblxuZnVuY3Rpb24gaW5kZXgkMSgpIHtcbiAgdmFyIHRpbGUgPSBzcXVhcmlmeSxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nU3RhY2sgPSBbMF0sXG4gICAgICBwYWRkaW5nSW5uZXIgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nVG9wID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1JpZ2h0ID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ0JvdHRvbSA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdMZWZ0ID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHRyZWVtYXAocm9vdCkge1xuICAgIHJvb3QueDAgPVxuICAgIHJvb3QueTAgPSAwO1xuICAgIHJvb3QueDEgPSBkeDtcbiAgICByb290LnkxID0gZHk7XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZSk7XG4gICAgcGFkZGluZ1N0YWNrID0gWzBdO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUobm9kZSkge1xuICAgIHZhciBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGhdLFxuICAgICAgICB4MCA9IG5vZGUueDAgKyBwLFxuICAgICAgICB5MCA9IG5vZGUueTAgKyBwLFxuICAgICAgICB4MSA9IG5vZGUueDEgLSBwLFxuICAgICAgICB5MSA9IG5vZGUueTEgLSBwO1xuICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgbm9kZS54MCA9IHgwO1xuICAgIG5vZGUueTAgPSB5MDtcbiAgICBub2RlLngxID0geDE7XG4gICAgbm9kZS55MSA9IHkxO1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGggKyAxXSA9IHBhZGRpbmdJbm5lcihub2RlKSAvIDI7XG4gICAgICB4MCArPSBwYWRkaW5nTGVmdChub2RlKSAtIHA7XG4gICAgICB5MCArPSBwYWRkaW5nVG9wKG5vZGUpIC0gcDtcbiAgICAgIHgxIC09IHBhZGRpbmdSaWdodChub2RlKSAtIHA7XG4gICAgICB5MSAtPSBwYWRkaW5nQm90dG9tKG5vZGUpIC0gcDtcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIHRpbGUobm9kZSwgeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxuXG4gIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHRyZWVtYXApIDogcm91bmQ7XG4gIH07XG5cbiAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWVtYXApIDogW2R4LCBkeV07XG4gIH07XG5cbiAgdHJlZW1hcC50aWxlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpbGUgPSByZXF1aXJlZCh4KSwgdHJlZW1hcCkgOiB0aWxlO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ0lubmVyKHgpLnBhZGRpbmdPdXRlcih4KSA6IHRyZWVtYXAucGFkZGluZ0lubmVyKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ091dGVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJlZW1hcC5wYWRkaW5nVG9wKHgpLnBhZGRpbmdSaWdodCh4KS5wYWRkaW5nQm90dG9tKHgpLnBhZGRpbmdMZWZ0KHgpIDogdHJlZW1hcC5wYWRkaW5nVG9wKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nVG9wID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdUb3AgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nVG9wO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ1JpZ2h0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdSaWdodCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdSaWdodDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdCb3R0b20gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0JvdHRvbSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdCb3R0b207XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nTGVmdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nTGVmdCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdMZWZ0O1xuICB9O1xuXG4gIHJldHVybiB0cmVlbWFwO1xufVxuXG5mdW5jdGlvbiBiaW5hcnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgc3VtLCBzdW1zID0gbmV3IEFycmF5KG4gKyAxKTtcblxuICBmb3IgKHN1bXNbMF0gPSBzdW0gPSBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHN1bXNbaSArIDFdID0gc3VtICs9IG5vZGVzW2ldLnZhbHVlO1xuICB9XG5cbiAgcGFydGl0aW9uKDAsIG4sIHBhcmVudC52YWx1ZSwgeDAsIHkwLCB4MSwgeTEpO1xuXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihpLCBqLCB2YWx1ZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBpZiAoaSA+PSBqIC0gMSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIG5vZGUueDAgPSB4MCwgbm9kZS55MCA9IHkwO1xuICAgICAgbm9kZS54MSA9IHgxLCBub2RlLnkxID0geTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlT2Zmc2V0ID0gc3Vtc1tpXSxcbiAgICAgICAgdmFsdWVUYXJnZXQgPSAodmFsdWUgLyAyKSArIHZhbHVlT2Zmc2V0LFxuICAgICAgICBrID0gaSArIDEsXG4gICAgICAgIGhpID0gaiAtIDE7XG5cbiAgICB3aGlsZSAoayA8IGhpKSB7XG4gICAgICB2YXIgbWlkID0gayArIGhpID4+PiAxO1xuICAgICAgaWYgKHN1bXNbbWlkXSA8IHZhbHVlVGFyZ2V0KSBrID0gbWlkICsgMTtcbiAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgfVxuXG4gICAgaWYgKCh2YWx1ZVRhcmdldCAtIHN1bXNbayAtIDFdKSA8IChzdW1zW2tdIC0gdmFsdWVUYXJnZXQpICYmIGkgKyAxIDwgaykgLS1rO1xuXG4gICAgdmFyIHZhbHVlTGVmdCA9IHN1bXNba10gLSB2YWx1ZU9mZnNldCxcbiAgICAgICAgdmFsdWVSaWdodCA9IHZhbHVlIC0gdmFsdWVMZWZ0O1xuXG4gICAgaWYgKCh4MSAtIHgwKSA+ICh5MSAtIHkwKSkge1xuICAgICAgdmFyIHhrID0gKHgwICogdmFsdWVSaWdodCArIHgxICogdmFsdWVMZWZ0KSAvIHZhbHVlO1xuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4aywgeTEpO1xuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHhrLCB5MCwgeDEsIHkxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHlrID0gKHkwICogdmFsdWVSaWdodCArIHkxICogdmFsdWVMZWZ0KSAvIHZhbHVlO1xuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4MSwgeWspO1xuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHgwLCB5aywgeDEsIHkxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2xpY2VEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgKHBhcmVudC5kZXB0aCAmIDEgPyB0cmVlbWFwU2xpY2UgOiB0cmVlbWFwRGljZSkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG59XG5cbnZhciByZXNxdWFyaWZ5ID0gKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuXG4gIGZ1bmN0aW9uIHJlc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmICgocm93cyA9IHBhcmVudC5fc3F1YXJpZnkpICYmIChyb3dzLnJhdGlvID09PSByYXRpbykpIHtcbiAgICAgIHZhciByb3dzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBub2RlcyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGogPSAtMSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIG0gPSByb3dzLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZTtcblxuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgcm93ID0gcm93c1tqXSwgbm9kZXMgPSByb3cuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IHJvdy52YWx1ZSA9IDAsIG4gPSBub2Rlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHJvdy52YWx1ZSArPSBub2Rlc1tpXS52YWx1ZTtcbiAgICAgICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHkwICs9ICh5MSAtIHkwKSAqIHJvdy52YWx1ZSAvIHZhbHVlKTtcbiAgICAgICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHgwICs9ICh4MSAtIHgwKSAqIHJvdy52YWx1ZSAvIHZhbHVlLCB5MSk7XG4gICAgICAgIHZhbHVlIC09IHJvdy52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Ll9zcXVhcmlmeSA9IHJvd3MgPSBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgIHJvd3MucmF0aW8gPSByYXRpbztcbiAgICB9XG4gIH1cblxuICByZXNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICB9O1xuXG4gIHJldHVybiByZXNxdWFyaWZ5O1xufSkocGhpKTtcblxuZXhwb3J0cy5jbHVzdGVyID0gY2x1c3RlcjtcbmV4cG9ydHMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuZXhwb3J0cy5wYWNrID0gaW5kZXg7XG5leHBvcnRzLnBhY2tFbmNsb3NlID0gZW5jbG9zZTtcbmV4cG9ydHMucGFja1NpYmxpbmdzID0gc2libGluZ3M7XG5leHBvcnRzLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbmV4cG9ydHMuc3RyYXRpZnkgPSBzdHJhdGlmeTtcbmV4cG9ydHMudHJlZSA9IHRyZWU7XG5leHBvcnRzLnRyZWVtYXAgPSBpbmRleCQxO1xuZXhwb3J0cy50cmVlbWFwQmluYXJ5ID0gYmluYXJ5O1xuZXhwb3J0cy50cmVlbWFwRGljZSA9IHRyZWVtYXBEaWNlO1xuZXhwb3J0cy50cmVlbWFwUmVzcXVhcmlmeSA9IHJlc3F1YXJpZnk7XG5leHBvcnRzLnRyZWVtYXBTbGljZSA9IHRyZWVtYXBTbGljZTtcbmV4cG9ydHMudHJlZW1hcFNsaWNlRGljZSA9IHNsaWNlRGljZTtcbmV4cG9ydHMudHJlZW1hcFNxdWFyaWZ5ID0gc3F1YXJpZnk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtaW50ZXJwb2xhdGUvIHYxLjQuMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWNvbG9yJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtY29sb3InXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSwgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0NvbG9yKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYmFzaXModDEsIHYwLCB2MSwgdjIsIHYzKSB7XG4gIHZhciB0MiA9IHQxICogdDEsIHQzID0gdDIgKiB0MTtcbiAgcmV0dXJuICgoMSAtIDMgKiB0MSArIDMgKiB0MiAtIHQzKSAqIHYwXG4gICAgICArICg0IC0gNiAqIHQyICsgMyAqIHQzKSAqIHYxXG4gICAgICArICgxICsgMyAqIHQxICsgMyAqIHQyIC0gMyAqIHQzKSAqIHYyXG4gICAgICArIHQzICogdjMpIC8gNjtcbn1cblxuZnVuY3Rpb24gYmFzaXMkMSh2YWx1ZXMpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQgPD0gMCA/ICh0ID0gMCkgOiB0ID49IDEgPyAodCA9IDEsIG4gLSAxKSA6IE1hdGguZmxvb3IodCAqIG4pLFxuICAgICAgICB2MSA9IHZhbHVlc1tpXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbaSArIDFdLFxuICAgICAgICB2MCA9IGkgPiAwID8gdmFsdWVzW2kgLSAxXSA6IDIgKiB2MSAtIHYyLFxuICAgICAgICB2MyA9IGkgPCBuIC0gMSA/IHZhbHVlc1tpICsgMl0gOiAyICogdjIgLSB2MTtcbiAgICByZXR1cm4gYmFzaXMoKHQgLSBpIC8gbikgKiBuLCB2MCwgdjEsIHYyLCB2Myk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJhc2lzQ2xvc2VkKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxpbmVhcihhLCBkKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyB0ICogZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwb25lbnRpYWwoYSwgYiwgeSkge1xuICByZXR1cm4gYSA9IE1hdGgucG93KGEsIHkpLCBiID0gTWF0aC5wb3coYiwgeSkgLSBhLCB5ID0gMSAvIHksIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coYSArIHQgKiBiLCB5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaHVlKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCA+IDE4MCB8fCBkIDwgLTE4MCA/IGQgLSAzNjAgKiBNYXRoLnJvdW5kKGQgLyAzNjApIDogZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG52YXIgcmdiID0gKGZ1bmN0aW9uIHJnYkdhbW1hKHkpIHtcbiAgdmFyIGNvbG9yID0gZ2FtbWEoeSk7XG5cbiAgZnVuY3Rpb24gcmdiKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGNvbG9yKChzdGFydCA9IGQzQ29sb3IucmdiKHN0YXJ0KSkuciwgKGVuZCA9IGQzQ29sb3IucmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3Ioc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYjtcbn0pKDEpO1xuXG5mdW5jdGlvbiByZ2JTcGxpbmUoc3BsaW5lKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xvcnMpIHtcbiAgICB2YXIgbiA9IGNvbG9ycy5sZW5ndGgsXG4gICAgICAgIHIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGcgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGksIGNvbG9yO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbG9yID0gZDNDb2xvci5yZ2IoY29sb3JzW2ldKTtcbiAgICAgIHJbaV0gPSBjb2xvci5yIHx8IDA7XG4gICAgICBnW2ldID0gY29sb3IuZyB8fCAwO1xuICAgICAgYltpXSA9IGNvbG9yLmIgfHwgMDtcbiAgICB9XG4gICAgciA9IHNwbGluZShyKTtcbiAgICBnID0gc3BsaW5lKGcpO1xuICAgIGIgPSBzcGxpbmUoYik7XG4gICAgY29sb3Iub3BhY2l0eSA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbG9yLnIgPSByKHQpO1xuICAgICAgY29sb3IuZyA9IGcodCk7XG4gICAgICBjb2xvci5iID0gYih0KTtcbiAgICAgIHJldHVybiBjb2xvciArIFwiXCI7XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIHJnYkJhc2lzID0gcmdiU3BsaW5lKGJhc2lzJDEpO1xudmFyIHJnYkJhc2lzQ2xvc2VkID0gcmdiU3BsaW5lKGJhc2lzQ2xvc2VkKTtcblxuZnVuY3Rpb24gbnVtYmVyQXJyYXkoYSwgYikge1xuICBpZiAoIWIpIGIgPSBbXTtcbiAgdmFyIG4gPSBhID8gTWF0aC5taW4oYi5sZW5ndGgsIGEubGVuZ3RoKSA6IDAsXG4gICAgICBjID0gYi5zbGljZSgpLFxuICAgICAgaTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjW2ldID0gYVtpXSAqICgxIC0gdCkgKyBiW2ldICogdDtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheSh4KSB7XG4gIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoeCkgJiYgISh4IGluc3RhbmNlb2YgRGF0YVZpZXcpO1xufVxuXG5mdW5jdGlvbiBhcnJheShhLCBiKSB7XG4gIHJldHVybiAoaXNOdW1iZXJBcnJheShiKSA/IG51bWJlckFycmF5IDogZ2VuZXJpY0FycmF5KShhLCBiKTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJpY0FycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYSksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSB2YWx1ZShhW2ldLCBiW2ldKTtcbiAgZm9yICg7IGkgPCBuYjsgKytpKSBjW2ldID0gYltpXTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGF0ZShhLCBiKSB7XG4gIHZhciBkID0gbmV3IERhdGU7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkLnNldFRpbWUoYSAqICgxIC0gdCkgKyBiICogdCksIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG51bWJlcihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBvYmplY3QoYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmluZyhhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiBudW1iZXIoYW0sIGJtKX0pO1xuICAgIH1cbiAgICBiaSA9IHJlQi5sYXN0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgcmVtYWlucyBvZiBiLlxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgZWxzZSBzWysraV0gPSBicztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxuICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIG51bWJlcnMgYW5kIHJlam9pbiB0aGUgc3RyaW5nLlxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gKHFbMF1cbiAgICAgID8gb25lKHFbMF0ueClcbiAgICAgIDogemVybyhiKSlcbiAgICAgIDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlKGEsIGIpIHtcbiAgdmFyIHQgPSB0eXBlb2YgYiwgYztcbiAgcmV0dXJuIGIgPT0gbnVsbCB8fCB0ID09PSBcImJvb2xlYW5cIiA/IGNvbnN0YW50KGIpXG4gICAgICA6ICh0ID09PSBcIm51bWJlclwiID8gbnVtYmVyXG4gICAgICA6IHQgPT09IFwic3RyaW5nXCIgPyAoKGMgPSBkM0NvbG9yLmNvbG9yKGIpKSA/IChiID0gYywgcmdiKSA6IHN0cmluZylcbiAgICAgIDogYiBpbnN0YW5jZW9mIGQzQ29sb3IuY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGRpc2NyZXRlKHJhbmdlKSB7XG4gIHZhciBuID0gcmFuZ2UubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiByYW5nZVtNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICogbikpKV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZSQxKGEsIGIpIHtcbiAgdmFyIGkgPSBodWUoK2EsICtiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgeCA9IGkodCk7XG4gICAgcmV0dXJuIHggLSAzNjAgKiBNYXRoLmZsb29yKHggLyAzNjApO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3VuZChhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuXG52YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbnZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmZ1bmN0aW9uIGRlY29tcG9zZShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBzY2FsZVgsIHNjYWxlWSwgc2tld1g7XG4gIGlmIChzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYikpIGEgLz0gc2NhbGVYLCBiIC89IHNjYWxlWDtcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xuICBpZiAoc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpKSBjIC89IHNjYWxlWSwgZCAvPSBzY2FsZVksIHNrZXdYIC89IHNjYWxlWTtcbiAgaWYgKGEgKiBkIDwgYiAqIGMpIGEgPSAtYSwgYiA9IC1iLCBza2V3WCA9IC1za2V3WCwgc2NhbGVYID0gLXNjYWxlWDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBlLFxuICAgIHRyYW5zbGF0ZVk6IGYsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcbiAgICBza2V3WDogTWF0aC5hdGFuKHNrZXdYKSAqIGRlZ3JlZXMsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn1cblxudmFyIGNzc05vZGUsXG4gICAgY3NzUm9vdCxcbiAgICBjc3NWaWV3LFxuICAgIHN2Z05vZGU7XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJub25lXCIpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFjc3NOb2RlKSBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKSwgY3NzUm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgY3NzVmlldyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjc3NOb2RlLnN0eWxlLnRyYW5zZm9ybSA9IHZhbHVlO1xuICB2YWx1ZSA9IGNzc1ZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShjc3NSb290LmFwcGVuZENoaWxkKGNzc05vZGUpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwidHJhbnNmb3JtXCIpO1xuICBjc3NSb290LnJlbW92ZUNoaWxkKGNzc05vZGUpO1xuICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDcsIC0xKS5zcGxpdChcIixcIik7XG4gIHJldHVybiBkZWNvbXBvc2UoK3ZhbHVlWzBdLCArdmFsdWVbMV0sICt2YWx1ZVsyXSwgK3ZhbHVlWzNdLCArdmFsdWVbNF0sICt2YWx1ZVs1XSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3ZnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghc3ZnTm9kZSkgc3ZnTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcbiAgc3ZnTm9kZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdmFsdWUpO1xuICBpZiAoISh2YWx1ZSA9IHN2Z05vZGUudHJhbnNmb3JtLmJhc2VWYWwuY29uc29saWRhdGUoKSkpIHJldHVybiBpZGVudGl0eTtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiIHx8IHliKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB4YiArIHB4Q29tbWEgKyB5YiArIHB4UGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdGF0ZShhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIGlmIChhIC0gYiA+IDE4MCkgYiArPSAzNjA7IGVsc2UgaWYgKGIgLSBhID4gMTgwKSBhICs9IDM2MDsgLy8gc2hvcnRlc3QgcGF0aFxuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IG51bWJlcihhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiBudW1iZXIoeGEsIHhiKX0sIHtpOiBpIC0gMiwgeDogbnVtYmVyKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG52YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuXG52YXIgcmhvID0gTWF0aC5TUVJUMixcbiAgICByaG8yID0gMixcbiAgICByaG80ID0gNCxcbiAgICBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG4vLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4vLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG5mdW5jdGlvbiB6b29tKHAwLCBwMSkge1xuICB2YXIgdXgwID0gcDBbMF0sIHV5MCA9IHAwWzFdLCB3MCA9IHAwWzJdLFxuICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgZHggPSB1eDEgLSB1eDAsXG4gICAgICBkeSA9IHV5MSAtIHV5MCxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICBpLFxuICAgICAgUztcblxuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgaWYgKGQyIDwgZXBzaWxvbjIpIHtcbiAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyByaG87XG4gICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHV4MCArIHQgKiBkeCxcbiAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICB3MCAqIE1hdGguZXhwKHJobyAqIHQgKiBTKVxuICAgICAgXTtcbiAgICB9O1xuICB9XG5cbiAgLy8gR2VuZXJhbCBjYXNlLlxuICBlbHNlIHtcbiAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLFxuICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgYjEgPSAodzEgKiB3MSAtIHcwICogdzAgLSByaG80ICogZDIpIC8gKDIgKiB3MSAqIHJobzIgKiBkMSksXG4gICAgICAgIHIwID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIwICogYjAgKyAxKSAtIGIwKSxcbiAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgIFMgPSAocjEgLSByMCkgLyByaG87XG4gICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgY29zaHIwID0gY29zaChyMCksXG4gICAgICAgICAgdSA9IHcwIC8gKHJobzIgKiBkMSkgKiAoY29zaHIwICogdGFuaChyaG8gKiBzICsgcjApIC0gc2luaChyMCkpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdXgwICsgdSAqIGR4LFxuICAgICAgICB1eTAgKyB1ICogZHksXG4gICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICBdO1xuICAgIH07XG4gIH1cblxuICBpLmR1cmF0aW9uID0gUyAqIDEwMDA7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGhzbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBkM0NvbG9yLmhzbChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmhzbChlbmQpKS5oKSxcbiAgICAgICAgcyA9IG5vZ2FtbWEoc3RhcnQucywgZW5kLnMpLFxuICAgICAgICBsID0gbm9nYW1tYShzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGhzbCQxID0gaHNsKGh1ZSk7XG52YXIgaHNsTG9uZyA9IGhzbChub2dhbW1hKTtcblxuZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBub2dhbW1hKChzdGFydCA9IGQzQ29sb3IubGFiKHN0YXJ0KSkubCwgKGVuZCA9IGQzQ29sb3IubGFiKGVuZCkpLmwpLFxuICAgICAgYSA9IG5vZ2FtbWEoc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IG5vZ2FtbWEoc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgIHN0YXJ0LmEgPSBhKHQpO1xuICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGhjbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBkM0NvbG9yLmhjbChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmhjbChlbmQpKS5oKSxcbiAgICAgICAgYyA9IG5vZ2FtbWEoc3RhcnQuYywgZW5kLmMpLFxuICAgICAgICBsID0gbm9nYW1tYShzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5jID0gYyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGhjbCQxID0gaGNsKGh1ZSk7XG52YXIgaGNsTG9uZyA9IGhjbChub2dhbW1hKTtcblxuZnVuY3Rpb24gY3ViZWhlbGl4KGh1ZSkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcbiAgICB5ID0gK3k7XG5cbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGggPSBodWUoKHN0YXJ0ID0gZDNDb2xvci5jdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5jdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IG5vZ2FtbWEoc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeC5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeDtcbiAgfSkoMSk7XG59XG5cbnZhciBjdWJlaGVsaXgkMSA9IGN1YmVoZWxpeChodWUpO1xudmFyIGN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXgobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIHBpZWNld2lzZShpbnRlcnBvbGF0ZSwgdmFsdWVzKSB7XG4gIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGggLSAxLCB2ID0gdmFsdWVzWzBdLCBJID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIElbaV0gPSBpbnRlcnBvbGF0ZSh2LCB2ID0gdmFsdWVzWysraV0pO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obiAtIDEsIE1hdGguZmxvb3IodCAqPSBuKSkpO1xuICAgIHJldHVybiBJW2ldKHQgLSBpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpemUoaW50ZXJwb2xhdG9yLCBuKSB7XG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcihpIC8gKG4gLSAxKSk7XG4gIHJldHVybiBzYW1wbGVzO1xufVxuXG5leHBvcnRzLmludGVycG9sYXRlID0gdmFsdWU7XG5leHBvcnRzLmludGVycG9sYXRlQXJyYXkgPSBhcnJheTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCYXNpcyA9IGJhc2lzJDE7XG5leHBvcnRzLmludGVycG9sYXRlQmFzaXNDbG9zZWQgPSBiYXNpc0Nsb3NlZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXggPSBjdWJlaGVsaXgkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4TG9uZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVEYXRlID0gZGF0ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVEaXNjcmV0ZSA9IGRpc2NyZXRlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbCA9IGhjbCQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBoY2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbCA9IGhzbCQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbExvbmcgPSBoc2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUh1ZSA9IGh1ZSQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUxhYiA9IGxhYjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVOdW1iZXIgPSBudW1iZXI7XG5leHBvcnRzLmludGVycG9sYXRlTnVtYmVyQXJyYXkgPSBudW1iZXJBcnJheTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPYmplY3QgPSBvYmplY3Q7XG5leHBvcnRzLmludGVycG9sYXRlUmdiID0gcmdiO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYkJhc2lzID0gcmdiQmFzaXM7XG5leHBvcnRzLmludGVycG9sYXRlUmdiQmFzaXNDbG9zZWQgPSByZ2JCYXNpc0Nsb3NlZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSb3VuZCA9IHJvdW5kO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVN0cmluZyA9IHN0cmluZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVab29tID0gem9vbTtcbmV4cG9ydHMucGllY2V3aXNlID0gcGllY2V3aXNlO1xuZXhwb3J0cy5xdWFudGl6ZSA9IHF1YW50aXplO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXBhdGgvIHYxLjAuOSBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBwaSA9IE1hdGguUEksXG4gICAgdGF1ID0gMiAqIHBpLFxuICAgIGVwc2lsb24gPSAxZS02LFxuICAgIHRhdUVwc2lsb24gPSB0YXUgLSBlcHNpbG9uO1xuXG5mdW5jdGlvbiBQYXRoKCkge1xuICB0aGlzLl94MCA9IHRoaXMuX3kwID0gLy8gc3RhcnQgb2YgY3VycmVudCBzdWJwYXRoXG4gIHRoaXMuX3gxID0gdGhpcy5feTEgPSBudWxsOyAvLyBlbmQgb2YgY3VycmVudCBzdWJwYXRoXG4gIHRoaXMuXyA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHBhdGgoKSB7XG4gIHJldHVybiBuZXcgUGF0aDtcbn1cblxuUGF0aC5wcm90b3R5cGUgPSBwYXRoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFBhdGgsXG4gIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5feDEgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3gxID0gdGhpcy5feDAsIHRoaXMuX3kxID0gdGhpcy5feTA7XG4gICAgICB0aGlzLl8gKz0gXCJaXCI7XG4gICAgfVxuICB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiUVwiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJDXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICgreDIpICsgXCIsXCIgKyAoK3kyKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGFyY1RvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Miwgcikge1xuICAgIHgxID0gK3gxLCB5MSA9ICt5MSwgeDIgPSAreDIsIHkyID0gK3kyLCByID0gK3I7XG4gICAgdmFyIHgwID0gdGhpcy5feDEsXG4gICAgICAgIHkwID0gdGhpcy5feTEsXG4gICAgICAgIHgyMSA9IHgyIC0geDEsXG4gICAgICAgIHkyMSA9IHkyIC0geTEsXG4gICAgICAgIHgwMSA9IHgwIC0geDEsXG4gICAgICAgIHkwMSA9IHkwIC0geTEsXG4gICAgICAgIGwwMV8yID0geDAxICogeDAxICsgeTAxICogeTAxO1xuXG4gICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXG4gICAgaWYgKHIgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgxLHkxKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MSA9IHgxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEpO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDEseTEpIGNvaW5jaWRlbnQgd2l0aCAoeDAseTApPyBEbyBub3RoaW5nLlxuICAgIGVsc2UgaWYgKCEobDAxXzIgPiBlcHNpbG9uKSk7XG5cbiAgICAvLyBPciwgYXJlICh4MCx5MCksICh4MSx5MSkgYW5kICh4Mix5MikgY29sbGluZWFyP1xuICAgIC8vIEVxdWl2YWxlbnRseSwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgyLHkyKT9cbiAgICAvLyBPciwgaXMgdGhlIHJhZGl1cyB6ZXJvPyBMaW5lIHRvICh4MSx5MSkuXG4gICAgZWxzZSBpZiAoIShNYXRoLmFicyh5MDEgKiB4MjEgLSB5MjEgKiB4MDEpID4gZXBzaWxvbikgfHwgIXIpIHtcbiAgICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9IHgxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEpO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgZHJhdyBhbiBhcmMhXG4gICAgZWxzZSB7XG4gICAgICB2YXIgeDIwID0geDIgLSB4MCxcbiAgICAgICAgICB5MjAgPSB5MiAtIHkwLFxuICAgICAgICAgIGwyMV8yID0geDIxICogeDIxICsgeTIxICogeTIxLFxuICAgICAgICAgIGwyMF8yID0geDIwICogeDIwICsgeTIwICogeTIwLFxuICAgICAgICAgIGwyMSA9IE1hdGguc3FydChsMjFfMiksXG4gICAgICAgICAgbDAxID0gTWF0aC5zcXJ0KGwwMV8yKSxcbiAgICAgICAgICBsID0gciAqIE1hdGgudGFuKChwaSAtIE1hdGguYWNvcygobDIxXzIgKyBsMDFfMiAtIGwyMF8yKSAvICgyICogbDIxICogbDAxKSkpIC8gMiksXG4gICAgICAgICAgdDAxID0gbCAvIGwwMSxcbiAgICAgICAgICB0MjEgPSBsIC8gbDIxO1xuXG4gICAgICAvLyBJZiB0aGUgc3RhcnQgdGFuZ2VudCBpcyBub3QgY29pbmNpZGVudCB3aXRoICh4MCx5MCksIGxpbmUgdG8uXG4gICAgICBpZiAoTWF0aC5hYnModDAxIC0gMSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHRoaXMuXyArPSBcIkxcIiArICh4MSArIHQwMSAqIHgwMSkgKyBcIixcIiArICh5MSArIHQwMSAqIHkwMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDAsXCIgKyAoKyh5MDEgKiB4MjAgPiB4MDEgKiB5MjApKSArIFwiLFwiICsgKHRoaXMuX3gxID0geDEgKyB0MjEgKiB4MjEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSArIHQyMSAqIHkyMSk7XG4gICAgfVxuICB9LFxuICBhcmM6IGZ1bmN0aW9uKHgsIHksIHIsIGEwLCBhMSwgY2N3KSB7XG4gICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArciwgY2N3ID0gISFjY3c7XG4gICAgdmFyIGR4ID0gciAqIE1hdGguY29zKGEwKSxcbiAgICAgICAgZHkgPSByICogTWF0aC5zaW4oYTApLFxuICAgICAgICB4MCA9IHggKyBkeCxcbiAgICAgICAgeTAgPSB5ICsgZHksXG4gICAgICAgIGN3ID0gMSBeIGNjdyxcbiAgICAgICAgZGEgPSBjY3cgPyBhMCAtIGExIDogYTEgLSBhMDtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MCx5MCkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MCx5MCkgbm90IGNvaW5jaWRlbnQgd2l0aCB0aGUgcHJldmlvdXMgcG9pbnQ/IExpbmUgdG8gKHgwLHkwKS5cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHgwKSA+IGVwc2lsb24gfHwgTWF0aC5hYnModGhpcy5feTEgLSB5MCkgPiBlcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgZW1wdHk/IFdl4oCZcmUgZG9uZS5cbiAgICBpZiAoIXIpIHJldHVybjtcblxuICAgIC8vIERvZXMgdGhlIGFuZ2xlIGdvIHRoZSB3cm9uZyB3YXk/IEZsaXAgdGhlIGRpcmVjdGlvbi5cbiAgICBpZiAoZGEgPCAwKSBkYSA9IGRhICUgdGF1ICsgdGF1O1xuXG4gICAgLy8gSXMgdGhpcyBhIGNvbXBsZXRlIGNpcmNsZT8gRHJhdyB0d28gYXJjcyB0byBjb21wbGV0ZSB0aGUgY2lyY2xlLlxuICAgIGlmIChkYSA+IHRhdUVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHggLSBkeCkgKyBcIixcIiArICh5IC0gZHkpICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHgwKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTApO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIG5vbi1lbXB0eT8gRHJhdyBhbiBhcmMhXG4gICAgZWxzZSBpZiAoZGEgPiBlcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCxcIiArICgrKGRhID49IHBpKSkgKyBcIixcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4ICsgciAqIE1hdGguY29zKGExKSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkgKyByICogTWF0aC5zaW4oYTEpKTtcbiAgICB9XG4gIH0sXG4gIHJlY3Q6IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSkgKyBcImhcIiArICgrdykgKyBcInZcIiArICgraCkgKyBcImhcIiArICgtdykgKyBcIlpcIjtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbmV4cG9ydHMucGF0aCA9IHBhdGg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtcG9seWdvbi8gdjEuMC42IENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXJlYShwb2x5Z29uKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICBhLFxuICAgICAgYiA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgYXJlYSA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhID0gYjtcbiAgICBiID0gcG9seWdvbltpXTtcbiAgICBhcmVhICs9IGFbMV0gKiBiWzBdIC0gYVswXSAqIGJbMV07XG4gIH1cblxuICByZXR1cm4gYXJlYSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkKHBvbHlnb24pIHtcbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBwb2x5Z29uLmxlbmd0aCxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBhLFxuICAgICAgYiA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgYyxcbiAgICAgIGsgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYSA9IGI7XG4gICAgYiA9IHBvbHlnb25baV07XG4gICAgayArPSBjID0gYVswXSAqIGJbMV0gLSBiWzBdICogYVsxXTtcbiAgICB4ICs9IChhWzBdICsgYlswXSkgKiBjO1xuICAgIHkgKz0gKGFbMV0gKyBiWzFdKSAqIGM7XG4gIH1cblxuICByZXR1cm4gayAqPSAzLCBbeCAvIGssIHkgLyBrXTtcbn1cblxuLy8gUmV0dXJucyB0aGUgMkQgY3Jvc3MgcHJvZHVjdCBvZiBBQiBhbmQgQUMgdmVjdG9ycywgaS5lLiwgdGhlIHotY29tcG9uZW50IG9mXG4vLyB0aGUgM0QgY3Jvc3MgcHJvZHVjdCBpbiBhIHF1YWRyYW50IEkgQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtICgreCBpc1xuLy8gcmlnaHQsICt5IGlzIHVwKS4gUmV0dXJucyBhIHBvc2l0aXZlIHZhbHVlIGlmIEFCQyBpcyBjb3VudGVyLWNsb2Nrd2lzZSxcbi8vIG5lZ2F0aXZlIGlmIGNsb2Nrd2lzZSwgYW5kIHplcm8gaWYgdGhlIHBvaW50cyBhcmUgY29sbGluZWFyLlxuZnVuY3Rpb24gY3Jvc3MoYSwgYiwgYykge1xuICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgLSAoYlsxXSAtIGFbMV0pICogKGNbMF0gLSBhWzBdKTtcbn1cblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpY09yZGVyKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgdXBwZXIgY29udmV4IGh1bGwgcGVyIHRoZSBtb25vdG9uZSBjaGFpbiBhbGdvcml0aG0uXG4vLyBBc3N1bWVzIHBvaW50cy5sZW5ndGggPj0gMywgaXMgc29ydGVkIGJ5IHgsIHVuaXF1ZSBpbiB5LlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBpbmRpY2VzIGludG8gcG9pbnRzIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG5mdW5jdGlvbiBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhwb2ludHMpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgaW5kZXhlcyA9IFswLCAxXSxcbiAgICAgIHNpemUgPSAyO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgbjsgKytpKSB7XG4gICAgd2hpbGUgKHNpemUgPiAxICYmIGNyb3NzKHBvaW50c1tpbmRleGVzW3NpemUgLSAyXV0sIHBvaW50c1tpbmRleGVzW3NpemUgLSAxXV0sIHBvaW50c1tpXSkgPD0gMCkgLS1zaXplO1xuICAgIGluZGV4ZXNbc2l6ZSsrXSA9IGk7XG4gIH1cblxuICByZXR1cm4gaW5kZXhlcy5zbGljZSgwLCBzaXplKTsgLy8gcmVtb3ZlIHBvcHBlZCBwb2ludHNcbn1cblxuZnVuY3Rpb24gaHVsbChwb2ludHMpIHtcbiAgaWYgKChuID0gcG9pbnRzLmxlbmd0aCkgPCAzKSByZXR1cm4gbnVsbDtcblxuICB2YXIgaSxcbiAgICAgIG4sXG4gICAgICBzb3J0ZWRQb2ludHMgPSBuZXcgQXJyYXkobiksXG4gICAgICBmbGlwcGVkUG9pbnRzID0gbmV3IEFycmF5KG4pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHNvcnRlZFBvaW50c1tpXSA9IFsrcG9pbnRzW2ldWzBdLCArcG9pbnRzW2ldWzFdLCBpXTtcbiAgc29ydGVkUG9pbnRzLnNvcnQobGV4aWNvZ3JhcGhpY09yZGVyKTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgZmxpcHBlZFBvaW50c1tpXSA9IFtzb3J0ZWRQb2ludHNbaV1bMF0sIC1zb3J0ZWRQb2ludHNbaV1bMV1dO1xuXG4gIHZhciB1cHBlckluZGV4ZXMgPSBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhzb3J0ZWRQb2ludHMpLFxuICAgICAgbG93ZXJJbmRleGVzID0gY29tcHV0ZVVwcGVySHVsbEluZGV4ZXMoZmxpcHBlZFBvaW50cyk7XG5cbiAgLy8gQ29uc3RydWN0IHRoZSBodWxsIHBvbHlnb24sIHJlbW92aW5nIHBvc3NpYmxlIGR1cGxpY2F0ZSBlbmRwb2ludHMuXG4gIHZhciBza2lwTGVmdCA9IGxvd2VySW5kZXhlc1swXSA9PT0gdXBwZXJJbmRleGVzWzBdLFxuICAgICAgc2tpcFJpZ2h0ID0gbG93ZXJJbmRleGVzW2xvd2VySW5kZXhlcy5sZW5ndGggLSAxXSA9PT0gdXBwZXJJbmRleGVzW3VwcGVySW5kZXhlcy5sZW5ndGggLSAxXSxcbiAgICAgIGh1bGwgPSBbXTtcblxuICAvLyBBZGQgdXBwZXIgaHVsbCBpbiByaWdodC10by1sIG9yZGVyLlxuICAvLyBUaGVuIGFkZCBsb3dlciBodWxsIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gIGZvciAoaSA9IHVwcGVySW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgaHVsbC5wdXNoKHBvaW50c1tzb3J0ZWRQb2ludHNbdXBwZXJJbmRleGVzW2ldXVsyXV0pO1xuICBmb3IgKGkgPSArc2tpcExlZnQ7IGkgPCBsb3dlckluZGV4ZXMubGVuZ3RoIC0gc2tpcFJpZ2h0OyArK2kpIGh1bGwucHVzaChwb2ludHNbc29ydGVkUG9pbnRzW2xvd2VySW5kZXhlc1tpXV1bMl1dKTtcblxuICByZXR1cm4gaHVsbDtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocG9seWdvbiwgcG9pbnQpIHtcbiAgdmFyIG4gPSBwb2x5Z29uLmxlbmd0aCxcbiAgICAgIHAgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdLFxuICAgICAgeDAgPSBwWzBdLCB5MCA9IHBbMV0sXG4gICAgICB4MSwgeTEsXG4gICAgICBpbnNpZGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBwb2x5Z29uW2ldLCB4MSA9IHBbMF0sIHkxID0gcFsxXTtcbiAgICBpZiAoKCh5MSA+IHkpICE9PSAoeTAgPiB5KSkgJiYgKHggPCAoeDAgLSB4MSkgKiAoeSAtIHkxKSAvICh5MCAtIHkxKSArIHgxKSkgaW5zaWRlID0gIWluc2lkZTtcbiAgICB4MCA9IHgxLCB5MCA9IHkxO1xuICB9XG5cbiAgcmV0dXJuIGluc2lkZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKHBvbHlnb24pIHtcbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBwb2x5Z29uLmxlbmd0aCxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIHhhLFxuICAgICAgeWEsXG4gICAgICB4YiA9IGJbMF0sXG4gICAgICB5YiA9IGJbMV0sXG4gICAgICBwZXJpbWV0ZXIgPSAwO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgeGEgPSB4YjtcbiAgICB5YSA9IHliO1xuICAgIGIgPSBwb2x5Z29uW2ldO1xuICAgIHhiID0gYlswXTtcbiAgICB5YiA9IGJbMV07XG4gICAgeGEgLT0geGI7XG4gICAgeWEgLT0geWI7XG4gICAgcGVyaW1ldGVyICs9IE1hdGguc3FydCh4YSAqIHhhICsgeWEgKiB5YSk7XG4gIH1cblxuICByZXR1cm4gcGVyaW1ldGVyO1xufVxuXG5leHBvcnRzLnBvbHlnb25BcmVhID0gYXJlYTtcbmV4cG9ydHMucG9seWdvbkNlbnRyb2lkID0gY2VudHJvaWQ7XG5leHBvcnRzLnBvbHlnb25Db250YWlucyA9IGNvbnRhaW5zO1xuZXhwb3J0cy5wb2x5Z29uSHVsbCA9IGh1bGw7XG5leHBvcnRzLnBvbHlnb25MZW5ndGggPSBsZW5ndGg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtcXVhZHRyZWUvIHYxLjAuNyBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHRyZWVfYWRkKGQpIHtcbiAgdmFyIHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XG4gIHJldHVybiBhZGQodGhpcy5jb3Zlcih4LCB5KSwgeCwgeSwgZCk7XG59XG5cbmZ1bmN0aW9uIGFkZCh0cmVlLCB4LCB5LCBkKSB7XG4gIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIHRyZWU7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdHJlZS5fcm9vdCxcbiAgICAgIGxlYWYgPSB7ZGF0YTogZH0sXG4gICAgICB4MCA9IHRyZWUuX3gwLFxuICAgICAgeTAgPSB0cmVlLl95MCxcbiAgICAgIHgxID0gdHJlZS5feDEsXG4gICAgICB5MSA9IHRyZWUuX3kxLFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHhwLFxuICAgICAgeXAsXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gRmluZCB0aGUgZXhpc3RpbmcgbGVhZiBmb3IgdGhlIG5ldyBwb2ludCwgb3IgYWRkIGl0LlxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbiAgfVxuXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xuICB4cCA9ICt0cmVlLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgeXAgPSArdHJlZS5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIGlmICh4ID09PSB4cCAmJiB5ID09PSB5cCkgcmV0dXJuIGxlYWYubmV4dCA9IG5vZGUsIHBhcmVudCA/IHBhcmVudFtpXSA9IGxlYWYgOiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBPdGhlcndpc2UsIHNwbGl0IHRoZSBsZWFmIG5vZGUgdW50aWwgdGhlIG9sZCBhbmQgbmV3IHBvaW50IGFyZSBzZXBhcmF0ZWQuXG4gIGRvIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnRbaV0gPSBuZXcgQXJyYXkoNCkgOiB0cmVlLl9yb290ID0gbmV3IEFycmF5KDQpO1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICB9IHdoaWxlICgoaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHQpID09PSAoaiA9ICh5cCA+PSB5bSkgPDwgMSB8ICh4cCA+PSB4bSkpKTtcbiAgcmV0dXJuIHBhcmVudFtqXSA9IG5vZGUsIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG59XG5cbmZ1bmN0aW9uIGFkZEFsbChkYXRhKSB7XG4gIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHh6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeXogPSBuZXcgQXJyYXkobiksXG4gICAgICB4MCA9IEluZmluaXR5LFxuICAgICAgeTAgPSBJbmZpbml0eSxcbiAgICAgIHgxID0gLUluZmluaXR5LFxuICAgICAgeTEgPSAtSW5maW5pdHk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9pbnRzIGFuZCB0aGVpciBleHRlbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCA9IGRhdGFbaV0pKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICB5eltpXSA9IHk7XG4gICAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICAgIGlmICh4ID4geDEpIHgxID0geDtcbiAgICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gICAgaWYgKHkgPiB5MSkgeTEgPSB5O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxIHx8IHkwID4geTEpIHJldHVybiB0aGlzO1xuXG4gIC8vIEV4cGFuZCB0aGUgdHJlZSB0byBjb3ZlciB0aGUgbmV3IHBvaW50cy5cbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XG5cbiAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCB5eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdHJlZV9jb3Zlcih4LCB5KSB7XG4gIGlmIChpc05hTih4ID0gK3gpIHx8IGlzTmFOKHkgPSAreSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MTtcblxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxuICAvLyBJbnRlZ2VyIGV4dGVudCBhcmUgbmVjZXNzYXJ5IHNvIHRoYXQgaWYgd2UgbGF0ZXIgZG91YmxlIHRoZSBleHRlbnQsXG4gIC8vIHRoZSBleGlzdGluZyBxdWFkcmFudCBib3VuZGFyaWVzIGRvbuKAmXQgY2hhbmdlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvciFcbiAgaWYgKGlzTmFOKHgwKSkge1xuICAgIHgxID0gKHgwID0gTWF0aC5mbG9vcih4KSkgKyAxO1xuICAgIHkxID0gKHkwID0gTWF0aC5mbG9vcih5KSkgKyAxO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkb3VibGUgcmVwZWF0ZWRseSB0byBjb3Zlci5cbiAgZWxzZSB7XG4gICAgdmFyIHogPSB4MSAtIHgwLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxIHx8IHkwID4geSB8fCB5ID49IHkxKSB7XG4gICAgICBpID0gKHkgPCB5MCkgPDwgMSB8ICh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgeiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogeDEgPSB4MCArIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB4MCA9IHgxIC0geiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX2RhdGEoKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiB0cmVlX2V4dGVudChfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuY292ZXIoK19bMF1bMF0sICtfWzBdWzFdKS5jb3ZlcigrX1sxXVswXSwgK19bMV1bMV0pXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwXSwgW3RoaXMuX3gxLCB0aGlzLl95MV1dO1xufVxuXG5mdW5jdGlvbiBRdWFkKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbn1cblxuZnVuY3Rpb24gdHJlZV9maW5kKHgsIHksIHJhZGl1cykge1xuICB2YXIgZGF0YSxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHF1YWRzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHgwLCB5MCwgeDMsIHkzKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzO1xuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xuICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gIH1cblxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxuICAgIGlmICghKG5vZGUgPSBxLm5vZGUpXG4gICAgICAgIHx8ICh4MSA9IHEueDApID4geDNcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IHF1YWRyYW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICAgIHF1YWRzLnB1c2goXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbM10sIHhtLCB5bSwgeDIsIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsyXSwgeDEsIHltLCB4bSwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMF0sIHgxLCB5MSwgeG0sIHltKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgcXVhZHJhbnQgZmlyc3QuXG4gICAgICBpZiAoaSA9ICh5ID49IHltKSA8PCAxIHwgKHggPj0geG0pKSB7XG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV0gPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSArdGhpcy5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xuICAgICAgICB4MCA9IHggLSBkLCB5MCA9IHkgLSBkO1xuICAgICAgICB4MyA9IHggKyBkLCB5MyA9IHkgKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiB0cmVlX3JlbW92ZShkKSB7XG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcmV0YWluZXIsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIG5leHQsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRmluZCB0aGUgbGVhZiBub2RlIGZvciB0aGUgcG9pbnQuXG4gIC8vIFdoaWxlIGRlc2NlbmRpbmcsIGFsc28gcmV0YWluIHRoZSBkZWVwZXN0IHBhcmVudCB3aXRoIGEgbm9uLXJlbW92ZWQgc2libGluZy5cbiAgaWYgKG5vZGUubGVuZ3RoKSB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmICghKHBhcmVudCA9IG5vZGUsIG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiB0aGlzO1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGJyZWFrO1xuICAgIGlmIChwYXJlbnRbKGkgKyAxKSAmIDNdIHx8IHBhcmVudFsoaSArIDIpICYgM10gfHwgcGFyZW50WyhpICsgMykgJiAzXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbM10pXG4gICAgICAmJiBub2RlID09PSAocGFyZW50WzNdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzBdKVxuICAgICAgJiYgIW5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJldGFpbmVyKSByZXRhaW5lcltqXSA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRyZWVfcm9vdCgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG5cbmZ1bmN0aW9uIHRyZWVfc2l6ZSgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHRyZWVfdmlzaXQoY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIHEsIG5vZGUgPSB0aGlzLl9yb290LCBjaGlsZCwgeDAsIHkwLCB4MSwgeTE7XG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICBpZiAoIWNhbGxiYWNrKG5vZGUgPSBxLm5vZGUsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSkgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmVlX3Zpc2l0QWZ0ZXIoY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmZ1bmN0aW9uIHRyZWVfeChfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmZ1bmN0aW9uIHRyZWVfeShfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3kgPSBfLCB0aGlzKSA6IHRoaXMuX3k7XG59XG5cbmZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IGFkZEFsbDtcbnRyZWVQcm90by5jb3ZlciA9IHRyZWVfY292ZXI7XG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcbnRyZWVQcm90by5leHRlbnQgPSB0cmVlX2V4dGVudDtcbnRyZWVQcm90by5maW5kID0gdHJlZV9maW5kO1xudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xudHJlZVByb3RvLnJlbW92ZUFsbCA9IHJlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xuXG5leHBvcnRzLnF1YWR0cmVlID0gcXVhZHRyZWU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtcmFuZG9tLyB2MS4xLjIgQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTb3VyY2UoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpO1xufVxuXG52YXIgdW5pZm9ybSA9IChmdW5jdGlvbiBzb3VyY2VSYW5kb21Vbmlmb3JtKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21Vbmlmb3JtKG1pbiwgbWF4KSB7XG4gICAgbWluID0gbWluID09IG51bGwgPyAwIDogK21pbjtcbiAgICBtYXggPSBtYXggPT0gbnVsbCA/IDEgOiArbWF4O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSBtYXggPSBtaW4sIG1pbiA9IDA7XG4gICAgZWxzZSBtYXggLT0gbWluO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzb3VyY2UoKSAqIG1heCArIG1pbjtcbiAgICB9O1xuICB9XG5cbiAgcmFuZG9tVW5pZm9ybS5zb3VyY2UgPSBzb3VyY2VSYW5kb21Vbmlmb3JtO1xuXG4gIHJldHVybiByYW5kb21Vbmlmb3JtO1xufSkoZGVmYXVsdFNvdXJjZSk7XG5cbnZhciBub3JtYWwgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tTm9ybWFsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21Ob3JtYWwobXUsIHNpZ21hKSB7XG4gICAgdmFyIHgsIHI7XG4gICAgbXUgPSBtdSA9PSBudWxsID8gMCA6ICttdTtcbiAgICBzaWdtYSA9IHNpZ21hID09IG51bGwgPyAxIDogK3NpZ21hO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB5O1xuXG4gICAgICAvLyBJZiBhdmFpbGFibGUsIHVzZSB0aGUgc2Vjb25kIHByZXZpb3VzbHktZ2VuZXJhdGVkIHVuaWZvcm0gcmFuZG9tLlxuICAgICAgaWYgKHggIT0gbnVsbCkgeSA9IHgsIHggPSBudWxsO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIGdlbmVyYXRlIGEgbmV3IHggYW5kIHkuXG4gICAgICBlbHNlIGRvIHtcbiAgICAgICAgeCA9IHNvdXJjZSgpICogMiAtIDE7XG4gICAgICAgIHkgPSBzb3VyY2UoKSAqIDIgLSAxO1xuICAgICAgICByID0geCAqIHggKyB5ICogeTtcbiAgICAgIH0gd2hpbGUgKCFyIHx8IHIgPiAxKTtcblxuICAgICAgcmV0dXJuIG11ICsgc2lnbWEgKiB5ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocikgLyByKTtcbiAgICB9O1xuICB9XG5cbiAgcmFuZG9tTm9ybWFsLnNvdXJjZSA9IHNvdXJjZVJhbmRvbU5vcm1hbDtcblxuICByZXR1cm4gcmFuZG9tTm9ybWFsO1xufSkoZGVmYXVsdFNvdXJjZSk7XG5cbnZhciBsb2dOb3JtYWwgPSAoZnVuY3Rpb24gc291cmNlUmFuZG9tTG9nTm9ybWFsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21Mb2dOb3JtYWwoKSB7XG4gICAgdmFyIHJhbmRvbU5vcm1hbCA9IG5vcm1hbC5zb3VyY2Uoc291cmNlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cChyYW5kb21Ob3JtYWwoKSk7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUxvZ05vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Mb2dOb3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbUxvZ05vcm1hbDtcbn0pKGRlZmF1bHRTb3VyY2UpO1xuXG52YXIgaXJ3aW5IYWxsID0gKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbUlyd2luSGFsbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tSXJ3aW5IYWxsKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBzdW0gPSAwLCBpID0gMDsgaSA8IG47ICsraSkgc3VtICs9IHNvdXJjZSgpO1xuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuICB9XG5cbiAgcmFuZG9tSXJ3aW5IYWxsLnNvdXJjZSA9IHNvdXJjZVJhbmRvbUlyd2luSGFsbDtcblxuICByZXR1cm4gcmFuZG9tSXJ3aW5IYWxsO1xufSkoZGVmYXVsdFNvdXJjZSk7XG5cbnZhciBiYXRlcyA9IChmdW5jdGlvbiBzb3VyY2VSYW5kb21CYXRlcyhzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tQmF0ZXMobikge1xuICAgIHZhciByYW5kb21JcndpbkhhbGwgPSBpcndpbkhhbGwuc291cmNlKHNvdXJjZSkobik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbUlyd2luSGFsbCgpIC8gbjtcbiAgICB9O1xuICB9XG5cbiAgcmFuZG9tQmF0ZXMuc291cmNlID0gc291cmNlUmFuZG9tQmF0ZXM7XG5cbiAgcmV0dXJuIHJhbmRvbUJhdGVzO1xufSkoZGVmYXVsdFNvdXJjZSk7XG5cbnZhciBleHBvbmVudGlhbCA9IChmdW5jdGlvbiBzb3VyY2VSYW5kb21FeHBvbmVudGlhbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tRXhwb25lbnRpYWwobGFtYmRhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC1NYXRoLmxvZygxIC0gc291cmNlKCkpIC8gbGFtYmRhO1xuICAgIH07XG4gIH1cblxuICByYW5kb21FeHBvbmVudGlhbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21FeHBvbmVudGlhbDtcblxuICByZXR1cm4gcmFuZG9tRXhwb25lbnRpYWw7XG59KShkZWZhdWx0U291cmNlKTtcblxuZXhwb3J0cy5yYW5kb21Vbmlmb3JtID0gdW5pZm9ybTtcbmV4cG9ydHMucmFuZG9tTm9ybWFsID0gbm9ybWFsO1xuZXhwb3J0cy5yYW5kb21Mb2dOb3JtYWwgPSBsb2dOb3JtYWw7XG5leHBvcnRzLnJhbmRvbUJhdGVzID0gYmF0ZXM7XG5leHBvcnRzLnJhbmRvbUlyd2luSGFsbCA9IGlyd2luSGFsbDtcbmV4cG9ydHMucmFuZG9tRXhwb25lbnRpYWwgPSBleHBvbmVudGlhbDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2NhbGUtY2hyb21hdGljLyB2MS41LjAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy1jb2xvcicpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLWNvbG9yJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30sIGdsb2JhbC5kMywgZ2xvYmFsLmQzKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM0ludGVycG9sYXRlLCBkM0NvbG9yKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29sb3JzKHNwZWNpZmllcikge1xuICB2YXIgbiA9IHNwZWNpZmllci5sZW5ndGggLyA2IHwgMCwgY29sb3JzID0gbmV3IEFycmF5KG4pLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBuKSBjb2xvcnNbaV0gPSBcIiNcIiArIHNwZWNpZmllci5zbGljZShpICogNiwgKytpICogNik7XG4gIHJldHVybiBjb2xvcnM7XG59XG5cbnZhciBjYXRlZ29yeTEwID0gY29sb3JzKFwiMWY3N2I0ZmY3ZjBlMmNhMDJjZDYyNzI4OTQ2N2JkOGM1NjRiZTM3N2MyN2Y3ZjdmYmNiZDIyMTdiZWNmXCIpO1xuXG52YXIgQWNjZW50ID0gY29sb3JzKFwiN2ZjOTdmYmVhZWQ0ZmRjMDg2ZmZmZjk5Mzg2Y2IwZjAwMjdmYmY1YjE3NjY2NjY2XCIpO1xuXG52YXIgRGFyazIgPSBjb2xvcnMoXCIxYjllNzdkOTVmMDI3NTcwYjNlNzI5OGE2NmE2MWVlNmFiMDJhNjc2MWQ2NjY2NjZcIik7XG5cbnZhciBQYWlyZWQgPSBjb2xvcnMoXCJhNmNlZTMxZjc4YjRiMmRmOGEzM2EwMmNmYjlhOTllMzFhMWNmZGJmNmZmZjdmMDBjYWIyZDY2YTNkOWFmZmZmOTliMTU5MjhcIik7XG5cbnZhciBQYXN0ZWwxID0gY29sb3JzKFwiZmJiNGFlYjNjZGUzY2NlYmM1ZGVjYmU0ZmVkOWE2ZmZmZmNjZTVkOGJkZmRkYWVjZjJmMmYyXCIpO1xuXG52YXIgUGFzdGVsMiA9IGNvbG9ycyhcImIzZTJjZGZkY2RhY2NiZDVlOGY0Y2FlNGU2ZjVjOWZmZjJhZWYxZTJjY2NjY2NjY1wiKTtcblxudmFyIFNldDEgPSBjb2xvcnMoXCJlNDFhMWMzNzdlYjg0ZGFmNGE5ODRlYTNmZjdmMDBmZmZmMzNhNjU2MjhmNzgxYmY5OTk5OTlcIik7XG5cbnZhciBTZXQyID0gY29sb3JzKFwiNjZjMmE1ZmM4ZDYyOGRhMGNiZTc4YWMzYTZkODU0ZmZkOTJmZTVjNDk0YjNiM2IzXCIpO1xuXG52YXIgU2V0MyA9IGNvbG9ycyhcIjhkZDNjN2ZmZmZiM2JlYmFkYWZiODA3MjgwYjFkM2ZkYjQ2MmIzZGU2OWZjY2RlNWQ5ZDlkOWJjODBiZGNjZWJjNWZmZWQ2ZlwiKTtcblxudmFyIFRhYmxlYXUxMCA9IGNvbG9ycyhcIjRlNzlhN2YyOGUyY2UxNTc1OTc2YjdiMjU5YTE0ZmVkYzk0OWFmN2FhMWZmOWRhNzljNzU1ZmJhYjBhYlwiKTtcblxuZnVuY3Rpb24gcmFtcChzY2hlbWUpIHtcbiAgcmV0dXJuIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSZ2JCYXNpcyhzY2hlbWVbc2NoZW1lLmxlbmd0aCAtIDFdKTtcbn1cblxudmFyIHNjaGVtZSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZDhiMzY1ZjVmNWY1NWFiNGFjXCIsXG4gIFwiYTY2MTFhZGZjMjdkODBjZGMxMDE4NTcxXCIsXG4gIFwiYTY2MTFhZGZjMjdkZjVmNWY1ODBjZGMxMDE4NTcxXCIsXG4gIFwiOGM1MTBhZDhiMzY1ZjZlOGMzYzdlYWU1NWFiNGFjMDE2NjVlXCIsXG4gIFwiOGM1MTBhZDhiMzY1ZjZlOGMzZjVmNWY1YzdlYWU1NWFiNGFjMDE2NjVlXCIsXG4gIFwiOGM1MTBhYmY4MTJkZGZjMjdkZjZlOGMzYzdlYWU1ODBjZGMxMzU5NzhmMDE2NjVlXCIsXG4gIFwiOGM1MTBhYmY4MTJkZGZjMjdkZjZlOGMzZjVmNWY1YzdlYWU1ODBjZGMxMzU5NzhmMDE2NjVlXCIsXG4gIFwiNTQzMDA1OGM1MTBhYmY4MTJkZGZjMjdkZjZlOGMzYzdlYWU1ODBjZGMxMzU5NzhmMDE2NjVlMDAzYzMwXCIsXG4gIFwiNTQzMDA1OGM1MTBhYmY4MTJkZGZjMjdkZjZlOGMzZjVmNWY1YzdlYWU1ODBjZGMxMzU5NzhmMDE2NjVlMDAzYzMwXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBCckJHID0gcmFtcChzY2hlbWUpO1xuXG52YXIgc2NoZW1lJDEgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImFmOGRjM2Y3ZjdmNzdmYmY3YlwiLFxuICBcIjdiMzI5NGMyYTVjZmE2ZGJhMDAwODgzN1wiLFxuICBcIjdiMzI5NGMyYTVjZmY3ZjdmN2E2ZGJhMDAwODgzN1wiLFxuICBcIjc2MmE4M2FmOGRjM2U3ZDRlOGQ5ZjBkMzdmYmY3YjFiNzgzN1wiLFxuICBcIjc2MmE4M2FmOGRjM2U3ZDRlOGY3ZjdmN2Q5ZjBkMzdmYmY3YjFiNzgzN1wiLFxuICBcIjc2MmE4Mzk5NzBhYmMyYTVjZmU3ZDRlOGQ5ZjBkM2E2ZGJhMDVhYWU2MTFiNzgzN1wiLFxuICBcIjc2MmE4Mzk5NzBhYmMyYTVjZmU3ZDRlOGY3ZjdmN2Q5ZjBkM2E2ZGJhMDVhYWU2MTFiNzgzN1wiLFxuICBcIjQwMDA0Yjc2MmE4Mzk5NzBhYmMyYTVjZmU3ZDRlOGQ5ZjBkM2E2ZGJhMDVhYWU2MTFiNzgzNzAwNDQxYlwiLFxuICBcIjQwMDA0Yjc2MmE4Mzk5NzBhYmMyYTVjZmU3ZDRlOGY3ZjdmN2Q5ZjBkM2E2ZGJhMDVhYWU2MTFiNzgzNzAwNDQxYlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUFJHbiA9IHJhbXAoc2NoZW1lJDEpO1xuXG52YXIgc2NoZW1lJDIgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImU5YTNjOWY3ZjdmN2ExZDc2YVwiLFxuICBcImQwMWM4YmYxYjZkYWI4ZTE4NjRkYWMyNlwiLFxuICBcImQwMWM4YmYxYjZkYWY3ZjdmN2I4ZTE4NjRkYWMyNlwiLFxuICBcImM1MWI3ZGU5YTNjOWZkZTBlZmU2ZjVkMGExZDc2YTRkOTIyMVwiLFxuICBcImM1MWI3ZGU5YTNjOWZkZTBlZmY3ZjdmN2U2ZjVkMGExZDc2YTRkOTIyMVwiLFxuICBcImM1MWI3ZGRlNzdhZWYxYjZkYWZkZTBlZmU2ZjVkMGI4ZTE4NjdmYmM0MTRkOTIyMVwiLFxuICBcImM1MWI3ZGRlNzdhZWYxYjZkYWZkZTBlZmY3ZjdmN2U2ZjVkMGI4ZTE4NjdmYmM0MTRkOTIyMVwiLFxuICBcIjhlMDE1MmM1MWI3ZGRlNzdhZWYxYjZkYWZkZTBlZmU2ZjVkMGI4ZTE4NjdmYmM0MTRkOTIyMTI3NjQxOVwiLFxuICBcIjhlMDE1MmM1MWI3ZGRlNzdhZWYxYjZkYWZkZTBlZmY3ZjdmN2U2ZjVkMGI4ZTE4NjdmYmM0MTRkOTIyMTI3NjQxOVwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUGlZRyA9IHJhbXAoc2NoZW1lJDIpO1xuXG52YXIgc2NoZW1lJDMgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcIjk5OGVjM2Y3ZjdmN2YxYTM0MFwiLFxuICBcIjVlM2M5OWIyYWJkMmZkYjg2M2U2NjEwMVwiLFxuICBcIjVlM2M5OWIyYWJkMmY3ZjdmN2ZkYjg2M2U2NjEwMVwiLFxuICBcIjU0Mjc4ODk5OGVjM2Q4ZGFlYmZlZTBiNmYxYTM0MGIzNTgwNlwiLFxuICBcIjU0Mjc4ODk5OGVjM2Q4ZGFlYmY3ZjdmN2ZlZTBiNmYxYTM0MGIzNTgwNlwiLFxuICBcIjU0Mjc4ODgwNzNhY2IyYWJkMmQ4ZGFlYmZlZTBiNmZkYjg2M2UwODIxNGIzNTgwNlwiLFxuICBcIjU0Mjc4ODgwNzNhY2IyYWJkMmQ4ZGFlYmY3ZjdmN2ZlZTBiNmZkYjg2M2UwODIxNGIzNTgwNlwiLFxuICBcIjJkMDA0YjU0Mjc4ODgwNzNhY2IyYWJkMmQ4ZGFlYmZlZTBiNmZkYjg2M2UwODIxNGIzNTgwNjdmM2IwOFwiLFxuICBcIjJkMDA0YjU0Mjc4ODgwNzNhY2IyYWJkMmQ4ZGFlYmY3ZjdmN2ZlZTBiNmZkYjg2M2UwODIxNGIzNTgwNjdmM2IwOFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUHVPciA9IHJhbXAoc2NoZW1lJDMpO1xuXG52YXIgc2NoZW1lJDQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVmOGE2MmY3ZjdmNzY3YTljZlwiLFxuICBcImNhMDAyMGY0YTU4MjkyYzVkZTA1NzFiMFwiLFxuICBcImNhMDAyMGY0YTU4MmY3ZjdmNzkyYzVkZTA1NzFiMFwiLFxuICBcImIyMTgyYmVmOGE2MmZkZGJjN2QxZTVmMDY3YTljZjIxNjZhY1wiLFxuICBcImIyMTgyYmVmOGE2MmZkZGJjN2Y3ZjdmN2QxZTVmMDY3YTljZjIxNjZhY1wiLFxuICBcImIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2QxZTVmMDkyYzVkZTQzOTNjMzIxNjZhY1wiLFxuICBcImIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2Y3ZjdmN2QxZTVmMDkyYzVkZTQzOTNjMzIxNjZhY1wiLFxuICBcIjY3MDAxZmIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2QxZTVmMDkyYzVkZTQzOTNjMzIxNjZhYzA1MzA2MVwiLFxuICBcIjY3MDAxZmIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2Y3ZjdmN2QxZTVmMDkyYzVkZTQzOTNjMzIxNjZhYzA1MzA2MVwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUmRCdSA9IHJhbXAoc2NoZW1lJDQpO1xuXG52YXIgc2NoZW1lJDUgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVmOGE2MmZmZmZmZjk5OTk5OVwiLFxuICBcImNhMDAyMGY0YTU4MmJhYmFiYTQwNDA0MFwiLFxuICBcImNhMDAyMGY0YTU4MmZmZmZmZmJhYmFiYTQwNDA0MFwiLFxuICBcImIyMTgyYmVmOGE2MmZkZGJjN2UwZTBlMDk5OTk5OTRkNGQ0ZFwiLFxuICBcImIyMTgyYmVmOGE2MmZkZGJjN2ZmZmZmZmUwZTBlMDk5OTk5OTRkNGQ0ZFwiLFxuICBcImIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2UwZTBlMGJhYmFiYTg3ODc4NzRkNGQ0ZFwiLFxuICBcImIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2ZmZmZmZmUwZTBlMGJhYmFiYTg3ODc4NzRkNGQ0ZFwiLFxuICBcIjY3MDAxZmIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2UwZTBlMGJhYmFiYTg3ODc4NzRkNGQ0ZDFhMWExYVwiLFxuICBcIjY3MDAxZmIyMTgyYmQ2NjA0ZGY0YTU4MmZkZGJjN2ZmZmZmZmUwZTBlMGJhYmFiYTg3ODc4NzRkNGQ0ZDFhMWExYVwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUmRHeSA9IHJhbXAoc2NoZW1lJDUpO1xuXG52YXIgc2NoZW1lJDYgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZjOGQ1OWZmZmZiZjkxYmZkYlwiLFxuICBcImQ3MTkxY2ZkYWU2MWFiZDllOTJjN2JiNlwiLFxuICBcImQ3MTkxY2ZkYWU2MWZmZmZiZmFiZDllOTJjN2JiNlwiLFxuICBcImQ3MzAyN2ZjOGQ1OWZlZTA5MGUwZjNmODkxYmZkYjQ1NzViNFwiLFxuICBcImQ3MzAyN2ZjOGQ1OWZlZTA5MGZmZmZiZmUwZjNmODkxYmZkYjQ1NzViNFwiLFxuICBcImQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA5MGUwZjNmOGFiZDllOTc0YWRkMTQ1NzViNFwiLFxuICBcImQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA5MGZmZmZiZmUwZjNmOGFiZDllOTc0YWRkMTQ1NzViNFwiLFxuICBcImE1MDAyNmQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA5MGUwZjNmOGFiZDllOTc0YWRkMTQ1NzViNDMxMzY5NVwiLFxuICBcImE1MDAyNmQ3MzAyN2Y0NmQ0M2ZkYWU2MWZlZTA5MGZmZmZiZmUwZjNmOGFiZDllOTc0YWRkMTQ1NzViNDMxMzY5NVwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUmRZbEJ1ID0gcmFtcChzY2hlbWUkNik7XG5cbnZhciBzY2hlbWUkNyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmM4ZDU5ZmZmZmJmOTFjZjYwXCIsXG4gIFwiZDcxOTFjZmRhZTYxYTZkOTZhMWE5NjQxXCIsXG4gIFwiZDcxOTFjZmRhZTYxZmZmZmJmYTZkOTZhMWE5NjQxXCIsXG4gIFwiZDczMDI3ZmM4ZDU5ZmVlMDhiZDllZjhiOTFjZjYwMWE5ODUwXCIsXG4gIFwiZDczMDI3ZmM4ZDU5ZmVlMDhiZmZmZmJmZDllZjhiOTFjZjYwMWE5ODUwXCIsXG4gIFwiZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDhiZDllZjhiYTZkOTZhNjZiZDYzMWE5ODUwXCIsXG4gIFwiZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDhiZmZmZmJmZDllZjhiYTZkOTZhNjZiZDYzMWE5ODUwXCIsXG4gIFwiYTUwMDI2ZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDhiZDllZjhiYTZkOTZhNjZiZDYzMWE5ODUwMDA2ODM3XCIsXG4gIFwiYTUwMDI2ZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDhiZmZmZmJmZDllZjhiYTZkOTZhNjZiZDYzMWE5ODUwMDA2ODM3XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZFlsR24gPSByYW1wKHNjaGVtZSQ3KTtcblxudmFyIHNjaGVtZSQ4ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmYzhkNTlmZmZmYmY5OWQ1OTRcIixcbiAgXCJkNzE5MWNmZGFlNjFhYmRkYTQyYjgzYmFcIixcbiAgXCJkNzE5MWNmZGFlNjFmZmZmYmZhYmRkYTQyYjgzYmFcIixcbiAgXCJkNTNlNGZmYzhkNTlmZWUwOGJlNmY1OTg5OWQ1OTQzMjg4YmRcIixcbiAgXCJkNTNlNGZmYzhkNTlmZWUwOGJmZmZmYmZlNmY1OTg5OWQ1OTQzMjg4YmRcIixcbiAgXCJkNTNlNGZmNDZkNDNmZGFlNjFmZWUwOGJlNmY1OThhYmRkYTQ2NmMyYTUzMjg4YmRcIixcbiAgXCJkNTNlNGZmNDZkNDNmZGFlNjFmZWUwOGJmZmZmYmZlNmY1OThhYmRkYTQ2NmMyYTUzMjg4YmRcIixcbiAgXCI5ZTAxNDJkNTNlNGZmNDZkNDNmZGFlNjFmZWUwOGJlNmY1OThhYmRkYTQ2NmMyYTUzMjg4YmQ1ZTRmYTJcIixcbiAgXCI5ZTAxNDJkNTNlNGZmNDZkNDNmZGFlNjFmZWUwOGJmZmZmYmZlNmY1OThhYmRkYTQ2NmMyYTUzMjg4YmQ1ZTRmYTJcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFNwZWN0cmFsID0gcmFtcChzY2hlbWUkOCk7XG5cbnZhciBzY2hlbWUkOSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTVmNWY5OTlkOGM5MmNhMjVmXCIsXG4gIFwiZWRmOGZiYjJlMmUyNjZjMmE0MjM4YjQ1XCIsXG4gIFwiZWRmOGZiYjJlMmUyNjZjMmE0MmNhMjVmMDA2ZDJjXCIsXG4gIFwiZWRmOGZiY2NlY2U2OTlkOGM5NjZjMmE0MmNhMjVmMDA2ZDJjXCIsXG4gIFwiZWRmOGZiY2NlY2U2OTlkOGM5NjZjMmE0NDFhZTc2MjM4YjQ1MDA1ODI0XCIsXG4gIFwiZjdmY2ZkZTVmNWY5Y2NlY2U2OTlkOGM5NjZjMmE0NDFhZTc2MjM4YjQ1MDA1ODI0XCIsXG4gIFwiZjdmY2ZkZTVmNWY5Y2NlY2U2OTlkOGM5NjZjMmE0NDFhZTc2MjM4YjQ1MDA2ZDJjMDA0NDFiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBCdUduID0gcmFtcChzY2hlbWUkOSk7XG5cbnZhciBzY2hlbWUkYSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTBlY2Y0OWViY2RhODg1NmE3XCIsXG4gIFwiZWRmOGZiYjNjZGUzOGM5NmM2ODg0MTlkXCIsXG4gIFwiZWRmOGZiYjNjZGUzOGM5NmM2ODg1NmE3ODEwZjdjXCIsXG4gIFwiZWRmOGZiYmZkM2U2OWViY2RhOGM5NmM2ODg1NmE3ODEwZjdjXCIsXG4gIFwiZWRmOGZiYmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkNmUwMTZiXCIsXG4gIFwiZjdmY2ZkZTBlY2Y0YmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkNmUwMTZiXCIsXG4gIFwiZjdmY2ZkZTBlY2Y0YmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkODEwZjdjNGQwMDRiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBCdVB1ID0gcmFtcChzY2hlbWUkYSk7XG5cbnZhciBzY2hlbWUkYiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTBmM2RiYThkZGI1NDNhMmNhXCIsXG4gIFwiZjBmOWU4YmFlNGJjN2JjY2M0MmI4Y2JlXCIsXG4gIFwiZjBmOWU4YmFlNGJjN2JjY2M0NDNhMmNhMDg2OGFjXCIsXG4gIFwiZjBmOWU4Y2NlYmM1YThkZGI1N2JjY2M0NDNhMmNhMDg2OGFjXCIsXG4gIFwiZjBmOWU4Y2NlYmM1YThkZGI1N2JjY2M0NGViM2QzMmI4Y2JlMDg1ODllXCIsXG4gIFwiZjdmY2YwZTBmM2RiY2NlYmM1YThkZGI1N2JjY2M0NGViM2QzMmI4Y2JlMDg1ODllXCIsXG4gIFwiZjdmY2YwZTBmM2RiY2NlYmM1YThkZGI1N2JjY2M0NGViM2QzMmI4Y2JlMDg2OGFjMDg0MDgxXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBHbkJ1ID0gcmFtcChzY2hlbWUkYik7XG5cbnZhciBzY2hlbWUkYyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmVlOGM4ZmRiYjg0ZTM0YTMzXCIsXG4gIFwiZmVmMGQ5ZmRjYzhhZmM4ZDU5ZDczMDFmXCIsXG4gIFwiZmVmMGQ5ZmRjYzhhZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZTM0YTMzYjMwMDAwXCIsXG4gIFwiZmVmMGQ5ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmOTkwMDAwXCIsXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmOTkwMDAwXCIsXG4gIFwiZmZmN2VjZmVlOGM4ZmRkNDllZmRiYjg0ZmM4ZDU5ZWY2NTQ4ZDczMDFmYjMwMDAwN2YwMDAwXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBPclJkID0gcmFtcChzY2hlbWUkYyk7XG5cbnZhciBzY2hlbWUkZCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWNlMmYwYTZiZGRiMWM5MDk5XCIsXG4gIFwiZjZlZmY3YmRjOWUxNjdhOWNmMDI4MThhXCIsXG4gIFwiZjZlZmY3YmRjOWUxNjdhOWNmMWM5MDk5MDE2YzU5XCIsXG4gIFwiZjZlZmY3ZDBkMWU2YTZiZGRiNjdhOWNmMWM5MDk5MDE2YzU5XCIsXG4gIFwiZjZlZmY3ZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2NDUwXCIsXG4gIFwiZmZmN2ZiZWNlMmYwZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2NDUwXCIsXG4gIFwiZmZmN2ZiZWNlMmYwZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2YzU5MDE0NjM2XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdUJ1R24gPSByYW1wKHNjaGVtZSRkKTtcblxudmFyIHNjaGVtZSRlID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlY2U3ZjJhNmJkZGIyYjhjYmVcIixcbiAgXCJmMWVlZjZiZGM5ZTE3NGE5Y2YwNTcwYjBcIixcbiAgXCJmMWVlZjZiZGM5ZTE3NGE5Y2YyYjhjYmUwNDVhOGRcIixcbiAgXCJmMWVlZjZkMGQxZTZhNmJkZGI3NGE5Y2YyYjhjYmUwNDVhOGRcIixcbiAgXCJmMWVlZjZkMGQxZTZhNmJkZGI3NGE5Y2YzNjkwYzAwNTcwYjAwMzRlN2JcIixcbiAgXCJmZmY3ZmJlY2U3ZjJkMGQxZTZhNmJkZGI3NGE5Y2YzNjkwYzAwNTcwYjAwMzRlN2JcIixcbiAgXCJmZmY3ZmJlY2U3ZjJkMGQxZTZhNmJkZGI3NGE5Y2YzNjkwYzAwNTcwYjAwNDVhOGQwMjM4NThcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFB1QnUgPSByYW1wKHNjaGVtZSRlKTtcblxudmFyIHNjaGVtZSRmID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlN2UxZWZjOTk0YzdkZDFjNzdcIixcbiAgXCJmMWVlZjZkN2I1ZDhkZjY1YjBjZTEyNTZcIixcbiAgXCJmMWVlZjZkN2I1ZDhkZjY1YjBkZDFjNzc5ODAwNDNcIixcbiAgXCJmMWVlZjZkNGI5ZGFjOTk0YzdkZjY1YjBkZDFjNzc5ODAwNDNcIixcbiAgXCJmMWVlZjZkNGI5ZGFjOTk0YzdkZjY1YjBlNzI5OGFjZTEyNTY5MTAwM2ZcIixcbiAgXCJmN2Y0ZjllN2UxZWZkNGI5ZGFjOTk0YzdkZjY1YjBlNzI5OGFjZTEyNTY5MTAwM2ZcIixcbiAgXCJmN2Y0ZjllN2UxZWZkNGI5ZGFjOTk0YzdkZjY1YjBlNzI5OGFjZTEyNTY5ODAwNDM2NzAwMWZcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFB1UmQgPSByYW1wKHNjaGVtZSRmKTtcblxudmFyIHNjaGVtZSRnID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZGUwZGRmYTlmYjVjNTFiOGFcIixcbiAgXCJmZWViZTJmYmI0YjlmNzY4YTFhZTAxN2VcIixcbiAgXCJmZWViZTJmYmI0YjlmNzY4YTFjNTFiOGE3YTAxNzdcIixcbiAgXCJmZWViZTJmY2M1YzBmYTlmYjVmNzY4YTFjNTFiOGE3YTAxNzdcIixcbiAgXCJmZWViZTJmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzdcIixcbiAgXCJmZmY3ZjNmZGUwZGRmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzdcIixcbiAgXCJmZmY3ZjNmZGUwZGRmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzc0OTAwNmFcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFJkUHUgPSByYW1wKHNjaGVtZSRnKTtcblxudmFyIHNjaGVtZSRoID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlZGY4YjE3ZmNkYmIyYzdmYjhcIixcbiAgXCJmZmZmY2NhMWRhYjQ0MWI2YzQyMjVlYThcIixcbiAgXCJmZmZmY2NhMWRhYjQ0MWI2YzQyYzdmYjgyNTM0OTRcIixcbiAgXCJmZmZmY2NjN2U5YjQ3ZmNkYmI0MWI2YzQyYzdmYjgyNTM0OTRcIixcbiAgXCJmZmZmY2NjN2U5YjQ3ZmNkYmI0MWI2YzQxZDkxYzAyMjVlYTgwYzJjODRcIixcbiAgXCJmZmZmZDllZGY4YjFjN2U5YjQ3ZmNkYmI0MWI2YzQxZDkxYzAyMjVlYTgwYzJjODRcIixcbiAgXCJmZmZmZDllZGY4YjFjN2U5YjQ3ZmNkYmI0MWI2YzQxZDkxYzAyMjVlYTgyNTM0OTQwODFkNThcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFlsR25CdSA9IHJhbXAoc2NoZW1lJGgpO1xuXG52YXIgc2NoZW1lJGkgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImY3ZmNiOWFkZGQ4ZTMxYTM1NFwiLFxuICBcImZmZmZjY2MyZTY5OTc4YzY3OTIzODQ0M1wiLFxuICBcImZmZmZjY2MyZTY5OTc4YzY3OTMxYTM1NDAwNjgzN1wiLFxuICBcImZmZmZjY2Q5ZjBhM2FkZGQ4ZTc4YzY3OTMxYTM1NDAwNjgzN1wiLFxuICBcImZmZmZjY2Q5ZjBhM2FkZGQ4ZTc4YzY3OTQxYWI1ZDIzODQ0MzAwNWEzMlwiLFxuICBcImZmZmZlNWY3ZmNiOWQ5ZjBhM2FkZGQ4ZTc4YzY3OTQxYWI1ZDIzODQ0MzAwNWEzMlwiLFxuICBcImZmZmZlNWY3ZmNiOWQ5ZjBhM2FkZGQ4ZTc4YzY3OTQxYWI1ZDIzODQ0MzAwNjgzNzAwNDUyOVwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgWWxHbiA9IHJhbXAoc2NoZW1lJGkpO1xuXG52YXIgc2NoZW1lJGogPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZmZjdiY2ZlYzQ0ZmQ5NWYwZVwiLFxuICBcImZmZmZkNGZlZDk4ZWZlOTkyOWNjNGMwMlwiLFxuICBcImZmZmZkNGZlZDk4ZWZlOTkyOWQ5NWYwZTk5MzQwNFwiLFxuICBcImZmZmZkNGZlZTM5MWZlYzQ0ZmZlOTkyOWQ5NWYwZTk5MzQwNFwiLFxuICBcImZmZmZkNGZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjhjMmQwNFwiLFxuICBcImZmZmZlNWZmZjdiY2ZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjhjMmQwNFwiLFxuICBcImZmZmZlNWZmZjdiY2ZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjk5MzQwNDY2MjUwNlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgWWxPckJyID0gcmFtcChzY2hlbWUkaik7XG5cbnZhciBzY2hlbWUkayA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmZlZGEwZmViMjRjZjAzYjIwXCIsXG4gIFwiZmZmZmIyZmVjYzVjZmQ4ZDNjZTMxYTFjXCIsXG4gIFwiZmZmZmIyZmVjYzVjZmQ4ZDNjZjAzYjIwYmQwMDI2XCIsXG4gIFwiZmZmZmIyZmVkOTc2ZmViMjRjZmQ4ZDNjZjAzYjIwYmQwMDI2XCIsXG4gIFwiZmZmZmIyZmVkOTc2ZmViMjRjZmQ4ZDNjZmM0ZTJhZTMxYTFjYjEwMDI2XCIsXG4gIFwiZmZmZmNjZmZlZGEwZmVkOTc2ZmViMjRjZmQ4ZDNjZmM0ZTJhZTMxYTFjYjEwMDI2XCIsXG4gIFwiZmZmZmNjZmZlZGEwZmVkOTc2ZmViMjRjZmQ4ZDNjZmM0ZTJhZTMxYTFjYmQwMDI2ODAwMDI2XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBZbE9yUmQgPSByYW1wKHNjaGVtZSRrKTtcblxudmFyIHNjaGVtZSRsID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJkZWViZjc5ZWNhZTEzMTgyYmRcIixcbiAgXCJlZmYzZmZiZGQ3ZTc2YmFlZDYyMTcxYjVcIixcbiAgXCJlZmYzZmZiZGQ3ZTc2YmFlZDYzMTgyYmQwODUxOWNcIixcbiAgXCJlZmYzZmZjNmRiZWY5ZWNhZTE2YmFlZDYzMTgyYmQwODUxOWNcIixcbiAgXCJlZmYzZmZjNmRiZWY5ZWNhZTE2YmFlZDY0MjkyYzYyMTcxYjUwODQ1OTRcIixcbiAgXCJmN2ZiZmZkZWViZjdjNmRiZWY5ZWNhZTE2YmFlZDY0MjkyYzYyMTcxYjUwODQ1OTRcIixcbiAgXCJmN2ZiZmZkZWViZjdjNmRiZWY5ZWNhZTE2YmFlZDY0MjkyYzYyMTcxYjUwODUxOWMwODMwNmJcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIEJsdWVzID0gcmFtcChzY2hlbWUkbCk7XG5cbnZhciBzY2hlbWUkbSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTVmNWUwYTFkOTliMzFhMzU0XCIsXG4gIFwiZWRmOGU5YmFlNGIzNzRjNDc2MjM4YjQ1XCIsXG4gIFwiZWRmOGU5YmFlNGIzNzRjNDc2MzFhMzU0MDA2ZDJjXCIsXG4gIFwiZWRmOGU5YzdlOWMwYTFkOTliNzRjNDc2MzFhMzU0MDA2ZDJjXCIsXG4gIFwiZWRmOGU5YzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA1YTMyXCIsXG4gIFwiZjdmY2Y1ZTVmNWUwYzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA1YTMyXCIsXG4gIFwiZjdmY2Y1ZTVmNWUwYzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA2ZDJjMDA0NDFiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBHcmVlbnMgPSByYW1wKHNjaGVtZSRtKTtcblxudmFyIHNjaGVtZSRuID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmMGYwZjBiZGJkYmQ2MzYzNjNcIixcbiAgXCJmN2Y3ZjdjY2NjY2M5Njk2OTY1MjUyNTJcIixcbiAgXCJmN2Y3ZjdjY2NjY2M5Njk2OTY2MzYzNjMyNTI1MjVcIixcbiAgXCJmN2Y3ZjdkOWQ5ZDliZGJkYmQ5Njk2OTY2MzYzNjMyNTI1MjVcIixcbiAgXCJmN2Y3ZjdkOWQ5ZDliZGJkYmQ5Njk2OTY3MzczNzM1MjUyNTIyNTI1MjVcIixcbiAgXCJmZmZmZmZmMGYwZjBkOWQ5ZDliZGJkYmQ5Njk2OTY3MzczNzM1MjUyNTIyNTI1MjVcIixcbiAgXCJmZmZmZmZmMGYwZjBkOWQ5ZDliZGJkYmQ5Njk2OTY3MzczNzM1MjUyNTIyNTI1MjUwMDAwMDBcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIEdyZXlzID0gcmFtcChzY2hlbWUkbik7XG5cbnZhciBzY2hlbWUkbyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWZlZGY1YmNiZGRjNzU2YmIxXCIsXG4gIFwiZjJmMGY3Y2JjOWUyOWU5YWM4NmE1MWEzXCIsXG4gIFwiZjJmMGY3Y2JjOWUyOWU5YWM4NzU2YmIxNTQyNzhmXCIsXG4gIFwiZjJmMGY3ZGFkYWViYmNiZGRjOWU5YWM4NzU2YmIxNTQyNzhmXCIsXG4gIFwiZjJmMGY3ZGFkYWViYmNiZGRjOWU5YWM4ODA3ZGJhNmE1MWEzNGExNDg2XCIsXG4gIFwiZmNmYmZkZWZlZGY1ZGFkYWViYmNiZGRjOWU5YWM4ODA3ZGJhNmE1MWEzNGExNDg2XCIsXG4gIFwiZmNmYmZkZWZlZGY1ZGFkYWViYmNiZGRjOWU5YWM4ODA3ZGJhNmE1MWEzNTQyNzhmM2YwMDdkXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdXJwbGVzID0gcmFtcChzY2hlbWUkbyk7XG5cbnZhciBzY2hlbWUkcCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmVlMGQyZmM5MjcyZGUyZDI2XCIsXG4gIFwiZmVlNWQ5ZmNhZTkxZmI2YTRhY2IxODFkXCIsXG4gIFwiZmVlNWQ5ZmNhZTkxZmI2YTRhZGUyZDI2YTUwZjE1XCIsXG4gIFwiZmVlNWQ5ZmNiYmExZmM5MjcyZmI2YTRhZGUyZDI2YTUwZjE1XCIsXG4gIFwiZmVlNWQ5ZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkOTkwMDBkXCIsXG4gIFwiZmZmNWYwZmVlMGQyZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkOTkwMDBkXCIsXG4gIFwiZmZmNWYwZmVlMGQyZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkYTUwZjE1NjcwMDBkXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZWRzID0gcmFtcChzY2hlbWUkcCk7XG5cbnZhciBzY2hlbWUkcSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmVlNmNlZmRhZTZiZTY1NTBkXCIsXG4gIFwiZmVlZGRlZmRiZTg1ZmQ4ZDNjZDk0NzAxXCIsXG4gIFwiZmVlZGRlZmRiZTg1ZmQ4ZDNjZTY1NTBkYTYzNjAzXCIsXG4gIFwiZmVlZGRlZmRkMGEyZmRhZTZiZmQ4ZDNjZTY1NTBkYTYzNjAzXCIsXG4gIFwiZmVlZGRlZmRkMGEyZmRhZTZiZmQ4ZDNjZjE2OTEzZDk0ODAxOGMyZDA0XCIsXG4gIFwiZmZmNWViZmVlNmNlZmRkMGEyZmRhZTZiZmQ4ZDNjZjE2OTEzZDk0ODAxOGMyZDA0XCIsXG4gIFwiZmZmNWViZmVlNmNlZmRkMGEyZmRhZTZiZmQ4ZDNjZjE2OTEzZDk0ODAxYTYzNjAzN2YyNzA0XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBPcmFuZ2VzID0gcmFtcChzY2hlbWUkcSk7XG5cbmZ1bmN0aW9uIGNpdmlkaXModCkge1xuICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuICByZXR1cm4gXCJyZ2IoXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKC00LjU0IC0gdCAqICgzNS4zNCAtIHQgKiAoMjM4MS43MyAtIHQgKiAoNjQwMi43IC0gdCAqICg3MDI0LjcyIC0gdCAqIDI3MTAuNTcpKSkpKSkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCgzMi40OSArIHQgKiAoMTcwLjczICsgdCAqICg1Mi44MiAtIHQgKiAoMTMxLjQ2IC0gdCAqICgxNzYuNTggLSB0ICogNjcuMzcpKSkpKSkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCg4MS4yNCArIHQgKiAoNDQyLjM2IC0gdCAqICgyNDgyLjQzIC0gdCAqICg2MTY3LjI0IC0gdCAqICg2NjE0Ljk0IC0gdCAqIDI0NzUuNjcpKSkpKSkpXG4gICAgICArIFwiKVwiO1xufVxuXG52YXIgY3ViZWhlbGl4ID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoMzAwLCAwLjUsIDAuMCksIGQzQ29sb3IuY3ViZWhlbGl4KC0yNDAsIDAuNSwgMS4wKSk7XG5cbnZhciB3YXJtID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoLTEwMCwgMC43NSwgMC4zNSksIGQzQ29sb3IuY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxudmFyIGNvb2wgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlQ3ViZWhlbGl4TG9uZyhkM0NvbG9yLmN1YmVoZWxpeCgyNjAsIDAuNzUsIDAuMzUpLCBkM0NvbG9yLmN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XG5cbnZhciBjID0gZDNDb2xvci5jdWJlaGVsaXgoKTtcblxuZnVuY3Rpb24gcmFpbmJvdyh0KSB7XG4gIGlmICh0IDwgMCB8fCB0ID4gMSkgdCAtPSBNYXRoLmZsb29yKHQpO1xuICB2YXIgdHMgPSBNYXRoLmFicyh0IC0gMC41KTtcbiAgYy5oID0gMzYwICogdCAtIDEwMDtcbiAgYy5zID0gMS41IC0gMS41ICogdHM7XG4gIGMubCA9IDAuOCAtIDAuOSAqIHRzO1xuICByZXR1cm4gYyArIFwiXCI7XG59XG5cbnZhciBjJDEgPSBkM0NvbG9yLnJnYigpLFxuICAgIHBpXzFfMyA9IE1hdGguUEkgLyAzLFxuICAgIHBpXzJfMyA9IE1hdGguUEkgKiAyIC8gMztcblxuZnVuY3Rpb24gc2luZWJvdyh0KSB7XG4gIHZhciB4O1xuICB0ID0gKDAuNSAtIHQpICogTWF0aC5QSTtcbiAgYyQxLnIgPSAyNTUgKiAoeCA9IE1hdGguc2luKHQpKSAqIHg7XG4gIGMkMS5nID0gMjU1ICogKHggPSBNYXRoLnNpbih0ICsgcGlfMV8zKSkgKiB4O1xuICBjJDEuYiA9IDI1NSAqICh4ID0gTWF0aC5zaW4odCArIHBpXzJfMykpICogeDtcbiAgcmV0dXJuIGMkMSArIFwiXCI7XG59XG5cbmZ1bmN0aW9uIHR1cmJvKHQpIHtcbiAgdCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHQpKTtcbiAgcmV0dXJuIFwicmdiKFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCgzNC42MSArIHQgKiAoMTE3Mi4zMyAtIHQgKiAoMTA3OTMuNTYgLSB0ICogKDMzMzAwLjEyIC0gdCAqICgzODM5NC40OSAtIHQgKiAxNDgyNS4wNSkpKSkpKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKDIzLjMxICsgdCAqICg1NTcuMzMgKyB0ICogKDEyMjUuMzMgLSB0ICogKDM1NzQuOTYgLSB0ICogKDEwNzMuNzcgKyB0ICogNzA3LjU2KSkpKSkpKSArIFwiLCBcIlxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQoMjcuMiArIHQgKiAoMzIxMS4xIC0gdCAqICgxNTMyNy45NyAtIHQgKiAoMjc4MTQgLSB0ICogKDIyNTY5LjE4IC0gdCAqIDY4MzguNjYpKSkpKSkpXG4gICAgICArIFwiKVwiO1xufVxuXG5mdW5jdGlvbiByYW1wJDEocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cblxudmFyIHZpcmlkaXMgPSByYW1wJDEoY29sb3JzKFwiNDQwMTU0NDQwMjU2NDUwNDU3NDUwNTU5NDYwNzVhNDYwODVjNDYwYTVkNDYwYjVlNDcwZDYwNDcwZTYxNDcxMDYzNDcxMTY0NDcxMzY1NDgxNDY3NDgxNjY4NDgxNzY5NDgxODZhNDgxYTZjNDgxYjZkNDgxYzZlNDgxZDZmNDgxZjcwNDgyMDcxNDgyMTczNDgyMzc0NDgyNDc1NDgyNTc2NDgyNjc3NDgyODc4NDgyOTc5NDcyYTdhNDcyYzdhNDcyZDdiNDcyZTdjNDcyZjdkNDYzMDdlNDYzMjdlNDYzMzdmNDYzNDgwNDUzNTgxNDUzNzgxNDUzODgyNDQzOTgzNDQzYTgzNDQzYjg0NDMzZDg0NDMzZTg1NDIzZjg1NDI0MDg2NDI0MTg2NDE0Mjg3NDE0NDg3NDA0NTg4NDA0Njg4M2Y0Nzg4M2Y0ODg5M2U0OTg5M2U0YTg5M2U0YzhhM2Q0ZDhhM2Q0ZThhM2M0ZjhhM2M1MDhiM2I1MThiM2I1MjhiM2E1MzhiM2E1NDhjMzk1NThjMzk1NjhjMzg1ODhjMzg1OThjMzc1YThjMzc1YjhkMzY1YzhkMzY1ZDhkMzU1ZThkMzU1ZjhkMzQ2MDhkMzQ2MThkMzM2MjhkMzM2MzhkMzI2NDhlMzI2NThlMzE2NjhlMzE2NzhlMzE2ODhlMzA2OThlMzA2YThlMmY2YjhlMmY2YzhlMmU2ZDhlMmU2ZThlMmU2ZjhlMmQ3MDhlMmQ3MThlMmM3MThlMmM3MjhlMmM3MzhlMmI3NDhlMmI3NThlMmE3NjhlMmE3NzhlMmE3ODhlMjk3OThlMjk3YThlMjk3YjhlMjg3YzhlMjg3ZDhlMjc3ZThlMjc3ZjhlMjc4MDhlMjY4MThlMjY4MjhlMjY4MjhlMjU4MzhlMjU4NDhlMjU4NThlMjQ4NjhlMjQ4NzhlMjM4ODhlMjM4OThlMjM4YThkMjI4YjhkMjI4YzhkMjI4ZDhkMjE4ZThkMjE4ZjhkMjE5MDhkMjE5MThjMjA5MjhjMjA5MjhjMjA5MzhjMWY5NDhjMWY5NThiMWY5NjhiMWY5NzhiMWY5ODhiMWY5OThhMWY5YThhMWU5YjhhMWU5Yzg5MWU5ZDg5MWY5ZTg5MWY5Zjg4MWZhMDg4MWZhMTg4MWZhMTg3MWZhMjg3MjBhMzg2MjBhNDg2MjFhNTg1MjFhNjg1MjJhNzg1MjJhODg0MjNhOTgzMjRhYTgzMjVhYjgyMjVhYzgyMjZhZDgxMjdhZDgxMjhhZTgwMjlhZjdmMmFiMDdmMmNiMTdlMmRiMjdkMmViMzdjMmZiNDdjMzFiNTdiMzJiNjdhMzRiNjc5MzViNzc5MzdiODc4MzhiOTc3M2FiYTc2M2JiYjc1M2RiYzc0M2ZiYzczNDBiZDcyNDJiZTcxNDRiZjcwNDZjMDZmNDhjMTZlNGFjMTZkNGNjMjZjNGVjMzZiNTBjNDZhNTJjNTY5NTRjNTY4NTZjNjY3NThjNzY1NWFjODY0NWNjODYzNWVjOTYyNjBjYTYwNjNjYjVmNjVjYjVlNjdjYzVjNjljZDViNmNjZDVhNmVjZTU4NzBjZjU3NzNkMDU2NzVkMDU0NzdkMTUzN2FkMTUxN2NkMjUwN2ZkMzRlODFkMzRkODRkNDRiODZkNTQ5ODlkNTQ4OGJkNjQ2OGVkNjQ1OTBkNzQzOTNkNzQxOTVkODQwOThkODNlOWJkOTNjOWRkOTNiYTBkYTM5YTJkYTM3YTVkYjM2YThkYjM0YWFkYzMyYWRkYzMwYjBkZDJmYjJkZDJkYjVkZTJiYjhkZTI5YmFkZTI4YmRkZjI2YzBkZjI1YzJkZjIzYzVlMDIxYzhlMDIwY2FlMTFmY2RlMTFkZDBlMTFjZDJlMjFiZDVlMjFhZDhlMjE5ZGFlMzE5ZGRlMzE4ZGZlMzE4ZTJlNDE4ZTVlNDE5ZTdlNDE5ZWFlNTFhZWNlNTFiZWZlNTFjZjFlNTFkZjRlNjFlZjZlNjIwZjhlNjIxZmJlNzIzZmRlNzI1XCIpKTtcblxudmFyIG1hZ21hID0gcmFtcCQxKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwOTAyMDIwYjAyMDIwZDAzMDMwZjAzMDMxMjA0MDQxNDA1MDQxNjA2MDUxODA2MDUxYTA3MDYxYzA4MDcxZTA5MDcyMDBhMDgyMjBiMDkyNDBjMDkyNjBkMGEyOTBlMGIyYjEwMGIyZDExMGMyZjEyMGQzMTEzMGQzNDE0MGUzNjE1MGUzODE2MGYzYjE4MGYzZDE5MTAzZjFhMTA0MjFjMTA0NDFkMTE0NzFlMTE0OTIwMTE0YjIxMTE0ZTIyMTE1MDI0MTI1MzI1MTI1NTI3MTI1ODI5MTE1YTJhMTE1YzJjMTE1ZjJkMTE2MTJmMTE2MzMxMTE2NTMzMTA2NzM0MTA2OTM2MTA2YjM4MTA2YzM5MGY2ZTNiMGY3MDNkMGY3MTNmMGY3MjQwMGY3NDQyMGY3NTQ0MGY3NjQ1MTA3NzQ3MTA3ODQ5MTA3ODRhMTA3OTRjMTE3YTRlMTE3YjRmMTI3YjUxMTI3YzUyMTM3YzU0MTM3ZDU2MTQ3ZDU3MTU3ZTU5MTU3ZTVhMTY3ZTVjMTY3ZjVkMTc3ZjVmMTg3ZjYwMTg4MDYyMTk4MDY0MWE4MDY1MWE4MDY3MWI4MDY4MWM4MTZhMWM4MTZiMWQ4MTZkMWQ4MTZlMWU4MTcwMWY4MTcyMWY4MTczMjA4MTc1MjE4MTc2MjE4MTc4MjI4MTc5MjI4MjdiMjM4MjdjMjM4MjdlMjQ4MjgwMjU4MjgxMjU4MTgzMjY4MTg0MjY4MTg2Mjc4MTg4Mjc4MTg5Mjg4MThiMjk4MThjMjk4MThlMmE4MTkwMmE4MTkxMmI4MTkzMmI4MDk0MmM4MDk2MmM4MDk4MmQ4MDk5MmQ4MDliMmU3ZjljMmU3ZjllMmY3ZmEwMmY3ZmExMzA3ZWEzMzA3ZWE1MzE3ZWE2MzE3ZGE4MzI3ZGFhMzM3ZGFiMzM3Y2FkMzQ3Y2FlMzQ3YmIwMzU3YmIyMzU3YmIzMzY3YWI1MzY3YWI3Mzc3OWI4Mzc3OWJhMzg3OGJjMzk3OGJkMzk3N2JmM2E3N2MwM2E3NmMyM2I3NWM0M2M3NWM1M2M3NGM3M2Q3M2M4M2U3M2NhM2U3MmNjM2Y3MWNkNDA3MWNmNDA3MGQwNDE2ZmQyNDI2ZmQzNDM2ZWQ1NDQ2ZGQ2NDU2Y2Q4NDU2Y2Q5NDY2YmRiNDc2YWRjNDg2OWRlNDk2OGRmNGE2OGUwNGM2N2UyNGQ2NmUzNGU2NWU0NGY2NGU1NTA2NGU3NTI2M2U4NTM2MmU5NTQ2MmVhNTY2MWViNTc2MGVjNTg2MGVkNWE1ZmVlNWI1ZWVmNWQ1ZWYwNWY1ZWYxNjA1ZGYyNjI1ZGYyNjQ1Y2YzNjU1Y2Y0Njc1Y2Y0Njk1Y2Y1NmI1Y2Y2NmM1Y2Y2NmU1Y2Y3NzA1Y2Y3NzI1Y2Y4NzQ1Y2Y4NzY1Y2Y5Nzg1ZGY5Nzk1ZGY5N2I1ZGZhN2Q1ZWZhN2Y1ZWZhODE1ZmZiODM1ZmZiODU2MGZiODc2MWZjODk2MWZjOGE2MmZjOGM2M2ZjOGU2NGZjOTA2NWZkOTI2NmZkOTQ2N2ZkOTY2OGZkOTg2OWZkOWE2YWZkOWI2YmZlOWQ2Y2ZlOWY2ZGZlYTE2ZWZlYTM2ZmZlYTU3MWZlYTc3MmZlYTk3M2ZlYWE3NGZlYWM3NmZlYWU3N2ZlYjA3OGZlYjI3YWZlYjQ3YmZlYjY3Y2ZlYjc3ZWZlYjk3ZmZlYmI4MWZlYmQ4MmZlYmY4NGZlYzE4NWZlYzI4N2ZlYzQ4OGZlYzY4YWZlYzg4Y2ZlY2E4ZGZlY2M4ZmZlY2Q5MGZlY2Y5MmZlZDE5NGZlZDM5NWZlZDU5N2ZlZDc5OWZlZDg5YWZkZGE5Y2ZkZGM5ZWZkZGVhMGZkZTBhMWZkZTJhM2ZkZTNhNWZkZTVhN2ZkZTdhOWZkZTlhYWZkZWJhY2ZjZWNhZWZjZWViMGZjZjBiMmZjZjJiNGZjZjRiNmZjZjZiOGZjZjdiOWZjZjliYmZjZmJiZGZjZmRiZlwiKSk7XG5cbnZhciBpbmZlcm5vID0gcmFtcCQxKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwYTAyMDIwYzAyMDIwZTAzMDIxMDA0MDMxMjA0MDMxNDA1MDQxNzA2MDQxOTA3MDUxYjA4MDUxZDA5MDYxZjBhMDcyMjBiMDcyNDBjMDgyNjBkMDgyOTBlMDkyYjEwMDkyZDExMGEzMDEyMGEzMjE0MGIzNDE1MGIzNzE2MGIzOTE4MGMzYzE5MGMzZTFiMGM0MTFjMGM0MzFlMGM0NTFmMGM0ODIxMGM0YTIzMGM0YzI0MGM0ZjI2MGM1MTI4MGI1MzI5MGI1NTJiMGI1NzJkMGI1OTJmMGE1YjMxMGE1YzMyMGE1ZTM0MGE1ZjM2MDk2MTM4MDk2MjM5MDk2MzNiMDk2NDNkMDk2NTNlMDk2NjQwMGE2NzQyMGE2ODQ0MGE2ODQ1MGE2OTQ3MGI2YTQ5MGI2YTRhMGM2YjRjMGM2YjRkMGQ2YzRmMGQ2YzUxMGU2YzUyMGU2ZDU0MGY2ZDU1MGY2ZDU3MTA2ZTU5MTA2ZTVhMTE2ZTVjMTI2ZTVkMTI2ZTVmMTM2ZTYxMTM2ZTYyMTQ2ZTY0MTU2ZTY1MTU2ZTY3MTY2ZTY5MTY2ZTZhMTc2ZTZjMTg2ZTZkMTg2ZTZmMTk2ZTcxMTk2ZTcyMWE2ZTc0MWE2ZTc1MWI2ZTc3MWM2ZDc4MWM2ZDdhMWQ2ZDdjMWQ2ZDdkMWU2ZDdmMWU2YzgwMWY2YzgyMjA2Yzg0MjA2Yjg1MjE2Yjg3MjE2Yjg4MjI2YThhMjI2YThjMjM2OThkMjM2OThmMjQ2OTkwMjU2ODkyMjU2ODkzMjY2Nzk1MjY2Nzk3Mjc2Njk4Mjc2NjlhMjg2NTliMjk2NDlkMjk2NDlmMmE2M2EwMmE2M2EyMmI2MmEzMmM2MWE1MmM2MGE2MmQ2MGE4MmU1ZmE5MmU1ZWFiMmY1ZWFkMzA1ZGFlMzA1Y2IwMzE1YmIxMzI1YWIzMzI1YWI0MzM1OWI2MzQ1OGI3MzU1N2I5MzU1NmJhMzY1NWJjMzc1NGJkMzg1M2JmMzk1MmMwM2E1MWMxM2E1MGMzM2I0ZmM0M2M0ZWM2M2Q0ZGM3M2U0Y2M4M2Y0YmNhNDA0YWNiNDE0OWNjNDI0OGNlNDM0N2NmNDQ0NmQwNDU0NWQyNDY0NGQzNDc0M2Q0NDg0MmQ1NGE0MWQ3NGIzZmQ4NGMzZWQ5NGQzZGRhNGUzY2RiNTAzYmRkNTEzYWRlNTIzOGRmNTMzN2UwNTUzNmUxNTYzNWUyNTczNGUzNTkzM2U0NWEzMWU1NWMzMGU2NWQyZmU3NWUyZWU4NjAyZGU5NjEyYmVhNjMyYWViNjQyOWViNjYyOGVjNjcyNmVkNjkyNWVlNmEyNGVmNmMyM2VmNmUyMWYwNmYyMGYxNzExZmYxNzMxZGYyNzQxY2YzNzYxYmYzNzgxOWY0NzkxOGY1N2IxN2Y1N2QxNWY2N2UxNGY2ODAxM2Y3ODIxMmY3ODQxMGY4ODUwZmY4ODcwZWY4ODkwY2Y5OGIwYmY5OGMwYWY5OGUwOWZhOTAwOGZhOTIwN2ZhOTQwN2ZiOTYwNmZiOTcwNmZiOTkwNmZiOWIwNmZiOWQwN2ZjOWYwN2ZjYTEwOGZjYTMwOWZjYTUwYWZjYTYwY2ZjYTgwZGZjYWEwZmZjYWMxMWZjYWUxMmZjYjAxNGZjYjIxNmZjYjQxOGZiYjYxYWZiYjgxZGZiYmExZmZiYmMyMWZiYmUyM2ZhYzAyNmZhYzIyOGZhYzQyYWZhYzYyZGY5YzcyZmY5YzkzMmY5Y2IzNWY4Y2QzN2Y4Y2YzYWY3ZDEzZGY3ZDM0MGY2ZDU0M2Y2ZDc0NmY1ZDk0OWY1ZGI0Y2Y0ZGQ0ZmY0ZGY1M2Y0ZTE1NmYzZTM1YWYzZTU1ZGYyZTY2MWYyZTg2NWYyZWE2OWYxZWM2ZGYxZWQ3MWYxZWY3NWYxZjE3OWYyZjI3ZGYyZjQ4MmYzZjU4NmYzZjY4YWY0Zjg4ZWY1Zjk5MmY2ZmE5NmY4ZmI5YWY5ZmM5ZGZhZmRhMWZjZmZhNFwiKSk7XG5cbnZhciBwbGFzbWEgPSByYW1wJDEoY29sb3JzKFwiMGQwODg3MTAwNzg4MTMwNzg5MTYwNzhhMTkwNjhjMWIwNjhkMWQwNjhlMjAwNjhmMjIwNjkwMjQwNjkxMjYwNTkxMjgwNTkyMmEwNTkzMmMwNTk0MmUwNTk1MmYwNTk2MzEwNTk3MzMwNTk3MzUwNDk4MzcwNDk5MzgwNDlhM2EwNDlhM2MwNDliM2UwNDljM2YwNDljNDEwNDlkNDMwMzllNDQwMzllNDYwMzlmNDgwMzlmNDkwM2EwNGIwM2ExNGMwMmExNGUwMmEyNTAwMmEyNTEwMmEzNTMwMmEzNTUwMmE0NTYwMWE0NTgwMWE0NTkwMWE1NWIwMWE1NWMwMWE2NWUwMWE2NjAwMWE2NjEwMGE3NjMwMGE3NjQwMGE3NjYwMGE3NjcwMGE4NjkwMGE4NmEwMGE4NmMwMGE4NmUwMGE4NmYwMGE4NzEwMGE4NzIwMWE4NzQwMWE4NzUwMWE4NzcwMWE4NzgwMWE4N2EwMmE4N2IwMmE4N2QwM2E4N2UwM2E4ODAwNGE4ODEwNGE3ODMwNWE3ODQwNWE3ODYwNmE2ODcwN2E2ODgwOGE2OGEwOWE1OGIwYWE1OGQwYmE1OGUwY2E0OGYwZGE0OTEwZWEzOTIwZmEzOTQxMGEyOTUxMWExOTYxM2ExOTgxNGEwOTkxNTlmOWExNjlmOWMxNzllOWQxODlkOWUxOTlkYTAxYTljYTExYjliYTIxZDlhYTMxZTlhYTUxZjk5YTYyMDk4YTcyMTk3YTgyMjk2YWEyMzk1YWIyNDk0YWMyNjk0YWQyNzkzYWUyODkyYjAyOTkxYjEyYTkwYjIyYjhmYjMyYzhlYjQyZThkYjUyZjhjYjYzMDhiYjczMThhYjgzMjg5YmEzMzg4YmIzNDg4YmMzNTg3YmQzNzg2YmUzODg1YmYzOTg0YzAzYTgzYzEzYjgyYzIzYzgxYzMzZDgwYzQzZTdmYzU0MDdlYzY0MTdkYzc0MjdjYzg0MzdiYzk0NDdhY2E0NTdhY2I0Njc5Y2M0Nzc4Y2M0OTc3Y2Q0YTc2Y2U0Yjc1Y2Y0Yzc0ZDA0ZDczZDE0ZTcyZDI0ZjcxZDM1MTcxZDQ1MjcwZDU1MzZmZDU1NDZlZDY1NTZkZDc1NjZjZDg1NzZiZDk1ODZhZGE1YTZhZGE1YjY5ZGI1YzY4ZGM1ZDY3ZGQ1ZTY2ZGU1ZjY1ZGU2MTY0ZGY2MjYzZTA2MzYzZTE2NDYyZTI2NTYxZTI2NjYwZTM2ODVmZTQ2OTVlZTU2YTVkZTU2YjVkZTY2YzVjZTc2ZTViZTc2ZjVhZTg3MDU5ZTk3MTU4ZTk3MjU3ZWE3NDU3ZWI3NTU2ZWI3NjU1ZWM3NzU0ZWQ3OTUzZWQ3YTUyZWU3YjUxZWY3YzUxZWY3ZTUwZjA3ZjRmZjA4MDRlZjE4MTRkZjE4MzRjZjI4NDRiZjM4NTRiZjM4NzRhZjQ4ODQ5ZjQ4OTQ4ZjU4YjQ3ZjU4YzQ2ZjY4ZDQ1ZjY4ZjQ0Zjc5MDQ0Zjc5MTQzZjc5MzQyZjg5NDQxZjg5NTQwZjk5NzNmZjk5ODNlZjk5YTNlZmE5YjNkZmE5YzNjZmE5ZTNiZmI5ZjNhZmJhMTM5ZmJhMjM4ZmNhMzM4ZmNhNTM3ZmNhNjM2ZmNhODM1ZmNhOTM0ZmRhYjMzZmRhYzMzZmRhZTMyZmRhZjMxZmRiMTMwZmRiMjJmZmRiNDJmZmRiNTJlZmViNzJkZmViODJjZmViYTJjZmViYjJiZmViZDJhZmViZTJhZmVjMDI5ZmRjMjI5ZmRjMzI4ZmRjNTI3ZmRjNjI3ZmRjODI3ZmRjYTI2ZmRjYjI2ZmNjZDI1ZmNjZTI1ZmNkMDI1ZmNkMjI1ZmJkMzI0ZmJkNTI0ZmJkNzI0ZmFkODI0ZmFkYTI0ZjlkYzI0ZjlkZDI1ZjhkZjI1ZjhlMTI1ZjdlMjI1ZjdlNDI1ZjZlNjI2ZjZlODI2ZjVlOTI2ZjVlYjI3ZjRlZDI3ZjNlZTI3ZjNmMDI3ZjJmMjI3ZjFmNDI2ZjFmNTI1ZjBmNzI0ZjBmOTIxXCIpKTtcblxuZXhwb3J0cy5pbnRlcnBvbGF0ZUJsdWVzID0gQmx1ZXM7XG5leHBvcnRzLmludGVycG9sYXRlQnJCRyA9IEJyQkc7XG5leHBvcnRzLmludGVycG9sYXRlQnVHbiA9IEJ1R247XG5leHBvcnRzLmludGVycG9sYXRlQnVQdSA9IEJ1UHU7XG5leHBvcnRzLmludGVycG9sYXRlQ2l2aWRpcyA9IGNpdmlkaXM7XG5leHBvcnRzLmludGVycG9sYXRlQ29vbCA9IGNvb2w7XG5leHBvcnRzLmludGVycG9sYXRlQ3ViZWhlbGl4RGVmYXVsdCA9IGN1YmVoZWxpeDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVHbkJ1ID0gR25CdTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVHcmVlbnMgPSBHcmVlbnM7XG5leHBvcnRzLmludGVycG9sYXRlR3JleXMgPSBHcmV5cztcbmV4cG9ydHMuaW50ZXJwb2xhdGVJbmZlcm5vID0gaW5mZXJubztcbmV4cG9ydHMuaW50ZXJwb2xhdGVNYWdtYSA9IG1hZ21hO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU9yUmQgPSBPclJkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU9yYW5nZXMgPSBPcmFuZ2VzO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVBSR24gPSBQUkduO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVBpWUcgPSBQaVlHO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVBsYXNtYSA9IHBsYXNtYTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVQdUJ1ID0gUHVCdTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVQdUJ1R24gPSBQdUJ1R247XG5leHBvcnRzLmludGVycG9sYXRlUHVPciA9IFB1T3I7XG5leHBvcnRzLmludGVycG9sYXRlUHVSZCA9IFB1UmQ7XG5leHBvcnRzLmludGVycG9sYXRlUHVycGxlcyA9IFB1cnBsZXM7XG5leHBvcnRzLmludGVycG9sYXRlUmFpbmJvdyA9IHJhaW5ib3c7XG5leHBvcnRzLmludGVycG9sYXRlUmRCdSA9IFJkQnU7XG5leHBvcnRzLmludGVycG9sYXRlUmRHeSA9IFJkR3k7XG5leHBvcnRzLmludGVycG9sYXRlUmRQdSA9IFJkUHU7XG5leHBvcnRzLmludGVycG9sYXRlUmRZbEJ1ID0gUmRZbEJ1O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJkWWxHbiA9IFJkWWxHbjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZWRzID0gUmVkcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVTaW5lYm93ID0gc2luZWJvdztcbmV4cG9ydHMuaW50ZXJwb2xhdGVTcGVjdHJhbCA9IFNwZWN0cmFsO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVR1cmJvID0gdHVyYm87XG5leHBvcnRzLmludGVycG9sYXRlVmlyaWRpcyA9IHZpcmlkaXM7XG5leHBvcnRzLmludGVycG9sYXRlV2FybSA9IHdhcm07XG5leHBvcnRzLmludGVycG9sYXRlWWxHbiA9IFlsR247XG5leHBvcnRzLmludGVycG9sYXRlWWxHbkJ1ID0gWWxHbkJ1O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVlsT3JCciA9IFlsT3JCcjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVZbE9yUmQgPSBZbE9yUmQ7XG5leHBvcnRzLnNjaGVtZUFjY2VudCA9IEFjY2VudDtcbmV4cG9ydHMuc2NoZW1lQmx1ZXMgPSBzY2hlbWUkbDtcbmV4cG9ydHMuc2NoZW1lQnJCRyA9IHNjaGVtZTtcbmV4cG9ydHMuc2NoZW1lQnVHbiA9IHNjaGVtZSQ5O1xuZXhwb3J0cy5zY2hlbWVCdVB1ID0gc2NoZW1lJGE7XG5leHBvcnRzLnNjaGVtZUNhdGVnb3J5MTAgPSBjYXRlZ29yeTEwO1xuZXhwb3J0cy5zY2hlbWVEYXJrMiA9IERhcmsyO1xuZXhwb3J0cy5zY2hlbWVHbkJ1ID0gc2NoZW1lJGI7XG5leHBvcnRzLnNjaGVtZUdyZWVucyA9IHNjaGVtZSRtO1xuZXhwb3J0cy5zY2hlbWVHcmV5cyA9IHNjaGVtZSRuO1xuZXhwb3J0cy5zY2hlbWVPclJkID0gc2NoZW1lJGM7XG5leHBvcnRzLnNjaGVtZU9yYW5nZXMgPSBzY2hlbWUkcTtcbmV4cG9ydHMuc2NoZW1lUFJHbiA9IHNjaGVtZSQxO1xuZXhwb3J0cy5zY2hlbWVQYWlyZWQgPSBQYWlyZWQ7XG5leHBvcnRzLnNjaGVtZVBhc3RlbDEgPSBQYXN0ZWwxO1xuZXhwb3J0cy5zY2hlbWVQYXN0ZWwyID0gUGFzdGVsMjtcbmV4cG9ydHMuc2NoZW1lUGlZRyA9IHNjaGVtZSQyO1xuZXhwb3J0cy5zY2hlbWVQdUJ1ID0gc2NoZW1lJGU7XG5leHBvcnRzLnNjaGVtZVB1QnVHbiA9IHNjaGVtZSRkO1xuZXhwb3J0cy5zY2hlbWVQdU9yID0gc2NoZW1lJDM7XG5leHBvcnRzLnNjaGVtZVB1UmQgPSBzY2hlbWUkZjtcbmV4cG9ydHMuc2NoZW1lUHVycGxlcyA9IHNjaGVtZSRvO1xuZXhwb3J0cy5zY2hlbWVSZEJ1ID0gc2NoZW1lJDQ7XG5leHBvcnRzLnNjaGVtZVJkR3kgPSBzY2hlbWUkNTtcbmV4cG9ydHMuc2NoZW1lUmRQdSA9IHNjaGVtZSRnO1xuZXhwb3J0cy5zY2hlbWVSZFlsQnUgPSBzY2hlbWUkNjtcbmV4cG9ydHMuc2NoZW1lUmRZbEduID0gc2NoZW1lJDc7XG5leHBvcnRzLnNjaGVtZVJlZHMgPSBzY2hlbWUkcDtcbmV4cG9ydHMuc2NoZW1lU2V0MSA9IFNldDE7XG5leHBvcnRzLnNjaGVtZVNldDIgPSBTZXQyO1xuZXhwb3J0cy5zY2hlbWVTZXQzID0gU2V0MztcbmV4cG9ydHMuc2NoZW1lU3BlY3RyYWwgPSBzY2hlbWUkODtcbmV4cG9ydHMuc2NoZW1lVGFibGVhdTEwID0gVGFibGVhdTEwO1xuZXhwb3J0cy5zY2hlbWVZbEduID0gc2NoZW1lJGk7XG5leHBvcnRzLnNjaGVtZVlsR25CdSA9IHNjaGVtZSRoO1xuZXhwb3J0cy5zY2hlbWVZbE9yQnIgPSBzY2hlbWUkajtcbmV4cG9ydHMuc2NoZW1lWWxPclJkID0gc2NoZW1lJGs7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2NhbGUvIHYyLjIuMiBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWNvbGxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtYXJyYXknKSwgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLXRpbWUnKSwgcmVxdWlyZSgnZDMtdGltZS1mb3JtYXQnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1jb2xsZWN0aW9uJywgJ2QzLWFycmF5JywgJ2QzLWludGVycG9sYXRlJywgJ2QzLWZvcm1hdCcsICdkMy10aW1lJywgJ2QzLXRpbWUtZm9ybWF0J10sIGZhY3RvcnkpIDpcbihmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0NvbGxlY3Rpb24sZDNBcnJheSxkM0ludGVycG9sYXRlLGQzRm9ybWF0LGQzVGltZSxkM1RpbWVGb3JtYXQpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBpbml0UmFuZ2UoZG9tYWluLCByYW5nZSkge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IGJyZWFrO1xuICAgIGNhc2UgMTogdGhpcy5yYW5nZShkb21haW4pOyBicmVhaztcbiAgICBkZWZhdWx0OiB0aGlzLnJhbmdlKHJhbmdlKS5kb21haW4oZG9tYWluKTsgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMuaW50ZXJwb2xhdG9yKGludGVycG9sYXRvcikuZG9tYWluKGRvbWFpbik7IGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBtYXAgPSBhcnJheS5tYXA7XG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxudmFyIGltcGxpY2l0ID0ge25hbWU6IFwiaW1wbGljaXRcIn07XG5cbmZ1bmN0aW9uIG9yZGluYWwoKSB7XG4gIHZhciBpbmRleCA9IGQzQ29sbGVjdGlvbi5tYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IGQzQ29sbGVjdGlvbi5tYXAoKTtcbiAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbChkb21haW4sIHJhbmdlKS51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGJhbmQoKSB7XG4gIHZhciBzY2FsZSA9IG9yZGluYWwoKS51bmtub3duKHVuZGVmaW5lZCksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBvcmRpbmFsUmFuZ2UgPSBzY2FsZS5yYW5nZSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgc3RlcCxcbiAgICAgIGJhbmR3aWR0aCxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBwYWRkaW5nSW5uZXIgPSAwLFxuICAgICAgcGFkZGluZ091dGVyID0gMCxcbiAgICAgIGFsaWduID0gMC41O1xuXG4gIGRlbGV0ZSBzY2FsZS51bmtub3duO1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIG4gPSBkb21haW4oKS5sZW5ndGgsXG4gICAgICAgIHJldmVyc2UgPSByYW5nZVsxXSA8IHJhbmdlWzBdLFxuICAgICAgICBzdGFydCA9IHJhbmdlW3JldmVyc2UgLSAwXSxcbiAgICAgICAgc3RvcCA9IHJhbmdlWzEgLSByZXZlcnNlXTtcbiAgICBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgxLCBuIC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgaWYgKHJvdW5kKSBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KSwgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIHZhciB2YWx1ZXMgPSBkM0FycmF5LnJhbmdlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gTWF0aC5taW4oMSwgcGFkZGluZ091dGVyID0gK18pLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbigxLCBfKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gK18sIHJlc2NhbGUoKSkgOiBwYWRkaW5nT3V0ZXI7XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxpZ24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBhbGlnbjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGJhbmQoZG9tYWluKCksIHJhbmdlKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KHJlc2NhbGUoKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHJldHVybiBwb2ludGlzaChiYW5kLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFkZGluZ0lubmVyKDEpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG51bWJlcih4KSB7XG4gIHJldHVybiAreDtcbn1cblxudmFyIHVuaXQgPSBbMCwgMV07XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGRvbWFpbikge1xuICB2YXIgYSA9IGRvbWFpblswXSwgYiA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBkM0FycmF5LmJpc2VjdChkb21haW4sIHgsIDEsIGopIC0gMTtcbiAgICByZXR1cm4gcltpXShkW2ldKHgpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5yYW5nZShzb3VyY2UucmFuZ2UoKSlcbiAgICAgIC5pbnRlcnBvbGF0ZShzb3VyY2UuaW50ZXJwb2xhdGUoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IChvdXRwdXQgfHwgKG91dHB1dCA9IHBpZWNld2lzZShkb21haW4ubWFwKHRyYW5zZm9ybSksIHJhbmdlLCBpbnRlcnBvbGF0ZSkpKSh0cmFuc2Zvcm0oY2xhbXAoeCkpKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gY2xhbXAodW50cmFuc2Zvcm0oKGlucHV0IHx8IChpbnB1dCA9IHBpZWNld2lzZShyYW5nZSwgZG9tYWluLm1hcCh0cmFuc2Zvcm0pLCBkM0ludGVycG9sYXRlLmludGVycG9sYXRlTnVtYmVyKSkpKHkpKSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIGNsYW1wID09PSBpZGVudGl0eSB8fCAoY2xhbXAgPSBjbGFtcGVyKGRvbWFpbikpLCByZXNjYWxlKCkpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSA9IHNsaWNlLmNhbGwoXyksIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJvdW5kLCByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSBfID8gY2xhbXBlcihkb21haW4pIDogaWRlbnRpdHksIHNjYWxlKSA6IGNsYW1wICE9PSBpZGVudGl0eTtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHJlc2NhbGUoKSkgOiBpbnRlcnBvbGF0ZTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0LCB1KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdW50cmFuc2Zvcm0gPSB1O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRpbnVvdXModHJhbnNmb3JtLCB1bnRyYW5zZm9ybSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoKSh0cmFuc2Zvcm0sIHVudHJhbnNmb3JtKTtcbn1cblxuZnVuY3Rpb24gdGlja0Zvcm1hdChzdGFydCwgc3RvcCwgY291bnQsIHNwZWNpZmllcikge1xuICB2YXIgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZDNGb3JtYXQuZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gZDNGb3JtYXQucHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkM0Zvcm1hdC5mb3JtYXQoc3BlY2lmaWVyKTtcbn1cblxuZnVuY3Rpb24gbGluZWFyaXNoKHNjYWxlKSB7XG4gIHZhciBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIGQzQXJyYXkudGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrRm9ybWF0KGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICBpMCA9IDAsXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxuICAgICAgICBzdGFydCA9IGRbaTBdLFxuICAgICAgICBzdG9wID0gZFtpMV0sXG4gICAgICAgIHN0ZXA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG5cbiAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmNlaWwoc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBzdGVwID0gZDNBcnJheS50aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGlkZW50aXR5LCBpZGVudGl0eSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSQxKGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogeDtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IHNjYWxlO1xuXG4gIHNjYWxlLmRvbWFpbiA9IHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcC5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eSQxKGRvbWFpbikudW5rbm93bih1bmtub3duKTtcbiAgfTtcblxuICBkb21haW4gPSBhcmd1bWVudHMubGVuZ3RoID8gbWFwLmNhbGwoZG9tYWluLCBudW1iZXIpIDogWzAsIDFdO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBuaWNlKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZyh4KSB7XG4gIHJldHVybiBNYXRoLmxvZyh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwKHgpIHtcbiAgcmV0dXJuIE1hdGguZXhwKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2duKHgpIHtcbiAgcmV0dXJuIC1NYXRoLmxvZygteCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUV4cG4oeCkge1xuICByZXR1cm4gLU1hdGguZXhwKC14KTtcbn1cblxuZnVuY3Rpb24gcG93MTAoeCkge1xuICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gcG93cChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucG93KGJhc2UsIHgpOyB9O1xufVxuXG5mdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IE1hdGguRSA/IE1hdGgubG9nXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICB8fCAoYmFzZSA9IE1hdGgubG9nKGJhc2UpLCBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIGJhc2U7IH0pO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gLWYoLXgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsb2dnaXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nLCB0cmFuc2Zvcm1FeHApLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgYmFzZSA9IDEwLFxuICAgICAgbG9ncyxcbiAgICAgIHBvd3M7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBsb2dzID0gbG9ncChiYXNlKSwgcG93cyA9IHBvd3AoYmFzZSk7XG4gICAgaWYgKGRvbWFpbigpWzBdIDwgMCkge1xuICAgICAgbG9ncyA9IHJlZmxlY3QobG9ncyksIHBvd3MgPSByZWZsZWN0KHBvd3MpO1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZ24sIHRyYW5zZm9ybUV4cG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nLCB0cmFuc2Zvcm1FeHApO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB1ID0gZFswXSxcbiAgICAgICAgdiA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgcjtcblxuICAgIGlmIChyID0gdiA8IHUpIGkgPSB1LCB1ID0gdiwgdiA9IGk7XG5cbiAgICB2YXIgaSA9IGxvZ3ModSksXG4gICAgICAgIGogPSBsb2dzKHYpLFxuICAgICAgICBwLFxuICAgICAgICBrLFxuICAgICAgICB0LFxuICAgICAgICBuID0gY291bnQgPT0gbnVsbCA/IDEwIDogK2NvdW50LFxuICAgICAgICB6ID0gW107XG5cbiAgICBpZiAoIShiYXNlICUgMSkgJiYgaiAtIGkgPCBuKSB7XG4gICAgICBpID0gTWF0aC5yb3VuZChpKSAtIDEsIGogPSBNYXRoLnJvdW5kKGopICsgMTtcbiAgICAgIGlmICh1ID4gMCkgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gMSwgcCA9IHBvd3MoaSk7IGsgPCBiYXNlOyArK2spIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IGJhc2UgLSAxLCBwID0gcG93cyhpKTsgayA+PSAxOyAtLWspIHtcbiAgICAgICAgICB0ID0gcCAqIGs7XG4gICAgICAgICAgaWYgKHQgPCB1KSBjb250aW51ZTtcbiAgICAgICAgICBpZiAodCA+IHYpIGJyZWFrO1xuICAgICAgICAgIHoucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gZDNBcnJheS50aWNrcyhpLCBqLCBNYXRoLm1pbihqIC0gaSwgbikpLm1hcChwb3dzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gciA/IHoucmV2ZXJzZSgpIDogejtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIGlmIChzcGVjaWZpZXIgPT0gbnVsbCkgc3BlY2lmaWVyID0gYmFzZSA9PT0gMTAgPyBcIi4wZVwiIDogXCIsXCI7XG4gICAgaWYgKHR5cGVvZiBzcGVjaWZpZXIgIT09IFwiZnVuY3Rpb25cIikgc3BlY2lmaWVyID0gZDNGb3JtYXQuZm9ybWF0KHNwZWNpZmllcik7XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIHNwZWNpZmllcjtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcbiAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBjb3VudCAvIHNjYWxlLnRpY2tzKCkubGVuZ3RoKTsgLy8gVE9ETyBmYXN0IGVzdGltYXRlP1xuICAgIHJldHVybiBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgaSA9IGQgLyBwb3dzKE1hdGgucm91bmQobG9ncyhkKSkpO1xuICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgICAgcmV0dXJuIGkgPD0gayA/IHNwZWNpZmllcihkKSA6IFwiXCI7XG4gICAgfTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbihuaWNlKGRvbWFpbigpLCB7XG4gICAgICBmbG9vcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmZsb29yKGxvZ3MoeCkpKTsgfSxcbiAgICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5jZWlsKGxvZ3MoeCkpKTsgfVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nMXAoTWF0aC5hYnMoeCAvIGMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltZXhwKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzeW1sb2dpc2godHJhbnNmb3JtKSB7XG4gIHZhciBjID0gMSwgc2NhbGUgPSB0cmFuc2Zvcm0odHJhbnNmb3JtU3ltbG9nKGMpLCB0cmFuc2Zvcm1TeW1leHAoYykpO1xuXG4gIHNjYWxlLmNvbnN0YW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjID0gK18pLCB0cmFuc2Zvcm1TeW1leHAoYykpIDogYztcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gc3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtUG93KGV4cG9uZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBleHBvbmVudCkgOiBNYXRoLnBvdyh4LCBleHBvbmVudCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNxcnQoeCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5zcXJ0KC14KSA6IE1hdGguc3FydCh4KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3F1YXJlKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gLXggKiB4IDogeCAqIHg7XG59XG5cbmZ1bmN0aW9uIHBvd2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSksXG4gICAgICBleHBvbmVudCA9IDE7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICByZXR1cm4gZXhwb25lbnQgPT09IDEgPyB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KVxuICAgICAgICA6IGV4cG9uZW50ID09PSAwLjUgPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3FydCwgdHJhbnNmb3JtU3F1YXJlKVxuICAgICAgICA6IHRyYW5zZm9ybSh0cmFuc2Zvcm1Qb3coZXhwb25lbnQpLCB0cmFuc2Zvcm1Qb3coMSAvIGV4cG9uZW50KSk7XG4gIH1cblxuICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCByZXNjYWxlKCkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIHBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgcG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHNxcnQoKSB7XG4gIHJldHVybiBwb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IGQzQXJyYXkucXVhbnRpbGUoZG9tYWluLCBpIC8gbik7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHJhbmdlW2QzQXJyYXkuYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChkM0FycmF5LmFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlLmNhbGwoXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpemUoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UgPSBbMCwgMV0sXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdLCB4MSA9ICtfWzFdLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSA9IHNsaWNlLmNhbGwoXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnRocmVzaG9sZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGl6ZSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShsaW5lYXJpc2goc2NhbGUpLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA8PSB4ID8gcmFuZ2VbZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHNsaWNlLmNhbGwoXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogZG9tYWluLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDEwMDAsXG4gICAgZHVyYXRpb25NaW51dGUgPSBkdXJhdGlvblNlY29uZCAqIDYwLFxuICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgZHVyYXRpb25EYXkgPSBkdXJhdGlvbkhvdXIgKiAyNCxcbiAgICBkdXJhdGlvbldlZWsgPSBkdXJhdGlvbkRheSAqIDcsXG4gICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgZHVyYXRpb25ZZWFyID0gZHVyYXRpb25EYXkgKiAzNjU7XG5cbmZ1bmN0aW9uIGRhdGUodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlciQxKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGlkZW50aXR5LCBpZGVudGl0eSksXG4gICAgICBpbnZlcnQgPSBzY2FsZS5pbnZlcnQsXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgdmFyIGZvcm1hdE1pbGxpc2Vjb25kID0gZm9ybWF0KFwiLiVMXCIpLFxuICAgICAgZm9ybWF0U2Vjb25kID0gZm9ybWF0KFwiOiVTXCIpLFxuICAgICAgZm9ybWF0TWludXRlID0gZm9ybWF0KFwiJUk6JU1cIiksXG4gICAgICBmb3JtYXRIb3VyID0gZm9ybWF0KFwiJUkgJXBcIiksXG4gICAgICBmb3JtYXREYXkgPSBmb3JtYXQoXCIlYSAlZFwiKSxcbiAgICAgIGZvcm1hdFdlZWsgPSBmb3JtYXQoXCIlYiAlZFwiKSxcbiAgICAgIGZvcm1hdE1vbnRoID0gZm9ybWF0KFwiJUJcIiksXG4gICAgICBmb3JtYXRZZWFyID0gZm9ybWF0KFwiJVlcIik7XG5cbiAgdmFyIHRpY2tJbnRlcnZhbHMgPSBbXG4gICAgW3NlY29uZCwgIDEsICAgICAgZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsICA1LCAgNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAxNSwgMTUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMzAsIDMwICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFttaW51dGUsICAxLCAgICAgIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAgNSwgIDUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMTUsIDE1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDMwLCAzMCAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbICBob3VyLCAgMSwgICAgICBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDMsICAzICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICA2LCAgNiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAxMiwgMTIgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgIGRheSwgIDEsICAgICAgZHVyYXRpb25EYXkgICBdLFxuICAgIFsgICBkYXksICAyLCAgMiAqIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICB3ZWVrLCAgMSwgICAgICBkdXJhdGlvbldlZWsgIF0sXG4gICAgWyBtb250aCwgIDEsICAgICAgZHVyYXRpb25Nb250aCBdLFxuICAgIFsgbW9udGgsICAzLCAgMyAqIGR1cmF0aW9uTW9udGggXSxcbiAgICBbICB5ZWFyLCAgMSwgICAgICBkdXJhdGlvblllYXIgIF1cbiAgXTtcblxuICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRhdGUpIHtcbiAgICByZXR1cm4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IG1pbnV0ZShkYXRlKSA8IGRhdGUgPyBmb3JtYXRTZWNvbmRcbiAgICAgICAgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbnV0ZVxuICAgICAgICA6IGRheShkYXRlKSA8IGRhdGUgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogbW9udGgoZGF0ZSkgPCBkYXRlID8gKHdlZWsoZGF0ZSkgPCBkYXRlID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1vbnRoXG4gICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGludGVydmFsID09IG51bGwpIGludGVydmFsID0gMTA7XG5cbiAgICAvLyBJZiBhIGRlc2lyZWQgdGljayBjb3VudCBpcyBzcGVjaWZpZWQsIHBpY2sgYSByZWFzb25hYmxlIHRpY2sgaW50ZXJ2YWxcbiAgICAvLyBiYXNlZCBvbiB0aGUgZXh0ZW50IG9mIHRoZSBkb21haW4gYW5kIGEgcm91Z2ggZXN0aW1hdGUgb2YgdGljayBzaXplLlxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGludGVydmFsIGlzIGFscmVhZHkgYSB0aW1lIGludGVydmFsIGFuZCB1c2UgaXQuXG4gICAgaWYgKHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgdmFyIHRhcmdldCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBpbnRlcnZhbCxcbiAgICAgICAgICBpID0gZDNBcnJheS5iaXNlY3RvcihmdW5jdGlvbihpKSB7IHJldHVybiBpWzJdOyB9KS5yaWdodCh0aWNrSW50ZXJ2YWxzLCB0YXJnZXQpO1xuICAgICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0geWVhcjtcbiAgICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IE1hdGgubWF4KGQzQXJyYXkudGlja1N0ZXAoc3RhcnQsIHN0b3AsIGludGVydmFsKSwgMSk7XG4gICAgICAgIGludGVydmFsID0gbWlsbGlzZWNvbmQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXAgPT0gbnVsbCA/IGludGVydmFsIDogaW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGludmVydCh5KSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZG9tYWluKG1hcC5jYWxsKF8sIG51bWJlciQxKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHQwID0gZFswXSxcbiAgICAgICAgdDEgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHIgPSB0MSA8IHQwLFxuICAgICAgICB0O1xuICAgIGlmIChyKSB0ID0gdDAsIHQwID0gdDEsIHQxID0gdDtcbiAgICB0ID0gdGlja0ludGVydmFsKGludGVydmFsLCB0MCwgdDEsIHN0ZXApO1xuICAgIHQgPSB0ID8gdC5yYW5nZSh0MCwgdDEgKyAxKSA6IFtdOyAvLyBpbmNsdXNpdmUgc3RvcFxuICAgIHJldHVybiByID8gdC5yZXZlcnNlKCkgOiB0O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc3RlcCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIChpbnRlcnZhbCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBzdGVwKSlcbiAgICAgICAgPyBkb21haW4obmljZShkLCBpbnRlcnZhbCkpXG4gICAgICAgIDogc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBjYWxlbmRhcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gdGltZSgpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcihkM1RpbWUudGltZVllYXIsIGQzVGltZS50aW1lTW9udGgsIGQzVGltZS50aW1lV2VlaywgZDNUaW1lLnRpbWVEYXksIGQzVGltZS50aW1lSG91ciwgZDNUaW1lLnRpbWVNaW51dGUsIGQzVGltZS50aW1lU2Vjb25kLCBkM1RpbWUudGltZU1pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdXRjVGltZSgpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcihkM1RpbWUudXRjWWVhciwgZDNUaW1lLnV0Y01vbnRoLCBkM1RpbWUudXRjV2VlaywgZDNUaW1lLnV0Y0RheSwgZDNUaW1lLnV0Y0hvdXIsIGQzVGltZS51dGNNaW51dGUsIGQzVGltZS51dGNTZWNvbmQsIGQzVGltZS51dGNNaWxsaXNlY29uZCwgZDNUaW1lRm9ybWF0LnV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIkMSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiBpbnRlcnBvbGF0b3IoazEwID09PSAwID8gMC41IDogKHggPSAodHJhbnNmb3JtKHgpIC0gdDApICogazEwLCBjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAxIC8gKHQxIC0gdDApLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb3B5JDEoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAuaW50ZXJwb2xhdG9yKHNvdXJjZS5pbnRlcnBvbGF0b3IoKSlcbiAgICAgIC5jbGFtcChzb3VyY2UuY2xhbXAoKSlcbiAgICAgIC51bmtub3duKHNvdXJjZS51bmtub3duKCkpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIkMSgpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWwoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxMb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIkMSgpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWxMb2coKSkuYmFzZShzY2FsZS5iYXNlKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsU3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIkMSgpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkkMShzY2FsZSwgc2VxdWVudGlhbFN5bWxvZygpKS5jb25zdGFudChzY2FsZS5jb25zdGFudCgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VxdWVudGlhbFBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyJDEoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5JDEoc2NhbGUsIHNlcXVlbnRpYWxQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxTcXJ0KCkge1xuICByZXR1cm4gc2VxdWVudGlhbFBvdy5hcHBseShudWxsLCBhcmd1bWVudHMpLmV4cG9uZW50KDAuNSk7XG59XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWxRdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgaW50ZXJwb2xhdG9yID0gaWRlbnRpdHk7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIGludGVycG9sYXRvcigoZDNBcnJheS5iaXNlY3QoZG9tYWluLCB4KSAtIDEpIC8gKGRvbWFpbi5sZW5ndGggLSAxKSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgZG9tYWluID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBfLmxlbmd0aCwgZDsgaSA8IG47ICsraSkgaWYgKGQgPSBfW2ldLCBkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGQzQXJyYXkuYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlcXVlbnRpYWxRdWFudGlsZShpbnRlcnBvbGF0b3IpLmRvbWFpbihkb21haW4pO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lciQyKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAwLjUsXG4gICAgICB4MiA9IDEsXG4gICAgICB0MCxcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICBrMTAsXG4gICAgICBrMjEsXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiAoeCA9IDAuNSArICgoeCA9ICt0cmFuc2Zvcm0oeCkpIC0gdDEpICogKHggPCB0MSA/IGsxMCA6IGsyMSksIGludGVycG9sYXRvcihjbGFtcCA/IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHgpKSA6IHgpKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0MCA9IHRyYW5zZm9ybSh4MCA9ICtfWzBdKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSArX1sxXSksIHQyID0gdHJhbnNmb3JtKHgyID0gK19bMl0pLCBrMTAgPSB0MCA9PT0gdDEgPyAwIDogMC41IC8gKHQxIC0gdDApLCBrMjEgPSB0MSA9PT0gdDIgPyAwIDogMC41IC8gKHQyIC0gdDEpLCBzY2FsZSkgOiBbeDAsIHgxLCB4Ml07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHQwID0gdCh4MCksIHQxID0gdCh4MSksIHQyID0gdCh4MiksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXZlcmdpbmcoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lciQyKCkoaWRlbnRpdHkpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkkMShzY2FsZSwgZGl2ZXJnaW5nKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkaXZlcmdpbmdMb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIkMigpKS5kb21haW4oWzAuMSwgMSwgMTBdKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkkMShzY2FsZSwgZGl2ZXJnaW5nTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZGl2ZXJnaW5nU3ltbG9nKCkge1xuICB2YXIgc2NhbGUgPSBzeW1sb2dpc2godHJhbnNmb3JtZXIkMigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkkMShzY2FsZSwgZGl2ZXJnaW5nU3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBkaXZlcmdpbmdQb3coKSB7XG4gIHZhciBzY2FsZSA9IHBvd2lzaCh0cmFuc2Zvcm1lciQyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weSQxKHNjYWxlLCBkaXZlcmdpbmdQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGRpdmVyZ2luZ1NxcnQoKSB7XG4gIHJldHVybiBkaXZlcmdpbmdQb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5leHBvbmVudCgwLjUpO1xufVxuXG5leHBvcnRzLnNjYWxlQmFuZCA9IGJhbmQ7XG5leHBvcnRzLnNjYWxlUG9pbnQgPSBwb2ludDtcbmV4cG9ydHMuc2NhbGVJZGVudGl0eSA9IGlkZW50aXR5JDE7XG5leHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyO1xuZXhwb3J0cy5zY2FsZUxvZyA9IGxvZztcbmV4cG9ydHMuc2NhbGVTeW1sb2cgPSBzeW1sb2c7XG5leHBvcnRzLnNjYWxlT3JkaW5hbCA9IG9yZGluYWw7XG5leHBvcnRzLnNjYWxlSW1wbGljaXQgPSBpbXBsaWNpdDtcbmV4cG9ydHMuc2NhbGVQb3cgPSBwb3c7XG5leHBvcnRzLnNjYWxlU3FydCA9IHNxcnQ7XG5leHBvcnRzLnNjYWxlUXVhbnRpbGUgPSBxdWFudGlsZTtcbmV4cG9ydHMuc2NhbGVRdWFudGl6ZSA9IHF1YW50aXplO1xuZXhwb3J0cy5zY2FsZVRocmVzaG9sZCA9IHRocmVzaG9sZDtcbmV4cG9ydHMuc2NhbGVUaW1lID0gdGltZTtcbmV4cG9ydHMuc2NhbGVVdGMgPSB1dGNUaW1lO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWwgPSBzZXF1ZW50aWFsO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxMb2cgPSBzZXF1ZW50aWFsTG9nO1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxQb3cgPSBzZXF1ZW50aWFsUG93O1xuZXhwb3J0cy5zY2FsZVNlcXVlbnRpYWxTcXJ0ID0gc2VxdWVudGlhbFNxcnQ7XG5leHBvcnRzLnNjYWxlU2VxdWVudGlhbFN5bWxvZyA9IHNlcXVlbnRpYWxTeW1sb2c7XG5leHBvcnRzLnNjYWxlU2VxdWVudGlhbFF1YW50aWxlID0gc2VxdWVudGlhbFF1YW50aWxlO1xuZXhwb3J0cy5zY2FsZURpdmVyZ2luZyA9IGRpdmVyZ2luZztcbmV4cG9ydHMuc2NhbGVEaXZlcmdpbmdMb2cgPSBkaXZlcmdpbmdMb2c7XG5leHBvcnRzLnNjYWxlRGl2ZXJnaW5nUG93ID0gZGl2ZXJnaW5nUG93O1xuZXhwb3J0cy5zY2FsZURpdmVyZ2luZ1NxcnQgPSBkaXZlcmdpbmdTcXJ0O1xuZXhwb3J0cy5zY2FsZURpdmVyZ2luZ1N5bWxvZyA9IGRpdmVyZ2luZ1N5bWxvZztcbmV4cG9ydHMudGlja0Zvcm1hdCA9IHRpY2tGb3JtYXQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNlbGVjdGlvbi8gdjEuNC4xIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHhodG1sID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI7XG5cbnZhciBuYW1lc3BhY2VzID0ge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IHhodG1sLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcblxuZnVuY3Rpb24gbmFtZXNwYWNlKG5hbWUpIHtcbiAgdmFyIHByZWZpeCA9IG5hbWUgKz0gXCJcIiwgaSA9IHByZWZpeC5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICByZXR1cm4gbmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcmVmaXgpID8ge3NwYWNlOiBuYW1lc3BhY2VzW3ByZWZpeF0sIGxvY2FsOiBuYW1lfSA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JJbmhlcml0KG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkb2N1bWVudCA9IHRoaXMub3duZXJEb2N1bWVudCxcbiAgICAgICAgdXJpID0gdGhpcy5uYW1lc3BhY2VVUkk7XG4gICAgcmV0dXJuIHVyaSA9PT0geGh0bWwgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0geGh0bWxcbiAgICAgICAgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpXG4gICAgICAgIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHVyaSwgbmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3JGaXhlZChmdWxsbmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvcihuYW1lKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIChmdWxsbmFtZS5sb2NhbFxuICAgICAgPyBjcmVhdG9yRml4ZWRcbiAgICAgIDogY3JlYXRvckluaGVyaXQpKGZ1bGxuYW1lKTtcbn1cblxuZnVuY3Rpb24gbm9uZSgpIHt9XG5cbmZ1bmN0aW9uIHNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gbm9uZSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0KHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBlbXB0eSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zZWxlY3RBbGwoc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXIoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZmlsdGVyKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzcGFyc2UodXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9lbnRlcigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZW50ZXIgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gRW50ZXJOb2RlKHBhcmVudCwgZGF0dW0pIHtcbiAgdGhpcy5vd25lckRvY3VtZW50ID0gcGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMubmFtZXNwYWNlVVJJID0gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fX2RhdGFfXyA9IGRhdHVtO1xufVxuXG5FbnRlck5vZGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRW50ZXJOb2RlLFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuX25leHQpOyB9LFxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uKGNoaWxkLCBuZXh0KSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTsgfSxcbiAgcXVlcnlTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTsgfSxcbiAgcXVlcnlTZWxlY3RvckFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTsgfVxufTtcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbnZhciBrZXlQcmVmaXggPSBcIiRcIjsgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG5cbmZ1bmN0aW9uIGJpbmRJbmRleChwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG5vZGUsXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZml0IGludG8gdXBkYXRlLlxuICAvLyBQdXQgYW55IG51bGwgbm9kZXMgaW50byBlbnRlci5cbiAgLy8gUHV0IGFueSByZW1haW5pbmcgZGF0YSBpbnRvIGVudGVyLlxuICBmb3IgKDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGRvbuKAmXQgZml0IGludG8gZXhpdC5cbiAgZm9yICg7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRLZXkocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSwga2V5KSB7XG4gIHZhciBpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVCeUtleVZhbHVlID0ge30sXG4gICAgICBncm91cExlbmd0aCA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGtleVZhbHVlcyA9IG5ldyBBcnJheShncm91cExlbmd0aCksXG4gICAgICBrZXlWYWx1ZTtcblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggbm9kZS5cbiAgLy8gSWYgbXVsdGlwbGUgbm9kZXMgaGF2ZSB0aGUgc2FtZSBrZXksIHRoZSBkdXBsaWNhdGVzIGFyZSBhZGRlZCB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgICAgaWYgKGtleVZhbHVlIGluIG5vZGVCeUtleVZhbHVlKSB7XG4gICAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBrZXkgZm9yIGVhY2ggZGF0dW0uXG4gIC8vIElmIHRoZXJlIGEgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBrZXksIGpvaW4gYW5kIGFkZCBpdCB0byB1cGRhdGUuXG4gIC8vIElmIHRoZXJlIGlzIG5vdCAob3IgdGhlIGtleSBpcyBhIGR1cGxpY2F0ZSksIGFkZCBpdCB0byBlbnRlci5cbiAgZm9yIChpID0gMDsgaSA8IGRhdGFMZW5ndGg7ICsraSkge1xuICAgIGtleVZhbHVlID0ga2V5UHJlZml4ICsga2V5LmNhbGwocGFyZW50LCBkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICBpZiAobm9kZSA9IG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSkge1xuICAgICAgdXBkYXRlW2ldID0gbm9kZTtcbiAgICAgIG5vZGUuX19kYXRhX18gPSBkYXRhW2ldO1xuICAgICAgbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJbaV0gPSBuZXcgRW50ZXJOb2RlKHBhcmVudCwgZGF0YVtpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGFueSByZW1haW5pbmcgbm9kZXMgdGhhdCB3ZXJlIG5vdCBib3VuZCB0byBkYXRhIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZXNbaV1dID09PSBub2RlKSkge1xuICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9kYXRhKHZhbHVlLCBrZXkpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIGRhdGEgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBqID0gLTE7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGQpIHsgZGF0YVsrK2pdID0gZDsgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYmluZCA9IGtleSA/IGJpbmRLZXkgOiBiaW5kSW5kZXgsXG4gICAgICBwYXJlbnRzID0gdGhpcy5fcGFyZW50cyxcbiAgICAgIGdyb3VwcyA9IHRoaXMuX2dyb3VwcztcblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHZhbHVlID0gY29uc3RhbnQodmFsdWUpO1xuXG4gIGZvciAodmFyIG0gPSBncm91cHMubGVuZ3RoLCB1cGRhdGUgPSBuZXcgQXJyYXkobSksIGVudGVyID0gbmV3IEFycmF5KG0pLCBleGl0ID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2pdLFxuICAgICAgICBncm91cCA9IGdyb3Vwc1tqXSxcbiAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICAgIGRhdGEgPSB2YWx1ZS5jYWxsKHBhcmVudCwgcGFyZW50ICYmIHBhcmVudC5fX2RhdGFfXywgaiwgcGFyZW50cyksXG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZW50ZXJHcm91cCA9IGVudGVyW2pdID0gbmV3IEFycmF5KGRhdGFMZW5ndGgpLFxuICAgICAgICB1cGRhdGVHcm91cCA9IHVwZGF0ZVtqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgZXhpdEdyb3VwID0gZXhpdFtqXSA9IG5ldyBBcnJheShncm91cExlbmd0aCk7XG5cbiAgICBiaW5kKHBhcmVudCwgZ3JvdXAsIGVudGVyR3JvdXAsIHVwZGF0ZUdyb3VwLCBleGl0R3JvdXAsIGRhdGEsIGtleSk7XG5cbiAgICAvLyBOb3cgY29ubmVjdCB0aGUgZW50ZXIgbm9kZXMgdG8gdGhlaXIgZm9sbG93aW5nIHVwZGF0ZSBub2RlLCBzdWNoIHRoYXRcbiAgICAvLyBhcHBlbmRDaGlsZCBjYW4gaW5zZXJ0IHRoZSBtYXRlcmlhbGl6ZWQgZW50ZXIgbm9kZSBiZWZvcmUgdGhpcyBub2RlLFxuICAgIC8vIHJhdGhlciB0aGFuIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmVudCBub2RlLlxuICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAwLCBwcmV2aW91cywgbmV4dDsgaTAgPCBkYXRhTGVuZ3RoOyArK2kwKSB7XG4gICAgICBpZiAocHJldmlvdXMgPSBlbnRlckdyb3VwW2kwXSkge1xuICAgICAgICBpZiAoaTAgPj0gaTEpIGkxID0gaTAgKyAxO1xuICAgICAgICB3aGlsZSAoIShuZXh0ID0gdXBkYXRlR3JvdXBbaTFdKSAmJiArK2kxIDwgZGF0YUxlbmd0aCk7XG4gICAgICAgIHByZXZpb3VzLl9uZXh0ID0gbmV4dCB8fCBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSA9IG5ldyBTZWxlY3Rpb24odXBkYXRlLCBwYXJlbnRzKTtcbiAgdXBkYXRlLl9lbnRlciA9IGVudGVyO1xuICB1cGRhdGUuX2V4aXQgPSBleGl0O1xuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZXhpdCgpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZXhpdCB8fCB0aGlzLl9ncm91cHMubWFwKHNwYXJzZSksIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fam9pbihvbmVudGVyLCBvbnVwZGF0ZSwgb25leGl0KSB7XG4gIHZhciBlbnRlciA9IHRoaXMuZW50ZXIoKSwgdXBkYXRlID0gdGhpcywgZXhpdCA9IHRoaXMuZXhpdCgpO1xuICBlbnRlciA9IHR5cGVvZiBvbmVudGVyID09PSBcImZ1bmN0aW9uXCIgPyBvbmVudGVyKGVudGVyKSA6IGVudGVyLmFwcGVuZChvbmVudGVyICsgXCJcIik7XG4gIGlmIChvbnVwZGF0ZSAhPSBudWxsKSB1cGRhdGUgPSBvbnVwZGF0ZSh1cGRhdGUpO1xuICBpZiAob25leGl0ID09IG51bGwpIGV4aXQucmVtb3ZlKCk7IGVsc2Ugb25leGl0KGV4aXQpO1xuICByZXR1cm4gZW50ZXIgJiYgdXBkYXRlID8gZW50ZXIubWVyZ2UodXBkYXRlKS5vcmRlcigpIDogdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fbWVyZ2Uoc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fb3JkZXIoKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gLTEsIG0gPSBncm91cHMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gZ3JvdXAubGVuZ3RoIC0gMSwgbmV4dCA9IGdyb3VwW2ldLCBub2RlOyAtLWkgPj0gMDspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgaWYgKG5leHQgJiYgbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuZXh0KSBeIDQpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc29ydChjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2FsbCgpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX25vZGVzKCkge1xuICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBpID0gLTE7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgbm9kZXNbKytpXSA9IHRoaXM7IH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9ub2RlKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2l6ZSgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfSk7XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZW1wdHkoKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9lYWNoKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFZpZXcobm9kZSkge1xuICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKVxuICAgICAgOiBzdHlsZVZhbHVlKHRoaXMubm9kZSgpLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuXG5mdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl90ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cblxuZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9odG1sKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59XG5cbmZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fcmFpc2UoKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuXG5mdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2xvd2VyKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2FwcGVuZChuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25faW5zZXJ0KG5hbWUsIGJlZm9yZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpLFxuICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fcmVtb3ZlKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICByZXR1cm4gcGFyZW50ID8gcGFyZW50Lmluc2VydEJlZm9yZShjbG9uZSwgdGhpcy5uZXh0U2libGluZykgOiBjbG9uZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lRGVlcCgpIHtcbiAgdmFyIGNsb25lID0gdGhpcy5jbG9uZU5vZGUodHJ1ZSksIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRoaXMubmV4dFNpYmxpbmcpIDogY2xvbmU7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZShkZWVwKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdChkZWVwID8gc2VsZWN0aW9uX2Nsb25lRGVlcCA6IHNlbGVjdGlvbl9jbG9uZVNoYWxsb3cpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZGF0dW0odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLm5vZGUoKS5fX2RhdGFfXztcbn1cblxudmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnRzLmV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiBlbGVtZW50KSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSAmIDgpKSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQxKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV4cG9ydHMuZXZlbnQ7IC8vIEV2ZW50cyBjYW4gYmUgcmVlbnRyYW50IChlLmcuLCBmb2N1cykuXG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgICB0cnkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCB0aGlzLl9fZGF0YV9fLCBpbmRleCwgZ3JvdXApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX29uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgaWYgKGNhcHR1cmUgPT0gbnVsbCkgY2FwdHVyZSA9IGZhbHNlO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgY2FwdHVyZSkpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDtcbiAgZXZlbnQxLnNvdXJjZUV2ZW50ID0gZXhwb3J0cy5ldmVudDtcbiAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KG5vZGUsIHR5cGUsIHBhcmFtcykge1xuICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICBldmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgZWxzZSBldmVudC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZGlzcGF0Y2godHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBqb2luOiBzZWxlY3Rpb25fam9pbixcbiAgbWVyZ2U6IHNlbGVjdGlvbl9tZXJnZSxcbiAgb3JkZXI6IHNlbGVjdGlvbl9vcmRlcixcbiAgc29ydDogc2VsZWN0aW9uX3NvcnQsXG4gIGNhbGw6IHNlbGVjdGlvbl9jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX25vZGVzLFxuICBub2RlOiBzZWxlY3Rpb25fbm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3NpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fZW1wdHksXG4gIGVhY2g6IHNlbGVjdGlvbl9lYWNoLFxuICBhdHRyOiBzZWxlY3Rpb25fYXR0cixcbiAgc3R5bGU6IHNlbGVjdGlvbl9zdHlsZSxcbiAgcHJvcGVydHk6IHNlbGVjdGlvbl9wcm9wZXJ0eSxcbiAgY2xhc3NlZDogc2VsZWN0aW9uX2NsYXNzZWQsXG4gIHRleHQ6IHNlbGVjdGlvbl90ZXh0LFxuICBodG1sOiBzZWxlY3Rpb25faHRtbCxcbiAgcmFpc2U6IHNlbGVjdGlvbl9yYWlzZSxcbiAgbG93ZXI6IHNlbGVjdGlvbl9sb3dlcixcbiAgYXBwZW5kOiBzZWxlY3Rpb25fYXBwZW5kLFxuICBpbnNlcnQ6IHNlbGVjdGlvbl9pbnNlcnQsXG4gIHJlbW92ZTogc2VsZWN0aW9uX3JlbW92ZSxcbiAgY2xvbmU6IHNlbGVjdGlvbl9jbG9uZSxcbiAgZGF0dW06IHNlbGVjdGlvbl9kYXR1bSxcbiAgb246IHNlbGVjdGlvbl9vbixcbiAgZGlzcGF0Y2g6IHNlbGVjdGlvbl9kaXNwYXRjaFxufTtcblxuZnVuY3Rpb24gc2VsZWN0KHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtbc2VsZWN0b3JdXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShuYW1lKSB7XG4gIHJldHVybiBzZWxlY3QoY3JlYXRvcihuYW1lKS5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpO1xufVxuXG52YXIgbmV4dElkID0gMDtcblxuZnVuY3Rpb24gbG9jYWwoKSB7XG4gIHJldHVybiBuZXcgTG9jYWw7XG59XG5cbmZ1bmN0aW9uIExvY2FsKCkge1xuICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xufVxuXG5Mb2NhbC5wcm90b3R5cGUgPSBsb2NhbC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMb2NhbCxcbiAgZ2V0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fO1xuICAgIHdoaWxlICghKGlkIGluIG5vZGUpKSBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkgcmV0dXJuO1xuICAgIHJldHVybiBub2RlW2lkXTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiBub2RlW3RoaXMuX10gPSB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuXyBpbiBub2RlICYmIGRlbGV0ZSBub2RlW3RoaXMuX107XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VFdmVudCgpIHtcbiAgdmFyIGN1cnJlbnQgPSBleHBvcnRzLmV2ZW50LCBzb3VyY2U7XG4gIHdoaWxlIChzb3VyY2UgPSBjdXJyZW50LnNvdXJjZUV2ZW50KSBjdXJyZW50ID0gc291cmNlO1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gcG9pbnQobm9kZSwgZXZlbnQpIHtcbiAgdmFyIHN2ZyA9IG5vZGUub3duZXJTVkdFbGVtZW50IHx8IG5vZGU7XG5cbiAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHBvaW50LnggPSBldmVudC5jbGllbnRYLCBwb2ludC55ID0gZXZlbnQuY2xpZW50WTtcbiAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShub2RlLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKSk7XG4gICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgfVxuXG4gIHZhciByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIFtldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gbm9kZS5jbGllbnRMZWZ0LCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSBub2RlLmNsaWVudFRvcF07XG59XG5cbmZ1bmN0aW9uIG1vdXNlKG5vZGUpIHtcbiAgdmFyIGV2ZW50ID0gc291cmNlRXZlbnQoKTtcbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzKSBldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICByZXR1cm4gcG9pbnQobm9kZSwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RBbGwoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV0sIFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdKVxuICAgICAgOiBuZXcgU2VsZWN0aW9uKFtzZWxlY3RvciA9PSBudWxsID8gW10gOiBzZWxlY3Rvcl0sIHJvb3QpO1xufVxuXG5mdW5jdGlvbiB0b3VjaChub2RlLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgaWRlbnRpZmllciA9IHRvdWNoZXMsIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLmNoYW5nZWRUb3VjaGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcyA/IHRvdWNoZXMubGVuZ3RoIDogMCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmV0dXJuIHBvaW50KG5vZGUsIHRvdWNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdG91Y2hlcyhub2RlLCB0b3VjaGVzKSB7XG4gIGlmICh0b3VjaGVzID09IG51bGwpIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLnRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCBwb2ludHMgPSBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcbiAgICBwb2ludHNbaV0gPSBwb2ludChub2RlLCB0b3VjaGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydHMuY2xpZW50UG9pbnQgPSBwb2ludDtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jcmVhdG9yID0gY3JlYXRvcjtcbmV4cG9ydHMuY3VzdG9tRXZlbnQgPSBjdXN0b21FdmVudDtcbmV4cG9ydHMubG9jYWwgPSBsb2NhbDtcbmV4cG9ydHMubWF0Y2hlciA9IG1hdGNoZXI7XG5leHBvcnRzLm1vdXNlID0gbW91c2U7XG5leHBvcnRzLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbmV4cG9ydHMubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5leHBvcnRzLnNlbGVjdCA9IHNlbGVjdDtcbmV4cG9ydHMuc2VsZWN0QWxsID0gc2VsZWN0QWxsO1xuZXhwb3J0cy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG5leHBvcnRzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5leHBvcnRzLnNlbGVjdG9yQWxsID0gc2VsZWN0b3JBbGw7XG5leHBvcnRzLnN0eWxlID0gc3R5bGVWYWx1ZTtcbmV4cG9ydHMudG91Y2ggPSB0b3VjaDtcbmV4cG9ydHMudG91Y2hlcyA9IHRvdWNoZXM7XG5leHBvcnRzLndpbmRvdyA9IGRlZmF1bHRWaWV3O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNoYXBlLyB2MS4zLjcgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1wYXRoJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtcGF0aCddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzUGF0aCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0YW50KCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbnZhciBlcHNpbG9uID0gMWUtMTI7XG52YXIgcGkgPSBNYXRoLlBJO1xudmFyIGhhbGZQaSA9IHBpIC8gMjtcbnZhciB0YXUgPSAyICogcGk7XG5cbmZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSB5MzIgKiB4MTAgLSB4MzIgKiB5MTA7XG4gIGlmICh0ICogdCA8IGVwc2lsb24pIHJldHVybjtcbiAgdCA9ICh4MzIgKiAoeTAgLSB5MikgLSB5MzIgKiAoeDAgLSB4MikpIC8gdDtcbiAgcmV0dXJuIFt4MCArIHQgKiB4MTAsIHkwICsgdCAqIHkxMF07XG59XG5cbi8vIENvbXB1dGUgcGVycGVuZGljdWxhciBvZmZzZXQgbGluZSBvZiBsZW5ndGggcmMuXG4vLyBodHRwOi8vbWF0aHdvcmxkLndvbGZyYW0uY29tL0NpcmNsZS1MaW5lSW50ZXJzZWN0aW9uLmh0bWxcbmZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gIHZhciB4MDEgPSB4MCAtIHgxLFxuICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gc3FydCh4MDEgKiB4MDEgKyB5MDEgKiB5MDEpLFxuICAgICAgb3ggPSBsbyAqIHkwMSxcbiAgICAgIG95ID0gLWxvICogeDAxLFxuICAgICAgeDExID0geDAgKyBveCxcbiAgICAgIHkxMSA9IHkwICsgb3ksXG4gICAgICB4MTAgPSB4MSArIG94LFxuICAgICAgeTEwID0geTEgKyBveSxcbiAgICAgIHgwMCA9ICh4MTEgKyB4MTApIC8gMixcbiAgICAgIHkwMCA9ICh5MTEgKyB5MTApIC8gMixcbiAgICAgIGR4ID0geDEwIC0geDExLFxuICAgICAgZHkgPSB5MTAgLSB5MTEsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgciA9IHIxIC0gcmMsXG4gICAgICBEID0geDExICogeTEwIC0geDEwICogeTExLFxuICAgICAgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogc3FydChtYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksXG4gICAgICBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLFxuICAgICAgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsXG4gICAgICBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLFxuICAgICAgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsXG4gICAgICBkeDAgPSBjeDAgLSB4MDAsXG4gICAgICBkeTAgPSBjeTAgLSB5MDAsXG4gICAgICBkeDEgPSBjeDEgLSB4MDAsXG4gICAgICBkeTEgPSBjeTEgLSB5MDA7XG5cbiAgLy8gUGljayB0aGUgY2xvc2VyIG9mIHRoZSB0d28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgLy8gVE9ETyBJcyB0aGVyZSBhIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIHdoaWNoIGludGVyc2VjdGlvbiB0byB1c2U/XG4gIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuXG4gIHJldHVybiB7XG4gICAgY3g6IGN4MCxcbiAgICBjeTogY3kwLFxuICAgIHgwMTogLW94LFxuICAgIHkwMTogLW95LFxuICAgIHgxMTogY3gwICogKHIxIC8gciAtIDEpLFxuICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFyYygpIHtcbiAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsXG4gICAgICBvdXRlclJhZGl1cyA9IGFyY091dGVyUmFkaXVzLFxuICAgICAgY29ybmVyUmFkaXVzID0gY29uc3RhbnQoMCksXG4gICAgICBwYWRSYWRpdXMgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGFyY1N0YXJ0QW5nbGUsXG4gICAgICBlbmRBbmdsZSA9IGFyY0VuZEFuZ2xlLFxuICAgICAgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGFyYygpIHtcbiAgICB2YXIgYnVmZmVyLFxuICAgICAgICByLFxuICAgICAgICByMCA9ICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICByMSA9ICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBkYSA9IGFicyhhMSAtIGEwKSxcbiAgICAgICAgY3cgPSBhMSA+IGEwO1xuXG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXG4gICAgaWYgKHIxIDwgcjApIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluKGFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogc2luKGFwKSk7XG4gICAgICAgIGlmICgoZGEwIC09IHAwICogMikgPiBlcHNpbG9uKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgZWxzZSBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbikgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbihhMTEpLFxuICAgICAgICAgICAgeDAwID0gcjAgKiBjb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogc2luKGEwMCksXG4gICAgICAgICAgICBvYztcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkgJiYgKG9jID0gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSkpIHtcbiAgICAgICAgICB2YXIgYXggPSB4MDEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYnkgPSB5MTEgLSBvY1sxXSxcbiAgICAgICAgICAgICAga2MgPSAxIC8gc2luKGFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChzcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBzcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBtaW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIG91dGVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XG5cbiAgICAgIC8vIElzIHRoZXJlIG5vIGlubmVyIHJpbmcsIGFuZCBpdOKAmXMgYSBjaXJjdWxhciBzZWN0b3I/XG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICBpZiAoIShyMCA+IGVwc2lsb24pIHx8ICEoZGEwID4gZXBzaWxvbikpIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBpbm5lciByaW5nIChvciBwb2ludCkgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDEwLCB5MTAsIHgxMSwgeTExLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMwIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCBjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzAsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBpbm5lciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcbiAgICAgICAgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIHBpIC8gMjtcbiAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuXG5mdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjdXJ2ZUxpbmVhcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cblxuZnVuY3Rpb24gbGluZSgpIHtcbiAgdmFyIHgkMSA9IHgsXG4gICAgICB5JDEgPSB5LFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBsaW5lKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG5cbiAgICBpZiAoY29udGV4dCA9PSBudWxsKSBvdXRwdXQgPSBjdXJ2ZShidWZmZXIgPSBkM1BhdGgucGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICBlbHNlIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIG91dHB1dC5wb2ludCgreCQxKGQsIGksIGRhdGEpLCAreSQxKGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHgkMTtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeSQxO1xuICB9O1xuXG4gIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBsaW5lKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICB9O1xuXG4gIGxpbmUuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgbGluZSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBhcmVhKCkge1xuICB2YXIgeDAgPSB4LFxuICAgICAgeDEgPSBudWxsLFxuICAgICAgeTAgPSBjb25zdGFudCgwKSxcbiAgICAgIHkxID0geSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpIC0gMTsgayA+PSBqOyAtLWspIHtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7XG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xuICAgICAgICBvdXRwdXQucG9pbnQoeDEgPyAreDEoZCwgaSwgZGF0YSkgOiB4MHpbaV0sIHkxID8gK3kxKGQsIGksIGRhdGEpIDogeTB6W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlYWxpbmUoKSB7XG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHgxID0gbnVsbCwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgfTtcblxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeTEgPSBudWxsLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICB9O1xuXG4gIGFyZWEubGluZVgwID1cbiAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICB9O1xuXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGFyZWEpIDogZGVmaW5lZDtcbiAgfTtcblxuICBhcmVhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gIH07XG5cbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyZWE7XG59XG5cbmZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KGQpIHtcbiAgcmV0dXJuIGQ7XG59XG5cbmZ1bmN0aW9uIHBpZSgpIHtcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHksXG4gICAgICBzb3J0VmFsdWVzID0gZGVzY2VuZGluZyxcbiAgICAgIHNvcnQgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGNvbnN0YW50KDApLFxuICAgICAgZW5kQW5nbGUgPSBjb25zdGFudCh0YXUpLFxuICAgICAgcGFkQW5nbGUgPSBjb25zdGFudCgwKTtcblxuICBmdW5jdGlvbiBwaWUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIGluZGV4ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBhcmNzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBhMCA9ICtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGRhID0gTWF0aC5taW4odGF1LCBNYXRoLm1heCgtdGF1LCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSxcbiAgICAgICAgYTEsXG4gICAgICAgIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksXG4gICAgICAgIHY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHYgPSBhcmNzW2luZGV4W2ldID0gaV0gPSArdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSkpID4gMCkge1xuICAgICAgICBzdW0gKz0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cbiAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnRWYWx1ZXMoYXJjc1tpXSwgYXJjc1tqXSk7IH0pO1xuICAgIGVsc2UgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pOyB9KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGFyY3MhIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSdzIG9yZGVyLlxuICAgIGZvciAoaSA9IDAsIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMDsgaSA8IG47ICsraSwgYTAgPSBhMSkge1xuICAgICAgaiA9IGluZGV4W2ldLCB2ID0gYXJjc1tqXSwgYTEgPSBhMCArICh2ID4gMCA/IHYgKiBrIDogMCkgKyBwYSwgYXJjc1tqXSA9IHtcbiAgICAgICAgZGF0YTogZGF0YVtqXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiB2LFxuICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICBwYWRBbmdsZTogcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJjcztcbiAgfVxuXG4gIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogdmFsdWU7XG4gIH07XG5cbiAgcGllLnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFZhbHVlcyA9IF8sIHNvcnQgPSBudWxsLCBwaWUpIDogc29ydFZhbHVlcztcbiAgfTtcblxuICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0ID0gXywgc29ydFZhbHVlcyA9IG51bGwsIHBpZSkgOiBzb3J0O1xuICB9O1xuXG4gIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIHJldHVybiBwaWU7XG59XG5cbnZhciBjdXJ2ZVJhZGlhbExpbmVhciA9IGN1cnZlUmFkaWFsKGN1cnZlTGluZWFyKTtcblxuZnVuY3Rpb24gUmFkaWFsKGN1cnZlKSB7XG4gIHRoaXMuX2N1cnZlID0gY3VydmU7XG59XG5cblJhZGlhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUuYXJlYVN0YXJ0KCk7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFFbmQoKTtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZUVuZCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oYSwgcikge1xuICAgIHRoaXMuX2N1cnZlLnBvaW50KHIgKiBNYXRoLnNpbihhKSwgciAqIC1NYXRoLmNvcyhhKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGN1cnZlUmFkaWFsKGN1cnZlKSB7XG5cbiAgZnVuY3Rpb24gcmFkaWFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFJhZGlhbChjdXJ2ZShjb250ZXh0KSk7XG4gIH1cblxuICByYWRpYWwuX2N1cnZlID0gY3VydmU7XG5cbiAgcmV0dXJuIHJhZGlhbDtcbn1cblxuZnVuY3Rpb24gbGluZVJhZGlhbChsKSB7XG4gIHZhciBjID0gbC5jdXJ2ZTtcblxuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xuICBsLnJhZGl1cyA9IGwueSwgZGVsZXRlIGwueTtcblxuICBsLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gYyhjdXJ2ZVJhZGlhbChfKSkgOiBjKCkuX2N1cnZlO1xuICB9O1xuXG4gIHJldHVybiBsO1xufVxuXG5mdW5jdGlvbiBsaW5lUmFkaWFsJDEoKSB7XG4gIHJldHVybiBsaW5lUmFkaWFsKGxpbmUoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhcikpO1xufVxuXG5mdW5jdGlvbiBhcmVhUmFkaWFsKCkge1xuICB2YXIgYSA9IGFyZWEoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhciksXG4gICAgICBjID0gYS5jdXJ2ZSxcbiAgICAgIHgwID0gYS5saW5lWDAsXG4gICAgICB4MSA9IGEubGluZVgxLFxuICAgICAgeTAgPSBhLmxpbmVZMCxcbiAgICAgIHkxID0gYS5saW5lWTE7XG5cbiAgYS5hbmdsZSA9IGEueCwgZGVsZXRlIGEueDtcbiAgYS5zdGFydEFuZ2xlID0gYS54MCwgZGVsZXRlIGEueDA7XG4gIGEuZW5kQW5nbGUgPSBhLngxLCBkZWxldGUgYS54MTtcbiAgYS5yYWRpdXMgPSBhLnksIGRlbGV0ZSBhLnk7XG4gIGEuaW5uZXJSYWRpdXMgPSBhLnkwLCBkZWxldGUgYS55MDtcbiAgYS5vdXRlclJhZGl1cyA9IGEueTEsIGRlbGV0ZSBhLnkxO1xuICBhLmxpbmVTdGFydEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lUmFkaWFsKHgwKCkpOyB9LCBkZWxldGUgYS5saW5lWDA7XG4gIGEubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lUmFkaWFsKHgxKCkpOyB9LCBkZWxldGUgYS5saW5lWDE7XG4gIGEubGluZUlubmVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lUmFkaWFsKHkwKCkpOyB9LCBkZWxldGUgYS5saW5lWTA7XG4gIGEubGluZU91dGVyUmFkaXVzID0gZnVuY3Rpb24oKSB7IHJldHVybiBsaW5lUmFkaWFsKHkxKCkpOyB9LCBkZWxldGUgYS5saW5lWTE7XG5cbiAgYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gcG9pbnRSYWRpYWwoeCwgeSkge1xuICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XG59XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gbGlua1NvdXJjZShkKSB7XG4gIHJldHVybiBkLnNvdXJjZTtcbn1cblxuZnVuY3Rpb24gbGlua1RhcmdldChkKSB7XG4gIHJldHVybiBkLnRhcmdldDtcbn1cblxuZnVuY3Rpb24gbGluayhjdXJ2ZSkge1xuICB2YXIgc291cmNlID0gbGlua1NvdXJjZSxcbiAgICAgIHRhcmdldCA9IGxpbmtUYXJnZXQsXG4gICAgICB4JDEgPSB4LFxuICAgICAgeSQxID0geSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgdmFyIGJ1ZmZlciwgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSwgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuICAgIGN1cnZlKGNvbnRleHQsICt4JDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSBzLCBhcmd2KSksICt5JDEuYXBwbHkodGhpcywgYXJndiksICt4JDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksICt5JDEuYXBwbHkodGhpcywgYXJndikpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluay5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc291cmNlID0gXywgbGluaykgOiBzb3VyY2U7XG4gIH07XG5cbiAgbGluay50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFyZ2V0ID0gXywgbGluaykgOiB0YXJnZXQ7XG4gIH07XG5cbiAgbGluay54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHgkMTtcbiAgfTtcblxuICBsaW5rLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeSQxO1xuICB9O1xuXG4gIGxpbmsuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgbGluaykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUhvcml6b250YWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwID0gKHgwICsgeDEpIC8gMiwgeTAsIHgwLCB5MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gY3VydmVWZXJ0aWNhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8oeDAsIHkwID0gKHkwICsgeTEpIC8gMiwgeDEsIHkwLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVJhZGlhbCQxKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBwMCA9IHBvaW50UmFkaWFsKHgwLCB5MCksXG4gICAgICBwMSA9IHBvaW50UmFkaWFsKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIpLFxuICAgICAgcDIgPSBwb2ludFJhZGlhbCh4MSwgeTApLFxuICAgICAgcDMgPSBwb2ludFJhZGlhbCh4MSwgeTEpO1xuICBjb250ZXh0Lm1vdmVUbyhwMFswXSwgcDBbMV0pO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8ocDFbMF0sIHAxWzFdLCBwMlswXSwgcDJbMV0sIHAzWzBdLCBwM1sxXSk7XG59XG5cbmZ1bmN0aW9uIGxpbmtIb3Jpem9udGFsKCkge1xuICByZXR1cm4gbGluayhjdXJ2ZUhvcml6b250YWwpO1xufVxuXG5mdW5jdGlvbiBsaW5rVmVydGljYWwoKSB7XG4gIHJldHVybiBsaW5rKGN1cnZlVmVydGljYWwpO1xufVxuXG5mdW5jdGlvbiBsaW5rUmFkaWFsKCkge1xuICB2YXIgbCA9IGxpbmsoY3VydmVSYWRpYWwkMSk7XG4gIGwuYW5nbGUgPSBsLngsIGRlbGV0ZSBsLng7XG4gIGwucmFkaXVzID0gbC55LCBkZWxldGUgbC55O1xuICByZXR1cm4gbDtcbn1cblxudmFyIGNpcmNsZSA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBwaSk7XG4gICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgdGF1KTtcbiAgfVxufTtcblxudmFyIGNyb3NzID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICBjb250ZXh0Lm1vdmVUbygtMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyksXG4gICAgdGFuMzBfMiA9IHRhbjMwICogMjtcblxudmFyIGRpYW1vbmQgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IE1hdGguc3FydChzaXplIC8gdGFuMzBfMiksXG4gICAgICAgIHggPSB5ICogdGFuMzA7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIHkpO1xuICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIga2EgPSAwLjg5MDgxMzA5MTUyOTI4NTIyODEwLFxuICAgIGtyID0gTWF0aC5zaW4ocGkgLyAxMCkgLyBNYXRoLnNpbig3ICogcGkgLyAxMCksXG4gICAga3ggPSBNYXRoLnNpbih0YXUgLyAxMCkgKiBrcixcbiAgICBreSA9IC1NYXRoLmNvcyh0YXUgLyAxMCkgKiBrcjtcblxudmFyIHN0YXIgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplICoga2EpLFxuICAgICAgICB4ID0ga3ggKiByLFxuICAgICAgICB5ID0ga3kgKiByO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDU7ICsraSkge1xuICAgICAgdmFyIGEgPSB0YXUgKiBpIC8gNSxcbiAgICAgICAgICBjID0gTWF0aC5jb3MoYSksXG4gICAgICAgICAgcyA9IE1hdGguc2luKGEpO1xuICAgICAgY29udGV4dC5saW5lVG8ocyAqIHIsIC1jICogcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIHNxdWFyZSA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICB4ID0gLXcgLyAyO1xuICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgfVxufTtcblxudmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpO1xuXG52YXIgdHJpYW5nbGUgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCB5ICogMik7XG4gICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgLXkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBjID0gLTAuNSxcbiAgICBzID0gTWF0aC5zcXJ0KDMpIC8gMixcbiAgICBrID0gMSAvIE1hdGguc3FydCgxMiksXG4gICAgYSA9IChrIC8gMiArIDEpICogMztcblxudmFyIHd5ZSA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBhKSxcbiAgICAgICAgeDAgPSByIC8gMixcbiAgICAgICAgeTAgPSByICogayxcbiAgICAgICAgeDEgPSB4MCxcbiAgICAgICAgeTEgPSByICogayArIHIsXG4gICAgICAgIHgyID0gLXgxLFxuICAgICAgICB5MiA9IHkxO1xuICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCAtIHMgKiB5MCwgcyAqIHgwICsgYyAqIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgLSBzICogeTEsIHMgKiB4MSArIGMgKiB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MCArIHMgKiB5MCwgYyAqIHkwIC0gcyAqIHgwKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDEgKyBzICogeTEsIGMgKiB5MSAtIHMgKiB4MSk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBzeW1ib2xzID0gW1xuICBjaXJjbGUsXG4gIGNyb3NzLFxuICBkaWFtb25kLFxuICBzcXVhcmUsXG4gIHN0YXIsXG4gIHRyaWFuZ2xlLFxuICB3eWVcbl07XG5cbmZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgdmFyIHR5cGUgPSBjb25zdGFudChjaXJjbGUpLFxuICAgICAgc2l6ZSA9IGNvbnN0YW50KDY0KSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmZ1bmN0aW9uIEJhc2lzKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyAvLyBwcm9jZWVkXG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fY29udGV4dC5saW5lVG8oKDUgKiB0aGlzLl94MCArIHRoaXMuX3gxKSAvIDYsICg1ICogdGhpcy5feTAgKyB0aGlzLl95MSkgLyA2KTsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNpcyhjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXMoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5OyB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5mdW5jdGlvbiBiYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIEJhc2lzT3Blbihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc09wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB2YXIgeDAgPSAodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsIHkwID0gKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2OyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeDAsIHkwKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgwLCB5MCk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmFzaXNPcGVuKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIEJ1bmRsZShjb250ZXh0LCBiZXRhKSB7XG4gIHRoaXMuX2Jhc2lzID0gbmV3IEJhc2lzKGNvbnRleHQpO1xuICB0aGlzLl9iZXRhID0gYmV0YTtcbn1cblxuQnVuZGxlLnByb3RvdHlwZSA9IHtcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICAgIHRoaXMuX2Jhc2lzLmxpbmVTdGFydCgpO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBqID0geC5sZW5ndGggLSAxO1xuXG4gICAgaWYgKGogPiAwKSB7XG4gICAgICB2YXIgeDAgPSB4WzBdLFxuICAgICAgICAgIHkwID0geVswXSxcbiAgICAgICAgICBkeCA9IHhbal0gLSB4MCxcbiAgICAgICAgICBkeSA9IHlbal0gLSB5MCxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgdDtcblxuICAgICAgd2hpbGUgKCsraSA8PSBqKSB7XG4gICAgICAgIHQgPSBpIC8gajtcbiAgICAgICAgdGhpcy5fYmFzaXMucG9pbnQoXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHhbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHgwICsgdCAqIGR4KSxcbiAgICAgICAgICB0aGlzLl9iZXRhICogeVtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeTAgKyB0ICogZHkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICAgIHRoaXMuX2Jhc2lzLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbnZhciBidW5kbGUgPSAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcblxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xuICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgfVxuXG4gIGJ1bmRsZS5iZXRhID0gZnVuY3Rpb24oYmV0YSkge1xuICAgIHJldHVybiBjdXN0b20oK2JldGEpO1xuICB9O1xuXG4gIHJldHVybiBidW5kbGU7XG59KSgwLjg1KTtcblxuZnVuY3Rpb24gcG9pbnQkMSh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQkMSh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQxKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuXG5mdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQkMSh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXJkaW5hbENsb3NlZCA9IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSgwKTtcblxuZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQkMSh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXJkaW5hbE9wZW4gPSAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuXG5mdW5jdGlvbiBwb2ludCQyKHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2F0bXVsbFJvbSA9IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWwoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCQyKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXRtdWxsUm9tQ2xvc2VkID0gKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2F0bXVsbFJvbU9wZW4gPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSgwLjUpO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZWxzZSB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4vLyBJbnRlcnBvbGF0aW9uIGluIE9uZSBEaW1lbnNpb24uIEFzdHJvbm9teSBhbmQgQXN0cm9waHlzaWNzLCBWb2wuIDIzOSwgTk8uXG4vLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsXG4gICAgICBoMSA9IHgyIC0gdGhhdC5feDEsXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxuICAgICAgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSxcbiAgICAgIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbn1cblxuLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXG4vLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG5mdW5jdGlvbiBwb2ludCQzKHRoYXQsIHQwLCB0MSkge1xuICB2YXIgeDAgPSB0aGF0Ll94MCxcbiAgICAgIHkwID0gdGhhdC5feTAsXG4gICAgICB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIGR4ID0gKHgxIC0geDApIC8gMztcbiAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwICsgZHgsIHkwICsgZHggKiB0MCwgeDEgLSBkeCwgeTEgLSBkeCAqIHQxLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBNb25vdG9uZVgoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTW9ub3RvbmVYLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID1cbiAgICB0aGlzLl90MCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50JDModGhpcywgdGhpcy5fdDAsIHNsb3BlMih0aGlzLCB0aGlzLl90MCkpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdDEgPSBOYU47XG5cbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAoeCA9PT0gdGhpcy5feDEgJiYgeSA9PT0gdGhpcy5feTEpIHJldHVybjsgLy8gSWdub3JlIGNvaW5jaWRlbnQgcG9pbnRzLlxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgcG9pbnQkMyh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQkMyh0aGlzLCB0aGlzLl90MCwgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICAgIHRoaXMuX3QwID0gdDE7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBuZXcgUmVmbGVjdENvbnRleHQoY29udGV4dCk7XG59XG5cbihNb25vdG9uZVkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb25vdG9uZVgucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbn07XG5cbmZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbn07XG5cbmZ1bmN0aW9uIG1vbm90b25lWChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVYKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtb25vdG9uZVkoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWShjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5OYXR1cmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBuID0geC5sZW5ndGg7XG5cbiAgICBpZiAobikge1xuICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzFdLCB5WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBweCA9IGNvbnRyb2xQb2ludHMoeCksXG4gICAgICAgICAgICBweSA9IGNvbnRyb2xQb2ludHMoeSk7XG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8ocHhbMF1baTBdLCBweVswXVtpMF0sIHB4WzFdW2kwXSwgcHlbMV1baTBdLCB4W2kxXSwgeVtpMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL3d3dy5wYXJ0aWNsZWluY2VsbC5jb20vMjAxMi9iZXppZXItc3BsaW5lcy8gZm9yIGRlcml2YXRpb24uXG5mdW5jdGlvbiBjb250cm9sUG9pbnRzKHgpIHtcbiAgdmFyIGksXG4gICAgICBuID0geC5sZW5ndGggLSAxLFxuICAgICAgbSxcbiAgICAgIGEgPSBuZXcgQXJyYXkobiksXG4gICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgciA9IG5ldyBBcnJheShuKTtcbiAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xuICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSkgYVtpXSA9IDEsIGJbaV0gPSA0LCByW2ldID0gNCAqIHhbaV0gKyAyICogeFtpICsgMV07XG4gIGFbbiAtIDFdID0gMiwgYltuIC0gMV0gPSA3LCByW24gLSAxXSA9IDggKiB4W24gLSAxXSArIHhbbl07XG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XG4gIGFbbiAtIDFdID0gcltuIC0gMV0gLyBiW24gLSAxXTtcbiAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSBhW2ldID0gKHJbaV0gLSBhW2kgKyAxXSkgLyBiW2ldO1xuICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcbiAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpIGJbaV0gPSAyICogeFtpICsgMV0gLSBhW2kgKyAxXTtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZnVuY3Rpb24gbmF0dXJhbChjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTmF0dXJhbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gU3RlcChjb250ZXh0LCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl90ID0gdDtcbn1cblxuU3RlcC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIpIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBpZiAodGhpcy5fbGluZSA+PSAwKSB0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4MSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgeCAqIHRoaXMuX3Q7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHRoaXMuX3kpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG59XG5cbmZ1bmN0aW9uIHN0ZXBCZWZvcmUoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMCk7XG59XG5cbmZ1bmN0aW9uIHN0ZXBBZnRlcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcbn1cblxuZnVuY3Rpb24gbm9uZShzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpID0gMSwgaiwgczAsIHMxID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMxLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHMwID0gczEsIHMxID0gc2VyaWVzW29yZGVyW2ldXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vbmUkMShzZXJpZXMpIHtcbiAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBvID0gbmV3IEFycmF5KG4pO1xuICB3aGlsZSAoLS1uID49IDApIG9bbl0gPSBuO1xuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gc3RhY2tWYWx1ZShkLCBrZXkpIHtcbiAgcmV0dXJuIGRba2V5XTtcbn1cblxuZnVuY3Rpb24gc3RhY2soKSB7XG4gIHZhciBrZXlzID0gY29uc3RhbnQoW10pLFxuICAgICAgb3JkZXIgPSBub25lJDEsXG4gICAgICBvZmZzZXQgPSBub25lLFxuICAgICAgdmFsdWUgPSBzdGFja1ZhbHVlO1xuXG4gIGZ1bmN0aW9uIHN0YWNrKGRhdGEpIHtcbiAgICB2YXIga3ogPSBrZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGksXG4gICAgICAgIG0gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgbiA9IGt6Lmxlbmd0aCxcbiAgICAgICAgc3ogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIG96O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZm9yICh2YXIga2kgPSBreltpXSwgc2kgPSBzeltpXSA9IG5ldyBBcnJheShtKSwgaiA9IDAsIHNpajsgaiA8IG07ICsraikge1xuICAgICAgICBzaVtqXSA9IHNpaiA9IFswLCArdmFsdWUoZGF0YVtqXSwga2ksIGosIGRhdGEpXTtcbiAgICAgICAgc2lqLmRhdGEgPSBkYXRhW2pdO1xuICAgICAgfVxuICAgICAgc2kua2V5ID0ga2k7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgb3ogPSBvcmRlcihzeik7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN6W296W2ldXS5pbmRleCA9IGk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KHN6LCBveik7XG4gICAgcmV0dXJuIHN6O1xuICB9XG5cbiAgc3RhY2sua2V5cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrZXlzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcbiAgfTtcblxuICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzdGFjaykgOiB2YWx1ZTtcbiAgfTtcblxuICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvcmRlciA9IF8gPT0gbnVsbCA/IG5vbmUkMSA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoc2xpY2UuY2FsbChfKSksIHN0YWNrKSA6IG9yZGVyO1xuICB9O1xuXG4gIHN0YWNrLm9mZnNldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvZmZzZXQgPSBfID09IG51bGwgPyBub25lIDogXywgc3RhY2spIDogb2Zmc2V0O1xuICB9O1xuXG4gIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIG4sIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aCwgeTsgaiA8IG07ICsraikge1xuICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufVxuXG5mdW5jdGlvbiBkaXZlcmdpbmcoc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaSwgaiA9IDAsIGQsIGR5LCB5cCwgeW4sIG4sIG0gPSBzZXJpZXNbb3JkZXJbMF1dLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAoeXAgPSB5biA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKGR5ID0gKGQgPSBzZXJpZXNbb3JkZXJbaV1dW2pdKVsxXSAtIGRbMF0pID4gMCkge1xuICAgICAgICBkWzBdID0geXAsIGRbMV0gPSB5cCArPSBkeTtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGRbMV0gPSB5biwgZFswXSA9IHluICs9IGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFswXSA9IDAsIGRbMV0gPSBkeTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lsaG91ZXR0ZShzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciBqID0gMCwgczAgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczAubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIHMwW2pdWzFdICs9IHMwW2pdWzBdID0gLXkgLyAyO1xuICB9XG4gIG5vbmUoc2VyaWVzLCBvcmRlcik7XG59XG5cbmZ1bmN0aW9uIHdpZ2dsZShzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXG4gICAgICAgICAgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLFxuICAgICAgICAgIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xuICAgICAgICB2YXIgc2sgPSBzZXJpZXNbb3JkZXJba11dLFxuICAgICAgICAgICAgc2tqMCA9IHNrW2pdWzFdIHx8IDAsXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgfVxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xuICAgIH1cbiAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcbiAgfVxuICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn1cblxuZnVuY3Rpb24gYXBwZWFyYW5jZShzZXJpZXMpIHtcbiAgdmFyIHBlYWtzID0gc2VyaWVzLm1hcChwZWFrKTtcbiAgcmV0dXJuIG5vbmUkMShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gcGVha3NbYV0gLSBwZWFrc1tiXTsgfSk7XG59XG5cbmZ1bmN0aW9uIHBlYWsoc2VyaWVzKSB7XG4gIHZhciBpID0gLTEsIGogPSAwLCBuID0gc2VyaWVzLmxlbmd0aCwgdmksIHZqID0gLUluZmluaXR5O1xuICB3aGlsZSAoKytpIDwgbikgaWYgKCh2aSA9ICtzZXJpZXNbaV1bMV0pID4gdmopIHZqID0gdmksIGogPSBpO1xuICByZXR1cm4gajtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKHNlcmllcykge1xuICB2YXIgc3VtcyA9IHNlcmllcy5tYXAoc3VtKTtcbiAgcmV0dXJuIG5vbmUkMShzZXJpZXMpLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc3Vtc1thXSAtIHN1bXNbYl07IH0pO1xufVxuXG5mdW5jdGlvbiBzdW0oc2VyaWVzKSB7XG4gIHZhciBzID0gMCwgaSA9IC0xLCBuID0gc2VyaWVzLmxlbmd0aCwgdjtcbiAgd2hpbGUgKCsraSA8IG4pIGlmICh2ID0gK3Nlcmllc1tpXVsxXSkgcyArPSB2O1xuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZyQxKHNlcmllcykge1xuICByZXR1cm4gYXNjZW5kaW5nKHNlcmllcykucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBpbnNpZGVPdXQoc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgc3VtcyA9IHNlcmllcy5tYXAoc3VtKSxcbiAgICAgIG9yZGVyID0gYXBwZWFyYW5jZShzZXJpZXMpLFxuICAgICAgdG9wID0gMCxcbiAgICAgIGJvdHRvbSA9IDAsXG4gICAgICB0b3BzID0gW10sXG4gICAgICBib3R0b21zID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGogPSBvcmRlcltpXTtcbiAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgIHRvcHMucHVzaChqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm90dG9tICs9IHN1bXNbal07XG4gICAgICBib3R0b21zLnB1c2goaik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZShzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUkMShzZXJpZXMpLnJldmVyc2UoKTtcbn1cblxuZXhwb3J0cy5hcmMgPSBhcmM7XG5leHBvcnRzLmFyZWEgPSBhcmVhO1xuZXhwb3J0cy5hcmVhUmFkaWFsID0gYXJlYVJhZGlhbDtcbmV4cG9ydHMuY3VydmVCYXNpcyA9IGJhc2lzO1xuZXhwb3J0cy5jdXJ2ZUJhc2lzQ2xvc2VkID0gYmFzaXNDbG9zZWQ7XG5leHBvcnRzLmN1cnZlQmFzaXNPcGVuID0gYmFzaXNPcGVuO1xuZXhwb3J0cy5jdXJ2ZUJ1bmRsZSA9IGJ1bmRsZTtcbmV4cG9ydHMuY3VydmVDYXJkaW5hbCA9IGNhcmRpbmFsO1xuZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsQ2xvc2VkID0gY2FyZGluYWxDbG9zZWQ7XG5leHBvcnRzLmN1cnZlQ2FyZGluYWxPcGVuID0gY2FyZGluYWxPcGVuO1xuZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb20gPSBjYXRtdWxsUm9tO1xuZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb21DbG9zZWQgPSBjYXRtdWxsUm9tQ2xvc2VkO1xuZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb21PcGVuID0gY2F0bXVsbFJvbU9wZW47XG5leHBvcnRzLmN1cnZlTGluZWFyID0gY3VydmVMaW5lYXI7XG5leHBvcnRzLmN1cnZlTGluZWFyQ2xvc2VkID0gbGluZWFyQ2xvc2VkO1xuZXhwb3J0cy5jdXJ2ZU1vbm90b25lWCA9IG1vbm90b25lWDtcbmV4cG9ydHMuY3VydmVNb25vdG9uZVkgPSBtb25vdG9uZVk7XG5leHBvcnRzLmN1cnZlTmF0dXJhbCA9IG5hdHVyYWw7XG5leHBvcnRzLmN1cnZlU3RlcCA9IHN0ZXA7XG5leHBvcnRzLmN1cnZlU3RlcEFmdGVyID0gc3RlcEFmdGVyO1xuZXhwb3J0cy5jdXJ2ZVN0ZXBCZWZvcmUgPSBzdGVwQmVmb3JlO1xuZXhwb3J0cy5saW5lID0gbGluZTtcbmV4cG9ydHMubGluZVJhZGlhbCA9IGxpbmVSYWRpYWwkMTtcbmV4cG9ydHMubGlua0hvcml6b250YWwgPSBsaW5rSG9yaXpvbnRhbDtcbmV4cG9ydHMubGlua1JhZGlhbCA9IGxpbmtSYWRpYWw7XG5leHBvcnRzLmxpbmtWZXJ0aWNhbCA9IGxpbmtWZXJ0aWNhbDtcbmV4cG9ydHMucGllID0gcGllO1xuZXhwb3J0cy5wb2ludFJhZGlhbCA9IHBvaW50UmFkaWFsO1xuZXhwb3J0cy5yYWRpYWxBcmVhID0gYXJlYVJhZGlhbDtcbmV4cG9ydHMucmFkaWFsTGluZSA9IGxpbmVSYWRpYWwkMTtcbmV4cG9ydHMuc3RhY2sgPSBzdGFjaztcbmV4cG9ydHMuc3RhY2tPZmZzZXREaXZlcmdpbmcgPSBkaXZlcmdpbmc7XG5leHBvcnRzLnN0YWNrT2Zmc2V0RXhwYW5kID0gZXhwYW5kO1xuZXhwb3J0cy5zdGFja09mZnNldE5vbmUgPSBub25lO1xuZXhwb3J0cy5zdGFja09mZnNldFNpbGhvdWV0dGUgPSBzaWxob3VldHRlO1xuZXhwb3J0cy5zdGFja09mZnNldFdpZ2dsZSA9IHdpZ2dsZTtcbmV4cG9ydHMuc3RhY2tPcmRlckFwcGVhcmFuY2UgPSBhcHBlYXJhbmNlO1xuZXhwb3J0cy5zdGFja09yZGVyQXNjZW5kaW5nID0gYXNjZW5kaW5nO1xuZXhwb3J0cy5zdGFja09yZGVyRGVzY2VuZGluZyA9IGRlc2NlbmRpbmckMTtcbmV4cG9ydHMuc3RhY2tPcmRlckluc2lkZU91dCA9IGluc2lkZU91dDtcbmV4cG9ydHMuc3RhY2tPcmRlck5vbmUgPSBub25lJDE7XG5leHBvcnRzLnN0YWNrT3JkZXJSZXZlcnNlID0gcmV2ZXJzZTtcbmV4cG9ydHMuc3ltYm9sID0gc3ltYm9sO1xuZXhwb3J0cy5zeW1ib2xDaXJjbGUgPSBjaXJjbGU7XG5leHBvcnRzLnN5bWJvbENyb3NzID0gY3Jvc3M7XG5leHBvcnRzLnN5bWJvbERpYW1vbmQgPSBkaWFtb25kO1xuZXhwb3J0cy5zeW1ib2xTcXVhcmUgPSBzcXVhcmU7XG5leHBvcnRzLnN5bWJvbFN0YXIgPSBzdGFyO1xuZXhwb3J0cy5zeW1ib2xUcmlhbmdsZSA9IHRyaWFuZ2xlO1xuZXhwb3J0cy5zeW1ib2xXeWUgPSB3eWU7XG5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUtZm9ybWF0LyB2Mi4yLjMgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy10aW1lJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtdGltZSddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld0RhdGUoeSwgbSwgZCkge1xuICByZXR1cm4ge3k6IHksIG06IG0sIGQ6IGQsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcbiAgICBcInFcIjogZm9ybWF0UXVhcnRlcixcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciB1dGNGb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRVVENNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICBcInFcIjogZm9ybWF0VVRDUXVhcnRlcixcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICBcInFcIjogcGFyc2VRdWFydGVyLFxuICAgIFwiUVwiOiBwYXJzZVVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IHBhcnNlVW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IHBhcnNlU2Vjb25kcyxcbiAgICBcInVcIjogcGFyc2VXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IHBhcnNlV2Vla051bWJlcklTTyxcbiAgICBcIndcIjogcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBwYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IHBhcnNlTG9jYWxlRGF0ZSxcbiAgICBcIlhcIjogcGFyc2VMb2NhbGVUaW1lLFxuICAgIFwieVwiOiBwYXJzZVllYXIsXG4gICAgXCJZXCI6IHBhcnNlRnVsbFllYXIsXG4gICAgXCJaXCI6IHBhcnNlWm9uZSxcbiAgICBcIiVcIjogcGFyc2VMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIC8vIFRoZXNlIHJlY3Vyc2l2ZSBkaXJlY3RpdmUgZGVmaW5pdGlvbnMgbXVzdCBiZSBkZWZlcnJlZC5cbiAgZm9ybWF0cy54ID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5YID0gbmV3Rm9ybWF0KGxvY2FsZV90aW1lLCBmb3JtYXRzKTtcbiAgZm9ybWF0cy5jID0gbmV3Rm9ybWF0KGxvY2FsZV9kYXRlVGltZSwgZm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgdXRjRm9ybWF0cyk7XG4gIHV0Y0Zvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIHV0Y0Zvcm1hdHMpO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIsIGZvcm1hdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgdmFyIHN0cmluZyA9IFtdLFxuICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICBqID0gMCxcbiAgICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIHBhZCxcbiAgICAgICAgICBmb3JtYXQ7XG5cbiAgICAgIGlmICghKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkgZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKTtcblxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICAgICAgaWYgKChwYWQgPSBwYWRzW2MgPSBzcGVjaWZpZXIuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpO1xuICAgICAgICAgIGVsc2UgcGFkID0gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiO1xuICAgICAgICAgIGlmIChmb3JtYXQgPSBmb3JtYXRzW2NdKSBjID0gZm9ybWF0KGRhdGUsIHBhZCk7XG4gICAgICAgICAgc3RyaW5nLnB1c2goYyk7XG4gICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0cmluZy5wdXNoKHNwZWNpZmllci5zbGljZShqLCBpKSk7XG4gICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld1BhcnNlKHNwZWNpZmllciwgWikge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciBkID0gbmV3RGF0ZSgxOTAwLCB1bmRlZmluZWQsIDEpLFxuICAgICAgICAgIGkgPSBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZyArPSBcIlwiLCAwKSxcbiAgICAgICAgICB3ZWVrLCBkYXk7XG4gICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcblxuICAgICAgLy8gSWYgYSBVTklYIHRpbWVzdGFtcCBpcyBzcGVjaWZpZWQsIHJldHVybiBpdC5cbiAgICAgIGlmIChcIlFcIiBpbiBkKSByZXR1cm4gbmV3IERhdGUoZC5RKTtcbiAgICAgIGlmIChcInNcIiBpbiBkKSByZXR1cm4gbmV3IERhdGUoZC5zICogMTAwMCArIChcIkxcIiBpbiBkID8gZC5MIDogMCkpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIHV0Y1BhcnNlLCBuZXZlciB1c2UgdGhlIGxvY2FsIHRpbWV6b25lLlxuICAgICAgaWYgKFogJiYgIShcIlpcIiBpbiBkKSkgZC5aID0gMDtcblxuICAgICAgLy8gVGhlIGFtLXBtIGZsYWcgaXMgMCBmb3IgQU0sIGFuZCAxIGZvciBQTS5cbiAgICAgIGlmIChcInBcIiBpbiBkKSBkLkggPSBkLkggJSAxMiArIGQucCAqIDEyO1xuXG4gICAgICAvLyBJZiB0aGUgbW9udGggd2FzIG5vdCBzcGVjaWZpZWQsIGluaGVyaXQgZnJvbSB0aGUgcXVhcnRlci5cbiAgICAgIGlmIChkLm0gPT09IHVuZGVmaW5lZCkgZC5tID0gXCJxXCIgaW4gZCA/IGQucSA6IDA7XG5cbiAgICAgIC8vIENvbnZlcnQgZGF5LW9mLXdlZWsgYW5kIHdlZWstb2YteWVhciB0byBkYXktb2YteWVhci5cbiAgICAgIGlmIChcIlZcIiBpbiBkKSB7XG4gICAgICAgIGlmIChkLlYgPCAxIHx8IGQuViA+IDUzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IDE7XG4gICAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgICAgd2VlayA9IHV0Y0RhdGUobmV3RGF0ZShkLnksIDAsIDEpKSwgZGF5ID0gd2Vlay5nZXRVVENEYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyBkM1RpbWUudXRjTW9uZGF5LmNlaWwod2VlaykgOiBkM1RpbWUudXRjTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSBkM1RpbWUudXRjRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRVVENNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0VVRDRGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWVrID0gbG9jYWxEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSksIGRheSA9IHdlZWsuZ2V0RGF5KCk7XG4gICAgICAgICAgd2VlayA9IGRheSA+IDQgfHwgZGF5ID09PSAwID8gZDNUaW1lLnRpbWVNb25kYXkuY2VpbCh3ZWVrKSA6IGQzVGltZS50aW1lTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSBkM1RpbWUudGltZURheS5vZmZzZXQod2VlaywgKGQuViAtIDEpICogNyk7XG4gICAgICAgICAgZC55ID0gd2Vlay5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgIGQubSA9IHdlZWsuZ2V0TW9udGgoKTtcbiAgICAgICAgICBkLmQgPSB3ZWVrLmdldERhdGUoKSArIChkLncgKyA2KSAlIDc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXCJXXCIgaW4gZCB8fCBcIlVcIiBpbiBkKSB7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcInVcIiBpbiBkID8gZC51ICUgNyA6IFwiV1wiIGluIGQgPyAxIDogMDtcbiAgICAgICAgZGF5ID0gXCJaXCIgaW4gZCA/IHV0Y0RhdGUobmV3RGF0ZShkLnksIDAsIDEpKS5nZXRVVENEYXkoKSA6IGxvY2FsRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLmdldERheSgpO1xuICAgICAgICBkLm0gPSAwO1xuICAgICAgICBkLmQgPSBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF5ICsgNSkgJSA3IDogZC53ICsgZC5VICogNyAtIChkYXkgKyA2KSAlIDc7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgdGltZSB6b25lIGlzIHNwZWNpZmllZCwgYWxsIGZpZWxkcyBhcmUgaW50ZXJwcmV0ZWQgYXMgVVRDIGFuZCB0aGVuXG4gICAgICAvLyBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGltZSB6b25lLlxuICAgICAgaWYgKFwiWlwiIGluIGQpIHtcbiAgICAgICAgZC5IICs9IGQuWiAvIDEwMCB8IDA7XG4gICAgICAgIGQuTSArPSBkLlogJSAxMDA7XG4gICAgICAgIHJldHVybiB1dGNEYXRlKGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBmaWVsZHMgYXJlIGluIGxvY2FsIHRpbWUuXG4gICAgICByZXR1cm4gbG9jYWxEYXRlKGQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICBjLFxuICAgICAgICBwYXJzZTtcblxuICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgYyA9IHNwZWNpZmllci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgcGFyc2UgPSBwYXJzZXNbYyBpbiBwYWRzID8gc3BlY2lmaWVyLmNoYXJBdChpKyspIDogY107XG4gICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQZXJpb2QoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJpb2RSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5wID0gcGVyaW9kTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBzaG9ydE1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFF1YXJ0ZXIoZCkge1xuICAgIHJldHVybiAxICsgfn4oZC5nZXRNb250aCgpIC8gMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENRdWFydGVyKGQpIHtcbiAgICByZXR1cm4gMSArIH5+KGQuZ2V0VVRDTW9udGgoKSAvIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCBmYWxzZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIHRydWUpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9LFxuICAgIG51bWJlclJlID0gL15cXHMqXFxkKy8sIC8vIG5vdGU6IGlnbm9yZXMgbmV4dCBkaXJlY3RpdmVcbiAgICBwZXJjZW50UmUgPSAvXiUvLFxuICAgIHJlcXVvdGVSZSA9IC9bXFxcXF4kKis/fFtcXF0oKS57fV0vZztcblxuZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlcXVvdGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJlKG5hbWVzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gIHZhciBtYXAgPSB7fSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbWFwW25hbWVzW2ldLnRvTG93ZXJDYXNlKCldID0gaTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVySVNPKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuViA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWm9uZShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSAvXihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuWiA9IG5bMV0gPyAwIDogLShuWzJdICsgKG5bM10gfHwgXCIwMFwiKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWFydGVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQucSA9IG5bMF0gKiAzIC0gMywgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoTnVtYmVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvdXIyNChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWlsbGlzZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWljcm9zZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuTCA9IE1hdGguZmxvb3IoblswXSAvIDEwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuUSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcFNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLnMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIGQzVGltZS50aW1lRGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSwgZCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaWNyb3NlY29uZHMoZCwgcCkge1xuICByZXR1cm4gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApICsgXCIwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TW9udGhOdW1iZXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TW9udGgoKSArIDEsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaW51dGVzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0U2Vjb25kcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlck1vbmRheShkKSB7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICByZXR1cm4gZGF5ID09PSAwID8gNyA6IGRheTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQoZDNUaW1lLnRpbWVTdW5kYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IGQzVGltZS50aW1lVGh1cnNkYXkoZCkgOiBkM1RpbWUudGltZVRodXJzZGF5LmNlaWwoZCk7XG4gIHJldHVybiBwYWQoZDNUaW1lLnRpbWVUaHVyc2RheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpICsgKGQzVGltZS50aW1lWWVhcihkKS5nZXREYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lTW9uZGF5LmNvdW50KGQzVGltZS50aW1lWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudXRjRGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDU2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRvdyA9IGQuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiBkb3cgPT09IDAgPyA3IDogZG93O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjU3VuZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0VVRDRGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IGQzVGltZS51dGNUaHVyc2RheShkKSA6IGQzVGltZS51dGNUaHVyc2RheS5jZWlsKGQpO1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNUaHVyc2RheS5jb3VudChkM1RpbWUudXRjWWVhcihkKSwgZCkgKyAoZDNUaW1lLnV0Y1llYXIoZCkuZ2V0VVRDRGF5KCkgPT09IDQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlclN1bmRheShkKSB7XG4gIHJldHVybiBkLmdldFVUQ0RheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjTW9uZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICByZXR1cm4gXCIrMDAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgcmV0dXJuIFwiJVwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVbml4VGltZXN0YW1wKGQpIHtcbiAgcmV0dXJuICtkO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyhkKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKCtkIC8gMTAwMCk7XG59XG5cbnZhciBsb2NhbGU7XG5cbmRlZmF1bHRMb2NhbGUoe1xuICBkYXRlVGltZTogXCIleCwgJVhcIixcbiAgZGF0ZTogXCIlLW0vJS1kLyVZXCIsXG4gIHRpbWU6IFwiJS1JOiVNOiVTICVwXCIsXG4gIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMudGltZUZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMudGltZVBhcnNlID0gbG9jYWxlLnBhcnNlO1xuICBleHBvcnRzLnV0Y0Zvcm1hdCA9IGxvY2FsZS51dGNGb3JtYXQ7XG4gIGV4cG9ydHMudXRjUGFyc2UgPSBsb2NhbGUudXRjUGFyc2U7XG4gIHJldHVybiBsb2NhbGU7XG59XG5cbnZhciBpc29TcGVjaWZpZXIgPSBcIiVZLSVtLSVkVCVIOiVNOiVTLiVMWlwiO1xuXG5mdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufVxuXG52YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmdcbiAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgIDogZXhwb3J0cy51dGNGb3JtYXQoaXNvU3BlY2lmaWVyKTtcblxuZnVuY3Rpb24gcGFyc2VJc29OYXRpdmUoc3RyaW5nKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG59XG5cbnZhciBwYXJzZUlzbyA9ICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxuICAgID8gcGFyc2VJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjUGFyc2UoaXNvU3BlY2lmaWVyKTtcblxuZXhwb3J0cy5pc29Gb3JtYXQgPSBmb3JtYXRJc287XG5leHBvcnRzLmlzb1BhcnNlID0gcGFyc2VJc287XG5leHBvcnRzLnRpbWVGb3JtYXREZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbmV4cG9ydHMudGltZUZvcm1hdExvY2FsZSA9IGZvcm1hdExvY2FsZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10aW1lLyB2MS4xLjAgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgdDAgPSBuZXcgRGF0ZSxcbiAgICB0MSA9IG5ldyBEYXRlO1xuXG5mdW5jdGlvbiBuZXdJbnRlcnZhbChmbG9vcmksIG9mZnNldGksIGNvdW50LCBmaWVsZCkge1xuXG4gIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAwID8gbmV3IERhdGUgOiBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9XG5cbiAgaW50ZXJ2YWwuZmxvb3IgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGZsb29yaShkYXRlKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZDAgPSBpbnRlcnZhbChkYXRlKSxcbiAgICAgICAgZDEgPSBpbnRlcnZhbC5jZWlsKGRhdGUpO1xuICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICB9O1xuXG4gIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIHZhciByYW5nZSA9IFtdLCBwcmV2aW91cztcbiAgICBzdGFydCA9IGludGVydmFsLmNlaWwoc3RhcnQpO1xuICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICBkbyByYW5nZS5wdXNoKHByZXZpb3VzID0gbmV3IERhdGUoK3N0YXJ0KSksIG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpO1xuICAgIHdoaWxlIChwcmV2aW91cyA8IHN0YXJ0ICYmIHN0YXJ0IDwgc3RvcCk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkge1xuICAgICAgICBpZiAoc3RlcCA8IDApIHdoaWxlICgrK3N0ZXAgPD0gMCkge1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsIC0xKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBlbHNlIHdoaWxlICgtLXN0ZXAgPj0gMCkge1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsICsxKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGlmIChjb3VudCkge1xuICAgIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5ldmVyeSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShzdGVwKSB8fCAhKHN0ZXAgPiAwKSA/IG51bGxcbiAgICAgICAgICA6ICEoc3RlcCA+IDEpID8gaW50ZXJ2YWxcbiAgICAgICAgICA6IGludGVydmFsLmZpbHRlcihmaWVsZFxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZpZWxkKGQpICUgc3RlcCA9PT0gMDsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGludGVydmFsLmNvdW50KDAsIGQpICUgc3RlcCA9PT0gMDsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnZhbDtcbn1cblxudmFyIG1pbGxpc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gIC8vIG5vb3Bcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG5taWxsaXNlY29uZC5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xuICBpZiAoIShrID4gMSkpIHJldHVybiBtaWxsaXNlY29uZDtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBrKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gaztcbiAgfSk7XG59O1xudmFyIG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kLnJhbmdlO1xuXG52YXIgZHVyYXRpb25TZWNvbmQgPSAxZTM7XG52YXIgZHVyYXRpb25NaW51dGUgPSA2ZTQ7XG52YXIgZHVyYXRpb25Ib3VyID0gMzZlNTtcbnZhciBkdXJhdGlvbkRheSA9IDg2NGU1O1xudmFyIGR1cmF0aW9uV2VlayA9IDYwNDhlNTtcblxudmFyIHNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uU2Vjb25kKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvblNlY29uZDtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xufSk7XG52YXIgc2Vjb25kcyA9IHNlY29uZC5yYW5nZTtcblxudmFyIG1pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gZGF0ZS5nZXRTZWNvbmRzKCkgKiBkdXJhdGlvblNlY29uZCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xudmFyIG1pbnV0ZXMgPSBtaW51dGUucmFuZ2U7XG5cbnZhciBob3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoZGF0ZSAtIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBkYXRlLmdldFNlY29uZHMoKSAqIGR1cmF0aW9uU2Vjb25kIC0gZGF0ZS5nZXRNaW51dGVzKCkgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKTtcbn0pO1xudmFyIGhvdXJzID0gaG91ci5yYW5nZTtcblxudmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlKSAvIGR1cmF0aW9uRGF5O1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXREYXRlKCkgLSAxO1xufSk7XG52YXIgZGF5cyA9IGRheS5yYW5nZTtcblxuZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25XZWVrO1xuICB9KTtcbn1cblxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxudmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG52YXIgbW9uZGF5cyA9IG1vbmRheS5yYW5nZTtcbnZhciB0dWVzZGF5cyA9IHR1ZXNkYXkucmFuZ2U7XG52YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbnZhciB0aHVyc2RheXMgPSB0aHVyc2RheS5yYW5nZTtcbnZhciBmcmlkYXlzID0gZnJpZGF5LnJhbmdlO1xudmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuXG52YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0RGF0ZSgxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG59KTtcbnZhciBtb250aHMgPSBtb250aC5yYW5nZTtcblxudmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxueWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG52YXIgeWVhcnMgPSB5ZWFyLnJhbmdlO1xuXG52YXIgdXRjTWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ1NlY29uZHMoMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbn0pO1xudmFyIHV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbnZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xudmFyIHV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcblxudmFyIHV0Y0RheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25EYXk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKSAtIDE7XG59KTtcbnZhciB1dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG5mdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbnZhciB1dGNTdW5kYXkgPSB1dGNXZWVrZGF5KDApO1xudmFyIHV0Y01vbmRheSA9IHV0Y1dlZWtkYXkoMSk7XG52YXIgdXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG52YXIgdXRjV2VkbmVzZGF5ID0gdXRjV2Vla2RheSgzKTtcbnZhciB1dGNUaHVyc2RheSA9IHV0Y1dlZWtkYXkoNCk7XG52YXIgdXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcbnZhciB1dGNTYXR1cmRheSA9IHV0Y1dlZWtkYXkoNik7XG5cbnZhciB1dGNTdW5kYXlzID0gdXRjU3VuZGF5LnJhbmdlO1xudmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XG52YXIgdXRjVHVlc2RheXMgPSB1dGNUdWVzZGF5LnJhbmdlO1xudmFyIHV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXkucmFuZ2U7XG52YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XG52YXIgdXRjRnJpZGF5cyA9IHV0Y0ZyaWRheS5yYW5nZTtcbnZhciB1dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheS5yYW5nZTtcblxudmFyIHV0Y01vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0RhdGUoMSk7XG4gIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VVRDTW9udGgoZGF0ZS5nZXRVVENNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0VVRDTW9udGgoKSAtIHN0YXJ0LmdldFVUQ01vbnRoKCkgKyAoZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNb250aCgpO1xufSk7XG52YXIgdXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbnZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnV0Y1llYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xudmFyIHV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuZXhwb3J0cy50aW1lRGF5ID0gZGF5O1xuZXhwb3J0cy50aW1lRGF5cyA9IGRheXM7XG5leHBvcnRzLnRpbWVGcmlkYXkgPSBmcmlkYXk7XG5leHBvcnRzLnRpbWVGcmlkYXlzID0gZnJpZGF5cztcbmV4cG9ydHMudGltZUhvdXIgPSBob3VyO1xuZXhwb3J0cy50aW1lSG91cnMgPSBob3VycztcbmV4cG9ydHMudGltZUludGVydmFsID0gbmV3SW50ZXJ2YWw7XG5leHBvcnRzLnRpbWVNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy50aW1lTWludXRlID0gbWludXRlO1xuZXhwb3J0cy50aW1lTWludXRlcyA9IG1pbnV0ZXM7XG5leHBvcnRzLnRpbWVNb25kYXkgPSBtb25kYXk7XG5leHBvcnRzLnRpbWVNb25kYXlzID0gbW9uZGF5cztcbmV4cG9ydHMudGltZU1vbnRoID0gbW9udGg7XG5leHBvcnRzLnRpbWVNb250aHMgPSBtb250aHM7XG5leHBvcnRzLnRpbWVTYXR1cmRheSA9IHNhdHVyZGF5O1xuZXhwb3J0cy50aW1lU2F0dXJkYXlzID0gc2F0dXJkYXlzO1xuZXhwb3J0cy50aW1lU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy50aW1lU2Vjb25kcyA9IHNlY29uZHM7XG5leHBvcnRzLnRpbWVTdW5kYXkgPSBzdW5kYXk7XG5leHBvcnRzLnRpbWVTdW5kYXlzID0gc3VuZGF5cztcbmV4cG9ydHMudGltZVRodXJzZGF5ID0gdGh1cnNkYXk7XG5leHBvcnRzLnRpbWVUaHVyc2RheXMgPSB0aHVyc2RheXM7XG5leHBvcnRzLnRpbWVUdWVzZGF5ID0gdHVlc2RheTtcbmV4cG9ydHMudGltZVR1ZXNkYXlzID0gdHVlc2RheXM7XG5leHBvcnRzLnRpbWVXZWRuZXNkYXkgPSB3ZWRuZXNkYXk7XG5leHBvcnRzLnRpbWVXZWRuZXNkYXlzID0gd2VkbmVzZGF5cztcbmV4cG9ydHMudGltZVdlZWsgPSBzdW5kYXk7XG5leHBvcnRzLnRpbWVXZWVrcyA9IHN1bmRheXM7XG5leHBvcnRzLnRpbWVZZWFyID0geWVhcjtcbmV4cG9ydHMudGltZVllYXJzID0geWVhcnM7XG5leHBvcnRzLnV0Y0RheSA9IHV0Y0RheTtcbmV4cG9ydHMudXRjRGF5cyA9IHV0Y0RheXM7XG5leHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y0ZyaWRheTtcbmV4cG9ydHMudXRjRnJpZGF5cyA9IHV0Y0ZyaWRheXM7XG5leHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuZXhwb3J0cy51dGNIb3VycyA9IHV0Y0hvdXJzO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG5leHBvcnRzLnV0Y01pbnV0ZSA9IHV0Y01pbnV0ZTtcbmV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZXM7XG5leHBvcnRzLnV0Y01vbmRheSA9IHV0Y01vbmRheTtcbmV4cG9ydHMudXRjTW9uZGF5cyA9IHV0Y01vbmRheXM7XG5leHBvcnRzLnV0Y01vbnRoID0gdXRjTW9udGg7XG5leHBvcnRzLnV0Y01vbnRocyA9IHV0Y01vbnRocztcbmV4cG9ydHMudXRjU2F0dXJkYXkgPSB1dGNTYXR1cmRheTtcbmV4cG9ydHMudXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXlzO1xuZXhwb3J0cy51dGNTZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnV0Y1NlY29uZHMgPSBzZWNvbmRzO1xuZXhwb3J0cy51dGNTdW5kYXkgPSB1dGNTdW5kYXk7XG5leHBvcnRzLnV0Y1N1bmRheXMgPSB1dGNTdW5kYXlzO1xuZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1RodXJzZGF5O1xuZXhwb3J0cy51dGNUaHVyc2RheXMgPSB1dGNUaHVyc2RheXM7XG5leHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNUdWVzZGF5O1xuZXhwb3J0cy51dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXlzO1xuZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWRuZXNkYXk7XG5leHBvcnRzLnV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXlzO1xuZXhwb3J0cy51dGNXZWVrID0gdXRjU3VuZGF5O1xuZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y1llYXIgPSB1dGNZZWFyO1xuZXhwb3J0cy51dGNZZWFycyA9IHV0Y1llYXJzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWVyLyB2MS4wLjEwIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGZyYW1lID0gMCwgLy8gaXMgYW4gYW5pbWF0aW9uIGZyYW1lIHBlbmRpbmc/XG4gICAgdGltZW91dCA9IDAsIC8vIGlzIGEgdGltZW91dCBwZW5kaW5nP1xuICAgIGludGVydmFsID0gMCwgLy8gYXJlIGFueSB0aW1lcnMgYWN0aXZlP1xuICAgIHBva2VEZWxheSA9IDEwMDAsIC8vIGhvdyBmcmVxdWVudGx5IHdlIGNoZWNrIGZvciBjbG9jayBza2V3XG4gICAgdGFza0hlYWQsXG4gICAgdGFza1RhaWwsXG4gICAgY2xvY2tMYXN0ID0gMCxcbiAgICBjbG9ja05vdyA9IDAsXG4gICAgY2xvY2tTa2V3ID0gMCxcbiAgICBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGUsXG4gICAgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5mdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKG51bGwsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGltZW91dCQxKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbnRlcnZhbCQxKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lciwgdG90YWwgPSBkZWxheTtcbiAgaWYgKGRlbGF5ID09IG51bGwpIHJldHVybiB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSwgdDtcbiAgZGVsYXkgPSArZGVsYXksIHRpbWUgPSB0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lO1xuICB0LnJlc3RhcnQoZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgZWxhcHNlZCArPSB0b3RhbDtcbiAgICB0LnJlc3RhcnQodGljaywgdG90YWwgKz0gZGVsYXksIHRpbWUpO1xuICAgIGNhbGxiYWNrKGVsYXBzZWQpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnRzLmludGVydmFsID0gaW50ZXJ2YWwkMTtcbmV4cG9ydHMubm93ID0gbm93O1xuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCQxO1xuZXhwb3J0cy50aW1lciA9IHRpbWVyO1xuZXhwb3J0cy50aW1lckZsdXNoID0gdGltZXJGbHVzaDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10cmFuc2l0aW9uLyB2MS4zLjIgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtZGlzcGF0Y2gnKSwgcmVxdWlyZSgnZDMtdGltZXInKSwgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtY29sb3InKSwgcmVxdWlyZSgnZDMtZWFzZScpKSA6XG50eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXNlbGVjdGlvbicsICdkMy1kaXNwYXRjaCcsICdkMy10aW1lcicsICdkMy1pbnRlcnBvbGF0ZScsICdkMy1jb2xvcicsICdkMy1lYXNlJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30sIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzU2VsZWN0aW9uLCBkM0Rpc3BhdGNoLCBkM1RpbWVyLCBkM0ludGVycG9sYXRlLCBkM0NvbG9yLCBkM0Vhc2UpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPbiA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImNhbmNlbFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbnZhciBDUkVBVEVEID0gMDtcbnZhciBTQ0hFRFVMRUQgPSAxO1xudmFyIFNUQVJUSU5HID0gMjtcbnZhciBTVEFSVEVEID0gMztcbnZhciBSVU5OSU5HID0gNDtcbnZhciBFTkRJTkcgPSA1O1xudmFyIEVOREVEID0gNjtcblxuZnVuY3Rpb24gc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBDUkVBVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzY2hlZHVsZWRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJURUQpIHRocm93IG5ldyBFcnJvcihcInRvbyBsYXRlOyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gZ2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlIHx8ICEoc2NoZWR1bGUgPSBzY2hlZHVsZVtpZF0pKSB0aHJvdyBuZXcgRXJyb3IoXCJ0cmFuc2l0aW9uIG5vdCBmb3VuZFwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUobm9kZSwgaWQsIHNlbGYpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgdHdlZW47XG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGUgc2VsZiB0aW1lciB3aGVuIHRoZSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQuXG4gIC8vIE5vdGUgdGhlIGFjdHVhbCBkZWxheSBpcyBub3Qga25vd24gdW50aWwgdGhlIGZpcnN0IGNhbGxiYWNrIVxuICBzY2hlZHVsZXNbaWRdID0gc2VsZjtcbiAgc2VsZi50aW1lciA9IGQzVGltZXIudGltZXIoc2NoZWR1bGUsIDAsIHNlbGYudGltZSk7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgIHNlbGYuc3RhdGUgPSBTQ0hFRFVMRUQ7XG4gICAgc2VsZi50aW1lci5yZXN0YXJ0KHN0YXJ0LCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuXG4gICAgLy8gSWYgdGhlIGVsYXBzZWQgZGVsYXkgaXMgbGVzcyB0aGFuIG91ciBmaXJzdCBzbGVlcCwgc3RhcnQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHNlbGYuZGVsYXkgPD0gZWxhcHNlZCkgc3RhcnQoZWxhcHNlZCAtIHNlbGYuZGVsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnQoZWxhcHNlZCkge1xuICAgIHZhciBpLCBqLCBuLCBvO1xuXG4gICAgLy8gSWYgdGhlIHN0YXRlIGlzIG5vdCBTQ0hFRFVMRUQsIHRoZW4gd2UgcHJldmlvdXNseSBlcnJvcmVkIG9uIHN0YXJ0LlxuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTQ0hFRFVMRUQpIHJldHVybiBzdG9wKCk7XG5cbiAgICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgICBvID0gc2NoZWR1bGVzW2ldO1xuICAgICAgaWYgKG8ubmFtZSAhPT0gc2VsZi5uYW1lKSBjb250aW51ZTtcblxuICAgICAgLy8gV2hpbGUgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgc3RhcnRpbmcgdHJhbnNpdGlvbiBkdXJpbmcgdGhpcyBmcmFtZSxcbiAgICAgIC8vIGRlZmVyIHN0YXJ0aW5nIGFuIGludGVycnVwdGluZyB0cmFuc2l0aW9uIHVudGlsIHRoYXQgdHJhbnNpdGlvbiBoYXMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHRpY2sgKGFuZCBwb3NzaWJseSBlbmQpOyBzZWUgZDMvZDMtdHJhbnNpdGlvbiM1NCFcbiAgICAgIGlmIChvLnN0YXRlID09PSBTVEFSVEVEKSByZXR1cm4gZDNUaW1lci50aW1lb3V0KHN0YXJ0KTtcblxuICAgICAgLy8gSW50ZXJydXB0IHRoZSBhY3RpdmUgdHJhbnNpdGlvbiwgaWYgYW55LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIG8ub24uY2FsbChcImNhbmNlbFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBvLmluZGV4LCBvLmdyb3VwKTtcbiAgICAgICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZlciB0aGUgZmlyc3QgdGljayB0byBlbmQgb2YgdGhlIGN1cnJlbnQgZnJhbWU7IHNlZSBkMy9kMyMxNTc2LlxuICAgIC8vIE5vdGUgdGhlIHRyYW5zaXRpb24gbWF5IGJlIGNhbmNlbGVkIGFmdGVyIHN0YXJ0IGFuZCBiZWZvcmUgdGhlIGZpcnN0IHRpY2shXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgc2NoZWR1bGVkIGJlZm9yZSB0aGUgc3RhcnQgZXZlbnQ7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzE2IVxuICAgIC8vIEFzc3VtaW5nIHRoaXMgaXMgc3VjY2Vzc2Z1bCwgc3Vic2VxdWVudCBjYWxsYmFja3MgZ28gc3RyYWlnaHQgdG8gdGljay5cbiAgICBkM1RpbWVyLnRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gU1RBUlRFRCkge1xuICAgICAgICBzZWxmLnN0YXRlID0gUlVOTklORztcbiAgICAgICAgc2VsZi50aW1lci5yZXN0YXJ0KHRpY2ssIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG4gICAgICAgIHRpY2soZWxhcHNlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgc3RhcnQgZXZlbnQuXG4gICAgLy8gTm90ZSB0aGlzIG11c3QgYmUgZG9uZSBiZWZvcmUgdGhlIHR3ZWVuIGFyZSBpbml0aWFsaXplZC5cbiAgICBzZWxmLnN0YXRlID0gU1RBUlRJTkc7XG4gICAgc2VsZi5vbi5jYWxsKFwic3RhcnRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNUQVJUSU5HKSByZXR1cm47IC8vIGludGVycnVwdGVkXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJURUQ7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSB0d2VlbiwgZGVsZXRpbmcgbnVsbCB0d2Vlbi5cbiAgICB0d2VlbiA9IG5ldyBBcnJheShuID0gc2VsZi50d2Vlbi5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGogPSAtMTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG8gPSBzZWxmLnR3ZWVuW2ldLnZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCkpIHtcbiAgICAgICAgdHdlZW5bKytqXSA9IG87XG4gICAgICB9XG4gICAgfVxuICAgIHR3ZWVuLmxlbmd0aCA9IGogKyAxO1xuICB9XG5cbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgdmFyIHQgPSBlbGFwc2VkIDwgc2VsZi5kdXJhdGlvbiA/IHNlbGYuZWFzZS5jYWxsKG51bGwsIGVsYXBzZWQgLyBzZWxmLmR1cmF0aW9uKSA6IChzZWxmLnRpbWVyLnJlc3RhcnQoc3RvcCksIHNlbGYuc3RhdGUgPSBFTkRJTkcsIDEpLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0d2Vlbi5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgdHdlZW5baV0uY2FsbChub2RlLCB0KTtcbiAgICB9XG5cbiAgICAvLyBEaXNwYXRjaCB0aGUgZW5kIGV2ZW50LlxuICAgIGlmIChzZWxmLnN0YXRlID09PSBFTkRJTkcpIHtcbiAgICAgIHNlbGYub24uY2FsbChcImVuZFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHNlbGYuc3RhdGUgPSBFTkRFRDtcbiAgICBzZWxmLnRpbWVyLnN0b3AoKTtcbiAgICBkZWxldGUgc2NoZWR1bGVzW2lkXTtcbiAgICBmb3IgKHZhciBpIGluIHNjaGVkdWxlcykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVycnVwdChub2RlLCBuYW1lKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHNjaGVkdWxlLFxuICAgICAgYWN0aXZlLFxuICAgICAgZW1wdHkgPSB0cnVlLFxuICAgICAgaTtcblxuICBpZiAoIXNjaGVkdWxlcykgcmV0dXJuO1xuXG4gIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG5cbiAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgIGlmICgoc2NoZWR1bGUgPSBzY2hlZHVsZXNbaV0pLm5hbWUgIT09IG5hbWUpIHsgZW1wdHkgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBhY3RpdmUgPSBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HICYmIHNjaGVkdWxlLnN0YXRlIDwgRU5ESU5HO1xuICAgIHNjaGVkdWxlLnN0YXRlID0gRU5ERUQ7XG4gICAgc2NoZWR1bGUudGltZXIuc3RvcCgpO1xuICAgIHNjaGVkdWxlLm9uLmNhbGwoYWN0aXZlID8gXCJpbnRlcnJ1cHRcIiA6IFwiY2FuY2VsXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25faW50ZXJydXB0KG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICBpbnRlcnJ1cHQodGhpcywgbmFtZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gdHdlZW4wID0gdHdlZW47XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xID0gdHdlZW4xLnNsaWNlKCk7XG4gICAgICAgICAgdHdlZW4xLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0d2VlbkZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgdHdlZW4gPSBzY2hlZHVsZS50d2VlbjtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgdHdlZW4gd2l0aCB0aGUgcHJldmlvdXMgbm9kZSxcbiAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgdHdlZW4gYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAvLyBPdGhlcndpc2UsIGNvcHktb24td3JpdGUuXG4gICAgaWYgKHR3ZWVuICE9PSB0d2VlbjApIHtcbiAgICAgIHR3ZWVuMSA9ICh0d2VlbjAgPSB0d2Vlbikuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIHQgPSB7bmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlfSwgaSA9IDAsIG4gPSB0d2VlbjEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICh0d2VlbjFbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHR3ZWVuMVtpXSA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBuKSB0d2VlbjEucHVzaCh0KTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZS50d2VlbiA9IHR3ZWVuMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl90d2VlbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICBuYW1lICs9IFwiXCI7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0KHRoaXMubm9kZSgpLCBpZCkudHdlZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodCA9IHR3ZWVuW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGwgPyB0d2VlblJlbW92ZSA6IHR3ZWVuRnVuY3Rpb24pKGlkLCBuYW1lLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoYSwgYikge1xuICB2YXIgYztcbiAgcmV0dXJuICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGQzQ29sb3IuY29sb3IgPyBkM0ludGVycG9sYXRlLmludGVycG9sYXRlUmdiXG4gICAgICA6IChjID0gZDNDb2xvci5jb2xvcihiKSkgPyAoYiA9IGMsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVTdHJpbmcpKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZTEpIHtcbiAgdmFyIHN0cmluZzAwLFxuICAgICAgc3RyaW5nMSA9IHZhbHVlMSArIFwiXCIsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpLCBzdHJpbmcxO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgc3RyaW5nMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIGludGVycG9sYXRlLCB2YWx1ZSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKSwgc3RyaW5nMTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICBzdHJpbmcwID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcwID09PSBzdHJpbmcxID8gbnVsbFxuICAgICAgICA6IHN0cmluZzAgPT09IHN0cmluZzAwICYmIHN0cmluZzEgPT09IHN0cmluZzEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogKHN0cmluZzEwID0gc3RyaW5nMSwgaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUoc3RyaW5nMDAgPSBzdHJpbmcwLCB2YWx1ZTEpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9hdHRyKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IGQzU2VsZWN0aW9uLm5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZyA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdGhpcy5hdHRyVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24pKGZ1bGxuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwiYXR0ci5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgIDogdmFsdWUgPT0gbnVsbCA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkoZnVsbG5hbWUsIGksIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGF0dHJJbnRlcnBvbGF0ZShuYW1lLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaS5jYWxsKHRoaXMsIHQpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clR3ZWVuTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgYXR0ckludGVycG9sYXRlTlMoZnVsbG5hbWUsIGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgdmFyIHQwLCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdDAgPSAoaTAgPSBpKSAmJiBhdHRySW50ZXJwb2xhdGUobmFtZSwgaSk7XG4gICAgcmV0dXJuIHQwO1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fYXR0clR3ZWVuKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IGQzU2VsZWN0aW9uLm5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZGVsYXkodmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZGVsYXk7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gK3ZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5kdXJhdGlvbiA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2R1cmF0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGR1cmF0aW9uRnVuY3Rpb25cbiAgICAgICAgICA6IGR1cmF0aW9uQ29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZWFzZSh2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fZmlsdGVyKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBkM1NlbGVjdGlvbi5tYXRjaGVyKG1hdGNoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gW10sIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgbWF0Y2guY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fbWVyZ2UodHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufVxuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gIXQgfHwgdCA9PT0gXCJzdGFydFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9uMCwgb24xLCBzaXQgPSBzdGFydChuYW1lKSA/IGluaXQgOiBzZXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX29uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9yZW1vdmUoKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdChzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBkM1NlbGVjdGlvbi5zZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgICAgc2NoZWR1bGUoc3ViZ3JvdXBbaV0sIG5hbWUsIGlkLCBpLCBzdWJncm91cCwgZ2V0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdEFsbChzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBkM1NlbGVjdGlvbi5zZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59XG5cbnZhciBTZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3NlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24odGhpcy5fZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVOdWxsKG5hbWUsIGludGVycG9sYXRlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgc3RyaW5nMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHN0cmluZzEwID0gc3RyaW5nMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQobmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlMSkge1xuICB2YXIgc3RyaW5nMDAsXG4gICAgICBzdHJpbmcxID0gdmFsdWUxICsgXCJcIixcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHJpbmcwID0gZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24obmFtZSwgaW50ZXJwb2xhdGUsIHZhbHVlKSB7XG4gIHZhciBzdHJpbmcwMCxcbiAgICAgIHN0cmluZzEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0cmluZzAgPSBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gdmFsdWUodGhpcyksXG4gICAgICAgIHN0cmluZzEgPSB2YWx1ZTEgKyBcIlwiO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgc3RyaW5nMSA9IHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHN0cmluZzAgPT09IHN0cmluZzEgPyBudWxsXG4gICAgICAgIDogc3RyaW5nMCA9PT0gc3RyaW5nMDAgJiYgc3RyaW5nMSA9PT0gc3RyaW5nMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiAoc3RyaW5nMTAgPSBzdHJpbmcxLCBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZShzdHJpbmcwMCA9IHN0cmluZzAsIHZhbHVlMSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZU1heWJlUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciBvbjAsIG9uMSwgbGlzdGVuZXIwLCBrZXkgPSBcInN0eWxlLlwiICsgbmFtZSwgZXZlbnQgPSBcImVuZC5cIiArIGtleSwgcmVtb3ZlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0KHRoaXMsIGlkKSxcbiAgICAgICAgb24gPSBzY2hlZHVsZS5vbixcbiAgICAgICAgbGlzdGVuZXIgPSBzY2hlZHVsZS52YWx1ZVtrZXldID09IG51bGwgPyByZW1vdmUgfHwgKHJlbW92ZSA9IHN0eWxlUmVtb3ZlKG5hbWUpKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHRoaXMgbm9kZSBzaGFyZWQgYSBkaXNwYXRjaCB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCBkaXNwYXRjaCBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAob24gIT09IG9uMCB8fCBsaXN0ZW5lcjAgIT09IGxpc3RlbmVyKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKGV2ZW50LCBsaXN0ZW5lcjAgPSBsaXN0ZW5lcik7XG5cbiAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGkgPSAobmFtZSArPSBcIlwiKSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgOiBpbnRlcnBvbGF0ZTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZU51bGwobmFtZSwgaSkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZShuYW1lKSlcbiAgICA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gdGhpc1xuICAgICAgLnN0eWxlVHdlZW4obmFtZSwgc3R5bGVGdW5jdGlvbihuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpKVxuICAgICAgLmVhY2goc3R5bGVNYXliZVJlbW92ZSh0aGlzLl9pZCwgbmFtZSkpXG4gICAgOiB0aGlzXG4gICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZUNvbnN0YW50KG5hbWUsIGksIHZhbHVlKSwgcHJpb3JpdHkpXG4gICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVJbnRlcnBvbGF0ZShuYW1lLCBpLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgaS5jYWxsKHRoaXMsIHQpLCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciB0LCBpMDtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChpICE9PSBpMCkgdCA9IChpMCA9IGkpICYmIHN0eWxlSW50ZXJwb2xhdGUobmFtZSwgaSwgcHJpb3JpdHkpO1xuICAgIHJldHVybiB0O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTEgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZTE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25fdGV4dCh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy50d2VlbihcInRleHRcIiwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gdGV4dEZ1bmN0aW9uKHR3ZWVuVmFsdWUodGhpcywgXCJ0ZXh0XCIsIHZhbHVlKSlcbiAgICAgIDogdGV4dENvbnN0YW50KHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XG59XG5cbmZ1bmN0aW9uIHRleHRJbnRlcnBvbGF0ZShpKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IGkuY2FsbCh0aGlzLCB0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dFR3ZWVuKHZhbHVlKSB7XG4gIHZhciB0MCwgaTA7XG4gIGZ1bmN0aW9uIHR3ZWVuKCkge1xuICAgIHZhciBpID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoaSAhPT0gaTApIHQwID0gKGkwID0gaSkgJiYgdGV4dEludGVycG9sYXRlKGkpO1xuICAgIHJldHVybiB0MDtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX3RleHRUd2Vlbih2YWx1ZSkge1xuICB2YXIga2V5ID0gXCJ0ZXh0XCI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCB0ZXh0VHdlZW4odmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbl90cmFuc2l0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2VuZCgpIHtcbiAgdmFyIG9uMCwgb24xLCB0aGF0ID0gdGhpcywgaWQgPSB0aGF0Ll9pZCwgc2l6ZSA9IHRoYXQuc2l6ZSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGNhbmNlbCA9IHt2YWx1ZTogcmVqZWN0fSxcbiAgICAgICAgZW5kID0ge3ZhbHVlOiBmdW5jdGlvbigpIHsgaWYgKC0tc2l6ZSA9PT0gMCkgcmVzb2x2ZSgpOyB9fTtcblxuICAgIHRoYXQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgICAgb24gPSBzY2hlZHVsZS5vbjtcblxuICAgICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgICAvLyBqdXN0IGFzc2lnbiB0aGUgdXBkYXRlZCBzaGFyZWQgZGlzcGF0Y2ggYW5kIHdl4oCZcmUgZG9uZSFcbiAgICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICAgIGlmIChvbiAhPT0gb24wKSB7XG4gICAgICAgIG9uMSA9IChvbjAgPSBvbikuY29weSgpO1xuICAgICAgICBvbjEuXy5jYW5jZWwucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5pbnRlcnJ1cHQucHVzaChjYW5jZWwpO1xuICAgICAgICBvbjEuXy5lbmQucHVzaChlbmQpO1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZS5vbiA9IG9uMTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciBpZCA9IDA7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBkM1NlbGVjdGlvbi5zZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBuZXdJZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvdG90eXBlID0gZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZTtcblxuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB0cmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb24sXG4gIHNlbGVjdDogdHJhbnNpdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogdHJhbnNpdGlvbl9zZWxlY3RBbGwsXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHRleHRUd2VlbjogdHJhbnNpdGlvbl90ZXh0VHdlZW4sXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZSxcbiAgZW5kOiB0cmFuc2l0aW9uX2VuZFxufTtcblxudmFyIGRlZmF1bHRUaW1pbmcgPSB7XG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogMjUwLFxuICBlYXNlOiBkM0Vhc2UuZWFzZUN1YmljSW5PdXRcbn07XG5cbmZ1bmN0aW9uIGluaGVyaXQobm9kZSwgaWQpIHtcbiAgdmFyIHRpbWluZztcbiAgd2hpbGUgKCEodGltaW5nID0gbm9kZS5fX3RyYW5zaXRpb24pIHx8ICEodGltaW5nID0gdGltaW5nW2lkXSkpIHtcbiAgICBpZiAoIShub2RlID0gbm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRUaW1pbmcudGltZSA9IGQzVGltZXIubm93KCksIGRlZmF1bHRUaW1pbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1pbmc7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl90cmFuc2l0aW9uKG5hbWUpIHtcbiAgdmFyIGlkLFxuICAgICAgdGltaW5nO1xuXG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVHJhbnNpdGlvbikge1xuICAgIGlkID0gbmFtZS5faWQsIG5hbWUgPSBuYW1lLl9uYW1lO1xuICB9IGVsc2Uge1xuICAgIGlkID0gbmV3SWQoKSwgKHRpbWluZyA9IGRlZmF1bHRUaW1pbmcpLnRpbWUgPSBkM1RpbWVyLm5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn1cblxuZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG5cbnZhciByb290ID0gW251bGxdO1xuXG5mdW5jdGlvbiBhY3RpdmUobm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QsIG5hbWUsICtpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5hY3RpdmUgPSBhY3RpdmU7XG5leHBvcnRzLmludGVycnVwdCA9IGludGVycnVwdDtcbmV4cG9ydHMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdm9yb25vaS8gdjEuMS40IENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbnR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4oZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrVHJlZSgpIHtcbiAgdGhpcy5fID0gbnVsbDsgLy8gcm9vdCBub2RlXG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrTm9kZShub2RlKSB7XG4gIG5vZGUuVSA9IC8vIHBhcmVudCBub2RlXG4gIG5vZGUuQyA9IC8vIGNvbG9yIC0gdHJ1ZSBmb3IgcmVkLCBmYWxzZSBmb3IgYmxhY2tcbiAgbm9kZS5MID0gLy8gbGVmdCBub2RlXG4gIG5vZGUuUiA9IC8vIHJpZ2h0IG5vZGVcbiAgbm9kZS5QID0gLy8gcHJldmlvdXMgbm9kZVxuICBub2RlLk4gPSBudWxsOyAvLyBuZXh0IG5vZGVcbn1cblxuUmVkQmxhY2tUcmVlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJlZEJsYWNrVHJlZSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uKGFmdGVyLCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCwgZ3JhbmRwYSwgdW5jbGU7XG5cbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIG5vZGUuUCA9IGFmdGVyO1xuICAgICAgbm9kZS5OID0gYWZ0ZXIuTjtcbiAgICAgIGlmIChhZnRlci5OKSBhZnRlci5OLlAgPSBub2RlO1xuICAgICAgYWZ0ZXIuTiA9IG5vZGU7XG4gICAgICBpZiAoYWZ0ZXIuUikge1xuICAgICAgICBhZnRlciA9IGFmdGVyLlI7XG4gICAgICAgIHdoaWxlIChhZnRlci5MKSBhZnRlciA9IGFmdGVyLkw7XG4gICAgICAgIGFmdGVyLkwgPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXIuUiA9IG5vZGU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuXykge1xuICAgICAgYWZ0ZXIgPSBSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XG4gICAgICBub2RlLlAgPSBudWxsO1xuICAgICAgbm9kZS5OID0gYWZ0ZXI7XG4gICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICBwYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLkwgPSBub2RlLlIgPSBudWxsO1xuICAgIG5vZGUuVSA9IHBhcmVudDtcbiAgICBub2RlLkMgPSB0cnVlO1xuXG4gICAgYWZ0ZXIgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LkMpIHtcbiAgICAgIGdyYW5kcGEgPSBwYXJlbnQuVTtcbiAgICAgIGlmIChwYXJlbnQgPT09IGdyYW5kcGEuTCkge1xuICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcbiAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuY2xlID0gZ3JhbmRwYS5MO1xuICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICB9XG4gICAgdGhpcy5fLkMgPSBmYWxzZTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5OKSBub2RlLk4uUCA9IG5vZGUuUDtcbiAgICBpZiAobm9kZS5QKSBub2RlLlAuTiA9IG5vZGUuTjtcbiAgICBub2RlLk4gPSBub2RlLlAgPSBudWxsO1xuXG4gICAgdmFyIHBhcmVudCA9IG5vZGUuVSxcbiAgICAgICAgc2libGluZyxcbiAgICAgICAgbGVmdCA9IG5vZGUuTCxcbiAgICAgICAgcmlnaHQgPSBub2RlLlIsXG4gICAgICAgIG5leHQsXG4gICAgICAgIHJlZDtcblxuICAgIGlmICghbGVmdCkgbmV4dCA9IHJpZ2h0O1xuICAgIGVsc2UgaWYgKCFyaWdodCkgbmV4dCA9IGxlZnQ7XG4gICAgZWxzZSBuZXh0ID0gUmVkQmxhY2tGaXJzdChyaWdodCk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LkwgPT09IG5vZGUpIHBhcmVudC5MID0gbmV4dDtcbiAgICAgIGVsc2UgcGFyZW50LlIgPSBuZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl8gPSBuZXh0O1xuICAgIH1cblxuICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XG4gICAgICByZWQgPSBuZXh0LkM7XG4gICAgICBuZXh0LkMgPSBub2RlLkM7XG4gICAgICBuZXh0LkwgPSBsZWZ0O1xuICAgICAgbGVmdC5VID0gbmV4dDtcbiAgICAgIGlmIChuZXh0ICE9PSByaWdodCkge1xuICAgICAgICBwYXJlbnQgPSBuZXh0LlU7XG4gICAgICAgIG5leHQuVSA9IG5vZGUuVTtcbiAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgcGFyZW50LkwgPSBub2RlO1xuICAgICAgICBuZXh0LlIgPSByaWdodDtcbiAgICAgICAgcmlnaHQuVSA9IG5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0LlUgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IG5leHQ7XG4gICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZCA9IG5vZGUuQztcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIGlmIChub2RlKSBub2RlLlUgPSBwYXJlbnQ7XG4gICAgaWYgKHJlZCkgcmV0dXJuO1xuICAgIGlmIChub2RlICYmIG5vZGUuQykgeyBub2RlLkMgPSBmYWxzZTsgcmV0dXJuOyB9XG5cbiAgICBkbyB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKSBicmVhaztcbiAgICAgIGlmIChub2RlID09PSBwYXJlbnQuTCkge1xuICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2libGluZy5MICYmIHNpYmxpbmcuTC5DKVxuICAgICAgICAgICAgfHwgKHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykpIHtcbiAgICAgICAgICBpZiAoIXNpYmxpbmcuUiB8fCAhc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2libGluZy5MICYmIHNpYmxpbmcuTC5DKVxuICAgICAgICAgIHx8IChzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpKSB7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5VO1xuICAgIH0gd2hpbGUgKCFub2RlLkMpO1xuXG4gICAgaWYgKG5vZGUpIG5vZGUuQyA9IGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZWRCbGFja1JvdGF0ZUxlZnQodHJlZSwgbm9kZSkge1xuICB2YXIgcCA9IG5vZGUsXG4gICAgICBxID0gbm9kZS5SLFxuICAgICAgcGFyZW50ID0gcC5VO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTtcbiAgICBlbHNlIHBhcmVudC5SID0gcTtcbiAgfSBlbHNlIHtcbiAgICB0cmVlLl8gPSBxO1xuICB9XG5cbiAgcS5VID0gcGFyZW50O1xuICBwLlUgPSBxO1xuICBwLlIgPSBxLkw7XG4gIGlmIChwLlIpIHAuUi5VID0gcDtcbiAgcS5MID0gcDtcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tSb3RhdGVSaWdodCh0cmVlLCBub2RlKSB7XG4gIHZhciBwID0gbm9kZSxcbiAgICAgIHEgPSBub2RlLkwsXG4gICAgICBwYXJlbnQgPSBwLlU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxO1xuICAgIGVsc2UgcGFyZW50LlIgPSBxO1xuICB9IGVsc2Uge1xuICAgIHRyZWUuXyA9IHE7XG4gIH1cblxuICBxLlUgPSBwYXJlbnQ7XG4gIHAuVSA9IHE7XG4gIHAuTCA9IHEuUjtcbiAgaWYgKHAuTCkgcC5MLlUgPSBwO1xuICBxLlIgPSBwO1xufVxuXG5mdW5jdGlvbiBSZWRCbGFja0ZpcnN0KG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2UobGVmdCwgcmlnaHQsIHYwLCB2MSkge1xuICB2YXIgZWRnZSA9IFtudWxsLCBudWxsXSxcbiAgICAgIGluZGV4ID0gZWRnZXMucHVzaChlZGdlKSAtIDE7XG4gIGVkZ2UubGVmdCA9IGxlZnQ7XG4gIGVkZ2UucmlnaHQgPSByaWdodDtcbiAgaWYgKHYwKSBzZXRFZGdlRW5kKGVkZ2UsIGxlZnQsIHJpZ2h0LCB2MCk7XG4gIGlmICh2MSkgc2V0RWRnZUVuZChlZGdlLCByaWdodCwgbGVmdCwgdjEpO1xuICBjZWxsc1tsZWZ0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gIGNlbGxzW3JpZ2h0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gIHJldHVybiBlZGdlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCb3JkZXJFZGdlKGxlZnQsIHYwLCB2MSkge1xuICB2YXIgZWRnZSA9IFt2MCwgdjFdO1xuICBlZGdlLmxlZnQgPSBsZWZ0O1xuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gc2V0RWRnZUVuZChlZGdlLCBsZWZ0LCByaWdodCwgdmVydGV4KSB7XG4gIGlmICghZWRnZVswXSAmJiAhZWRnZVsxXSkge1xuICAgIGVkZ2VbMF0gPSB2ZXJ0ZXg7XG4gICAgZWRnZS5sZWZ0ID0gbGVmdDtcbiAgICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XG4gIH0gZWxzZSBpZiAoZWRnZS5sZWZ0ID09PSByaWdodCkge1xuICAgIGVkZ2VbMV0gPSB2ZXJ0ZXg7XG4gIH0gZWxzZSB7XG4gICAgZWRnZVswXSA9IHZlcnRleDtcbiAgfVxufVxuXG4vLyBMaWFuZ+KAk0JhcnNreSBsaW5lIGNsaXBwaW5nLlxuZnVuY3Rpb24gY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGEgPSBlZGdlWzBdLFxuICAgICAgYiA9IGVkZ2VbMV0sXG4gICAgICBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAoISh0MCA+IDApICYmICEodDEgPCAxKSkgcmV0dXJuIHRydWU7IC8vIFRPRE8gQmV0dGVyIGNoZWNrP1xuXG4gIGlmICh0MCA+IDApIGVkZ2VbMF0gPSBbYXggKyB0MCAqIGR4LCBheSArIHQwICogZHldO1xuICBpZiAodDEgPCAxKSBlZGdlWzFdID0gW2F4ICsgdDEgKiBkeCwgYXkgKyB0MSAqIGR5XTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3RFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciB2MSA9IGVkZ2VbMV07XG4gIGlmICh2MSkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHYwID0gZWRnZVswXSxcbiAgICAgIGxlZnQgPSBlZGdlLmxlZnQsXG4gICAgICByaWdodCA9IGVkZ2UucmlnaHQsXG4gICAgICBseCA9IGxlZnRbMF0sXG4gICAgICBseSA9IGxlZnRbMV0sXG4gICAgICByeCA9IHJpZ2h0WzBdLFxuICAgICAgcnkgPSByaWdodFsxXSxcbiAgICAgIGZ4ID0gKGx4ICsgcngpIC8gMixcbiAgICAgIGZ5ID0gKGx5ICsgcnkpIC8gMixcbiAgICAgIGZtLFxuICAgICAgZmI7XG5cbiAgaWYgKHJ5ID09PSBseSkge1xuICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKSByZXR1cm47XG4gICAgaWYgKGx4ID4gcngpIHtcbiAgICAgIGlmICghdjApIHYwID0gW2Z4LCB5MF07XG4gICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSkgcmV0dXJuO1xuICAgICAgdjEgPSBbZngsIHkxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF2MCkgdjAgPSBbZngsIHkxXTtcbiAgICAgIGVsc2UgaWYgKHYwWzFdIDwgeTApIHJldHVybjtcbiAgICAgIHYxID0gW2Z4LCB5MF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZtID0gKGx4IC0gcngpIC8gKHJ5IC0gbHkpO1xuICAgIGZiID0gZnkgLSBmbSAqIGZ4O1xuICAgIGlmIChmbSA8IC0xIHx8IGZtID4gMSkge1xuICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcbiAgICAgICAgZWxzZSBpZiAodjBbMV0gPj0geTEpIHJldHVybjtcbiAgICAgICAgdjEgPSBbKHkxIC0gZmIpIC8gZm0sIHkxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdjApIHYwID0gWyh5MSAtIGZiKSAvIGZtLCB5MV07XG4gICAgICAgIGVsc2UgaWYgKHYwWzFdIDwgeTApIHJldHVybjtcbiAgICAgICAgdjEgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGx5IDwgcnkpIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbeDAsIGZtICogeDAgKyBmYl07XG4gICAgICAgIGVsc2UgaWYgKHYwWzBdID49IHgxKSByZXR1cm47XG4gICAgICAgIHYxID0gW3gxLCBmbSAqIHgxICsgZmJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbeDEsIGZtICogeDEgKyBmYl07XG4gICAgICAgIGVsc2UgaWYgKHYwWzBdIDwgeDApIHJldHVybjtcbiAgICAgICAgdjEgPSBbeDAsIGZtICogeDAgKyBmYl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWRnZVswXSA9IHYwO1xuICBlZGdlWzFdID0gdjE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjbGlwRWRnZXMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGkgPSBlZGdlcy5sZW5ndGgsXG4gICAgICBlZGdlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoIWNvbm5lY3RFZGdlKGVkZ2UgPSBlZGdlc1tpXSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgIHx8ICFjbGlwRWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSlcbiAgICAgICAgfHwgIShNYXRoLmFicyhlZGdlWzBdWzBdIC0gZWRnZVsxXVswXSkgPiBlcHNpbG9uXG4gICAgICAgICAgICB8fCBNYXRoLmFicyhlZGdlWzBdWzFdIC0gZWRnZVsxXVsxXSkgPiBlcHNpbG9uKSkge1xuICAgICAgZGVsZXRlIGVkZ2VzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHNpdGUpIHtcbiAgcmV0dXJuIGNlbGxzW3NpdGUuaW5kZXhdID0ge1xuICAgIHNpdGU6IHNpdGUsXG4gICAgaGFsZmVkZ2VzOiBbXVxuICB9O1xufVxuXG5mdW5jdGlvbiBjZWxsSGFsZmVkZ2VBbmdsZShjZWxsLCBlZGdlKSB7XG4gIHZhciBzaXRlID0gY2VsbC5zaXRlLFxuICAgICAgdmEgPSBlZGdlLmxlZnQsXG4gICAgICB2YiA9IGVkZ2UucmlnaHQ7XG4gIGlmIChzaXRlID09PSB2YikgdmIgPSB2YSwgdmEgPSBzaXRlO1xuICBpZiAodmIpIHJldHVybiBNYXRoLmF0YW4yKHZiWzFdIC0gdmFbMV0sIHZiWzBdIC0gdmFbMF0pO1xuICBpZiAoc2l0ZSA9PT0gdmEpIHZhID0gZWRnZVsxXSwgdmIgPSBlZGdlWzBdO1xuICBlbHNlIHZhID0gZWRnZVswXSwgdmIgPSBlZGdlWzFdO1xuICByZXR1cm4gTWF0aC5hdGFuMih2YVswXSAtIHZiWzBdLCB2YlsxXSAtIHZhWzFdKTtcbn1cblxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZSkge1xuICByZXR1cm4gZWRnZVsrKGVkZ2UubGVmdCAhPT0gY2VsbC5zaXRlKV07XG59XG5cbmZ1bmN0aW9uIGNlbGxIYWxmZWRnZUVuZChjZWxsLCBlZGdlKSB7XG4gIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ID09PSBjZWxsLnNpdGUpXTtcbn1cblxuZnVuY3Rpb24gc29ydENlbGxIYWxmZWRnZXMoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBoYWxmZWRnZXMsIGosIG07IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGNlbGwgPSBjZWxsc1tpXSkgJiYgKG0gPSAoaGFsZmVkZ2VzID0gY2VsbC5oYWxmZWRnZXMpLmxlbmd0aCkpIHtcbiAgICAgIHZhciBpbmRleCA9IG5ldyBBcnJheShtKSxcbiAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheShtKTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIGluZGV4W2pdID0gaiwgYXJyYXlbal0gPSBjZWxsSGFsZmVkZ2VBbmdsZShjZWxsLCBlZGdlc1toYWxmZWRnZXNbal1dKTtcbiAgICAgIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gYXJyYXlbal0gLSBhcnJheVtpXTsgfSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBhcnJheVtqXSA9IGhhbGZlZGdlc1tpbmRleFtqXV07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBoYWxmZWRnZXNbal0gPSBhcnJheVtqXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xpcENlbGxzKHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBuQ2VsbHMgPSBjZWxscy5sZW5ndGgsXG4gICAgICBpQ2VsbCxcbiAgICAgIGNlbGwsXG4gICAgICBzaXRlLFxuICAgICAgaUhhbGZlZGdlLFxuICAgICAgaGFsZmVkZ2VzLFxuICAgICAgbkhhbGZlZGdlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgZW5kLFxuICAgICAgZW5kWCxcbiAgICAgIGVuZFksXG4gICAgICBjb3ZlciA9IHRydWU7XG5cbiAgZm9yIChpQ2VsbCA9IDA7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcbiAgICAgIHNpdGUgPSBjZWxsLnNpdGU7XG4gICAgICBoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcztcbiAgICAgIGlIYWxmZWRnZSA9IGhhbGZlZGdlcy5sZW5ndGg7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgZGFuZ2xpbmcgY2xpcHBlZCBlZGdlcy5cbiAgICAgIHdoaWxlIChpSGFsZmVkZ2UtLSkge1xuICAgICAgICBpZiAoIWVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSkge1xuICAgICAgICAgIGhhbGZlZGdlcy5zcGxpY2UoaUhhbGZlZGdlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbnNlcnQgYW55IGJvcmRlciBlZGdlcyBhcyBuZWNlc3NhcnkuXG4gICAgICBpSGFsZmVkZ2UgPSAwLCBuSGFsZmVkZ2VzID0gaGFsZmVkZ2VzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpSGFsZmVkZ2UgPCBuSGFsZmVkZ2VzKSB7XG4gICAgICAgIGVuZCA9IGNlbGxIYWxmZWRnZUVuZChjZWxsLCBlZGdlc1toYWxmZWRnZXNbaUhhbGZlZGdlXV0pLCBlbmRYID0gZW5kWzBdLCBlbmRZID0gZW5kWzFdO1xuICAgICAgICBzdGFydCA9IGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1srK2lIYWxmZWRnZSAlIG5IYWxmZWRnZXNdXSksIHN0YXJ0WCA9IHN0YXJ0WzBdLCBzdGFydFkgPSBzdGFydFsxXTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGVuZFggLSBzdGFydFgpID4gZXBzaWxvbiB8fCBNYXRoLmFicyhlbmRZIC0gc3RhcnRZKSA+IGVwc2lsb24pIHtcbiAgICAgICAgICBoYWxmZWRnZXMuc3BsaWNlKGlIYWxmZWRnZSwgMCwgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIGVuZCxcbiAgICAgICAgICAgICAgTWF0aC5hYnMoZW5kWCAtIHgwKSA8IGVwc2lsb24gJiYgeTEgLSBlbmRZID4gZXBzaWxvbiA/IFt4MCwgTWF0aC5hYnMoc3RhcnRYIC0geDApIDwgZXBzaWxvbiA/IHN0YXJ0WSA6IHkxXVxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MSkgPCBlcHNpbG9uICYmIHgxIC0gZW5kWCA+IGVwc2lsb24gPyBbTWF0aC5hYnMoc3RhcnRZIC0geTEpIDwgZXBzaWxvbiA/IHN0YXJ0WCA6IHgxLCB5MV1cbiAgICAgICAgICAgICAgOiBNYXRoLmFicyhlbmRYIC0geDEpIDwgZXBzaWxvbiAmJiBlbmRZIC0geTAgPiBlcHNpbG9uID8gW3gxLCBNYXRoLmFicyhzdGFydFggLSB4MSkgPCBlcHNpbG9uID8gc3RhcnRZIDogeTBdXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWSAtIHkwKSA8IGVwc2lsb24gJiYgZW5kWCAtIHgwID4gZXBzaWxvbiA/IFtNYXRoLmFicyhzdGFydFkgLSB5MCkgPCBlcHNpbG9uID8gc3RhcnRYIDogeDAsIHkwXVxuICAgICAgICAgICAgICA6IG51bGwpKSAtIDEpO1xuICAgICAgICAgICsrbkhhbGZlZGdlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkhhbGZlZGdlcykgY292ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlbuKAmXQgYW55IGVkZ2VzLCBoYXZlIHRoZSBjbG9zZXN0IHNpdGUgY292ZXIgdGhlIGV4dGVudC5cbiAgLy8gSXQgZG9lc27igJl0IG1hdHRlciB3aGljaCBjb3JuZXIgb2YgdGhlIGV4dGVudCB3ZSBtZWFzdXJlIVxuICBpZiAoY292ZXIpIHtcbiAgICB2YXIgZHgsIGR5LCBkMiwgZGMgPSBJbmZpbml0eTtcblxuICAgIGZvciAoaUNlbGwgPSAwLCBjb3ZlciA9IG51bGw7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgICBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgICBkeCA9IHNpdGVbMF0gLSB4MDtcbiAgICAgICAgZHkgPSBzaXRlWzFdIC0geTA7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IGRjKSBkYyA9IGQyLCBjb3ZlciA9IGNlbGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdmVyKSB7XG4gICAgICB2YXIgdjAwID0gW3gwLCB5MF0sIHYwMSA9IFt4MCwgeTFdLCB2MTEgPSBbeDEsIHkxXSwgdjEwID0gW3gxLCB5MF07XG4gICAgICBjb3Zlci5oYWxmZWRnZXMucHVzaChcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUgPSBjb3Zlci5zaXRlLCB2MDAsIHYwMSkpIC0gMSxcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYwMSwgdjExKSkgLSAxLFxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjExLCB2MTApKSAtIDEsXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MTAsIHYwMCkpIC0gMVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBMYXN0bHkgZGVsZXRlIGFueSBjZWxscyB3aXRoIG5vIGVkZ2VzOyB0aGVzZSB3ZXJlIGVudGlyZWx5IGNsaXBwZWQuXG4gIGZvciAoaUNlbGwgPSAwOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICBpZiAoIWNlbGwuaGFsZmVkZ2VzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgY2VsbHNbaUNlbGxdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgY2lyY2xlUG9vbCA9IFtdO1xuXG52YXIgZmlyc3RDaXJjbGU7XG5cbmZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICB0aGlzLnggPVxuICB0aGlzLnkgPVxuICB0aGlzLmFyYyA9XG4gIHRoaXMuc2l0ZSA9XG4gIHRoaXMuY3kgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hDaXJjbGUoYXJjKSB7XG4gIHZhciBsQXJjID0gYXJjLlAsXG4gICAgICByQXJjID0gYXJjLk47XG5cbiAgaWYgKCFsQXJjIHx8ICFyQXJjKSByZXR1cm47XG5cbiAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLFxuICAgICAgY1NpdGUgPSBhcmMuc2l0ZSxcbiAgICAgIHJTaXRlID0gckFyYy5zaXRlO1xuXG4gIGlmIChsU2l0ZSA9PT0gclNpdGUpIHJldHVybjtcblxuICB2YXIgYnggPSBjU2l0ZVswXSxcbiAgICAgIGJ5ID0gY1NpdGVbMV0sXG4gICAgICBheCA9IGxTaXRlWzBdIC0gYngsXG4gICAgICBheSA9IGxTaXRlWzFdIC0gYnksXG4gICAgICBjeCA9IHJTaXRlWzBdIC0gYngsXG4gICAgICBjeSA9IHJTaXRlWzFdIC0gYnk7XG5cbiAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgaWYgKGQgPj0gLWVwc2lsb24yKSByZXR1cm47XG5cbiAgdmFyIGhhID0gYXggKiBheCArIGF5ICogYXksXG4gICAgICBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgeCA9IChjeSAqIGhhIC0gYXkgKiBoYykgLyBkLFxuICAgICAgeSA9IChheCAqIGhjIC0gY3ggKiBoYSkgLyBkO1xuXG4gIHZhciBjaXJjbGUgPSBjaXJjbGVQb29sLnBvcCgpIHx8IG5ldyBDaXJjbGU7XG4gIGNpcmNsZS5hcmMgPSBhcmM7XG4gIGNpcmNsZS5zaXRlID0gY1NpdGU7XG4gIGNpcmNsZS54ID0geCArIGJ4O1xuICBjaXJjbGUueSA9IChjaXJjbGUuY3kgPSB5ICsgYnkpICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpOyAvLyB5IGJvdHRvbVxuXG4gIGFyYy5jaXJjbGUgPSBjaXJjbGU7XG5cbiAgdmFyIGJlZm9yZSA9IG51bGwsXG4gICAgICBub2RlID0gY2lyY2xlcy5fO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKGNpcmNsZS55IDwgbm9kZS55IHx8IChjaXJjbGUueSA9PT0gbm9kZS55ICYmIGNpcmNsZS54IDw9IG5vZGUueCkpIHtcbiAgICAgIGlmIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gICAgICBlbHNlIHsgYmVmb3JlID0gbm9kZS5QOyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5SKSBub2RlID0gbm9kZS5SO1xuICAgICAgZWxzZSB7IGJlZm9yZSA9IG5vZGU7IGJyZWFrOyB9XG4gICAgfVxuICB9XG5cbiAgY2lyY2xlcy5pbnNlcnQoYmVmb3JlLCBjaXJjbGUpO1xuICBpZiAoIWJlZm9yZSkgZmlyc3RDaXJjbGUgPSBjaXJjbGU7XG59XG5cbmZ1bmN0aW9uIGRldGFjaENpcmNsZShhcmMpIHtcbiAgdmFyIGNpcmNsZSA9IGFyYy5jaXJjbGU7XG4gIGlmIChjaXJjbGUpIHtcbiAgICBpZiAoIWNpcmNsZS5QKSBmaXJzdENpcmNsZSA9IGNpcmNsZS5OO1xuICAgIGNpcmNsZXMucmVtb3ZlKGNpcmNsZSk7XG4gICAgY2lyY2xlUG9vbC5wdXNoKGNpcmNsZSk7XG4gICAgUmVkQmxhY2tOb2RlKGNpcmNsZSk7XG4gICAgYXJjLmNpcmNsZSA9IG51bGw7XG4gIH1cbn1cblxudmFyIGJlYWNoUG9vbCA9IFtdO1xuXG5mdW5jdGlvbiBCZWFjaCgpIHtcbiAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICB0aGlzLmVkZ2UgPVxuICB0aGlzLnNpdGUgPVxuICB0aGlzLmNpcmNsZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJlYWNoKHNpdGUpIHtcbiAgdmFyIGJlYWNoID0gYmVhY2hQb29sLnBvcCgpIHx8IG5ldyBCZWFjaDtcbiAgYmVhY2guc2l0ZSA9IHNpdGU7XG4gIHJldHVybiBiZWFjaDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoQmVhY2goYmVhY2gpIHtcbiAgZGV0YWNoQ2lyY2xlKGJlYWNoKTtcbiAgYmVhY2hlcy5yZW1vdmUoYmVhY2gpO1xuICBiZWFjaFBvb2wucHVzaChiZWFjaCk7XG4gIFJlZEJsYWNrTm9kZShiZWFjaCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUJlYWNoKGJlYWNoKSB7XG4gIHZhciBjaXJjbGUgPSBiZWFjaC5jaXJjbGUsXG4gICAgICB4ID0gY2lyY2xlLngsXG4gICAgICB5ID0gY2lyY2xlLmN5LFxuICAgICAgdmVydGV4ID0gW3gsIHldLFxuICAgICAgcHJldmlvdXMgPSBiZWFjaC5QLFxuICAgICAgbmV4dCA9IGJlYWNoLk4sXG4gICAgICBkaXNhcHBlYXJpbmcgPSBbYmVhY2hdO1xuXG4gIGRldGFjaEJlYWNoKGJlYWNoKTtcblxuICB2YXIgbEFyYyA9IHByZXZpb3VzO1xuICB3aGlsZSAobEFyYy5jaXJjbGVcbiAgICAgICYmIE1hdGguYWJzKHggLSBsQXJjLmNpcmNsZS54KSA8IGVwc2lsb25cbiAgICAgICYmIE1hdGguYWJzKHkgLSBsQXJjLmNpcmNsZS5jeSkgPCBlcHNpbG9uKSB7XG4gICAgcHJldmlvdXMgPSBsQXJjLlA7XG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgZGV0YWNoQmVhY2gobEFyYyk7XG4gICAgbEFyYyA9IHByZXZpb3VzO1xuICB9XG5cbiAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gIGRldGFjaENpcmNsZShsQXJjKTtcblxuICB2YXIgckFyYyA9IG5leHQ7XG4gIHdoaWxlIChyQXJjLmNpcmNsZVxuICAgICAgJiYgTWF0aC5hYnMoeCAtIHJBcmMuY2lyY2xlLngpIDwgZXBzaWxvblxuICAgICAgJiYgTWF0aC5hYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IGVwc2lsb24pIHtcbiAgICBuZXh0ID0gckFyYy5OO1xuICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgIGRldGFjaEJlYWNoKHJBcmMpO1xuICAgIHJBcmMgPSBuZXh0O1xuICB9XG5cbiAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gIGRldGFjaENpcmNsZShyQXJjKTtcblxuICB2YXIgbkFyY3MgPSBkaXNhcHBlYXJpbmcubGVuZ3RoLFxuICAgICAgaUFyYztcbiAgZm9yIChpQXJjID0gMTsgaUFyYyA8IG5BcmNzOyArK2lBcmMpIHtcbiAgICByQXJjID0gZGlzYXBwZWFyaW5nW2lBcmNdO1xuICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xuICAgIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgdmVydGV4KTtcbiAgfVxuXG4gIGxBcmMgPSBkaXNhcHBlYXJpbmdbMF07XG4gIHJBcmMgPSBkaXNhcHBlYXJpbmdbbkFyY3MgLSAxXTtcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgbnVsbCwgdmVydGV4KTtcblxuICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gIGF0dGFjaENpcmNsZShyQXJjKTtcbn1cblxuZnVuY3Rpb24gYWRkQmVhY2goc2l0ZSkge1xuICB2YXIgeCA9IHNpdGVbMF0sXG4gICAgICBkaXJlY3RyaXggPSBzaXRlWzFdLFxuICAgICAgbEFyYyxcbiAgICAgIHJBcmMsXG4gICAgICBkeGwsXG4gICAgICBkeHIsXG4gICAgICBub2RlID0gYmVhY2hlcy5fO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgZHhsID0gbGVmdEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KSAtIHg7XG4gICAgaWYgKGR4bCA+IGVwc2lsb24pIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgZHhyID0geCAtIHJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgaWYgKGR4ciA+IGVwc2lsb24pIHtcbiAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGR4bCA+IC1lcHNpbG9uKSB7XG4gICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICByQXJjID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChkeHIgPiAtZXBzaWxvbikge1xuICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNlbGwoc2l0ZSk7XG4gIHZhciBuZXdBcmMgPSBjcmVhdGVCZWFjaChzaXRlKTtcbiAgYmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcblxuICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcblxuICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgIGRldGFjaENpcmNsZShsQXJjKTtcbiAgICByQXJjID0gY3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICBiZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghckFyYykgeyAvLyAmJiBsQXJjXG4gICAgbmV3QXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVsc2UgbEFyYyAhPT0gckFyY1xuICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gIGRldGFjaENpcmNsZShyQXJjKTtcblxuICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsXG4gICAgICBheCA9IGxTaXRlWzBdLFxuICAgICAgYXkgPSBsU2l0ZVsxXSxcbiAgICAgIGJ4ID0gc2l0ZVswXSAtIGF4LFxuICAgICAgYnkgPSBzaXRlWzFdIC0gYXksXG4gICAgICByU2l0ZSA9IHJBcmMuc2l0ZSxcbiAgICAgIGN4ID0gclNpdGVbMF0gLSBheCxcbiAgICAgIGN5ID0gclNpdGVbMV0gLSBheSxcbiAgICAgIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSxcbiAgICAgIGhiID0gYnggKiBieCArIGJ5ICogYnksXG4gICAgICBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgdmVydGV4ID0gWyhjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsIChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXldO1xuXG4gIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCk7XG4gIG5ld0FyYy5lZGdlID0gY3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICBhdHRhY2hDaXJjbGUockFyYyk7XG59XG5cbmZ1bmN0aW9uIGxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gIHZhciBzaXRlID0gYXJjLnNpdGUsXG4gICAgICByZm9jeCA9IHNpdGVbMF0sXG4gICAgICByZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG5cbiAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG5cbiAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgaWYgKCFsQXJjKSByZXR1cm4gLUluZmluaXR5O1xuXG4gIHNpdGUgPSBsQXJjLnNpdGU7XG4gIHZhciBsZm9jeCA9IHNpdGVbMF0sXG4gICAgICBsZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuXG4gIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcblxuICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LFxuICAgICAgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLFxuICAgICAgYiA9IGhsIC8gcGxieTI7XG5cbiAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuXG4gIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xufVxuXG5mdW5jdGlvbiByaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgaWYgKHJBcmMpIHJldHVybiBsZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICByZXR1cm4gc2l0ZVsxXSA9PT0gZGlyZWN0cml4ID8gc2l0ZVswXSA6IEluZmluaXR5O1xufVxuXG52YXIgZXBzaWxvbiA9IDFlLTY7XG52YXIgZXBzaWxvbjIgPSAxZS0xMjtcbnZhciBiZWFjaGVzO1xudmFyIGNlbGxzO1xudmFyIGNpcmNsZXM7XG52YXIgZWRnZXM7XG5cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gIHJldHVybiAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBhWzFdKSAtIChhWzBdIC0gYlswXSkgKiAoY1sxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiBsZXhpY29ncmFwaGljKGEsIGIpIHtcbiAgcmV0dXJuIGJbMV0gLSBhWzFdXG4gICAgICB8fCBiWzBdIC0gYVswXTtcbn1cblxuZnVuY3Rpb24gRGlhZ3JhbShzaXRlcywgZXh0ZW50KSB7XG4gIHZhciBzaXRlID0gc2l0ZXMuc29ydChsZXhpY29ncmFwaGljKS5wb3AoKSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2lyY2xlO1xuXG4gIGVkZ2VzID0gW107XG4gIGNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gIGJlYWNoZXMgPSBuZXcgUmVkQmxhY2tUcmVlO1xuICBjaXJjbGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNpcmNsZSA9IGZpcnN0Q2lyY2xlO1xuICAgIGlmIChzaXRlICYmICghY2lyY2xlIHx8IHNpdGVbMV0gPCBjaXJjbGUueSB8fCAoc2l0ZVsxXSA9PT0gY2lyY2xlLnkgJiYgc2l0ZVswXSA8IGNpcmNsZS54KSkpIHtcbiAgICAgIGlmIChzaXRlWzBdICE9PSB4IHx8IHNpdGVbMV0gIT09IHkpIHtcbiAgICAgICAgYWRkQmVhY2goc2l0ZSk7XG4gICAgICAgIHggPSBzaXRlWzBdLCB5ID0gc2l0ZVsxXTtcbiAgICAgIH1cbiAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKGNpcmNsZSkge1xuICAgICAgcmVtb3ZlQmVhY2goY2lyY2xlLmFyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNvcnRDZWxsSGFsZmVkZ2VzKCk7XG5cbiAgaWYgKGV4dGVudCkge1xuICAgIHZhciB4MCA9ICtleHRlbnRbMF1bMF0sXG4gICAgICAgIHkwID0gK2V4dGVudFswXVsxXSxcbiAgICAgICAgeDEgPSArZXh0ZW50WzFdWzBdLFxuICAgICAgICB5MSA9ICtleHRlbnRbMV1bMV07XG4gICAgY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKTtcbiAgICBjbGlwQ2VsbHMoeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB0aGlzLmNlbGxzID0gY2VsbHM7XG5cbiAgYmVhY2hlcyA9XG4gIGNpcmNsZXMgPVxuICBlZGdlcyA9XG4gIGNlbGxzID0gbnVsbDtcbn1cblxuRGlhZ3JhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaWFncmFtLFxuXG4gIHBvbHlnb25zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuXG4gICAgcmV0dXJuIHRoaXMuY2VsbHMubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gY2VsbC5oYWxmZWRnZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2VzW2ldKTsgfSk7XG4gICAgICBwb2x5Z29uLmRhdGEgPSBjZWxsLnNpdGUuZGF0YTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH0pO1xuICB9LFxuXG4gIHRyaWFuZ2xlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdLFxuICAgICAgICBlZGdlcyA9IHRoaXMuZWRnZXM7XG5cbiAgICB0aGlzLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgaWYgKCEobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSkgcmV0dXJuO1xuICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsXG4gICAgICAgICAgaGFsZmVkZ2VzLFxuICAgICAgICAgIGogPSAtMSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHMwLFxuICAgICAgICAgIGUxID0gZWRnZXNbaGFsZmVkZ2VzW20gLSAxXV0sXG4gICAgICAgICAgczEgPSBlMS5sZWZ0ID09PSBzaXRlID8gZTEucmlnaHQgOiBlMS5sZWZ0O1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1tqXV07XG4gICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcbiAgICAgICAgaWYgKHMwICYmIHMxICYmIGkgPCBzMC5pbmRleCAmJiBpIDwgczEuaW5kZXggJiYgdHJpYW5nbGVBcmVhKHNpdGUsIHMwLCBzMSkgPCAwKSB7XG4gICAgICAgICAgdHJpYW5nbGVzLnB1c2goW3NpdGUuZGF0YSwgczAuZGF0YSwgczEuZGF0YV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xuICB9LFxuXG4gIGxpbmtzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucmlnaHQ7XG4gICAgfSkubWFwKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogZWRnZS5sZWZ0LmRhdGEsXG4gICAgICAgIHRhcmdldDogZWRnZS5yaWdodC5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgIHZhciB0aGF0ID0gdGhpcywgaTAsIGkxID0gdGhhdC5fZm91bmQgfHwgMCwgbiA9IHRoYXQuY2VsbHMubGVuZ3RoLCBjZWxsO1xuXG4gICAgLy8gVXNlIHRoZSBwcmV2aW91c2x5LWZvdW5kIGNlbGwsIG9yIHN0YXJ0IHdpdGggYW4gYXJiaXRyYXJ5IG9uZS5cbiAgICB3aGlsZSAoIShjZWxsID0gdGhhdC5jZWxsc1tpMV0pKSBpZiAoKytpMSA+PSBuKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZHggPSB4IC0gY2VsbC5zaXRlWzBdLCBkeSA9IHkgLSBjZWxsLnNpdGVbMV0sIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgaGFsZi1lZGdlcyB0byBmaW5kIGEgY2xvc2VyIGNlbGwsIGlmIGFueS5cbiAgICBkbyB7XG4gICAgICBjZWxsID0gdGhhdC5jZWxsc1tpMCA9IGkxXSwgaTEgPSBudWxsO1xuICAgICAgY2VsbC5oYWxmZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlZGdlID0gdGhhdC5lZGdlc1tlXSwgdiA9IGVkZ2UubGVmdDtcbiAgICAgICAgaWYgKCh2ID09PSBjZWxsLnNpdGUgfHwgIXYpICYmICEodiA9IGVkZ2UucmlnaHQpKSByZXR1cm47XG4gICAgICAgIHZhciB2eCA9IHggLSB2WzBdLCB2eSA9IHkgLSB2WzFdLCB2MiA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgICAgICBpZiAodjIgPCBkMikgZDIgPSB2MiwgaTEgPSB2LmluZGV4O1xuICAgICAgfSk7XG4gICAgfSB3aGlsZSAoaTEgIT09IG51bGwpO1xuXG4gICAgdGhhdC5fZm91bmQgPSBpMDtcblxuICAgIHJldHVybiByYWRpdXMgPT0gbnVsbCB8fCBkMiA8PSByYWRpdXMgKiByYWRpdXMgPyBjZWxsLnNpdGUgOiBudWxsO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2b3Jvbm9pKCkge1xuICB2YXIgeCQkMSA9IHgsXG4gICAgICB5JCQxID0geSxcbiAgICAgIGV4dGVudCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdm9yb25vaShkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBEaWFncmFtKGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBzID0gW01hdGgucm91bmQoeCQkMShkLCBpLCBkYXRhKSAvIGVwc2lsb24pICogZXBzaWxvbiwgTWF0aC5yb3VuZCh5JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbikgKiBlcHNpbG9uXTtcbiAgICAgIHMuaW5kZXggPSBpO1xuICAgICAgcy5kYXRhID0gZDtcbiAgICAgIHJldHVybiBzO1xuICAgIH0pLCBleHRlbnQpO1xuICB9XG5cbiAgdm9yb25vaS5wb2x5Z29ucyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdm9yb25vaShkYXRhKS5wb2x5Z29ucygpO1xuICB9O1xuXG4gIHZvcm9ub2kubGlua3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkubGlua3MoKTtcbiAgfTtcblxuICB2b3Jvbm9pLnRyaWFuZ2xlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdm9yb25vaShkYXRhKS50cmlhbmdsZXMoKTtcbiAgfTtcblxuICB2b3Jvbm9pLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB2b3Jvbm9pKSA6IHgkJDE7XG4gIH07XG5cbiAgdm9yb25vaS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgdm9yb25vaSkgOiB5JCQxO1xuICB9O1xuXG4gIHZvcm9ub2kuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IF8gPT0gbnVsbCA/IG51bGwgOiBbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW1tleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXV0sIFtleHRlbnRbMV1bMF0sIGV4dGVudFsxXVsxXV1dO1xuICB9O1xuXG4gIHZvcm9ub2kuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSBfID09IG51bGwgPyBudWxsIDogW1swLCAwXSwgWytfWzBdLCArX1sxXV1dLCB2b3Jvbm9pKSA6IGV4dGVudCAmJiBbZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdLCBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV1dO1xuICB9O1xuXG4gIHJldHVybiB2b3Jvbm9pO1xufVxuXG5leHBvcnRzLnZvcm9ub2kgPSB2b3Jvbm9pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy16b29tLyB2MS44LjMgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy1kcmFnJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy10cmFuc2l0aW9uJykpIDpcbnR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtZGlzcGF0Y2gnLCAnZDMtZHJhZycsICdkMy1pbnRlcnBvbGF0ZScsICdkMy1zZWxlY3Rpb24nLCAnZDMtdHJhbnNpdGlvbiddLCBmYWN0b3J5KSA6XG4oZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9LCBnbG9iYWwuZDMsIGdsb2JhbC5kMywgZ2xvYmFsLmQzLCBnbG9iYWwuZDMsIGdsb2JhbC5kMykpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cywgZDNEaXNwYXRjaCwgZDNEcmFnLCBkM0ludGVycG9sYXRlLCBkM1NlbGVjdGlvbiwgZDNUcmFuc2l0aW9uKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFpvb21FdmVudCh0YXJnZXQsIHR5cGUsIHRyYW5zZm9ybSkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxudmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHdoaWxlICghbm9kZS5fX3pvb20pIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHJldHVybiBub2RlLl9fem9vbTtcbn1cblxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbigpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5vZXZlbnQoKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoKSB7XG4gIHJldHVybiAhZDNTZWxlY3Rpb24uZXZlbnQuY3RybEtleSAmJiAhZDNTZWxlY3Rpb24uZXZlbnQuYnV0dG9uO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RXh0ZW50KCkge1xuICB2YXIgZSA9IHRoaXM7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIGlmIChlLmhhc0F0dHJpYnV0ZShcInZpZXdCb3hcIikpIHtcbiAgICAgIGUgPSBlLnZpZXdCb3guYmFzZVZhbDtcbiAgICAgIHJldHVybiBbW2UueCwgZS55XSwgW2UueCArIGUud2lkdGgsIGUueSArIGUuaGVpZ2h0XV07XG4gICAgfVxuICAgIHJldHVybiBbWzAsIDBdLCBbZS53aWR0aC5iYXNlVmFsLnZhbHVlLCBlLmhlaWdodC5iYXNlVmFsLnZhbHVlXV07XG4gIH1cbiAgcmV0dXJuIFtbMCwgMF0sIFtlLmNsaWVudFdpZHRoLCBlLmNsaWVudEhlaWdodF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXaGVlbERlbHRhKCkge1xuICByZXR1cm4gLWQzU2VsZWN0aW9uLmV2ZW50LmRlbHRhWSAqIChkM1NlbGVjdGlvbi5ldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZDNTZWxlY3Rpb24uZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSB7XG4gIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzBdLFxuICAgICAgZHgxID0gdHJhbnNmb3JtLmludmVydFgoZXh0ZW50WzFdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVswXSxcbiAgICAgIGR5MCA9IHRyYW5zZm9ybS5pbnZlcnRZKGV4dGVudFswXVsxXSkgLSB0cmFuc2xhdGVFeHRlbnRbMF1bMV0sXG4gICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzFdWzFdO1xuICByZXR1cm4gdHJhbnNmb3JtLnRyYW5zbGF0ZShcbiAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgZHkxID4gZHkwID8gKGR5MCArIGR5MSkgLyAyIDogTWF0aC5taW4oMCwgZHkwKSB8fCBNYXRoLm1heCgwLCBkeTEpXG4gICk7XG59XG5cbmZ1bmN0aW9uIHpvb20oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgZXh0ZW50ID0gZGVmYXVsdEV4dGVudCxcbiAgICAgIGNvbnN0cmFpbiA9IGRlZmF1bHRDb25zdHJhaW4sXG4gICAgICB3aGVlbERlbHRhID0gZGVmYXVsdFdoZWVsRGVsdGEsXG4gICAgICB0b3VjaGFibGUgPSBkZWZhdWx0VG91Y2hhYmxlLFxuICAgICAgc2NhbGVFeHRlbnQgPSBbMCwgSW5maW5pdHldLFxuICAgICAgdHJhbnNsYXRlRXh0ZW50ID0gW1stSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHldXSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlWm9vbSxcbiAgICAgIGxpc3RlbmVycyA9IGQzRGlzcGF0Y2guZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiB6b29tKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSlcbiAgICAgICAgLm9uKFwid2hlZWwuem9vbVwiLCB3aGVlbGVkKVxuICAgICAgICAub24oXCJtb3VzZWRvd24uem9vbVwiLCBtb3VzZWRvd25lZClcbiAgICAgICAgLm9uKFwiZGJsY2xpY2suem9vbVwiLCBkYmxjbGlja2VkKVxuICAgICAgLmZpbHRlcih0b3VjaGFibGUpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS56b29tXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICB6b29tLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSwgcG9pbnQpIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gY29sbGVjdGlvbi5zZWxlY3Rpb24gPyBjb2xsZWN0aW9uLnNlbGVjdGlvbigpIDogY29sbGVjdGlvbjtcbiAgICBzZWxlY3Rpb24ucHJvcGVydHkoXCJfX3pvb21cIiwgZGVmYXVsdFRyYW5zZm9ybSk7XG4gICAgaWYgKGNvbGxlY3Rpb24gIT09IHNlbGVjdGlvbikge1xuICAgICAgc2NoZWR1bGUoY29sbGVjdGlvbiwgdHJhbnNmb3JtLCBwb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcbiAgICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGssIHApIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0sIHApO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaywgcCkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwLFxuICAgICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgICBrMSA9IHR5cGVvZiBrID09PSBcImZ1bmN0aW9uXCIgPyBrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodDAsIGsxKSwgcDAsIHAxKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwKTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUJ5ID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb25zdHJhaW4odGhpcy5fX3pvb20udHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IHkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHlcbiAgICAgICksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlVG8gPSBmdW5jdGlvbihzZWxlY3Rpb24sIHgsIHksIHApIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGUgPSBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBwID09IG51bGwgPyBjZW50cm9pZChlKSA6IHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBwO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbihpZGVudGl0eS50cmFuc2xhdGUocDBbMF0sIHAwWzFdKS5zY2FsZSh0LmspLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IC14LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteCxcbiAgICAgICAgdHlwZW9mIHkgPT09IFwiZnVuY3Rpb25cIiA/IC15LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiAteVxuICAgICAgKSwgZSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9LCBwKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzY2FsZSh0cmFuc2Zvcm0sIGspIHtcbiAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCBrKSk7XG4gICAgcmV0dXJuIGsgPT09IHRyYW5zZm9ybS5rID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybShrLCB0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHRyYW5zZm9ybSwgcDAsIHAxKSB7XG4gICAgdmFyIHggPSBwMFswXSAtIHAxWzBdICogdHJhbnNmb3JtLmssIHkgPSBwMFsxXSAtIHAxWzFdICogdHJhbnNmb3JtLms7XG4gICAgcmV0dXJuIHggPT09IHRyYW5zZm9ybS54ICYmIHkgPT09IHRyYW5zZm9ybS55ID8gdHJhbnNmb3JtIDogbmV3IFRyYW5zZm9ybSh0cmFuc2Zvcm0uaywgeCwgeSk7XG4gIH1cblxuICBmdW5jdGlvbiBjZW50cm9pZChleHRlbnQpIHtcbiAgICByZXR1cm4gWygrZXh0ZW50WzBdWzBdICsgK2V4dGVudFsxXVswXSkgLyAyLCAoK2V4dGVudFswXVsxXSArICtleHRlbnRbMV1bMV0pIC8gMl07XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZSh0cmFuc2l0aW9uLCB0cmFuc2Zvcm0sIHBvaW50KSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5lbmQoKTsgfSlcbiAgICAgICAgLnR3ZWVuKFwiem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGcgPSBnZXN0dXJlKHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gcG9pbnQgPT0gbnVsbCA/IGNlbnRyb2lkKGUpIDogdHlwZW9mIHBvaW50ID09PSBcImZ1bmN0aW9uXCIgPyBwb2ludC5hcHBseSh0aGF0LCBhcmdzKSA6IHBvaW50LFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MsIGNsZWFuKSB7XG4gICAgcmV0dXJuICghY2xlYW4gJiYgdGhhdC5fX3pvb21pbmcpIHx8IG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB0aGlzLmV4dGVudCA9IGV4dGVudC5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB0aGlzLnRhcHMgPSAwO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy50aGF0Ll9fem9vbWluZyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aGF0Ll9fem9vbWluZztcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBkM1NlbGVjdGlvbi5jdXN0b21FdmVudChuZXcgWm9vbUV2ZW50KHpvb20sIHR5cGUsIHRoaXMudGhhdC5fX3pvb20pLCBsaXN0ZW5lcnMuYXBwbHksIGxpc3RlbmVycywgW3R5cGUsIHRoaXMudGhhdCwgdGhpcy5hcmdzXSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdoZWVsZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHQuayAqIE1hdGgucG93KDIsIHdoZWVsRGVsdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpKSxcbiAgICAgICAgcCA9IGQzU2VsZWN0aW9uLm1vdXNlKHRoaXMpO1xuXG4gICAgLy8gSWYgdGhlIG1vdXNlIGlzIGluIHRoZSBzYW1lIGxvY2F0aW9uIGFzIGJlZm9yZSwgcmV1c2UgaXQuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSByZWNlbnQgd2hlZWwgZXZlbnRzLCByZXNldCB0aGUgd2hlZWwgaWRsZSB0aW1lb3V0LlxuICAgIGlmIChnLndoZWVsKSB7XG4gICAgICBpZiAoZy5tb3VzZVswXVswXSAhPT0gcFswXSB8fCBnLm1vdXNlWzBdWzFdICE9PSBwWzFdKSB7XG4gICAgICAgIGcubW91c2VbMV0gPSB0LmludmVydChnLm1vdXNlWzBdID0gcCk7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQoZy53aGVlbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyB3aGVlbCBldmVudCB3b27igJl0IHRyaWdnZXIgYSB0cmFuc2Zvcm0gY2hhbmdlLCBpZ25vcmUgaXQuXG4gICAgZWxzZSBpZiAodC5rID09PSBrKSByZXR1cm47XG5cbiAgICAvLyBPdGhlcndpc2UsIGNhcHR1cmUgdGhlIG1vdXNlIHBvaW50IGFuZCBsb2NhdGlvbiBhdCB0aGUgc3RhcnQuXG4gICAgZWxzZSB7XG4gICAgICBnLm1vdXNlID0gW3AsIHQuaW52ZXJ0KHApXTtcbiAgICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhpcyk7XG4gICAgICBnLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgbm9ldmVudCgpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG5cbiAgICBmdW5jdGlvbiB3aGVlbGlkbGVkKCkge1xuICAgICAgZy53aGVlbCA9IG51bGw7XG4gICAgICBnLmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgIGlmICh0b3VjaGVuZGluZyB8fCAhZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzLCB0cnVlKSxcbiAgICAgICAgdiA9IGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gZDNTZWxlY3Rpb24ubW91c2UodGhpcyksXG4gICAgICAgIHgwID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WCxcbiAgICAgICAgeTAgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZO1xuXG4gICAgZDNEcmFnLmRyYWdEaXNhYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBnLm1vdXNlID0gW3AsIHRoaXMuX196b29tLmludmVydChwKV07XG4gICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgICAgbm9ldmVudCgpO1xuICAgICAgaWYgKCFnLm1vdmVkKSB7XG4gICAgICAgIHZhciBkeCA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFggLSB4MCwgZHkgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShnLnRoYXQuX196b29tLCBnLm1vdXNlWzBdID0gZDNTZWxlY3Rpb24ubW91c2UoZy50aGF0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xuICAgICAgdi5vbihcIm1vdXNlbW92ZS56b29tIG1vdXNldXAuem9vbVwiLCBudWxsKTtcbiAgICAgIGQzRHJhZy5kcmFnRW5hYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcsIGcubW92ZWQpO1xuICAgICAgbm9ldmVudCgpO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkYmxjbGlja2VkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdDAgPSB0aGlzLl9fem9vbSxcbiAgICAgICAgcDAgPSBkM1NlbGVjdGlvbi5tb3VzZSh0aGlzKSxcbiAgICAgICAgcDEgPSB0MC5pbnZlcnQocDApLFxuICAgICAgICBrMSA9IHQwLmsgKiAoZDNTZWxlY3Rpb24uZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0cmFuc2xhdGVFeHRlbnQpO1xuXG4gICAgbm9ldmVudCgpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIGQzU2VsZWN0aW9uLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCk7XG4gICAgZWxzZSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzLCBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IG4pLFxuICAgICAgICBzdGFydGVkLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gZDNTZWxlY3Rpb24udG91Y2godGhpcywgdG91Y2hlcywgdC5pZGVudGlmaWVyKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZSwgZy50YXBzID0gMSArICEhdG91Y2hzdGFydGluZztcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSAmJiBnLnRvdWNoMFsyXSAhPT0gcFsyXSkgZy50b3VjaDEgPSBwLCBnLnRhcHMgPSAwO1xuICAgIH1cblxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuXG4gICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgIGlmIChnLnRhcHMgPCAyKSB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIGlmICghdGhpcy5fX3pvb21pbmcpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIHQsIHAsIGw7XG5cbiAgICBub2V2ZW50KCk7XG4gICAgaWYgKHRvdWNoc3RhcnRpbmcpIHRvdWNoc3RhcnRpbmcgPSBjbGVhclRpbWVvdXQodG91Y2hzdGFydGluZyk7XG4gICAgZy50YXBzID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IGQzU2VsZWN0aW9uLnRvdWNoKHRoaXMsIHRvdWNoZXMsIHQuaWRlbnRpZmllcik7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9fem9vbWluZykgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdDtcblxuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldO1xuICAgICAgaWYgKGcudG91Y2gwICYmIGcudG91Y2gwWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMDtcbiAgICAgIGVsc2UgaWYgKGcudG91Y2gxICYmIGcudG91Y2gxWzJdID09PSB0LmlkZW50aWZpZXIpIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICB9XG4gICAgaWYgKGcudG91Y2gxICYmICFnLnRvdWNoMCkgZy50b3VjaDAgPSBnLnRvdWNoMSwgZGVsZXRlIGcudG91Y2gxO1xuICAgIGlmIChnLnRvdWNoMCkgZy50b3VjaDBbMV0gPSB0aGlzLl9fem9vbS5pbnZlcnQoZy50b3VjaDBbMF0pO1xuICAgIGVsc2Uge1xuICAgICAgZy5lbmQoKTtcbiAgICAgIC8vIElmIHRoaXMgd2FzIGEgZGJsdGFwLCByZXJvdXRlIHRvIHRoZSAob3B0aW9uYWwpIGRibGNsaWNrLnpvb20gaGFuZGxlci5cbiAgICAgIGlmIChnLnRhcHMgPT09IDIpIHtcbiAgICAgICAgdmFyIHAgPSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcykub24oXCJkYmxjbGljay56b29tXCIpO1xuICAgICAgICBpZiAocCkgcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHpvb20ud2hlZWxEZWx0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh3aGVlbERlbHRhID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHpvb20pIDogd2hlZWxEZWx0YTtcbiAgfTtcblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20udG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgem9vbS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSksIHpvb20pIDogZXh0ZW50O1xuICB9O1xuXG4gIHpvb20uc2NhbGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2NhbGVFeHRlbnRbMF0gPSArX1swXSwgc2NhbGVFeHRlbnRbMV0gPSArX1sxXSwgem9vbSkgOiBbc2NhbGVFeHRlbnRbMF0sIHNjYWxlRXh0ZW50WzFdXTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGVFeHRlbnRbMF1bMF0gPSArX1swXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzBdID0gK19bMV1bMF0sIHRyYW5zbGF0ZUV4dGVudFswXVsxXSA9ICtfWzBdWzFdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV0gPSArX1sxXVsxXSwgem9vbSkgOiBbW3RyYW5zbGF0ZUV4dGVudFswXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdXSwgW3RyYW5zbGF0ZUV4dGVudFsxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzFdWzFdXV07XG4gIH07XG5cbiAgem9vbS5jb25zdHJhaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29uc3RyYWluID0gXywgem9vbSkgOiBjb25zdHJhaW47XG4gIH07XG5cbiAgem9vbS5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkdXJhdGlvbiA9ICtfLCB6b29tKSA6IGR1cmF0aW9uO1xuICB9O1xuXG4gIHpvb20uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCB6b29tKSA6IGludGVycG9sYXRlO1xuICB9O1xuXG4gIHpvb20ub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gem9vbSA6IHZhbHVlO1xuICB9O1xuXG4gIHpvb20uY2xpY2tEaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlja0Rpc3RhbmNlMiA9IChfID0gK18pICogXywgem9vbSkgOiBNYXRoLnNxcnQoY2xpY2tEaXN0YW5jZTIpO1xuICB9O1xuXG4gIHJldHVybiB6b29tO1xufVxuXG5leHBvcnRzLnpvb20gPSB6b29tO1xuZXhwb3J0cy56b29tSWRlbnRpdHkgPSBpZGVudGl0eTtcbmV4cG9ydHMuem9vbVRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZDNBcnJheSA9IHJlcXVpcmUoJ2QzLWFycmF5Jyk7XG52YXIgZDNBeGlzID0gcmVxdWlyZSgnZDMtYXhpcycpO1xudmFyIGQzQnJ1c2ggPSByZXF1aXJlKCdkMy1icnVzaCcpO1xudmFyIGQzQ2hvcmQgPSByZXF1aXJlKCdkMy1jaG9yZCcpO1xudmFyIGQzQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ2QzLWNvbGxlY3Rpb24nKTtcbnZhciBkM0NvbG9yID0gcmVxdWlyZSgnZDMtY29sb3InKTtcbnZhciBkM0NvbnRvdXIgPSByZXF1aXJlKCdkMy1jb250b3VyJyk7XG52YXIgZDNEaXNwYXRjaCA9IHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyk7XG52YXIgZDNEcmFnID0gcmVxdWlyZSgnZDMtZHJhZycpO1xudmFyIGQzRHN2ID0gcmVxdWlyZSgnZDMtZHN2Jyk7XG52YXIgZDNFYXNlID0gcmVxdWlyZSgnZDMtZWFzZScpO1xudmFyIGQzRmV0Y2ggPSByZXF1aXJlKCdkMy1mZXRjaCcpO1xudmFyIGQzRm9yY2UgPSByZXF1aXJlKCdkMy1mb3JjZScpO1xudmFyIGQzRm9ybWF0ID0gcmVxdWlyZSgnZDMtZm9ybWF0Jyk7XG52YXIgZDNHZW8gPSByZXF1aXJlKCdkMy1nZW8nKTtcbnZhciBkM0hpZXJhcmNoeSA9IHJlcXVpcmUoJ2QzLWhpZXJhcmNoeScpO1xudmFyIGQzSW50ZXJwb2xhdGUgPSByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpO1xudmFyIGQzUGF0aCA9IHJlcXVpcmUoJ2QzLXBhdGgnKTtcbnZhciBkM1BvbHlnb24gPSByZXF1aXJlKCdkMy1wb2x5Z29uJyk7XG52YXIgZDNRdWFkdHJlZSA9IHJlcXVpcmUoJ2QzLXF1YWR0cmVlJyk7XG52YXIgZDNSYW5kb20gPSByZXF1aXJlKCdkMy1yYW5kb20nKTtcbnZhciBkM1NjYWxlID0gcmVxdWlyZSgnZDMtc2NhbGUnKTtcbnZhciBkM1NjYWxlQ2hyb21hdGljID0gcmVxdWlyZSgnZDMtc2NhbGUtY2hyb21hdGljJyk7XG52YXIgZDNTZWxlY3Rpb24gPSByZXF1aXJlKCdkMy1zZWxlY3Rpb24nKTtcbnZhciBkM1NoYXBlID0gcmVxdWlyZSgnZDMtc2hhcGUnKTtcbnZhciBkM1RpbWUgPSByZXF1aXJlKCdkMy10aW1lJyk7XG52YXIgZDNUaW1lRm9ybWF0ID0gcmVxdWlyZSgnZDMtdGltZS1mb3JtYXQnKTtcbnZhciBkM1RpbWVyID0gcmVxdWlyZSgnZDMtdGltZXInKTtcbnZhciBkM1RyYW5zaXRpb24gPSByZXF1aXJlKCdkMy10cmFuc2l0aW9uJyk7XG52YXIgZDNWb3Jvbm9pID0gcmVxdWlyZSgnZDMtdm9yb25vaScpO1xudmFyIGQzWm9vbSA9IHJlcXVpcmUoJ2QzLXpvb20nKTtcblxudmFyIHZlcnNpb24gPSBcIjUuMTUuMFwiO1xuXG5PYmplY3Qua2V5cyhkM0FycmF5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0FycmF5W2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzQXhpcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNBeGlzW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzQnJ1c2gpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzQnJ1c2hba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNDaG9yZCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNDaG9yZFtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0NvbGxlY3Rpb24pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzQ29sbGVjdGlvbltrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0NvbG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0NvbG9yW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzQ29udG91cikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNDb250b3VyW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzRGlzcGF0Y2gpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzRGlzcGF0Y2hba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNEcmFnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0RyYWdba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNEc3YpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzRHN2W2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzRWFzZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNFYXNlW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzRmV0Y2gpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzRmV0Y2hba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNGb3JjZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNGb3JjZVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0Zvcm1hdCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNGb3JtYXRba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNHZW8pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzR2VvW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzSGllcmFyY2h5KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0hpZXJhcmNoeVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM0ludGVycG9sYXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM0ludGVycG9sYXRlW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzUGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNQYXRoW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzUG9seWdvbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNQb2x5Z29uW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzUXVhZHRyZWUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzUXVhZHRyZWVba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNSYW5kb20pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzUmFuZG9tW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzU2NhbGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzU2NhbGVba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNTY2FsZUNocm9tYXRpYykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNTY2FsZUNocm9tYXRpY1trXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1NlbGVjdGlvbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNTZWxlY3Rpb25ba107XG5cdFx0fVxuXHR9KTtcbn0pO1xuT2JqZWN0LmtleXMoZDNTaGFwZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNTaGFwZVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1RpbWUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzVGltZVtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1RpbWVGb3JtYXQpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JykgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGssIHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGQzVGltZUZvcm1hdFtrXTtcblx0XHR9XG5cdH0pO1xufSk7XG5PYmplY3Qua2V5cyhkM1RpbWVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBkM1RpbWVyW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzVHJhbnNpdGlvbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNUcmFuc2l0aW9uW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzVm9yb25vaSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNWb3Jvbm9pW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbk9iamVjdC5rZXlzKGQzWm9vbSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgaywge1xuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gZDNab29tW2tdO1xuXHRcdH1cblx0fSk7XG59KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB3cmFwSWRiVmFsdWUgPSByZXF1aXJlKCcuL3dyYXAtaWRiLXZhbHVlLmpzJyk7XG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIEFkZGl0aW9uYWwgY2FsbGJhY2tzLlxuICovXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSwgdmVyc2lvbik7XG4gICAgY29uc3Qgb3BlblByb21pc2UgPSB3cmFwSWRiVmFsdWUud3JhcChyZXF1ZXN0KTtcbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3VwZ3JhZGVuZWVkZWQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHVwZ3JhZGUod3JhcElkYlZhbHVlLndyYXAocmVxdWVzdC5yZXN1bHQpLCBldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCB3cmFwSWRiVmFsdWUud3JhcChyZXF1ZXN0LnRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlZClcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKCkgPT4gYmxvY2tlZCgpKTtcbiAgICBvcGVuUHJvbWlzZVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgaWYgKHRlcm1pbmF0ZWQpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHRlcm1pbmF0ZWQoKSk7XG4gICAgICAgIGlmIChibG9ja2luZylcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ3ZlcnNpb25jaGFuZ2UnLCAoKSA9PiBibG9ja2luZygpKTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICByZXR1cm4gb3BlblByb21pc2U7XG59XG4vKipcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBkZWxldGVEQihuYW1lLCB7IGJsb2NrZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKTtcbiAgICBpZiAoYmxvY2tlZClcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKCkgPT4gYmxvY2tlZCgpKTtcbiAgICByZXR1cm4gd3JhcElkYlZhbHVlLndyYXAocmVxdWVzdCkudGhlbigoKSA9PiB1bmRlZmluZWQpO1xufVxuXG5jb25zdCByZWFkTWV0aG9kcyA9IFsnZ2V0JywgJ2dldEtleScsICdnZXRBbGwnLCAnZ2V0QWxsS2V5cycsICdjb3VudCddO1xuY29uc3Qgd3JpdGVNZXRob2RzID0gWydwdXQnLCAnYWRkJywgJ2RlbGV0ZScsICdjbGVhciddO1xuY29uc3QgY2FjaGVkTWV0aG9kcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHtcbiAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBJREJEYXRhYmFzZSAmJlxuICAgICAgICAhKHByb3AgaW4gdGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApKVxuICAgICAgICByZXR1cm4gY2FjaGVkTWV0aG9kcy5nZXQocHJvcCk7XG4gICAgY29uc3QgdGFyZ2V0RnVuY05hbWUgPSBwcm9wLnJlcGxhY2UoL0Zyb21JbmRleCQvLCAnJyk7XG4gICAgY29uc3QgdXNlSW5kZXggPSBwcm9wICE9PSB0YXJnZXRGdW5jTmFtZTtcbiAgICBjb25zdCBpc1dyaXRlID0gd3JpdGVNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKTtcbiAgICBpZiAoXG4gICAgLy8gQmFpbCBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHRhcmdldC4gRWcsIGdldEFsbCBpc24ndCBpbiBFZGdlLlxuICAgICEodGFyZ2V0RnVuY05hbWUgaW4gKHVzZUluZGV4ID8gSURCSW5kZXggOiBJREJPYmplY3RTdG9yZSkucHJvdG90eXBlKSB8fFxuICAgICAgICAhKGlzV3JpdGUgfHwgcmVhZE1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IGFzeW5jIGZ1bmN0aW9uIChzdG9yZU5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogdW5kZWZpbmVkIGd6aXBwcyBiZXR0ZXIsIGJ1dCBmYWlscyBpbiBFZGdlIDooXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy50cmFuc2FjdGlvbihzdG9yZU5hbWUsIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6ICdyZWFkb25seScpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdHguc3RvcmU7XG4gICAgICAgIGlmICh1c2VJbmRleClcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbmRleChhcmdzLnNoaWZ0KCkpO1xuICAgICAgICAvLyBNdXN0IHJlamVjdCBpZiBvcCByZWplY3RzLlxuICAgICAgICAvLyBJZiBpdCdzIGEgd3JpdGUgb3BlcmF0aW9uLCBtdXN0IHJlamVjdCBpZiB0eC5kb25lIHJlamVjdHMuXG4gICAgICAgIC8vIE11c3QgcmVqZWN0IHdpdGggb3AgcmVqZWN0aW9uIGZpcnN0LlxuICAgICAgICAvLyBNdXN0IHJlc29sdmUgd2l0aCBvcCB2YWx1ZS5cbiAgICAgICAgLy8gTXVzdCBoYW5kbGUgYm90aCBwcm9taXNlcyAobm8gdW5oYW5kbGVkIHJlamVjdGlvbnMpXG4gICAgICAgIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGFyZ2V0W3RhcmdldEZ1bmNOYW1lXSguLi5hcmdzKSxcbiAgICAgICAgICAgIGlzV3JpdGUgJiYgdHguZG9uZSxcbiAgICAgICAgXSkpWzBdO1xuICAgIH07XG4gICAgY2FjaGVkTWV0aG9kcy5zZXQocHJvcCwgbWV0aG9kKTtcbiAgICByZXR1cm4gbWV0aG9kO1xufVxud3JhcElkYlZhbHVlLnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuZXhwb3J0cy51bndyYXAgPSB3cmFwSWRiVmFsdWUudW53cmFwO1xuZXhwb3J0cy53cmFwID0gd3JhcElkYlZhbHVlLndyYXA7XG5leHBvcnRzLmRlbGV0ZURCID0gZGVsZXRlREI7XG5leHBvcnRzLm9wZW5EQiA9IG9wZW5EQjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW5zdGFuY2VPZkFueSA9IChvYmplY3QsIGNvbnN0cnVjdG9ycykgPT4gY29uc3RydWN0b3JzLnNvbWUoKGMpID0+IG9iamVjdCBpbnN0YW5jZW9mIGMpO1xuXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XG5sZXQgY3Vyc29yQWR2YW5jZU1ldGhvZHM7XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xuICAgIHJldHVybiAoaWRiUHJveHlhYmxlVHlwZXMgfHxcbiAgICAgICAgKGlkYlByb3h5YWJsZVR5cGVzID0gW1xuICAgICAgICAgICAgSURCRGF0YWJhc2UsXG4gICAgICAgICAgICBJREJPYmplY3RTdG9yZSxcbiAgICAgICAgICAgIElEQkluZGV4LFxuICAgICAgICAgICAgSURCQ3Vyc29yLFxuICAgICAgICAgICAgSURCVHJhbnNhY3Rpb24sXG4gICAgICAgIF0pKTtcbn1cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxuICAgICAgICAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZVByaW1hcnlLZXksXG4gICAgICAgIF0pKTtcbn1cbmNvbnN0IGN1cnNvclJlcXVlc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXAocmVxdWVzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgLy8gU2luY2UgY3Vyc29yaW5nIHJldXNlcyB0aGUgSURCUmVxdWVzdCAoKnNpZ2gqKSwgd2UgY2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAvLyAoc2VlIHdyYXBGdW5jdGlvbikuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQkN1cnNvcikge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdE1hcC5zZXQodmFsdWUsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdGNoaW5nIHRvIGF2b2lkIFwiVW5jYXVnaHQgUHJvbWlzZSBleGNlcHRpb25zXCJcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFBvbHlmaWxsIGZvciBvYmplY3RTdG9yZU5hbWVzIGJlY2F1c2Ugb2YgRWRnZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnb2JqZWN0U3RvcmVOYW1lcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm9iamVjdFN0b3JlTmFtZXMgfHwgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0eC5zdG9yZSByZXR1cm4gdGhlIG9ubHkgc3RvcmUgaW4gdGhlIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG1hbnkuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0b3JlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzFdXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogcmVjZWl2ZXIub2JqZWN0U3RvcmUocmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSB0cmFuc2Zvcm0gd2hhdGV2ZXIgd2UgZ2V0IGJhY2suXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldFtwcm9wXSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgKHByb3AgPT09ICdkb25lJyB8fCBwcm9wID09PSAnc3RvcmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVwbGFjZVRyYXBzKGNhbGxiYWNrKSB7XG4gICAgaWRiUHJveHlUcmFwcyA9IGNhbGxiYWNrKGlkYlByb3h5VHJhcHMpO1xufVxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBEdWUgdG8gZXhwZWN0ZWQgb2JqZWN0IGVxdWFsaXR5ICh3aGljaCBpcyBlbmZvcmNlZCBieSB0aGUgY2FjaGluZyBpbiBgd3JhcGApLCB3ZVxuICAgIC8vIG9ubHkgY3JlYXRlIG9uZSBuZXcgZnVuYyBwZXIgZnVuYy5cbiAgICAvLyBFZGdlIGRvZXNuJ3Qgc3VwcG9ydCBvYmplY3RTdG9yZU5hbWVzIChib29vKSwgc28gd2UgcG9seWZpbGwgaXQgaGVyZS5cbiAgICBpZiAoZnVuYyA9PT0gSURCRGF0YWJhc2UucHJvdG90eXBlLnRyYW5zYWN0aW9uICYmXG4gICAgICAgICEoJ29iamVjdFN0b3JlTmFtZXMnIGluIElEQlRyYW5zYWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZU5hbWVzLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGZ1bmMuY2FsbCh1bndyYXAodGhpcyksIHN0b3JlTmFtZXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLnNldCh0eCwgc3RvcmVOYW1lcy5zb3J0ID8gc3RvcmVOYW1lcy5zb3J0KCkgOiBbc3RvcmVOYW1lc10pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDdXJzb3IgbWV0aG9kcyBhcmUgc3BlY2lhbCwgYXMgdGhlIGJlaGF2aW91ciBpcyBhIGxpdHRsZSBtb3JlIGRpZmZlcmVudCB0byBzdGFuZGFyZCBJREIuIEluXG4gICAgLy8gSURCLCB5b3UgYWR2YW5jZSB0aGUgY3Vyc29yIGFuZCB3YWl0IGZvciBhIG5ldyAnc3VjY2Vzcycgb24gdGhlIElEQlJlcXVlc3QgdGhhdCBnYXZlIHlvdSB0aGVcbiAgICAvLyBjdXJzb3IuIEl0J3Mga2luZGEgbGlrZSBhIHByb21pc2UgdGhhdCBjYW4gcmVzb2x2ZSB3aXRoIG1hbnkgdmFsdWVzLiBUaGF0IGRvZXNuJ3QgbWFrZSBzZW5zZVxuICAgIC8vIHdpdGggcmVhbCBwcm9taXNlcywgc28gZWFjaCBhZHZhbmNlIG1ldGhvZHMgcmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgY3Vyc29yIG9iamVjdCwgb3JcbiAgICAvLyB1bmRlZmluZWQgaWYgdGhlIGVuZCBvZiB0aGUgY3Vyc29yIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgaWYgKGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkuaW5jbHVkZXMoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICAgICAgZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAoY3Vyc29yUmVxdWVzdE1hcC5nZXQodGhpcykpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbmV4cG9ydHMuaW5zdGFuY2VPZkFueSA9IGluc3RhbmNlT2ZBbnk7XG5leHBvcnRzLnJlcGxhY2VUcmFwcyA9IHJlcGxhY2VUcmFwcztcbmV4cG9ydHMucmV2ZXJzZVRyYW5zZm9ybUNhY2hlID0gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlO1xuZXhwb3J0cy51bndyYXAgPSB1bndyYXA7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuIiwiLyohXG4gKiBOdW1iZXItVG8tV29yZHMgdXRpbFxuICogQHZlcnNpb24gdjEuMi40XG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vbWFybHVuNzgvbnVtYmVyLXRvLXdvcmRzXG4gKiBAYXV0aG9yIE1hcnRpbiBFbmVxdmlzdCAoaHR0cHM6Ly9naXRodWIuY29tL21hcmx1bjc4KVxuICogQGNvbnRyaWJ1dG9ycyBBbGVrc2V5IFBpbHl1Z2luIChodHRwczovL2dpdGh1Yi5jb20vcGlseXVnaW4pLEplcmVtaWFoIEhhbGwgKGh0dHBzOi8vZ2l0aHViLmNvbS9qZXJlbWlhaHJoYWxsKSxBZHJpYW5vIE1lbG8gKGh0dHBzOi8vZ2l0aHViLmNvbS9hZHJpYW5vbWVsbyksZG1yem4gKGh0dHBzOi8vZ2l0aHViLmNvbS9kbXJ6bilcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4hZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgZT1cIm9iamVjdFwiPT10eXBlb2Ygc2VsZiYmc2VsZi5zZWxmPT09c2VsZiYmc2VsZnx8XCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsLmdsb2JhbD09PWdsb2JhbCYmZ2xvYmFsfHx0aGlzLHQ9OTAwNzE5OTI1NDc0MDk5MTtmdW5jdGlvbiBmKGUpe3JldHVybiEoXCJudW1iZXJcIiE9dHlwZW9mIGV8fGUhPWV8fGU9PT0xLzB8fGU9PT0tMS8wKX1mdW5jdGlvbiBsKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlJiZNYXRoLmFicyhlKTw9dH12YXIgbj0vKGh1bmRyZWR8dGhvdXNhbmR8KG18Ynx0cnxxdWFkcilpbGxpb24pJC8scj0vdGVlbiQvLG89L3kkLyxpPS8oemVyb3xvbmV8dHdvfHRocmVlfGZvdXJ8Zml2ZXxzaXh8c2V2ZW58ZWlnaHR8bmluZXx0ZW58ZWxldmVufHR3ZWx2ZSkkLyxzPXt6ZXJvOlwiemVyb3RoXCIsb25lOlwiZmlyc3RcIix0d286XCJzZWNvbmRcIix0aHJlZTpcInRoaXJkXCIsZm91cjpcImZvdXJ0aFwiLGZpdmU6XCJmaWZ0aFwiLHNpeDpcInNpeHRoXCIsc2V2ZW46XCJzZXZlbnRoXCIsZWlnaHQ6XCJlaWdodGhcIixuaW5lOlwibmludGhcIix0ZW46XCJ0ZW50aFwiLGVsZXZlbjpcImVsZXZlbnRoXCIsdHdlbHZlOlwidHdlbGZ0aFwifTtmdW5jdGlvbiBoKGUpe3JldHVybiBuLnRlc3QoZSl8fHIudGVzdChlKT9lK1widGhcIjpvLnRlc3QoZSk/ZS5yZXBsYWNlKG8sXCJpZXRoXCIpOmkudGVzdChlKT9lLnJlcGxhY2UoaSxhKTplfWZ1bmN0aW9uIGEoZSx0KXtyZXR1cm4gc1t0XX12YXIgdT0xMCxkPTEwMCxwPTFlMyx2PTFlNixiPTFlOSx5PTFlMTIsYz0xZTE1LGc9OTAwNzE5OTI1NDc0MDk5MixtPVtcInplcm9cIixcIm9uZVwiLFwidHdvXCIsXCJ0aHJlZVwiLFwiZm91clwiLFwiZml2ZVwiLFwic2l4XCIsXCJzZXZlblwiLFwiZWlnaHRcIixcIm5pbmVcIixcInRlblwiLFwiZWxldmVuXCIsXCJ0d2VsdmVcIixcInRoaXJ0ZWVuXCIsXCJmb3VydGVlblwiLFwiZmlmdGVlblwiLFwic2l4dGVlblwiLFwic2V2ZW50ZWVuXCIsXCJlaWdodGVlblwiLFwibmluZXRlZW5cIl0sdz1bXCJ6ZXJvXCIsXCJ0ZW5cIixcInR3ZW50eVwiLFwidGhpcnR5XCIsXCJmb3J0eVwiLFwiZmlmdHlcIixcInNpeHR5XCIsXCJzZXZlbnR5XCIsXCJlaWdodHlcIixcIm5pbmV0eVwiXTtmdW5jdGlvbiB4KGUsdCl7dmFyIG4scj1wYXJzZUludChlLDEwKTtpZighZihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGEgZmluaXRlIG51bWJlcjogXCIrZStcIiAoXCIrdHlwZW9mIGUrXCIpXCIpO2lmKCFsKHIpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgaXMgbm90IGEgc2FmZSBudW1iZXIsIGl04oCZcyBlaXRoZXIgdG9vIGxhcmdlIG9yIHRvbyBzbWFsbC5cIik7cmV0dXJuIG49ZnVuY3Rpb24gZSh0KXt2YXIgbixyLG89YXJndW1lbnRzWzFdO2lmKDA9PT10KXJldHVybiBvP28uam9pbihcIiBcIikucmVwbGFjZSgvLCQvLFwiXCIpOlwiemVyb1wiO298fChvPVtdKTt0PDAmJihvLnB1c2goXCJtaW51c1wiKSx0PU1hdGguYWJzKHQpKTt0PDIwPyhuPTAscj1tW3RdKTp0PGQ/KG49dCV1LHI9d1tNYXRoLmZsb29yKHQvdSldLG4mJihyKz1cIi1cIittW25dLG49MCkpOnQ8cD8obj10JWQscj1lKE1hdGguZmxvb3IodC9kKSkrXCIgaHVuZHJlZFwiKTp0PHY/KG49dCVwLHI9ZShNYXRoLmZsb29yKHQvcCkpK1wiIHRob3VzYW5kLFwiKTp0PGI/KG49dCV2LHI9ZShNYXRoLmZsb29yKHQvdikpK1wiIG1pbGxpb24sXCIpOnQ8eT8obj10JWIscj1lKE1hdGguZmxvb3IodC9iKSkrXCIgYmlsbGlvbixcIik6dDxjPyhuPXQleSxyPWUoTWF0aC5mbG9vcih0L3kpKStcIiB0cmlsbGlvbixcIik6dDw9ZyYmKG49dCVjLHI9ZShNYXRoLmZsb29yKHQvYykpK1wiIHF1YWRyaWxsaW9uLFwiKTtvLnB1c2gocik7cmV0dXJuIGUobixvKX0ociksdD9oKG4pOm59dmFyIE09e3RvT3JkaW5hbDpmdW5jdGlvbihlKXt2YXIgdD1wYXJzZUludChlLDEwKTtpZighZih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGEgZmluaXRlIG51bWJlcjogXCIrZStcIiAoXCIrdHlwZW9mIGUrXCIpXCIpO2lmKCFsKHQpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5wdXQgaXMgbm90IGEgc2FmZSBudW1iZXIsIGl04oCZcyBlaXRoZXIgdG9vIGxhcmdlIG9yIHRvbyBzbWFsbC5cIik7dmFyIG49U3RyaW5nKHQpLHI9TWF0aC5hYnModCUxMDApLG89MTE8PXImJnI8PTEzLGk9bi5jaGFyQXQobi5sZW5ndGgtMSk7cmV0dXJuIG4rKG8/XCJ0aFwiOlwiMVwiPT09aT9cInN0XCI6XCIyXCI9PT1pP1wibmRcIjpcIjNcIj09PWk/XCJyZFwiOlwidGhcIil9LHRvV29yZHM6eCx0b1dvcmRzT3JkaW5hbDpmdW5jdGlvbihlKXtyZXR1cm4gaCh4KGUpKX19O1widW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzPyhcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cyYmKGV4cG9ydHM9bW9kdWxlLmV4cG9ydHM9TSksZXhwb3J0cy5udW1iZXJUb1dvcmRzPU0pOmUubnVtYmVyVG9Xb3Jkcz1NfSgpOyIsIi8vIGZ1bGwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBjb21tb247XG5cbnZhciBjb21tb25SZSA9IC9cXC98XFwuLztcblxuLyoqXG4gKiBQcm92aWRlcyBjb21tb24gdHlwZSBkZWZpbml0aW9ucy5cbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIGdvb2dsZSB0eXBlcyBvciB5b3VyIG93biBjdXN0b20gdHlwZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTaG9ydCBuYW1lIGFzIGluIGBnb29nbGUvcHJvdG9idWYvW25hbWVdLnByb3RvYCBvciBmdWxsIGZpbGUgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0ganNvbiBKU09OIGRlZmluaXRpb24gd2l0aGluIGBnb29nbGUucHJvdG9idWZgIGlmIGEgc2hvcnQgbmFtZSwgb3RoZXJ3aXNlIHRoZSBmaWxlJ3Mgcm9vdCBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvYW55LnByb3RvIEFueVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8gRHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2VtcHR5LnByb3RvIEVtcHR5XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9maWVsZF9tYXNrLnByb3RvIEZpZWxkTWFza1xuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvIFN0cnVjdCwgVmFsdWUsIE51bGxWYWx1ZSBhbmQgTGlzdFZhbHVlXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8gVGltZXN0YW1wXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90byBXcmFwcGVyc1xuICogQGV4YW1wbGVcbiAqIC8vIG1hbnVhbGx5IHByb3ZpZGVzIGRlc2NyaXB0b3IucHJvdG8gKGFzc3VtZXMgZ29vZ2xlL3Byb3RvYnVmLyBuYW1lc3BhY2UgYW5kIC5wcm90byBleHRlbnNpb24pXG4gKiBwcm90b2J1Zi5jb21tb24oXCJkZXNjcmlwdG9yXCIsIGRlc2NyaXB0b3JKc29uKTtcbiAqXG4gKiAvLyBtYW51YWxseSBwcm92aWRlcyBhIGN1c3RvbSBkZWZpbml0aW9uICh1c2VzIG15LmZvbyBuYW1lc3BhY2UpXG4gKiBwcm90b2J1Zi5jb21tb24oXCJteS9mb28vYmFyLnByb3RvXCIsIG15Rm9vQmFySnNvbik7XG4gKi9cbmZ1bmN0aW9uIGNvbW1vbihuYW1lLCBqc29uKSB7XG4gICAgaWYgKCFjb21tb25SZS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBcImdvb2dsZS9wcm90b2J1Zi9cIiArIG5hbWUgKyBcIi5wcm90b1wiO1xuICAgICAgICBqc29uID0geyBuZXN0ZWQ6IHsgZ29vZ2xlOiB7IG5lc3RlZDogeyBwcm90b2J1ZjogeyBuZXN0ZWQ6IGpzb24gfSB9IH0gfSB9O1xuICAgIH1cbiAgICBjb21tb25bbmFtZV0gPSBqc29uO1xufVxuXG4vLyBOb3QgcHJvdmlkZWQgYmVjYXVzZSBvZiBsaW1pdGVkIHVzZSAoZmVlbCBmcmVlIHRvIGRpc2N1c3Mgb3IgdG8gcHJvdmlkZSB5b3Vyc2VsZik6XG4vL1xuLy8gZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG9cbi8vIGdvb2dsZS9wcm90b2J1Zi9zb3VyY2VfY29udGV4dC5wcm90b1xuLy8gZ29vZ2xlL3Byb3RvYnVmL3R5cGUucHJvdG9cbi8vXG4vLyBTdHJpcHBlZCBhbmQgcHJlLXBhcnNlZCB2ZXJzaW9ucyBvZiB0aGVzZSBub24tYnVuZGxlZCBmaWxlcyBhcmUgaW5zdGVhZCBhdmFpbGFibGUgYXMgcGFydCBvZlxuLy8gdGhlIHJlcG9zaXRvcnkgb3IgcGFja2FnZSB3aXRoaW4gdGhlIGdvb2dsZS9wcm90b2J1ZiBkaXJlY3RvcnkuXG5cbmNvbW1vbihcImFueVwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkFueSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUFueVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlVXJsXVxuICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2J5dGVzXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBBbnk6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB0eXBlX3VybDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciB0aW1lVHlwZTtcblxuY29tbW9uKFwiZHVyYXRpb25cIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUR1cmF0aW9uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbc2Vjb25kc11cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW25hbm9zXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBEdXJhdGlvbjogdGltZVR5cGUgPSB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgc2Vjb25kczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbm9zOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29tbW9uKFwidGltZXN0YW1wXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVGltZXN0YW1wXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbc2Vjb25kc11cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW25hbm9zXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBUaW1lc3RhbXA6IHRpbWVUeXBlXG59KTtcblxuY29tbW9uKFwiZW1wdHlcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5FbXB0eSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUVtcHR5XG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEVtcHR5OiB7XG4gICAgICAgIGZpZWxkczoge31cbiAgICB9XG59KTtcblxuY29tbW9uKFwic3RydWN0XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuU3RydWN0IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJU3RydWN0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElWYWx1ZT59IFtmaWVsZHNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFN0cnVjdDoge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2tpbmRdXG4gICAgICogQHByb3BlcnR5IHswfSBbbnVsbFZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHJpbmdWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtib29sVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtJU3RydWN0fSBbc3RydWN0VmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtJTGlzdFZhbHVlfSBbbGlzdFZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBWYWx1ZToge1xuICAgICAgICBvbmVvZnM6IHtcbiAgICAgICAgICAgIGtpbmQ6IHtcbiAgICAgICAgICAgICAgICBvbmVvZjogW1xuICAgICAgICAgICAgICAgICAgICBcIm51bGxWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJib29sVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJ1Y3RWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpc3RWYWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIG51bGxWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTnVsbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1iZXJWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG91YmxlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpbmdWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib29sVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBpZDogNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cnVjdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJTdHJ1Y3RcIixcbiAgICAgICAgICAgICAgICBpZDogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpc3RWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTGlzdFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBOdWxsVmFsdWU6IHtcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBOVUxMX1ZBTFVFOiAwXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElMaXN0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPElWYWx1ZT59IFt2YWx1ZXNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIExpc3RWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHJ1bGU6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJ3cmFwcGVyc1wiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRG91YmxlVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIERvdWJsZVZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRmxvYXRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRmxvYXRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJSW50NjRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBJbnQ2NFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVUludDY0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVUludDY0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElJbnQzMlZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBJbnQzMlZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVUludDMyVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFVJbnQzMlZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElCb29sVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBCb29sVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVN0cmluZ1ZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBTdHJpbmdWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUJ5dGVzVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBCeXRlc1ZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJmaWVsZF9tYXNrXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRmllbGRNYXNrIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRG91YmxlVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEZpZWxkTWFzazoge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHBhdGhzOiB7XG4gICAgICAgICAgICAgICAgcnVsZTogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIHJvb3QgZGVmaW5pdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGNvbW1vbiBwcm90byBmaWxlLlxuICpcbiAqIEJ1bmRsZWQgZGVmaW5pdGlvbnMgYXJlOlxuICogLSBnb29nbGUvcHJvdG9idWYvYW55LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3N0cnVjdC5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlIFByb3RvIGZpbGUgbmFtZVxuICogQHJldHVybnMge0lOYW1lc3BhY2V8bnVsbH0gUm9vdCBkZWZpbml0aW9uIG9yIGBudWxsYCBpZiBub3QgZGVmaW5lZFxuICovXG5jb21tb24uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpbGUpIHtcbiAgICByZXR1cm4gY29tbW9uW2ZpbGVdIHx8IG51bGw7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJ1bnRpbWUgbWVzc2FnZSBmcm9tL3RvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgY29udmVydGVyID0gZXhwb3J0cztcblxudmFyIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgZnJvbU9iamVjdCBjb252ZXRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSB7IGdlblxuICAgICAgICAgICAgKFwic3dpdGNoKGQlcyl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZm9yICh2YXIgdmFsdWVzID0gZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlcywga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5yZXBlYXRlZCAmJiB2YWx1ZXNba2V5c1tpXV0gPT09IGZpZWxkLnR5cGVEZWZhdWx0KSBnZW5cbiAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAoXCJjYXNlJWo6XCIsIGtleXNbaV0pXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgdmFsdWVzW2tleXNbaV1dKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9JWpcIiwgcHJvcCwgdmFsdWVzW2tleXNbaV1dKVxuICAgICAgICAgICAgICAgICAgICAoXCJicmVha1wiKTtcbiAgICAgICAgICAgIH0gZ2VuXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBvYmplY3QgZXhwZWN0ZWRcIilcbiAgICAgICAgICAgIChcIm0lcz10eXBlc1slaV0uZnJvbU9iamVjdChkJXMpXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc1Vuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1OdW1iZXIoZCVzKVwiLCBwcm9wLCBwcm9wKTsgLy8gYWxzbyBjYXRjaGVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlcz4+PjBcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzfDBcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICAgICAgaXNVbnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHV0aWwuTG9uZylcIilcbiAgICAgICAgICAgICAgICAgICAgKFwiKG0lcz11dGlsLkxvbmcuZnJvbVZhbHVlKGQlcykpLnVuc2lnbmVkPSVqXCIsIHByb3AsIHByb3AsIGlzVW5zaWduZWQpXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcInN0cmluZ1xcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1wYXJzZUludChkJXMsMTApXCIsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcIm51bWJlclxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPW5ldyB1dGlsLkxvbmdCaXRzKGQlcy5sb3c+Pj4wLGQlcy5oaWdoPj4+MCkudG9OdW1iZXIoJXMpXCIsIHByb3AsIHByb3AsIHByb3AsIGlzVW5zaWduZWQgPyBcInRydWVcIiA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiBkJXM9PT1cXFwic3RyaW5nXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwidXRpbC5iYXNlNjQuZGVjb2RlKGQlcyxtJXM9dXRpbC5uZXdCdWZmZXIodXRpbC5iYXNlNjQubGVuZ3RoKGQlcykpLDApXCIsIHByb3AsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZihkJXMubGVuZ3RoKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9U3RyaW5nKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9Qm9vbGVhbihkJXMpXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhazsgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBsYWluIG9iamVjdCB0byBydW50aW1lIG1lc3NhZ2UgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICB2YXIgZmllbGRzID0gbXR5cGUuZmllbGRzQXJyYXk7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJkXCJdLCBtdHlwZS5uYW1lICsgXCIkZnJvbU9iamVjdFwiKVxuICAgIChcImlmKGQgaW5zdGFuY2VvZiB0aGlzLmN0b3IpXCIpXG4gICAgICAgIChcInJldHVybiBkXCIpO1xuICAgIGlmICghZmllbGRzLmxlbmd0aCkgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBuZXcgdGhpcy5jdG9yXCIpO1xuICAgIGdlblxuICAgIChcInZhciBtPW5ldyB0aGlzLmN0b3JcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBwcm9wICAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIC8vIE1hcCBmaWVsZHNcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZih0eXBlb2YgZCVzIT09XFxcIm9iamVjdFxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IG9iamVjdCBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9e31cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyhkJXMpLGk9MDtpPGtzLmxlbmd0aDsrK2kpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCArIFwiW2tzW2ldXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZihkJXMpe1wiLCBwcm9wKVxuICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheShkJXMpKVwiLCBwcm9wKVxuICAgICAgICAgICAgKFwidGhyb3cgVHlwZUVycm9yKCVqKVwiLCBmaWVsZC5mdWxsTmFtZSArIFwiOiBhcnJheSBleHBlY3RlZFwiKVxuICAgICAgICAoXCJtJXM9W11cIiwgcHJvcClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTxkJXMubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJbaV1cIilcbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gTm9uLXJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkpIGdlbiAvLyBubyBuZWVkIHRvIHRlc3QgZm9yIG51bGwvdW5kZWZpbmVkIGlmIGFuIGVudW0gKHVzZXMgc3dpdGNoKVxuICAgIChcImlmKGQlcyE9bnVsbCl7XCIsIHByb3ApOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF9mcm9tT2JqZWN0KGdlbiwgZmllbGQsIC8qIG5vdCBzb3J0ZWQgKi8gaSwgcHJvcCk7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuXG4gICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gcmV0dXJuIGdlblxuICAgIChcInJldHVybiBtXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIHRvT2JqZWN0IGNvbnZlcnRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHByb3ApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz90eXBlc1slaV0udmFsdWVzW20lc106bSVzXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3AsIHByb3ApO1xuICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwiZCVzPXR5cGVzWyVpXS50b09iamVjdChtJXMsbylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5qc29uJiYhaXNGaW5pdGUobSVzKT9TdHJpbmcobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICAgICAgaXNVbnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgKFwiaWYodHlwZW9mIG0lcz09PVxcXCJudW1iZXJcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP1N0cmluZyhtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wKVxuICAgICAgICAgICAgKFwiZWxzZVwiKSAvLyBMb25nLWxpa2VcbiAgICAgICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz91dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobSVzKTpvLmxvbmdzPT09TnVtYmVyP25ldyB1dGlsLkxvbmdCaXRzKG0lcy5sb3c+Pj4wLG0lcy5oaWdoPj4+MCkudG9OdW1iZXIoJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wLCBpc1Vuc2lnbmVkID8gXCJ0cnVlXCI6IFwiXCIsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW8uYnl0ZXM9PT1TdHJpbmc/dXRpbC5iYXNlNjQuZW5jb2RlKG0lcywwLG0lcy5sZW5ndGgpOm8uYnl0ZXM9PT1BcnJheT9BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtJXMpOm0lc1wiLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGdlblxuICAgICAgICAgICAgKFwiZCVzPW0lc1wiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJ1bnRpbWUgbWVzc2FnZSB0byBwbGFpbiBvYmplY3QgY29udmVydGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmNvbnZlcnRlci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBmaWVsZHMgPSBtdHlwZS5maWVsZHNBcnJheS5zbGljZSgpLnNvcnQodXRpbC5jb21wYXJlRmllbGRzQnlJZCk7XG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdXRpbC5jb2RlZ2VuKCkoXCJyZXR1cm4ge31cIik7XG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwib1wiXSwgbXR5cGUubmFtZSArIFwiJHRvT2JqZWN0XCIpXG4gICAgKFwiaWYoIW8pXCIpXG4gICAgICAgIChcIm89e31cIilcbiAgICAoXCJ2YXIgZD17fVwiKTtcblxuICAgIHZhciByZXBlYXRlZEZpZWxkcyA9IFtdLFxuICAgICAgICBtYXBGaWVsZHMgPSBbXSxcbiAgICAgICAgbm9ybWFsRmllbGRzID0gW10sXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoIWZpZWxkc1tpXS5wYXJ0T2YpXG4gICAgICAgICAgICAoIGZpZWxkc1tpXS5yZXNvbHZlKCkucmVwZWF0ZWQgPyByZXBlYXRlZEZpZWxkc1xuICAgICAgICAgICAgOiBmaWVsZHNbaV0ubWFwID8gbWFwRmllbGRzXG4gICAgICAgICAgICA6IG5vcm1hbEZpZWxkcykucHVzaChmaWVsZHNbaV0pO1xuXG4gICAgaWYgKHJlcGVhdGVkRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLmFycmF5c3x8by5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0ZWRGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxuICAgICAgICAoXCJkJXM9W11cIiwgdXRpbC5zYWZlUHJvcChyZXBlYXRlZEZpZWxkc1tpXS5uYW1lKSk7XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG1hcEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5vYmplY3RzfHxvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXBGaWVsZHMubGVuZ3RoOyArK2kpIGdlblxuICAgICAgICAoXCJkJXM9e31cIiwgdXRpbC5zYWZlUHJvcChtYXBGaWVsZHNbaV0ubmFtZSkpO1xuICAgICAgICBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vcm1hbEZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gbm9ybWFsRmllbGRzW2ldLFxuICAgICAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cbiAgICAgICAgKFwiZCVzPW8uZW51bXM9PT1TdHJpbmc/JWo6JWpcIiwgcHJvcCwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc0J5SWRbZmllbGQudHlwZURlZmF1bHRdLCBmaWVsZC50eXBlRGVmYXVsdCk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5sb25nKSBnZW5cbiAgICAgICAgKFwiaWYodXRpbC5Mb25nKXtcIilcbiAgICAgICAgICAgIChcInZhciBuPW5ldyB1dGlsLkxvbmcoJWksJWksJWopXCIsIGZpZWxkLnR5cGVEZWZhdWx0LmxvdywgZmllbGQudHlwZURlZmF1bHQuaGlnaCwgZmllbGQudHlwZURlZmF1bHQudW5zaWduZWQpXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz9uLnRvU3RyaW5nKCk6by5sb25ncz09PU51bWJlcj9uLnRvTnVtYmVyKCk6blwiLCBwcm9wKVxuICAgICAgICAoXCJ9ZWxzZVwiKVxuICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/JWo6JWlcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQudG9TdHJpbmcoKSwgZmllbGQudHlwZURlZmF1bHQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5ieXRlcykge1xuICAgICAgICAgICAgICAgIHZhciBhcnJheURlZmF1bHQgPSBcIltcIiArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpZWxkLnR5cGVEZWZhdWx0KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIGdlblxuICAgICAgICAoXCJpZihvLmJ5dGVzPT09U3RyaW5nKWQlcz0lalwiLCBwcm9wLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZmllbGQudHlwZURlZmF1bHQpKVxuICAgICAgICAoXCJlbHNle1wiKVxuICAgICAgICAgICAgKFwiZCVzPSVzXCIsIHByb3AsIGFycmF5RGVmYXVsdClcbiAgICAgICAgICAgIChcImlmKG8uYnl0ZXMhPT1BcnJheSlkJXM9dXRpbC5uZXdCdWZmZXIoZCVzKVwiLCBwcm9wLCBwcm9wKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGdlblxuICAgICAgICAoXCJkJXM9JWpcIiwgcHJvcCwgZmllbGQudHlwZURlZmF1bHQpOyAvLyBhbHNvIG1lc3NhZ2VzICg9bnVsbClcbiAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuICAgIH1cbiAgICB2YXIgaGFzS3MyID0gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV0sXG4gICAgICAgICAgICBpbmRleCA9IG10eXBlLl9maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKSxcbiAgICAgICAgICAgIHByb3AgID0gdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkLm1hcCkge1xuICAgICAgICAgICAgaWYgKCFoYXNLczIpIHsgaGFzS3MyID0gdHJ1ZTsgZ2VuXG4gICAgKFwidmFyIGtzMlwiKTtcbiAgICAgICAgICAgIH0gZ2VuXG4gICAgKFwiaWYobSVzJiYoa3MyPU9iamVjdC5rZXlzKG0lcykpLmxlbmd0aCl7XCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcImQlcz17fVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPGtzMi5sZW5ndGg7KytqKXtcIik7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wICsgXCJba3MyW2pdXVwiKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKG0lcyYmbSVzLmxlbmd0aCl7XCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcImQlcz1bXVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGo9MDtqPG0lcy5sZW5ndGg7KytqKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgLyogc29ydGVkICovIGluZGV4LCBwcm9wICsgXCJbal1cIilcbiAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIHsgZ2VuXG4gICAgKFwiaWYobSVzIT1udWxsJiZtLmhhc093blByb3BlcnR5KCVqKSl7XCIsIHByb3AsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG4gICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3ApO1xuICAgICAgICBpZiAoZmllbGQucGFydE9mKSBnZW5cbiAgICAgICAgKFwiaWYoby5vbmVvZnMpXCIpXG4gICAgICAgICAgICAoXCJkJXM9JWpcIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5wYXJ0T2YubmFtZSksIGZpZWxkLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gZFwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlcjtcblxudmFyIEVudW0gICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHR5cGVzICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gbWlzc2luZyhmaWVsZCkge1xuICAgIHJldHVybiBcIm1pc3NpbmcgcmVxdWlyZWQgJ1wiICsgZmllbGQubmFtZSArIFwiJ1wiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGRlY29kZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZGVjb2RlcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJyXCIsIFwibFwiXSwgbXR5cGUubmFtZSArIFwiJGRlY29kZVwiKVxuICAgIChcImlmKCEociBpbnN0YW5jZW9mIFJlYWRlcikpXCIpXG4gICAgICAgIChcInI9UmVhZGVyLmNyZWF0ZShyKVwiKVxuICAgIChcInZhciBjPWw9PT11bmRlZmluZWQ/ci5sZW46ci5wb3MrbCxtPW5ldyB0aGlzLmN0b3JcIiArIChtdHlwZS5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkLm1hcDsgfSkubGVuZ3RoID8gXCIsayx2YWx1ZVwiIDogXCJcIikpXG4gICAgKFwid2hpbGUoci5wb3M8Yyl7XCIpXG4gICAgICAgIChcInZhciB0PXIudWludDMyKClcIik7XG4gICAgaWYgKG10eXBlLmdyb3VwKSBnZW5cbiAgICAgICAgKFwiaWYoKHQmNyk9PT00KVwiKVxuICAgICAgICAgICAgKFwiYnJlYWtcIik7XG4gICAgZ2VuXG4gICAgICAgIChcInN3aXRjaCh0Pj4+Myl7XCIpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHR5cGUgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXG4gICAgICAgICAgICByZWYgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTsgZ2VuXG4gICAgICAgICAgICAoXCJjYXNlICVpOlwiLCBmaWVsZC5pZCk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCVzPT09dXRpbC5lbXB0eU9iamVjdClcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCIlcz17fVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwidmFyIGMyID0gci51aW50MzIoKStyLnBvc1wiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIms9JWpcIiwgdHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0pO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCJrPW51bGxcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5kZWZhdWx0c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJ2YWx1ZT0lalwiLCB0eXBlcy5kZWZhdWx0c1t0eXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPW51bGxcIik7XG5cbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcIndoaWxlKHIucG9zPGMyKXtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIHRhZzI9ci51aW50MzIoKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCJzd2l0Y2godGFnMj4+PjMpe1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAxOiBrPXIuJXMoKTsgYnJlYWtcIiwgZmllbGQua2V5VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImNhc2UgMjpcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT10eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSlcIiwgaSk7IC8vIGNhbid0IGJlIGdyb3Vwc1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT1yLiVzKClcIiwgdHlwZSk7XG5cbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInIuc2tpcFR5cGUodGFnMiY3KVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIn1cIilcbiAgICAgICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMubG9uZ1tmaWVsZC5rZXlUeXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlc1t0eXBlb2Ygaz09PVxcXCJvYmplY3RcXFwiP3V0aWwubG9uZ1RvSGFzaChrKTprXT12YWx1ZVwiLCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlc1trXT12YWx1ZVwiLCByZWYpO1xuXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmJXMubGVuZ3RoKSlcIiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPVtdXCIsIHJlZik7XG5cbiAgICAgICAgICAgIC8vIFBhY2thYmxlIChhbHdheXMgY2hlY2sgZm9yIGZvcndhcmQgYW5kIGJhY2t3YXJkIGNvbXBhdGlibGl0eSlcbiAgICAgICAgICAgIGlmICh0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoKHQmNyk9PT0yKXtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIGMyPXIudWludDMyKCkrci5wb3NcIilcbiAgICAgICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIlcy5wdXNoKHIuJXMoKSlcIiwgcmVmLCB0eXBlKVxuICAgICAgICAgICAgICAgIChcIn1lbHNlXCIpO1xuXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXG4gICAgICAgICAgICBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLnJlc29sdmVkVHlwZS5ncm91cFxuICAgICAgICAgICAgICAgICAgICA/IFwiJXMucHVzaCh0eXBlc1slaV0uZGVjb2RlKHIpKVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKSlcIiwgcmVmLCBpKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlbihmaWVsZC5yZXNvbHZlZFR5cGUuZ3JvdXBcbiAgICAgICAgICAgICAgICA/IFwiJXM9dHlwZXNbJWldLmRlY29kZShyKVwiXG4gICAgICAgICAgICAgICAgOiBcIiVzPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCByZWYsIGkpO1xuICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzPXIuJXMoKVwiLCByZWYsIHR5cGUpO1xuICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKTtcbiAgICAvLyBVbmtub3duIGZpZWxkc1xuICAgIH0gZ2VuXG4gICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgIChcInIuc2tpcFR5cGUodCY3KVwiKVxuICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAvLyBGaWVsZCBwcmVzZW5jZVxuICAgIGZvciAoaSA9IDA7IGkgPCBtdHlwZS5fZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXTtcbiAgICAgICAgaWYgKHJmaWVsZC5yZXF1aXJlZCkgZ2VuXG4gICAgKFwiaWYoIW0uaGFzT3duUHJvcGVydHkoJWopKVwiLCByZmllbGQubmFtZSlcbiAgICAgICAgKFwidGhyb3cgdXRpbC5Qcm90b2NvbEVycm9yKCVqLHtpbnN0YW5jZTptfSlcIiwgbWlzc2luZyhyZmllbGQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZXI7XG5cbnZhciBFbnVtICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBtZXNzYWdlIHR5cGUgZW5jb2Rlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBmaWVsZEluZGV4LCByZWYpIHtcbiAgICByZXR1cm4gZmllbGQucmVzb2x2ZWRUeXBlLmdyb3VwXG4gICAgICAgID8gZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkpLnVpbnQzMiglaSlcIiwgZmllbGRJbmRleCwgcmVmLCAoZmllbGQuaWQgPDwgMyB8IDMpID4+PiAwLCAoZmllbGQuaWQgPDwgMyB8IDQpID4+PiAwKVxuICAgICAgICA6IGdlbihcInR5cGVzWyVpXS5lbmNvZGUoJXMsdy51aW50MzIoJWkpLmZvcmsoKSkubGRlbGltKClcIiwgZmllbGRJbmRleCwgcmVmLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gZW5jb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBlbmNvZGVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBnZW4gPSB1dGlsLmNvZGVnZW4oW1wibVwiLCBcIndcIl0sIG10eXBlLm5hbWUgKyBcIiRlbmNvZGVcIilcbiAgICAoXCJpZighdylcIilcbiAgICAgICAgKFwidz1Xcml0ZXIuY3JlYXRlKClcIik7XG5cbiAgICB2YXIgaSwgcmVmO1xuXG4gICAgLy8gXCJ3aGVuIGEgbWVzc2FnZSBpcyBzZXJpYWxpemVkIGl0cyBrbm93biBmaWVsZHMgc2hvdWxkIGJlIHdyaXR0ZW4gc2VxdWVudGlhbGx5IGJ5IGZpZWxkIG51bWJlclwiXG4gICAgdmFyIGZpZWxkcyA9IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCAgICA9IGZpZWxkc1tpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICBpbmRleCAgICA9IG10eXBlLl9maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKSxcbiAgICAgICAgICAgIHR5cGUgICAgID0gZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSA/IFwiaW50MzJcIiA6IGZpZWxkLnR5cGUsXG4gICAgICAgICAgICB3aXJlVHlwZSA9IHR5cGVzLmJhc2ljW3R5cGVdO1xuICAgICAgICAgICAgcmVmICAgICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgICAgICBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpe1wiLCByZWYsIGZpZWxkLm5hbWUpIC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgKFwiZm9yKHZhciBrcz1PYmplY3Qua2V5cyglcyksaT0wO2k8a3MubGVuZ3RoOysraSl7XCIsIHJlZilcbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKCkudWludDMyKCVpKS4lcyhrc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMCwgOCB8IHR5cGVzLm1hcEtleVtmaWVsZC5rZXlUeXBlXSwgZmllbGQua2V5VHlwZSk7XG4gICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAoXCJ0eXBlc1slaV0uZW5jb2RlKCVzW2tzW2ldXSx3LnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKS5sZGVsaW0oKVwiLCBpbmRleCwgcmVmKTsgLy8gY2FuJ3QgYmUgZ3JvdXBzXG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwiLnVpbnQzMiglaSkuJXMoJXNba3NbaV1dKS5sZGVsaW0oKVwiLCAxNiB8IHdpcmVUeXBlLCB0eXBlLCByZWYpO1xuICAgICAgICAgICAgZ2VuXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgICAgICAvLyBSZXBlYXRlZCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgeyBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmJXMubGVuZ3RoKXtcIiwgcmVmLCByZWYpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgICAgIC8vIFBhY2tlZCByZXBlYXRlZFxuICAgICAgICAgICAgaWYgKGZpZWxkLnBhY2tlZCAmJiB0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgeyBnZW5cblxuICAgICAgICAoXCJ3LnVpbnQzMiglaSkuZm9yaygpXCIsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy4lcyglc1tpXSlcIiwgdHlwZSwgcmVmKVxuICAgICAgICAoXCJ3LmxkZWxpbSgpXCIpO1xuXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXG4gICAgICAgICAgICB9IGVsc2UgeyBnZW5cblxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPCVzLmxlbmd0aDsrK2kpXCIsIHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmICsgXCJbaV1cIik7XG4gICAgICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgIChcIncudWludDMyKCVpKS4lcyglc1tpXSlcIiwgKGZpZWxkLmlkIDw8IDMgfCB3aXJlVHlwZSkgPj4+IDAsIHR5cGUsIHJlZik7XG5cbiAgICAgICAgICAgIH0gZ2VuXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgKFwiaWYoJXMhPW51bGwmJk9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG0sJWopKVwiLCByZWYsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBnZW5UeXBlUGFydGlhbChnZW4sIGZpZWxkLCBpbmRleCwgcmVmKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgIChcIncudWludDMyKCVpKS4lcyglcylcIiwgKGZpZWxkLmlkIDw8IDMgfCB3aXJlVHlwZSkgPj4+IDAsIHR5cGUsIHJlZik7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gd1wiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBFbnVtO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChFbnVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEVudW0pLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xuXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgZW51bSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIGVudW0uXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLG51bWJlcj59IFt2YWx1ZXNdIEVudW0gdmFsdWVzIGFzIGFuIG9iamVjdCwgYnkgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gVGhlIGNvbW1lbnQgZm9yIHRoaXMgZW51bVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBbY29tbWVudHNdIFRoZSB2YWx1ZSBjb21tZW50cyBmb3IgdGhpcyBlbnVtXG4gKi9cbmZ1bmN0aW9uIEVudW0obmFtZSwgdmFsdWVzLCBvcHRpb25zLCBjb21tZW50LCBjb21tZW50cykge1xuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIGlmICh2YWx1ZXMgJiYgdHlwZW9mIHZhbHVlcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwidmFsdWVzIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuXG4gICAgLyoqXG4gICAgICogRW51bSB2YWx1ZXMgYnkgaWQuXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNCeUlkID0ge307XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMudmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc0J5SWQpOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRW51bSBjb21tZW50IHRleHQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBjb21tZW50IHRleHRzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50cyA9IGNvbW1lbnRzIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXJ2ZWQgcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMucmVzZXJ2ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLy8gTm90ZSB0aGF0IHZhbHVlcyBpbmhlcml0IHZhbHVlc0J5SWQgb24gdGhlaXIgcHJvdG90eXBlIHdoaWNoIG1ha2VzIHRoZW0gYSBUeXBlU2NyaXB0LVxuICAgIC8vIGNvbXBhdGlibGUgZW51bS4gVGhpcyBpcyB1c2VkIGJ5IHBidHMgdG8gd3JpdGUgYWN0dWFsIGVudW0gZGVmaW5pdGlvbnMgdGhhdCB3b3JrIGZvclxuICAgIC8vIHN0YXRpYyBhbmQgcmVmbGVjdGlvbiBjb2RlIGFsaWtlIGluc3RlYWQgb2YgZW1pdHRpbmcgZ2VuZXJpYyBvYmplY3QgZGVmaW5pdGlvbnMuXG5cbiAgICBpZiAodmFsdWVzKVxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNba2V5c1tpXV0gPT09IFwibnVtYmVyXCIpIC8vIHVzZSBmb3J3YXJkIGVudHJpZXMgb25seVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzQnlJZFsgdGhpcy52YWx1ZXNba2V5c1tpXV0gPSB2YWx1ZXNba2V5c1tpXV0gXSA9IGtleXNbaV07XG59XG5cbi8qKlxuICogRW51bSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRW51bVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSB2YWx1ZXMgRW51bSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBFbnVtIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bSBmcm9tIGFuIGVudW0gZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVudW0gbmFtZVxuICogQHBhcmFtIHtJRW51bX0ganNvbiBFbnVtIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtFbnVtfSBDcmVhdGVkIGVudW1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkVudW0uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIGVubSA9IG5ldyBFbnVtKG5hbWUsIGpzb24udmFsdWVzLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCwganNvbi5jb21tZW50cyk7XG4gICAgZW5tLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICByZXR1cm4gZW5tO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGVudW0gdG8gYW4gZW51bSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SUVudW19IEVudW0gZGVzY3JpcHRvclxuICovXG5FbnVtLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJ2YWx1ZXNcIiAgICwgdGhpcy52YWx1ZXMsXG4gICAgICAgIFwicmVzZXJ2ZWRcIiAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRcIiAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiY29tbWVudHNcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudHMgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHZhbHVlIHRvIHRoaXMgZW51bS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFZhbHVlIG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBWYWx1ZSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50LCBpZiBhbnlcbiAqIEByZXR1cm5zIHtFbnVtfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZhbHVlIHdpdGggdGhpcyBuYW1lIG9yIGlkXG4gKi9cbkVudW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBpZCwgY29tbWVudCkge1xuICAgIC8vIHV0aWxpemVkIGJ5IHRoZSBwYXJzZXIgYnV0IG5vdCBieSAuZnJvbUpTT05cblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcblxuICAgIGlmICh0aGlzLnZhbHVlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChpZCkpXG4gICAgICAgIHRocm93IEVycm9yKFwiaWQgXCIgKyBpZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc1Jlc2VydmVkTmFtZShuYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLnZhbHVlc0J5SWRbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hbGxvd19hbGlhcykpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIGlkICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXNbbmFtZV0gPSBpZDtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhpcy52YWx1ZXNCeUlkW3RoaXMudmFsdWVzW25hbWVdID0gaWRdID0gbmFtZTtcblxuICAgIHRoaXMuY29tbWVudHNbbmFtZV0gPSBjb21tZW50IHx8IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoaXMgZW51bVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVmFsdWUgbmFtZVxuICogQHJldHVybnMge0VudW19IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgbmFtZWAgaXMgbm90IGEgbmFtZSBvZiB0aGlzIGVudW1cbiAqL1xuRW51bS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgdmFyIHZhbCA9IHRoaXMudmFsdWVzW25hbWVdO1xuICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3QgaW4gXCIgKyB0aGlzKTtcblxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc0J5SWRbdmFsXTtcbiAgICBkZWxldGUgdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgZGVsZXRlIHRoaXMuY29tbWVudHNbbmFtZV07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBpZCBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBJZCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5FbnVtLnByb3RvdHlwZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQoaWQpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWRJZCh0aGlzLnJlc2VydmVkLCBpZCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgbmFtZSBpcyByZXNlcnZlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuRW51bS5wcm90b3R5cGUuaXNSZXNlcnZlZE5hbWUgPSBmdW5jdGlvbiBpc1Jlc2VydmVkTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkTmFtZSh0aGlzLnJlc2VydmVkLCBuYW1lKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gRmllbGQ7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEZpZWxkKS5jbGFzc05hbWUgPSBcIkZpZWxkXCI7XG5cbnZhciBFbnVtICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBUeXBlOyAvLyBjeWNsaWNcblxudmFyIHJ1bGVSZSA9IC9ecmVxdWlyZWR8b3B0aW9uYWx8cmVwZWF0ZWQkLztcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc3NhZ2UgZmllbGQgaW5zdGFuY2UuIE5vdGUgdGhhdCB7QGxpbmsgTWFwRmllbGR8bWFwIGZpZWxkc30gaGF2ZSB0aGVpciBvd24gY2xhc3MuXG4gKiBAbmFtZSBGaWVsZFxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWVzc2FnZSBmaWVsZC5cbiAqIEBleHRlbmRzIEZpZWxkQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtleHRlbmRdIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIGZpZWxkIGZyb20gYSBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICogQHBhcmFtIHtJRmllbGR9IGpzb24gRmllbGQgZGVzY3JpcHRvclxuICogQHJldHVybnMge0ZpZWxkfSBDcmVhdGVkIGZpZWxkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5GaWVsZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEZpZWxkKG5hbWUsIGpzb24uaWQsIGpzb24udHlwZSwganNvbi5ydWxlLCBqc29uLmV4dGVuZCwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIEZpZWxkfSBpbnN0ZWFkLlxuICogQGNsYXNzZGVzYyBCYXNlIGNsYXNzIG9mIGFsbCByZWZsZWN0ZWQgbWVzc2FnZSBmaWVsZHMuIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBjbGFzcyBidXQgaGVyZSBmb3IgdGhlIHNha2Ugb2YgaGF2aW5nIGNvbnNpc3RlbnQgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBleHBvcnRzIEZpZWxkQmFzZVxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtydWxlPVwib3B0aW9uYWxcIl0gRmllbGQgcnVsZVxuICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0LjxzdHJpbmcsKj59IFtleHRlbmRdIEV4dGVuZGVkIHR5cGUgaWYgZGlmZmVyZW50IGZyb20gcGFyZW50XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtjb21tZW50XSBDb21tZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIEZpZWxkKG5hbWUsIGlkLCB0eXBlLCBydWxlLCBleHRlbmQsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIGlmICh1dGlsLmlzT2JqZWN0KHJ1bGUpKSB7XG4gICAgICAgIGNvbW1lbnQgPSBleHRlbmQ7XG4gICAgICAgIG9wdGlvbnMgPSBydWxlO1xuICAgICAgICBydWxlID0gZXh0ZW5kID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc09iamVjdChleHRlbmQpKSB7XG4gICAgICAgIGNvbW1lbnQgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kO1xuICAgICAgICBleHRlbmQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpZCkgfHwgaWQgPCAwKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJpZCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXJcIik7XG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcodHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIGlmIChydWxlICE9PSB1bmRlZmluZWQgJiYgIXJ1bGVSZS50ZXN0KHJ1bGUgPSBydWxlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJ1bGUgbXVzdCBiZSBhIHN0cmluZyBydWxlXCIpO1xuXG4gICAgaWYgKGV4dGVuZCAhPT0gdW5kZWZpbmVkICYmICF1dGlsLmlzU3RyaW5nKGV4dGVuZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImV4dGVuZCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogRmllbGQgcnVsZSwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucnVsZSA9IHJ1bGUgJiYgcnVsZSAhPT0gXCJvcHRpb25hbFwiID8gcnVsZSA6IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgZmllbGQgaWQuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gaWQ7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmRlZCB0eXBlIGlmIGRpZmZlcmVudCBmcm9tIHBhcmVudC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmV4dGVuZCA9IGV4dGVuZCB8fCB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIHJlcXVpcmVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWlyZWQgPSBydWxlID09PSBcInJlcXVpcmVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgb3B0aW9uYWwuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25hbCA9ICF0aGlzLnJlcXVpcmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIHJlcGVhdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwZWF0ZWQgPSBydWxlID09PSBcInJlcGVhdGVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgZmllbGQgaXMgYSBtYXAgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIHRoaXMgZmllbGQgYmVsb25ncyB0by5cbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBPbmVPZiB0aGlzIGZpZWxkIGJlbG9uZ3MgdG8sIGlmIGFueSxcbiAgICAgKiBAdHlwZSB7T25lT2Z8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcnRPZiA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQgdHlwZSdzIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy50eXBlRGVmYXVsdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmllbGQncyBkZWZhdWx0IHZhbHVlIG9uIHByb3RvdHlwZXMuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkJ3MgdmFsdWUgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsb25nLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9uZyA9IHV0aWwuTG9uZyA/IHR5cGVzLmxvbmdbdHlwZV0gIT09IHVuZGVmaW5lZCA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkJ3MgdmFsdWUgaXMgYSBidWZmZXIuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5ieXRlcyA9IHR5cGUgPT09IFwiYnl0ZXNcIjtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHR5cGUgaWYgbm90IGEgYmFzaWMgdHlwZS5cbiAgICAgKiBAdHlwZSB7VHlwZXxFbnVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZFR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2lzdGVyLWZpZWxkIHdpdGhpbiB0aGUgZXh0ZW5kZWQgdHlwZSBpZiBhIGRlY2xhcmluZyBleHRlbnNpb24gZmllbGQuXG4gICAgICogQHR5cGUge0ZpZWxkfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5leHRlbnNpb25GaWVsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBTaXN0ZXItZmllbGQgd2l0aGluIHRoZSBkZWNsYXJpbmcgbmFtZXNwYWNlIGlmIGFuIGV4dGVuZGVkIGZpZWxkLlxuICAgICAqIEB0eXBlIHtGaWVsZHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGVjbGFyaW5nRmllbGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxseSByZW1lbWJlcnMgd2hldGhlciB0aGlzIGZpZWxkIGlzIHBhY2tlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFja2VkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcGFja2VkLiBPbmx5IHJlbGV2YW50IHdoZW4gcmVwZWF0ZWQgYW5kIHdvcmtpbmcgd2l0aCBwcm90bzIuXG4gKiBAbmFtZSBGaWVsZCNwYWNrZWRcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaWVsZC5wcm90b3R5cGUsIFwicGFja2VkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSBpZiBub3QgZXhwbGljaXR5IHNldCB0byBmYWxzZVxuICAgICAgICBpZiAodGhpcy5fcGFja2VkID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcGFja2VkID0gdGhpcy5nZXRPcHRpb24oXCJwYWNrZWRcIikgIT09IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFja2VkO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5GaWVsZC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBpZk5vdFNldCkge1xuICAgIGlmIChuYW1lID09PSBcInBhY2tlZFwiKSAvLyBjbGVhciBjYWNoZWQgYmVmb3JlIHNldHRpbmdcbiAgICAgICAgdGhpcy5fcGFja2VkID0gbnVsbDtcbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uLmNhbGwodGhpcywgbmFtZSwgdmFsdWUsIGlmTm90U2V0KTtcbn07XG5cbi8qKlxuICogRmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBGaWVsZCB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaWQgRmllbGQgaWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBGaWVsZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBFeHRlbnNpb24gZmllbGQgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSUV4dGVuc2lvbkZpZWxkXG4gKiBAZXh0ZW5kcyBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBleHRlbmQgRXh0ZW5kZWQgdHlwZVxuICovXG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBmaWVsZCB0byBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJRmllbGR9IEZpZWxkIGRlc2NyaXB0b3JcbiAqL1xuRmllbGQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJydWxlXCIgICAgLCB0aGlzLnJ1bGUgIT09IFwib3B0aW9uYWxcIiAmJiB0aGlzLnJ1bGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInR5cGVcIiAgICAsIHRoaXMudHlwZSxcbiAgICAgICAgXCJpZFwiICAgICAgLCB0aGlzLmlkLFxuICAgICAgICBcImV4dGVuZFwiICAsIHRoaXMuZXh0ZW5kLFxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBmaWVsZCdzIHR5cGUgcmVmZXJlbmNlcy5cbiAqIEByZXR1cm5zIHtGaWVsZH0gYHRoaXNgXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IHJlZmVyZW5jZSBjYW5ub3QgYmUgcmVzb2x2ZWRcbiAqL1xuRmllbGQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuXG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCh0aGlzLnR5cGVEZWZhdWx0ID0gdHlwZXMuZGVmYXVsdHNbdGhpcy50eXBlXSkgPT09IHVuZGVmaW5lZCkgeyAvLyBpZiBub3QgYSBiYXNpYyB0eXBlLCByZXNvbHZlIGl0XG4gICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gKHRoaXMuZGVjbGFyaW5nRmllbGQgPyB0aGlzLmRlY2xhcmluZ0ZpZWxkLnBhcmVudCA6IHRoaXMucGFyZW50KS5sb29rdXBUeXBlT3JFbnVtKHRoaXMudHlwZSk7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcbiAgICAgICAgZWxzZSAvLyBpbnN0YW5jZW9mIEVudW1cbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbT2JqZWN0LmtleXModGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzKVswXV07IC8vIGZpcnN0IGRlZmluZWRcbiAgICB9XG5cbiAgICAvLyB1c2UgZXhwbGljaXRseSBzZXQgZGVmYXVsdCB2YWx1ZSBpZiBwcmVzZW50XG4gICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbXCJkZWZhdWx0XCJdICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl07XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gJiYgdHlwZW9mIHRoaXMudHlwZURlZmF1bHQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzW3RoaXMudHlwZURlZmF1bHRdO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBvcHRpb25zXG4gICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhY2tlZCA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMucGFja2VkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yZXNvbHZlZFR5cGUgJiYgISh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5wYWNrZWQ7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byBpbnRlcm5hbCBkYXRhIHR5cGUgaWYgbmVjZXNzc2FyeVxuICAgIGlmICh0aGlzLmxvbmcpIHtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHV0aWwuTG9uZy5mcm9tTnVtYmVyKHRoaXMudHlwZURlZmF1bHQsIHRoaXMudHlwZS5jaGFyQXQoMCkgPT09IFwidVwiKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSlcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcy50eXBlRGVmYXVsdCk7IC8vIGxvbmcgaW5zdGFuY2VzIGFyZSBtZWFudCB0byBiZSBpbW11dGFibGUgYW55d2F5IChpLmUuIHVzZSBzbWFsbCBpbnQgY2FjaGUgdGhhdCBldmVuIHJlcXVpcmVzIGl0KVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzICYmIHR5cGVvZiB0aGlzLnR5cGVEZWZhdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBidWY7XG4gICAgICAgIGlmICh1dGlsLmJhc2U2NC50ZXN0KHRoaXMudHlwZURlZmF1bHQpKVxuICAgICAgICAgICAgdXRpbC5iYXNlNjQuZGVjb2RlKHRoaXMudHlwZURlZmF1bHQsIGJ1ZiA9IHV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aCh0aGlzLnR5cGVEZWZhdWx0KSksIDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1dGlsLnV0Zjgud3JpdGUodGhpcy50eXBlRGVmYXVsdCwgYnVmID0gdXRpbC5uZXdCdWZmZXIodXRpbC51dGY4Lmxlbmd0aCh0aGlzLnR5cGVEZWZhdWx0KSksIDApO1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gYnVmO1xuICAgIH1cblxuICAgIC8vIHRha2Ugc3BlY2lhbCBjYXJlIG9mIG1hcHMgYW5kIHJlcGVhdGVkIGZpZWxkc1xuICAgIGlmICh0aGlzLm1hcClcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB1dGlsLmVtcHR5T2JqZWN0O1xuICAgIGVsc2UgaWYgKHRoaXMucmVwZWF0ZWQpXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdXRpbC5lbXB0eUFycmF5O1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0aGlzLnR5cGVEZWZhdWx0O1xuXG4gICAgLy8gZW5zdXJlIHByb3BlciB2YWx1ZSBvbiBwcm90b3R5cGVcbiAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICB0aGlzLnBhcmVudC5jdG9yLnByb3RvdHlwZVt0aGlzLm5hbWVdID0gdGhpcy5kZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIEZpZWxkLmR9IGFuZCB7QGxpbmsgTWFwRmllbGQuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgRmllbGREZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IHByb3RvdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7XCJkb3VibGVcInxcImZsb2F0XCJ8XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJzdHJpbmdcInxcImJvb2xcInxcImJ5dGVzXCJ8T2JqZWN0fSBmaWVsZFR5cGUgRmllbGQgdHlwZVxuICogQHBhcmFtIHtcIm9wdGlvbmFsXCJ8XCJyZXF1aXJlZFwifFwicmVwZWF0ZWRcIn0gW2ZpZWxkUnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gRGVmYXVsdCB2YWx1ZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10gfCBMb25nIHwgTG9uZ1tdIHwgc3RyaW5nIHwgc3RyaW5nW10gfCBib29sZWFuIHwgYm9vbGVhbltdIHwgVWludDhBcnJheSB8IFVpbnQ4QXJyYXlbXSB8IEJ1ZmZlciB8IEJ1ZmZlcltdXG4gKi9cbkZpZWxkLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZUZpZWxkKGZpZWxkSWQsIGZpZWxkVHlwZSwgZmllbGRSdWxlLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgIC8vIHN1Ym1lc3NhZ2U6IGRlY29yYXRlIHRoZSBzdWJtZXNzYWdlIGFuZCB1c2UgaXRzIG5hbWUgYXMgdGhlIHR5cGVcbiAgICBpZiAodHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmaWVsZFR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFR5cGUpLm5hbWU7XG5cbiAgICAvLyBlbnVtIHJlZmVyZW5jZTogY3JlYXRlIGEgcmVmbGVjdGVkIGNvcHkgb2YgdGhlIGVudW0gYW5kIGtlZXAgcmV1c2VpbmcgaXRcbiAgICBlbHNlIGlmIChmaWVsZFR5cGUgJiYgdHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZUVudW0oZmllbGRUeXBlKS5uYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpZWxkRGVjb3JhdG9yKHByb3RvdHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IEZpZWxkKGZpZWxkTmFtZSwgZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIHsgXCJkZWZhdWx0XCI6IGRlZmF1bHRWYWx1ZSB9KSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD58c3RyaW5nfSBmaWVsZFR5cGUgRmllbGQgdHlwZVxuICogQHBhcmFtIHtcIm9wdGlvbmFsXCJ8XCJyZXF1aXJlZFwifFwicmVwZWF0ZWRcIn0gW2ZpZWxkUnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBsaWtlIEZpZWxkLmQgYnV0IHdpdGhvdXQgYSBkZWZhdWx0IHZhbHVlXG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuRmllbGQuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZShUeXBlXykge1xuICAgIFR5cGUgPSBUeXBlXztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbWluaW1hbFwiKTtcblxucHJvdG9idWYuYnVpbGQgPSBcImxpZ2h0XCI7XG5cbi8qKlxuICogQSBub2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIGxvYWR9IGFuZCB7QGxpbmsgUm9vdCNsb2FkfS5cbiAqIEB0eXBlZGVmIExvYWRDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290LCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcGFyYW0ge0xvYWRDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAc2VlIHtAbGluayBSb290I2xvYWR9XG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIHJvb3QsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiByb290ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSByb290O1xuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICB9IGVsc2UgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkKGZpbGVuYW1lLCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqIEBuYW1lIGxvYWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqIEB2YXJpYXRpb24gM1xuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgW3Jvb3Q6Um9vdF0pOlByb21pc2U8Um9vdD5cblxucHJvdG9idWYubG9hZCA9IGxvYWQ7XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIChub2RlIG9ubHkpLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IFtyb290XSBSb290IG5hbWVzcGFjZSwgZGVmYXVsdHMgdG8gY3JlYXRlIGEgbmV3IG9uZSBpZiBvbWl0dGVkLlxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc3luY2hyb25vdXMgZmV0Y2hpbmcgaXMgbm90IHN1cHBvcnRlZCAoaS5lLiBpbiBicm93c2Vycykgb3IgaWYgYSBmaWxlJ3Mgc3ludGF4IGlzIGludmFsaWRcbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZFN5bmN9XG4gKi9cbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IHByb3RvYnVmLlJvb3QoKTtcbiAgICByZXR1cm4gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSk7XG59XG5cbnByb3RvYnVmLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLmVuY29kZXIgICAgICAgICAgPSByZXF1aXJlKFwiLi9lbmNvZGVyXCIpO1xucHJvdG9idWYuZGVjb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2RlY29kZXJcIik7XG5wcm90b2J1Zi52ZXJpZmllciAgICAgICAgID0gcmVxdWlyZShcIi4vdmVyaWZpZXJcIik7XG5wcm90b2J1Zi5jb252ZXJ0ZXIgICAgICAgID0gcmVxdWlyZShcIi4vY29udmVydGVyXCIpO1xuXG4vLyBSZWZsZWN0aW9uXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xucHJvdG9idWYuTmFtZXNwYWNlICAgICAgICA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbnByb3RvYnVmLlJvb3QgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9yb290XCIpO1xucHJvdG9idWYuRW51bSAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5wcm90b2J1Zi5UeXBlICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcbnByb3RvYnVmLkZpZWxkICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKTtcbnByb3RvYnVmLk9uZU9mICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKTtcbnByb3RvYnVmLk1hcEZpZWxkICAgICAgICAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKTtcbnByb3RvYnVmLlNlcnZpY2UgICAgICAgICAgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xucHJvdG9idWYuTWV0aG9kICAgICAgICAgICA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKTtcblxuLy8gUnVudGltZVxucHJvdG9idWYuTWVzc2FnZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG5wcm90b2J1Zi53cmFwcGVycyAgICAgICAgID0gcmVxdWlyZShcIi4vd3JhcHBlcnNcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnR5cGVzICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnByb3RvYnVmLnV0aWwgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vLyBTZXQgdXAgcG9zc2libHkgY3ljbGljIHJlZmxlY3Rpb24gZGVwZW5kZW5jaWVzXG5wcm90b2J1Zi5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUocHJvdG9idWYuUm9vdCk7XG5wcm90b2J1Zi5OYW1lc3BhY2UuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5TZXJ2aWNlLCBwcm90b2J1Zi5FbnVtKTtcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbnByb3RvYnVmLkZpZWxkLl9jb25maWd1cmUocHJvdG9idWYuVHlwZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2luZGV4LWxpZ2h0XCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwiZnVsbFwiO1xuXG4vLyBQYXJzZXJcbnByb3RvYnVmLnRva2VuaXplICAgICAgICAgPSByZXF1aXJlKFwiLi90b2tlbml6ZVwiKTtcbnByb3RvYnVmLnBhcnNlICAgICAgICAgICAgPSByZXF1aXJlKFwiLi9wYXJzZVwiKTtcbnByb3RvYnVmLmNvbW1vbiAgICAgICAgICAgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5cbi8vIENvbmZpZ3VyZSBwYXJzZXJcbnByb3RvYnVmLlJvb3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlLCBwcm90b2J1Zi5wYXJzZSwgcHJvdG9idWYuY29tbW9uKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNYXBGaWVsZDtcblxuLy8gZXh0ZW5kcyBGaWVsZFxudmFyIEZpZWxkID0gcmVxdWlyZShcIi4vZmllbGRcIik7XG4oKE1hcEZpZWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmllbGQucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBNYXBGaWVsZCkuY2xhc3NOYW1lID0gXCJNYXBGaWVsZFwiO1xuXG52YXIgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWFwIGZpZWxkIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgbWFwIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5VHlwZSBLZXkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVmFsdWUgdHlwZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBNYXBGaWVsZChuYW1lLCBpZCwga2V5VHlwZSwgdHlwZSwgb3B0aW9ucywgY29tbWVudCkge1xuICAgIEZpZWxkLmNhbGwodGhpcywgbmFtZSwgaWQsIHR5cGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLCBjb21tZW50KTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghdXRpbC5pc1N0cmluZyhrZXlUeXBlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwia2V5VHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyoqXG4gICAgICogS2V5IHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmtleVR5cGUgPSBrZXlUeXBlOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQga2V5IHR5cGUgaWYgbm90IGEgYmFzaWMgdHlwZS5cbiAgICAgKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRLZXlUeXBlID0gbnVsbDtcblxuICAgIC8vIE92ZXJyaWRlcyBGaWVsZCNtYXBcbiAgICB0aGlzLm1hcCA9IHRydWU7XG59XG5cbi8qKlxuICogTWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElNYXBGaWVsZFxuICogQGV4dGVuZHMge0lGaWVsZH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlUeXBlIEtleSB0eXBlXG4gKi9cblxuLyoqXG4gKiBFeHRlbnNpb24gbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElFeHRlbnNpb25NYXBGaWVsZFxuICogQGV4dGVuZHMgSU1hcEZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXh0ZW5kIEV4dGVuZGVkIHR5cGVcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtYXAgZmllbGQgZnJvbSBhIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICogQHBhcmFtIHtJTWFwRmllbGR9IGpzb24gTWFwIGZpZWxkIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtNYXBGaWVsZH0gQ3JlYXRlZCBtYXAgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1hcEZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTWFwRmllbGQobmFtZSwganNvbi5pZCwganNvbi5rZXlUeXBlLCBqc29uLnR5cGUsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtYXAgZmllbGQgdG8gYSBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lNYXBGaWVsZH0gTWFwIGZpZWxkIGRlc2NyaXB0b3JcbiAqL1xuTWFwRmllbGQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJrZXlUeXBlXCIgLCB0aGlzLmtleVR5cGUsXG4gICAgICAgIFwidHlwZVwiICAgICwgdGhpcy50eXBlLFxuICAgICAgICBcImlkXCIgICAgICAsIHRoaXMuaWQsXG4gICAgICAgIFwiZXh0ZW5kXCIgICwgdGhpcy5leHRlbmQsXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuTWFwRmllbGQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuICAgIGlmICh0aGlzLnJlc29sdmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIC8vIEJlc2lkZXMgYSB2YWx1ZSB0eXBlLCBtYXAgZmllbGRzIGhhdmUgYSBrZXkgdHlwZSB0aGF0IG1heSBiZSBcImFueSBzY2FsYXIgdHlwZSBleGNlcHQgZm9yIGZsb2F0aW5nIHBvaW50IHR5cGVzIGFuZCBieXRlc1wiXG4gICAgaWYgKHR5cGVzLm1hcEtleVt0aGlzLmtleVR5cGVdID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBrZXkgdHlwZTogXCIgKyB0aGlzLmtleVR5cGUpO1xuXG4gICAgcmV0dXJuIEZpZWxkLnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIE1hcCBmaWVsZCBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQG5hbWUgTWFwRmllbGQuZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJZCBGaWVsZCBpZFxuICogQHBhcmFtIHtcImludDMyXCJ8XCJ1aW50MzJcInxcInNpbnQzMlwifFwiZml4ZWQzMlwifFwic2ZpeGVkMzJcInxcImludDY0XCJ8XCJ1aW50NjRcInxcInNpbnQ2NFwifFwiZml4ZWQ2NFwifFwic2ZpeGVkNjRcInxcImJvb2xcInxcInN0cmluZ1wifSBmaWVsZEtleVR5cGUgRmllbGQga2V5IHR5cGVcbiAqIEBwYXJhbSB7XCJkb3VibGVcInxcImZsb2F0XCJ8XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJib29sXCJ8XCJzdHJpbmdcInxcImJ5dGVzXCJ8T2JqZWN0fENvbnN0cnVjdG9yPHt9Pn0gZmllbGRWYWx1ZVR5cGUgRmllbGQgdmFsdWUgdHlwZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfCBMb25nIHwgc3RyaW5nIHwgYm9vbGVhbiB8IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBudW1iZXJbXSB8IE1lc3NhZ2U8e30+IH1cbiAqL1xuTWFwRmllbGQuZCA9IGZ1bmN0aW9uIGRlY29yYXRlTWFwRmllbGQoZmllbGRJZCwgZmllbGRLZXlUeXBlLCBmaWVsZFZhbHVlVHlwZSkge1xuXG4gICAgLy8gc3VibWVzc2FnZSB2YWx1ZTogZGVjb3JhdGUgdGhlIHN1Ym1lc3NhZ2UgYW5kIHVzZSBpdHMgbmFtZSBhcyB0aGUgdHlwZVxuICAgIGlmICh0eXBlb2YgZmllbGRWYWx1ZVR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFZhbHVlVHlwZSkubmFtZTtcblxuICAgIC8vIGVudW0gcmVmZXJlbmNlIHZhbHVlOiBjcmVhdGUgYSByZWZsZWN0ZWQgY29weSBvZiB0aGUgZW51bSBhbmQga2VlcCByZXVzZWluZyBpdFxuICAgIGVsc2UgaWYgKGZpZWxkVmFsdWVUeXBlICYmIHR5cGVvZiBmaWVsZFZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgZmllbGRWYWx1ZVR5cGUgPSB1dGlsLmRlY29yYXRlRW51bShmaWVsZFZhbHVlVHlwZSkubmFtZTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXBGaWVsZERlY29yYXRvcihwcm90b3R5cGUsIGZpZWxkTmFtZSkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZShwcm90b3R5cGUuY29uc3RydWN0b3IpXG4gICAgICAgICAgICAuYWRkKG5ldyBNYXBGaWVsZChmaWVsZE5hbWUsIGZpZWxkSWQsIGZpZWxkS2V5VHlwZSwgZmllbGRWYWx1ZVR5cGUpKTtcbiAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFic3RyYWN0IHJ1bnRpbWUgbWVzc2FnZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQcm9wZXJ0aWVzPFQ+fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgb2JqZWN0ID0gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIE1lc3NhZ2UocHJvcGVydGllcykge1xuICAgIC8vIG5vdCB1c2VkIGludGVybmFsbHlcbiAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbn1cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIHJlZmxlY3RlZCB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS4kdHlwZVxuICogQHR5cGUge1R5cGV9XG4gKiBAcmVhZG9ubHlcbiAqL1xuXG4vKipcbiAqIFJlZmVyZW5jZSB0byB0aGUgcmVmbGVjdGVkIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlIyR0eXBlXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEByZWFkb25seVxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTxUPn0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuY3JlYXRlKHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1R8T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSB0byBlbmNvZGVcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gdXNlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBXcml0ZXJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcik7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7VHxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIHRvIGVuY29kZVxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byB1c2VcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IFdyaXRlclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5lbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS5kZWNvZGVcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7VH0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmRlY29kZShyZWFkZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBNZXNzYWdlLmRlY29kZURlbGltaXRlZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtUfSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZGVjb2RlRGVsaW1pdGVkKHJlYWRlcik7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAbmFtZSBNZXNzYWdlLnZlcmlmeVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gKi9cbk1lc3NhZ2UudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS52ZXJpZnkobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAqIEByZXR1cm5zIHtUfSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtUfSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1lc3NhZ2UgdG8gSlNPTi5cbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLnRvT2JqZWN0KHRoaXMsIHV0aWwudG9KU09OT3B0aW9ucyk7XG59O1xuXG4vKmVzbGludC1lbmFibGUgdmFsaWQtanNkb2MqLyIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNZXRob2Q7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE1ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBNZXRob2QpLmNsYXNzTmFtZSA9IFwiTWV0aG9kXCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHNlcnZpY2UgbWV0aG9kIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgc2VydmljZSBtZXRob2QuXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHR5cGUgTWV0aG9kIHR5cGUsIHVzdWFsbHkgYFwicnBjXCJgXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdFR5cGUgUmVxdWVzdCBtZXNzYWdlIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVR5cGUgUmVzcG9uc2UgbWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0LjxzdHJpbmcsKj59IFtyZXF1ZXN0U3RyZWFtXSBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWVkXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0LjxzdHJpbmcsKj59IFtyZXNwb25zZVN0cmVhbV0gV2hldGhlciB0aGUgcmVzcG9uc2UgaXMgc3RyZWFtZWRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIFRoZSBjb21tZW50IGZvciB0aGlzIG1ldGhvZFxuICovXG5mdW5jdGlvbiBNZXRob2QobmFtZSwgdHlwZSwgcmVxdWVzdFR5cGUsIHJlc3BvbnNlVHlwZSwgcmVxdWVzdFN0cmVhbSwgcmVzcG9uc2VTdHJlYW0sIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocmVxdWVzdFN0cmVhbSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlcXVlc3RTdHJlYW07XG4gICAgICAgIHJlcXVlc3RTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QocmVzcG9uc2VTdHJlYW0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXNwb25zZVN0cmVhbTtcbiAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHV0aWwuaXNTdHJpbmcodHlwZSkpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ0eXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcocmVxdWVzdFR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0VHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHJlc3BvbnNlVHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlc3BvbnNlVHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IFwicnBjXCI7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0VHlwZSA9IHJlcXVlc3RUeXBlOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3RTdHJlYW0gPSByZXF1ZXN0U3RyZWFtID8gdHJ1ZSA6IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zZSB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZVN0cmVhbSA9IHJlc3BvbnNlU3RyZWFtID8gdHJ1ZSA6IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCByZXF1ZXN0IHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgcmVzcG9uc2UgdHlwZS5cbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBtZXRob2RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcbn1cblxuLyoqXG4gKiBNZXRob2QgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU1ldGhvZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlPVwicnBjXCJdIE1ldGhvZCB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVxdWVzdFR5cGUgUmVxdWVzdCB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVlc3RTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXNwb25zZVN0cmVhbT1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gTWV0aG9kIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBtZXRob2QgZnJvbSBhIG1ldGhvZCBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWV0aG9kIG5hbWVcbiAqIEBwYXJhbSB7SU1ldGhvZH0ganNvbiBNZXRob2QgZGVzY3JpcHRvclxuICogQHJldHVybnMge01ldGhvZH0gQ3JlYXRlZCBtZXRob2RcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk1ldGhvZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1ldGhvZChuYW1lLCBqc29uLnR5cGUsIGpzb24ucmVxdWVzdFR5cGUsIGpzb24ucmVzcG9uc2VUeXBlLCBqc29uLnJlcXVlc3RTdHJlYW0sIGpzb24ucmVzcG9uc2VTdHJlYW0sIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtZXRob2QgdG8gYSBtZXRob2QgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lNZXRob2R9IE1ldGhvZCBkZXNjcmlwdG9yXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcInR5cGVcIiAgICAgICAgICAgLCB0aGlzLnR5cGUgIT09IFwicnBjXCIgJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdGhpcy50eXBlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJyZXF1ZXN0VHlwZVwiICAgICwgdGhpcy5yZXF1ZXN0VHlwZSxcbiAgICAgICAgXCJyZXF1ZXN0U3RyZWFtXCIgICwgdGhpcy5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICBcInJlc3BvbnNlVHlwZVwiICAgLCB0aGlzLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgXCJyZXNwb25zZVN0cmVhbVwiICwgdGhpcy5yZXNwb25zZVN0cmVhbSxcbiAgICAgICAgXCJvcHRpb25zXCIgICAgICAgICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcImNvbW1lbnRcIiAgICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk1ldGhvZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSB0aGlzLnBhcmVudC5sb29rdXBUeXBlKHRoaXMucmVxdWVzdFR5cGUpO1xuICAgIHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSB0aGlzLnBhcmVudC5sb29rdXBUeXBlKHRoaXMucmVzcG9uc2VUeXBlKTtcblxuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlLmNhbGwodGhpcyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE5hbWVzcGFjZTtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoTmFtZXNwYWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE5hbWVzcGFjZSkuY2xhc3NOYW1lID0gXCJOYW1lc3BhY2VcIjtcblxudmFyIEZpZWxkICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgdXRpbCAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgVHlwZSwgICAgLy8gY3ljbGljXG4gICAgU2VydmljZSxcbiAgICBFbnVtO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQG5hbWUgTmFtZXNwYWNlXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBuYW1lc3BhY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5hbWVzcGFjZSBmcm9tIEpTT04uXG4gKiBAbWVtYmVyb2YgTmFtZXNwYWNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBDcmVhdGVkIG5hbWVzcGFjZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTmFtZXNwYWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTmFtZXNwYWNlKG5hbWUsIGpzb24ub3B0aW9ucykuYWRkSlNPTihqc29uLm5lc3RlZCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHJlZmxlY3Rpb24gb2JqZWN0cyB0byBKU09OLlxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0W119IGFycmF5IE9iamVjdCBhcnJheVxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfSBKU09OIG9iamVjdCBvciBgdW5kZWZpbmVkYCB3aGVuIGFycmF5IGlzIGVtcHR5XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9KU09OKGFycmF5LCB0b0pTT05PcHRpb25zKSB7XG4gICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgb2JqW2FycmF5W2ldLm5hbWVdID0gYXJyYXlbaV0udG9KU09OKHRvSlNPTk9wdGlvbnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbk5hbWVzcGFjZS5hcnJheVRvSlNPTiA9IGFycmF5VG9KU09OO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbk5hbWVzcGFjZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQocmVzZXJ2ZWQsIGlkKSB7XG4gICAgaWYgKHJlc2VydmVkKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNlcnZlZFtpXSAhPT0gXCJzdHJpbmdcIiAmJiByZXNlcnZlZFtpXVswXSA8PSBpZCAmJiByZXNlcnZlZFtpXVsxXSA+IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyW118c3RyaW5nPnx1bmRlZmluZWR9IHJlc2VydmVkIEFycmF5IG9mIHJlc2VydmVkIHJhbmdlcyBhbmQgbmFtZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUocmVzZXJ2ZWQsIG5hbWUpIHtcbiAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRbaV0gPT09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIE5hbWVzcGFjZX0gaW5zdGVhZC5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzIGNvbnRhaW5pbmcgbmVzdGVkIG9iamVjdHMuIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBjbGFzcyBidXQgaGVyZSBmb3IgdGhlIHNha2Ugb2YgaGF2aW5nIGNvbnNpc3RlbnQgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBleHBvcnRzIE5hbWVzcGFjZUJhc2VcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBhYnN0cmFjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIE5hbWVzcGFjZX1cbiAqL1xuZnVuY3Rpb24gTmFtZXNwYWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgb2JqZWN0cyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSZWZsZWN0aW9uT2JqZWN0Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXN0ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG5lc3RlZCBvYmplY3RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX25lc3RlZEFycmF5ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYWNoZShuYW1lc3BhY2UpIHtcbiAgICBuYW1lc3BhY2UuX25lc3RlZEFycmF5ID0gbnVsbDtcbiAgICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG4vKipcbiAqIE5lc3RlZCBvYmplY3RzIG9mIHRoaXMgbmFtZXNwYWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI25lc3RlZEFycmF5XG4gKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYW1lc3BhY2UucHJvdG90eXBlLCBcIm5lc3RlZEFycmF5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVzdGVkQXJyYXkgfHwgKHRoaXMuX25lc3RlZEFycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubmVzdGVkKSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogTmFtZXNwYWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBOYW1lc3BhY2Ugb3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBbbmVzdGVkXSBOZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXG4gKi9cblxuLyoqXG4gKiBBbnkgZXh0ZW5zaW9uIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAdHlwZWRlZiBBbnlFeHRlbnNpb25GaWVsZFxuICogQHR5cGUge0lFeHRlbnNpb25GaWVsZHxJRXh0ZW5zaW9uTWFwRmllbGR9XG4gKi9cblxuLyoqXG4gKiBBbnkgbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yLlxuICogQHR5cGVkZWYgQW55TmVzdGVkT2JqZWN0XG4gKiBAdHlwZSB7SUVudW18SVR5cGV8SVNlcnZpY2V8QW55RXh0ZW5zaW9uRmllbGR8SU5hbWVzcGFjZX1cbiAqL1xuLy8gXiBCRVdBUkU6IFZTQ29kZSBoYW5ncyBmb3JldmVyIHdoZW4gdXNpbmcgbW9yZSB0aGFuIDUgdHlwZXMgKHRoYXQncyB3aHkgQW55RXh0ZW5zaW9uRmllbGQgZXhpc3RzIGluIHRoZSBmaXJzdCBwbGFjZSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG5hbWVzcGFjZSB0byBhIG5hbWVzcGFjZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZX0gTmFtZXNwYWNlIGRlc2NyaXB0b3JcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwibmVzdGVkXCIgICwgYXJyYXlUb0pTT04odGhpcy5uZXN0ZWRBcnJheSwgdG9KU09OT3B0aW9ucylcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyBuZXN0ZWQgb2JqZWN0cyB0byB0aGlzIG5hbWVzcGFjZSBmcm9tIG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLEFueU5lc3RlZE9iamVjdD59IG5lc3RlZEpzb24gQW55IG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnNcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZEpTT04gPSBmdW5jdGlvbiBhZGRKU09OKG5lc3RlZEpzb24pIHtcbiAgICB2YXIgbnMgPSB0aGlzO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5lc3RlZEpzb24pIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhuZXN0ZWRKc29uKSwgaSA9IDAsIG5lc3RlZDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRKc29uW25hbWVzW2ldXTtcbiAgICAgICAgICAgIG5zLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLnZhbHVlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTZXJ2aWNlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXN0ZWQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5lc3RlZCBvYmplY3QgbmFtZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gVGhlIHJlZmxlY3Rpb24gb2JqZWN0IG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cbiAgICAgICAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEVudW18ZW51bX0gb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICogVGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2dldHxnZXR9IGluIHRoYXQgaXQgcmV0dXJucyBhbiBlbnVtJ3MgdmFsdWVzIGRpcmVjdGx5IGFuZCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmVzdGVkIGVudW0gbmFtZVxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLG51bWJlcj59IEVudW0gdmFsdWVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0RW51bSA9IGZ1bmN0aW9uIGdldEVudW0obmFtZSkge1xuICAgIGlmICh0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXSBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgIHJldHVybiB0aGlzLm5lc3RlZFtuYW1lXS52YWx1ZXM7XG4gICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIGVudW06IFwiICsgbmFtZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbmVzdGVkIG9iamVjdCB3aXRoIHRoaXMgbmFtZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUeXBlIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVudW0gfHwgb2JqZWN0IGluc3RhbmNlb2YgU2VydmljZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIHZhbGlkIG5lc3RlZCBvYmplY3RcIik7XG5cbiAgICBpZiAoIXRoaXMubmVzdGVkKVxuICAgICAgICB0aGlzLm5lc3RlZCA9IHt9O1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJldiA9IHRoaXMuZ2V0KG9iamVjdC5uYW1lKTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGlmIChwcmV2IGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAhKHByZXYgaW5zdGFuY2VvZiBUeXBlIHx8IHByZXYgaW5zdGFuY2VvZiBTZXJ2aWNlKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcGxhaW4gbmFtZXNwYWNlIGJ1dCBrZWVwIGV4aXN0aW5nIG5lc3RlZCBlbGVtZW50cyBhbmQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBwcmV2Lm5lc3RlZEFycmF5O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVzdGVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuYWRkKG5lc3RlZFtpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUocHJldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm5lc3RlZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBvYmplY3Quc2V0T3B0aW9ucyhwcmV2Lm9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5uZXN0ZWRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYG9iamVjdGAgaXMgbm90IGEgbWVtYmVyIG9mIHRoaXMgbmFtZXNwYWNlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuXG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgUmVmbGVjdGlvbk9iamVjdCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9iamVjdCBtdXN0IGJlIGEgUmVmbGVjdGlvbk9iamVjdFwiKTtcbiAgICBpZiAob2JqZWN0LnBhcmVudCAhPT0gdGhpcylcbiAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICBkZWxldGUgdGhpcy5uZXN0ZWRbb2JqZWN0Lm5hbWVdO1xuICAgIGlmICghT2JqZWN0LmtleXModGhpcy5uZXN0ZWQpLmxlbmd0aClcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XG4gICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYWRkaXRpYWwgbmFtZXNwYWNlcyB3aXRoaW4gdGhpcyBvbmUgaWYgbm90IHlldCBleGlzdGluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gY3JlYXRlXG4gKiBAcGFyYW0geyp9IFtqc29uXSBOZXN0ZWQgdHlwZXMgdG8gY3JlYXRlIGZyb20gSlNPTlxuICogQHJldHVybnMge05hbWVzcGFjZX0gUG9pbnRlciB0byB0aGUgbGFzdCBuYW1lc3BhY2UgY3JlYXRlZCBvciBgdGhpc2AgaWYgcGF0aCBpcyBlbXB0eVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShwYXRoLCBqc29uKSB7XG5cbiAgICBpZiAodXRpbC5pc1N0cmluZyhwYXRoKSlcbiAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJpbGxlZ2FsIHBhdGhcIik7XG4gICAgaWYgKHBhdGggJiYgcGF0aC5sZW5ndGggJiYgcGF0aFswXSA9PT0gXCJcIilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIG11c3QgYmUgcmVsYXRpdmVcIik7XG5cbiAgICB2YXIgcHRyID0gdGhpcztcbiAgICB3aGlsZSAocGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAocHRyLm5lc3RlZCAmJiBwdHIubmVzdGVkW3BhcnRdKSB7XG4gICAgICAgICAgICBwdHIgPSBwdHIubmVzdGVkW3BhcnRdO1xuICAgICAgICAgICAgaWYgKCEocHRyIGluc3RhbmNlb2YgTmFtZXNwYWNlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcInBhdGggY29uZmxpY3RzIHdpdGggbm9uLW5hbWVzcGFjZSBvYmplY3RzXCIpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHB0ci5hZGQocHRyID0gbmV3IE5hbWVzcGFjZShwYXJ0KSk7XG4gICAgfVxuICAgIGlmIChqc29uKVxuICAgICAgICBwdHIuYWRkSlNPTihqc29uKTtcbiAgICByZXR1cm4gcHRyO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIG5hbWVzcGFjZSdzIGFuZCBhbGwgaXRzIG5lc3RlZCBvYmplY3RzJyB0eXBlIHJlZmVyZW5jZXMuIFVzZWZ1bCB0byB2YWxpZGF0ZSBhIHJlZmxlY3Rpb24gdHJlZSwgYnV0IGNvbWVzIGF0IGEgY29zdC5cbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIHZhciBuZXN0ZWQgPSB0aGlzLm5lc3RlZEFycmF5LCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG5lc3RlZC5sZW5ndGgpXG4gICAgICAgIGlmIChuZXN0ZWRbaV0gaW5zdGFuY2VvZiBOYW1lc3BhY2UpXG4gICAgICAgICAgICBuZXN0ZWRbaSsrXS5yZXNvbHZlQWxsKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5lc3RlZFtpKytdLnJlc29sdmUoKTtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKCk7XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGxvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHBhdGggaW4gdGhlIHNjb3BlIG9mIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0geyp8QXJyYXkuPCo+fSBmaWx0ZXJUeXBlcyBGaWx0ZXIgdHlwZXMsIGFueSBjb21iaW5hdGlvbiBvZiB0aGUgY29uc3RydWN0b3JzIG9mIGBwcm90b2J1Zi5UeXBlYCwgYHByb3RvYnVmLkVudW1gLCBgcHJvdG9idWYuU2VydmljZWAgZXRjLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyZW50QWxyZWFkeUNoZWNrZWQ9ZmFsc2VdIElmIGtub3duLCB3aGV0aGVyIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBMb29rZWQgdXAgb2JqZWN0IG9yIGBudWxsYCBpZiBub25lIGNvdWxkIGJlIGZvdW5kXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gbG9va3VwKHBhdGgsIGZpbHRlclR5cGVzLCBwYXJlbnRBbHJlYWR5Q2hlY2tlZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGZpbHRlclR5cGVzID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBwYXJlbnRBbHJlYWR5Q2hlY2tlZCA9IGZpbHRlclR5cGVzO1xuICAgICAgICBmaWx0ZXJUeXBlcyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGZpbHRlclR5cGVzICYmICFBcnJheS5pc0FycmF5KGZpbHRlclR5cGVzKSlcbiAgICAgICAgZmlsdGVyVHlwZXMgPSBbIGZpbHRlclR5cGVzIF07XG5cbiAgICBpZiAodXRpbC5pc1N0cmluZyhwYXRoKSAmJiBwYXRoLmxlbmd0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gXCIuXCIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgICAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgfSBlbHNlIGlmICghcGF0aC5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgLy8gU3RhcnQgYXQgcm9vdCBpZiBwYXRoIGlzIGFic29sdXRlXG4gICAgaWYgKHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QubG9va3VwKHBhdGguc2xpY2UoMSksIGZpbHRlclR5cGVzKTtcblxuICAgIC8vIFRlc3QgaWYgdGhlIGZpcnN0IHBhcnQgbWF0Y2hlcyBhbnkgbmVzdGVkIG9iamVjdCwgYW5kIGlmIHNvLCB0cmF2ZXJzZSBpZiBwYXRoIGNvbnRhaW5zIG1vcmVcbiAgICB2YXIgZm91bmQgPSB0aGlzLmdldChwYXRoWzBdKTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoIWZpbHRlclR5cGVzIHx8IGZpbHRlclR5cGVzLmluZGV4T2YoZm91bmQuY29uc3RydWN0b3IpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9IGVsc2UgaWYgKGZvdW5kIGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIChmb3VuZCA9IGZvdW5kLmxvb2t1cChwYXRoLnNsaWNlKDEpLCBmaWx0ZXJUeXBlcywgdHJ1ZSkpKVxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuXG4gICAgLy8gT3RoZXJ3aXNlIHRyeSBlYWNoIG5lc3RlZCBuYW1lc3BhY2VcbiAgICB9IGVsc2VcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgTmFtZXNwYWNlICYmIChmb3VuZCA9IHRoaXMuX25lc3RlZEFycmF5W2ldLmxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgdHJ1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcblxuICAgIC8vIElmIHRoZXJlIGhhc24ndCBiZWVuIGEgbWF0Y2gsIHRyeSBhZ2FpbiBhdCB0aGUgcGFyZW50XG4gICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsIHx8IHBhcmVudEFscmVhZHlDaGVja2VkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQubG9va3VwKHBhdGgsIGZpbHRlclR5cGVzKTtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHJlZmxlY3Rpb24gb2JqZWN0IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI2xvb2t1cFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBXaGV0aGVyIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkXG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdHxudWxsfSBMb29rZWQgdXAgb2JqZWN0IG9yIGBudWxsYCBpZiBub25lIGNvdWxkIGJlIGZvdW5kXG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuLy8gbG9va3VwKHBhdGg6IHN0cmluZywgW3BhcmVudEFscmVhZHlDaGVja2VkOiBib29sZWFuXSlcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFR5cGV8dHlwZX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1R5cGV9IExvb2tlZCB1cCB0eXBlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgdHlwZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGUgPSBmdW5jdGlvbiBsb29rdXBUeXBlKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFR5cGUgXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIHR5cGU6IFwiICsgcGF0aCk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUgdmFsdWVzIG9mIHRoZSB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7RW51bX0gTG9va2VkIHVwIGVudW1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYW4gZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cEVudW0gPSBmdW5jdGlvbiBsb29rdXBFbnVtKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIEVudW0gXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIEVudW0gJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBUeXBlfHR5cGV9IG9yIHtAbGluayBFbnVtfGVudW19IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtUeXBlfSBMb29rZWQgdXAgdHlwZSBvciBlbnVtXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgdHlwZSBvciBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwVHlwZU9yRW51bSA9IGZ1bmN0aW9uIGxvb2t1cFR5cGVPckVudW0ocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgVHlwZSwgRW51bSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggVHlwZSBvciBFbnVtICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgU2VydmljZXxzZXJ2aWNlfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7U2VydmljZX0gTG9va2VkIHVwIHNlcnZpY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcGF0aGAgZG9lcyBub3QgcG9pbnQgdG8gYSBzZXJ2aWNlXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUubG9va3VwU2VydmljZSA9IGZ1bmN0aW9uIGxvb2t1cFNlcnZpY2UocGF0aCkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMubG9va3VwKHBhdGgsIFsgU2VydmljZSBdKTtcbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggU2VydmljZSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5OYW1lc3BhY2UuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKFR5cGVfLCBTZXJ2aWNlXywgRW51bV8pIHtcbiAgICBUeXBlICAgID0gVHlwZV87XG4gICAgU2VydmljZSA9IFNlcnZpY2VfO1xuICAgIEVudW0gICAgPSBFbnVtXztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVmbGVjdGlvbk9iamVjdDtcblxuUmVmbGVjdGlvbk9iamVjdC5jbGFzc05hbWUgPSBcIlJlZmxlY3Rpb25PYmplY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgUm9vdDsgLy8gY3ljbGljXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWZsZWN0aW9uIG9iamVjdCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPYmplY3QgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBhYnN0cmFjdFxuICovXG5mdW5jdGlvbiBSZWZsZWN0aW9uT2JqZWN0KG5hbWUsIG9wdGlvbnMpIHtcblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgIXV0aWwuaXNPYmplY3Qob3B0aW9ucykpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25zLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZWQgT3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdC48c3RyaW5nLCo+Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5wYXJzZWRPcHRpb25zID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIFBhcmVudCBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUge05hbWVzcGFjZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYWxyZWFkeSByZXNvbHZlZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCB0ZXh0LCBpZiBhbnkuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmluZyBmaWxlIG5hbWUuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZmlsZW5hbWUgPSBudWxsO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSByb290IG5hbWVzcGFjZS5cbiAgICAgKiBAbmFtZSBSZWZsZWN0aW9uT2JqZWN0I3Jvb3RcbiAgICAgKiBAdHlwZSB7Um9vdH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICByb290OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHRyID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChwdHIucGFyZW50ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcHRyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZ1bGwgbmFtZSBpbmNsdWRpbmcgbGVhZGluZyBkb3QuXG4gICAgICogQG5hbWUgUmVmbGVjdGlvbk9iamVjdCNmdWxsTmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZnVsbE5hbWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gWyB0aGlzLm5hbWUgXSxcbiAgICAgICAgICAgICAgICBwdHIgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlIChwdHIpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnVuc2hpZnQocHRyLm5hbWUpO1xuICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5qb2luKFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgcmVmbGVjdGlvbiBvYmplY3QgdG8gaXRzIGRlc2NyaXB0b3IgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc2NyaXB0b3JcbiAqIEBhYnN0cmFjdFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS50b0pTT04gPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgdGhyb3cgRXJyb3IoKTsgLy8gbm90IGltcGxlbWVudGVkLCBzaG91bGRuJ3QgaGFwcGVuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIGFkZGVkIHRvIGEgcGFyZW50LlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBwYXJlbnQgUGFyZW50IGFkZGVkIHRvXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uIG9uQWRkKHBhcmVudCkge1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudCAhPT0gcGFyZW50KVxuICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICByb290Ll9oYW5kbGVBZGQodGhpcyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoaXMgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIHBhcmVudC5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gcGFyZW50IFBhcmVudCByZW1vdmVkIGZyb21cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gb25SZW1vdmUocGFyZW50KSB7XG4gICAgdmFyIHJvb3QgPSBwYXJlbnQucm9vdDtcbiAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHJvb3QuX2hhbmRsZVJlbW92ZSh0aGlzKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIG9iamVjdHMgdHlwZSByZWZlcmVuY2VzLlxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIFJvb3QpXG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlOyAvLyBvbmx5IGlmIHBhcnQgb2YgYSByb290XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgYW4gb3B0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT3B0aW9uIG5hbWVcbiAqIEByZXR1cm5zIHsqfSBPcHRpb24gdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgbm90IHNldFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0XSBTZXRzIHRoZSBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbiA9IGZ1bmN0aW9uIHNldE9wdGlvbihuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpIHtcbiAgICBpZiAoIWlmTm90U2V0IHx8ICF0aGlzLm9wdGlvbnMgfHwgdGhpcy5vcHRpb25zW25hbWVdID09PSB1bmRlZmluZWQpXG4gICAgICAgICh0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KSlbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIHBhcnNlZCBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBwYXJzZWQgT3B0aW9uIG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgZG90ICcuJyBkZWxpbWl0ZWQgZnVsbCBwYXRoIG9mIHByb3BlcnR5IHdpdGhpbiB0aGUgb3B0aW9uIHRvIHNldC4gaWYgdW5kZWZpbmVkXFxlbXB0eSwgd2lsbCBhZGQgYSBuZXcgb3B0aW9uIHdpdGggdGhhdCB2YWx1ZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRQYXJzZWRPcHRpb24gPSBmdW5jdGlvbiBzZXRQYXJzZWRPcHRpb24obmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wYXJzZWRPcHRpb25zID0gW107XG4gICAgfVxuICAgIHZhciBwYXJzZWRPcHRpb25zID0gdGhpcy5wYXJzZWRPcHRpb25zO1xuICAgIGlmIChwcm9wTmFtZSkge1xuICAgICAgICAvLyBJZiBzZXR0aW5nIGEgc3ViIHByb3BlcnR5IG9mIGFuIG9wdGlvbiB0aGVuIHRyeSB0byBtZXJnZSBpdFxuICAgICAgICAvLyB3aXRoIGFuIGV4aXN0aW5nIG9wdGlvblxuICAgICAgICB2YXIgb3B0ID0gcGFyc2VkT3B0aW9ucy5maW5kKGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0LCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGFuIGV4aXN0aW5nIG9wdGlvbiAtIGp1c3QgbWVyZ2UgdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBvcHRbbmFtZV07XG4gICAgICAgICAgICB1dGlsLnNldFByb3BlcnR5KG5ld1ZhbHVlLCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBjcmVhdGUgYSBuZXcgb3B0aW9uLCBzZXQgaXQncyBwcm9wZXJ0eSBhbmQgYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICAgICAgICBvcHQgPSB7fTtcbiAgICAgICAgICAgIG9wdFtuYW1lXSA9IHV0aWwuc2V0UHJvcGVydHkoe30sIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBwYXJzZWRPcHRpb25zLnB1c2gob3B0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFsd2F5cyBjcmVhdGUgYSBuZXcgb3B0aW9uIHdoZW4gc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBpdHNlbGZcbiAgICAgICAgdmFyIG5ld09wdCA9IHt9O1xuICAgICAgICBuZXdPcHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcGFyc2VkT3B0aW9ucy5wdXNoKG5ld09wdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIG11bHRpcGxlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE9wdGlvbnMgdG8gc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldF0gU2V0cyBhbiBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGlmTm90U2V0KSB7XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb24oa2V5c1tpXSwgb3B0aW9uc1trZXlzW2ldXSwgaWZOb3RTZXQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGluc3RhbmNlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDbGFzcyBuYW1lWywgc3BhY2UsIGZ1bGwgbmFtZV1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWUsXG4gICAgICAgIGZ1bGxOYW1lICA9IHRoaXMuZnVsbE5hbWU7XG4gICAgaWYgKGZ1bGxOYW1lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIFwiICsgZnVsbE5hbWU7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUmVmbGVjdGlvbk9iamVjdC5fY29uZmlndXJlID0gZnVuY3Rpb24oUm9vdF8pIHtcbiAgICBSb290ID0gUm9vdF87XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IE9uZU9mO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChPbmVPZi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBPbmVPZikuY2xhc3NOYW1lID0gXCJPbmVPZlwiO1xuXG52YXIgRmllbGQgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICB1dGlsICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBvbmVvZiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG9uZW9mLlxuICogQGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ1tdfE9iamVjdC48c3RyaW5nLCo+fSBbZmllbGROYW1lc10gRmllbGQgbmFtZXNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gT25lT2YobmFtZSwgZmllbGROYW1lcywgb3B0aW9ucywgY29tbWVudCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkge1xuICAgICAgICBvcHRpb25zID0gZmllbGROYW1lcztcbiAgICAgICAgZmllbGROYW1lcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGROYW1lcyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoZmllbGROYW1lcykpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZE5hbWVzIG11c3QgYmUgYW4gQXJyYXlcIik7XG5cbiAgICAvKipcbiAgICAgKiBGaWVsZCBuYW1lcyB0aGF0IGJlbG9uZyB0byB0aGlzIG9uZW9mLlxuICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB0aGlzLm9uZW9mID0gZmllbGROYW1lcyB8fCBbXTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIEZpZWxkcyB0aGF0IGJlbG9uZyB0byB0aGlzIG9uZW9mIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgdGhpcy5maWVsZHNBcnJheSA9IFtdOyAvLyBkZWNsYXJlZCByZWFkb25seSBmb3IgY29uZm9ybWFuY2UsIHBvc3NpYmx5IG5vdCB5ZXQgYWRkZWQgdG8gcGFyZW50XG5cbiAgICAvKipcbiAgICAgKiBDb21tZW50IGZvciB0aGlzIGZpZWxkLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBjb21tZW50O1xufVxuXG4vKipcbiAqIE9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElPbmVPZlxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gb25lb2YgT25lb2YgZmllbGQgbmFtZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBPbmVvZiBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgb25lb2YgZnJvbSBhIG9uZW9mIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPbmVvZiBuYW1lXG4gKiBAcGFyYW0ge0lPbmVPZn0ganNvbiBPbmVvZiBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7T25lT2Z9IENyZWF0ZWQgb25lb2ZcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbk9uZU9mLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgT25lT2YobmFtZSwganNvbi5vbmVvZiwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG9uZW9mIHRvIGEgb25lb2YgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lPbmVPZn0gT25lb2YgZGVzY3JpcHRvclxuICovXG5PbmVPZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJvbmVvZlwiICAgLCB0aGlzLm9uZW9mLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSBmaWVsZHMgb2YgdGhlIHNwZWNpZmllZCBvbmVvZiB0byB0aGUgcGFyZW50IGlmIG5vdCBhbHJlYWR5IGRvbmUgc28uXG4gKiBAcGFyYW0ge09uZU9mfSBvbmVvZiBUaGUgb25lb2ZcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAaW5uZXJcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gYWRkRmllbGRzVG9QYXJlbnQob25lb2YpIHtcbiAgICBpZiAob25lb2YucGFyZW50KVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9uZW9mLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKCFvbmVvZi5maWVsZHNBcnJheVtpXS5wYXJlbnQpXG4gICAgICAgICAgICAgICAgb25lb2YucGFyZW50LmFkZChvbmVvZi5maWVsZHNBcnJheVtpXSk7XG59XG5cbi8qKlxuICogQWRkcyBhIGZpZWxkIHRvIHRoaXMgb25lb2YgYW5kIHJlbW92ZXMgaXQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnQsIGlmIGFueS5cbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIEZpZWxkIHRvIGFkZFxuICogQHJldHVybnMge09uZU9mfSBgdGhpc2BcbiAqL1xuT25lT2YucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChmaWVsZCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEoZmllbGQgaW5zdGFuY2VvZiBGaWVsZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkIG11c3QgYmUgYSBGaWVsZFwiKTtcblxuICAgIGlmIChmaWVsZC5wYXJlbnQgJiYgZmllbGQucGFyZW50ICE9PSB0aGlzLnBhcmVudClcbiAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XG4gICAgdGhpcy5vbmVvZi5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIHRoaXMuZmllbGRzQXJyYXkucHVzaChmaWVsZCk7XG4gICAgZmllbGQucGFydE9mID0gdGhpczsgLy8gZmllbGQucGFyZW50IHJlbWFpbnMgbnVsbFxuICAgIGFkZEZpZWxkc1RvUGFyZW50KHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgZmllbGQgZnJvbSB0aGlzIG9uZW9mIGFuZCBwdXRzIGl0IGJhY2sgdG8gdGhlIG9uZW9mJ3MgcGFyZW50LlxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRmllbGQgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxuICovXG5PbmVPZi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGZpZWxkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIEZpZWxkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5maWVsZHNBcnJheS5pbmRleE9mKGZpZWxkKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpbmRleCA8IDApXG4gICAgICAgIHRocm93IEVycm9yKGZpZWxkICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICB0aGlzLmZpZWxkc0FycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgaW5kZXggPSB0aGlzLm9uZW9mLmluZGV4T2YoZmllbGQubmFtZSk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbmRleCA+IC0xKSAvLyB0aGVvcmV0aWNhbFxuICAgICAgICB0aGlzLm9uZW9mLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBmaWVsZC5wYXJ0T2YgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuT25lT2YucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gb25BZGQocGFyZW50KSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBwYXJlbnQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBDb2xsZWN0IHByZXNlbnQgZmllbGRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9uZW9mLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHBhcmVudC5nZXQodGhpcy5vbmVvZltpXSk7XG4gICAgICAgIGlmIChmaWVsZCAmJiAhZmllbGQucGFydE9mKSB7XG4gICAgICAgICAgICBmaWVsZC5wYXJ0T2YgPSBzZWxmO1xuICAgICAgICAgICAgc2VsZi5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGQgbm90IHlldCBwcmVzZW50IGZpZWxkc1xuICAgIGFkZEZpZWxkc1RvUGFyZW50KHRoaXMpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuT25lT2YucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gb25SZW1vdmUocGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKChmaWVsZCA9IHRoaXMuZmllbGRzQXJyYXlbaV0pLnBhcmVudClcbiAgICAgICAgICAgIGZpZWxkLnBhcmVudC5yZW1vdmUoZmllbGQpO1xuICAgIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgcGFyZW50KTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBPbmVPZi5kfSAoVHlwZVNjcmlwdCkuXG4gKiBAdHlwZWRlZiBPbmVPZkRlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgcHJvdG90eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lb2ZOYW1lIE9uZU9mIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBPbmVPZiBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgc3RyaW5nXG4gKi9cbk9uZU9mLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU9uZU9mKCkge1xuICAgIHZhciBmaWVsZE5hbWVzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLFxuICAgICAgICBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgZmllbGROYW1lc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uZU9mRGVjb3JhdG9yKHByb3RvdHlwZSwgb25lb2ZOYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IE9uZU9mKG9uZW9mTmFtZSwgZmllbGROYW1lcykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBvbmVvZk5hbWUsIHtcbiAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcihmaWVsZE5hbWVzKSxcbiAgICAgICAgICAgIHNldDogdXRpbC5vbmVPZlNldHRlcihmaWVsZE5hbWVzKVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxucGFyc2UuZmlsZW5hbWUgPSBudWxsO1xucGFyc2UuZGVmYXVsdHMgPSB7IGtlZXBDYXNlOiBmYWxzZSB9O1xuXG52YXIgdG9rZW5pemUgID0gcmVxdWlyZShcIi4vdG9rZW5pemVcIiksXG4gICAgUm9vdCAgICAgID0gcmVxdWlyZShcIi4vcm9vdFwiKSxcbiAgICBUeXBlICAgICAgPSByZXF1aXJlKFwiLi90eXBlXCIpLFxuICAgIEZpZWxkICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIE1hcEZpZWxkICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpLFxuICAgIE9uZU9mICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIEVudW0gICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgU2VydmljZSAgID0gcmVxdWlyZShcIi4vc2VydmljZVwiKSxcbiAgICBNZXRob2QgICAgPSByZXF1aXJlKFwiLi9tZXRob2RcIiksXG4gICAgdHlwZXMgICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIGJhc2UxMFJlICAgID0gL15bMS05XVswLTldKiQvLFxuICAgIGJhc2UxME5lZ1JlID0gL14tP1sxLTldWzAtOV0qJC8sXG4gICAgYmFzZTE2UmUgICAgPSAvXjBbeF1bMC05YS1mQS1GXSskLyxcbiAgICBiYXNlMTZOZWdSZSA9IC9eLT8wW3hdWzAtOWEtZkEtRl0rJC8sXG4gICAgYmFzZThSZSAgICAgPSAvXjBbMC03XSskLyxcbiAgICBiYXNlOE5lZ1JlICA9IC9eLT8wWzAtN10rJC8sXG4gICAgbnVtYmVyUmUgICAgPSAvXig/IVtlRV0pWzAtOV0qKD86XFwuWzAtOV0qKT8oPzpbZUVdWystXT9bMC05XSspPyQvLFxuICAgIG5hbWVSZSAgICAgID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC8sXG4gICAgdHlwZVJlZlJlICAgPSAvXig/OlxcLj9bYS16QS1aX11bYS16QS1aXzAtOV0qKSg/OlxcLlthLXpBLVpfXVthLXpBLVpfMC05XSopKiQvLFxuICAgIGZxVHlwZVJlZlJlID0gL14oPzpcXC5bYS16QS1aX11bYS16QS1aXzAtOV0qKSskLztcblxuLyoqXG4gKiBSZXN1bHQgb2JqZWN0IHJldHVybmVkIGZyb20ge0BsaW5rIHBhcnNlfS5cbiAqIEBpbnRlcmZhY2UgSVBhcnNlclJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYWNrYWdlIFBhY2thZ2UgbmFtZSwgaWYgZGVjbGFyZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW118dW5kZWZpbmVkfSBpbXBvcnRzIEltcG9ydHMsIGlmIGFueVxuICogQHByb3BlcnR5IHtzdHJpbmdbXXx1bmRlZmluZWR9IHdlYWtJbXBvcnRzIFdlYWsgaW1wb3J0cywgaWYgYW55XG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHN5bnRheCBTeW50YXgsIGlmIHNwZWNpZmllZCAoZWl0aGVyIGBcInByb3RvMlwiYCBvciBgXCJwcm90bzNcImApXG4gKiBAcHJvcGVydHkge1Jvb3R9IHJvb3QgUG9wdWxhdGVkIHJvb3QgaW5zdGFuY2VcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiB7QGxpbmsgcGFyc2V9LlxuICogQGludGVyZmFjZSBJUGFyc2VPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwQ2FzZT1mYWxzZV0gS2VlcHMgZmllbGQgY2FzaW5nIGluc3RlYWQgb2YgY29udmVydGluZyB0byBjYW1lbCBjYXNlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthbHRlcm5hdGVDb21tZW50TW9kZT1mYWxzZV0gUmVjb2duaXplIGRvdWJsZS1zbGFzaCBjb21tZW50cyBpbiBhZGRpdGlvbiB0byBkb2MtYmxvY2sgY29tbWVudHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmVmZXJUcmFpbGluZ0NvbW1lbnQ9ZmFsc2VdIFVzZSB0cmFpbGluZyBjb21tZW50IHdoZW4gYm90aCBsZWFkaW5nIGNvbW1lbnQgYW5kIHRyYWlsaW5nIGNvbW1lbnQgZXhpc3QuXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIG1vZGlmeWluZyB0aGUgYmVoYXZpb3Igb2YgSlNPTiBzZXJpYWxpemF0aW9uLlxuICogQGludGVyZmFjZSBJVG9KU09OT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBba2VlcENvbW1lbnRzPWZhbHNlXSBTZXJpYWxpemVzIGNvbW1lbnRzLlxuICovXG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgY29udGVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgdG8gcG9wdWxhdGVcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge0lQYXJzZXJSZXN1bHR9IFBhcnNlciByZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlbmFtZT1udWxsIEN1cnJlbnRseSBwcm9jZXNzaW5nIGZpbGUgbmFtZSBmb3IgZXJyb3IgcmVwb3J0aW5nLCBpZiBrbm93blxuICogQHByb3BlcnR5IHtJUGFyc2VPcHRpb25zfSBkZWZhdWx0cyBEZWZhdWx0IHtAbGluayBJUGFyc2VPcHRpb25zfVxuICovXG5mdW5jdGlvbiBwYXJzZShzb3VyY2UsIHJvb3QsIG9wdGlvbnMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbiAgICBpZiAoIShyb290IGluc3RhbmNlb2YgUm9vdCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSBuZXcgUm9vdCgpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIG9wdGlvbnMgPSBwYXJzZS5kZWZhdWx0cztcblxuICAgIHZhciBwcmVmZXJUcmFpbGluZ0NvbW1lbnQgPSBvcHRpb25zLnByZWZlclRyYWlsaW5nQ29tbWVudCB8fCBmYWxzZTtcbiAgICB2YXIgdG4gPSB0b2tlbml6ZShzb3VyY2UsIG9wdGlvbnMuYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgZmFsc2UpLFxuICAgICAgICBuZXh0ID0gdG4ubmV4dCxcbiAgICAgICAgcHVzaCA9IHRuLnB1c2gsXG4gICAgICAgIHBlZWsgPSB0bi5wZWVrLFxuICAgICAgICBza2lwID0gdG4uc2tpcCxcbiAgICAgICAgY21udCA9IHRuLmNtbnQ7XG5cbiAgICB2YXIgaGVhZCA9IHRydWUsXG4gICAgICAgIHBrZyxcbiAgICAgICAgaW1wb3J0cyxcbiAgICAgICAgd2Vha0ltcG9ydHMsXG4gICAgICAgIHN5bnRheCxcbiAgICAgICAgaXNQcm90bzMgPSBmYWxzZTtcblxuICAgIHZhciBwdHIgPSByb290O1xuXG4gICAgdmFyIGFwcGx5Q2FzZSA9IG9wdGlvbnMua2VlcENhc2UgPyBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBuYW1lOyB9IDogdXRpbC5jYW1lbENhc2U7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGlsbGVnYWwodG9rZW4sIG5hbWUsIGluc2lkZVRyeUNhdGNoKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xuICAgICAgICBpZiAoIWluc2lkZVRyeUNhdGNoKVxuICAgICAgICAgICAgcGFyc2UuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gRXJyb3IoXCJpbGxlZ2FsIFwiICsgKG5hbWUgfHwgXCJ0b2tlblwiKSArIFwiICdcIiArIHRva2VuICsgXCInIChcIiArIChmaWxlbmFtZSA/IGZpbGVuYW1lICsgXCIsIFwiIDogXCJcIikgKyBcImxpbmUgXCIgKyB0bi5saW5lICsgXCIpXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICAgIHRva2VuO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICgodG9rZW4gPSBuZXh0KCkpICE9PSBcIlxcXCJcIiAmJiB0b2tlbiAhPT0gXCInXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5leHQoKSk7XG4gICAgICAgICAgICBza2lwKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gcGVlaygpO1xuICAgICAgICB9IHdoaWxlICh0b2tlbiA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRWYWx1ZShhY2NlcHRUeXBlUmVmKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXFwiXCI6XG4gICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IGNhc2UgXCJUUlVFXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogY2FzZSBcIkZBTFNFXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXIodG9rZW4sIC8qIGluc2lkZVRyeUNhdGNoICovIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoYWNjZXB0VHlwZVJlZiAmJiB0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRSYW5nZXModGFyZ2V0LCBhY2NlcHRTdHJpbmdzKSB7XG4gICAgICAgIHZhciB0b2tlbiwgc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRTdHJpbmdzICYmICgodG9rZW4gPSBwZWVrKCkpID09PSBcIlxcXCJcIiB8fCB0b2tlbiA9PT0gXCInXCIpKVxuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKHJlYWRTdHJpbmcoKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goWyBzdGFydCA9IHBhcnNlSWQobmV4dCgpKSwgc2tpcChcInRvXCIsIHRydWUpID8gcGFyc2VJZChuZXh0KCkpIDogc3RhcnQgXSk7XG4gICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcbiAgICAgICAgc2tpcChcIjtcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VOdW1iZXIodG9rZW4sIGluc2lkZVRyeUNhdGNoKSB7XG4gICAgICAgIHZhciBzaWduID0gMTtcbiAgICAgICAgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbmZcIjogY2FzZSBcIklORlwiOiBjYXNlIFwiSW5mXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBJbmZpbml0eTtcbiAgICAgICAgICAgIGNhc2UgXCJuYW5cIjogY2FzZSBcIk5BTlwiOiBjYXNlIFwiTmFuXCI6IGNhc2UgXCJOYU5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZTEwUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCAxMCk7XG4gICAgICAgIGlmIChiYXNlMTZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodG9rZW4sIDE2KTtcbiAgICAgICAgaWYgKGJhc2U4UmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCA4KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAobnVtYmVyUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlRmxvYXQodG9rZW4pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibnVtYmVyXCIsIGluc2lkZVRyeUNhdGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlkKHRva2VuLCBhY2NlcHROZWdhdGl2ZSkge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwibWF4XCI6IGNhc2UgXCJNQVhcIjogY2FzZSBcIk1heFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiA1MzY4NzA5MTE7XG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghYWNjZXB0TmVnYXRpdmUgJiYgdG9rZW4uY2hhckF0KDApID09PSBcIi1cIilcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwiaWRcIik7XG5cbiAgICAgICAgaWYgKGJhc2UxME5lZ1JlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCAxMCk7XG4gICAgICAgIGlmIChiYXNlMTZOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgMTYpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChiYXNlOE5lZ1JlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRva2VuLCA4KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcImlkXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUGFja2FnZSgpIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHBrZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcInBhY2thZ2VcIik7XG5cbiAgICAgICAgcGtnID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHBrZykpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHBrZywgXCJuYW1lXCIpO1xuXG4gICAgICAgIHB0ciA9IHB0ci5kZWZpbmUocGtnKTtcbiAgICAgICAgc2tpcChcIjtcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbXBvcnQoKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHBlZWsoKTtcbiAgICAgICAgdmFyIHdoaWNoSW1wb3J0cztcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIndlYWtcIjpcbiAgICAgICAgICAgICAgICB3aGljaEltcG9ydHMgPSB3ZWFrSW1wb3J0cyB8fCAod2Vha0ltcG9ydHMgPSBbXSk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInB1YmxpY1wiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHdoaWNoSW1wb3J0cyA9IGltcG9ydHMgfHwgKGltcG9ydHMgPSBbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSByZWFkU3RyaW5nKCk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICB3aGljaEltcG9ydHMucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTeW50YXgoKSB7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICBzeW50YXggPSByZWFkU3RyaW5nKCk7XG4gICAgICAgIGlzUHJvdG8zID0gc3ludGF4ID09PSBcInByb3RvM1wiO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWlzUHJvdG8zICYmIHN5bnRheCAhPT0gXCJwcm90bzJcIilcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoc3ludGF4LCBcInN5bnRheFwiKTtcblxuICAgICAgICBza2lwKFwiO1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbW1vbihwYXJlbnQsIHRva2VuKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlVHlwZShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICBwYXJzZUVudW0ocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJzZXJ2aWNlXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwiZXh0ZW5kXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VFeHRlbnNpb24ocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlmQmxvY2sob2JqLCBmbklmLCBmbkVsc2UpIHtcbiAgICAgICAgdmFyIHRyYWlsaW5nTGluZSA9IHRuLmxpbmU7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBvYmouY29tbWVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBvYmouY29tbWVudCA9IGNtbnQoKTsgLy8gdHJ5IGJsb2NrLXR5cGUgY29tbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXAoXCJ7XCIsIHRydWUpKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSAhPT0gXCJ9XCIpXG4gICAgICAgICAgICAgICAgZm5JZih0b2tlbik7XG4gICAgICAgICAgICBza2lwKFwiO1wiLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmbkVsc2UpXG4gICAgICAgICAgICAgICAgZm5FbHNlKCk7XG4gICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIGlmIChvYmogJiYgKHR5cGVvZiBvYmouY29tbWVudCAhPT0gXCJzdHJpbmdcIiB8fCBwcmVmZXJUcmFpbGluZ0NvbW1lbnQpKVxuICAgICAgICAgICAgICAgIG9iai5jb21tZW50ID0gY21udCh0cmFpbGluZ0xpbmUpIHx8IG9iai5jb21tZW50OyAvLyB0cnkgbGluZS10eXBlIGNvbW1lbnRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVHlwZShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJ0eXBlIG5hbWVcIik7XG5cbiAgICAgICAgdmFyIHR5cGUgPSBuZXcgVHlwZSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2sodHlwZSwgZnVuY3Rpb24gcGFyc2VUeXBlX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VDb21tb24odHlwZSwgdG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZU1hcEZpZWxkKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT25lT2YodHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJleHRlbnNpb25zXCI6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRSYW5nZXModHlwZS5leHRlbnNpb25zIHx8ICh0eXBlLmV4dGVuc2lvbnMgPSBbXSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxuICAgICAgICAgICAgICAgICAgICByZWFkUmFuZ2VzKHR5cGUucmVzZXJ2ZWQgfHwgKHR5cGUucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvdG8zIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodHlwZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VGaWVsZChwYXJlbnQsIHJ1bGUsIGV4dGVuZCkge1xuICAgICAgICB2YXIgdHlwZSA9IG5leHQoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICAgICAgcGFyc2VHcm91cChwYXJlbnQsIHJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHR5cGUsIFwidHlwZVwiKTtcblxuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIG5hbWUgPSBhcHBseUNhc2UobmFtZSk7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuXG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChuYW1lLCBwYXJzZUlkKG5leHQoKSksIHR5cGUsIHJ1bGUsIGV4dGVuZCk7XG4gICAgICAgIGlmQmxvY2soZmllbGQsIGZ1bmN0aW9uIHBhcnNlRmllbGRfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZUZpZWxkX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChmaWVsZCk7XG5cbiAgICAgICAgLy8gSlNPTiBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZSBpZiBub3Qgc2V0IHNvIHdlIGhhdmUgdG8gc2V0IHBhY2tlZD1mYWxzZSBleHBsaWNpdHkgd2hlblxuICAgICAgICAvLyBwYXJzaW5nIHByb3RvMiBkZXNjcmlwdG9ycyB3aXRob3V0IHRoZSBvcHRpb24sIHdoZXJlIGFwcGxpY2FibGUuIFRoaXMgbXVzdCBiZSBkb25lIGZvclxuICAgICAgICAvLyBhbGwga25vd24gcGFja2FibGUgdHlwZXMgYW5kIGFueXRoaW5nIHRoYXQgY291bGQgYmUgYW4gZW51bSAoPSBpcyBub3QgYSBiYXNpYyB0eXBlKS5cbiAgICAgICAgaWYgKCFpc1Byb3RvMyAmJiBmaWVsZC5yZXBlYXRlZCAmJiAodHlwZXMucGFja2VkW3R5cGVdICE9PSB1bmRlZmluZWQgfHwgdHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICBmaWVsZC5zZXRPcHRpb24oXCJwYWNrZWRcIiwgZmFsc2UsIC8qIGlmTm90U2V0ICovIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlR3JvdXAocGFyZW50LCBydWxlKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IHV0aWwubGNGaXJzdChuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUgPT09IGZpZWxkTmFtZSlcbiAgICAgICAgICAgIG5hbWUgPSB1dGlsLnVjRmlyc3QobmFtZSk7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgaWQgPSBwYXJzZUlkKG5leHQoKSk7XG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUobmFtZSk7XG4gICAgICAgIHR5cGUuZ3JvdXAgPSB0cnVlO1xuICAgICAgICB2YXIgZmllbGQgPSBuZXcgRmllbGQoZmllbGROYW1lLCBpZCwgbmFtZSwgcnVsZSk7XG4gICAgICAgIGZpZWxkLmZpbGVuYW1lID0gcGFyc2UuZmlsZW5hbWU7XG4gICAgICAgIGlmQmxvY2sodHlwZSwgZnVuY3Rpb24gcGFyc2VHcm91cF9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbih0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25hbFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pOyAvLyB0aGVyZSBhcmUgbm8gZ3JvdXBzIHdpdGggcHJvdG8zIHNlbWFudGljc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0eXBlKVxuICAgICAgICAgICAgICAuYWRkKGZpZWxkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkKHBhcmVudCkge1xuICAgICAgICBza2lwKFwiPFwiKTtcbiAgICAgICAgdmFyIGtleVR5cGUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0eXBlcy5tYXBLZXlba2V5VHlwZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoa2V5VHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHNraXAoXCIsXCIpO1xuICAgICAgICB2YXIgdmFsdWVUeXBlID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHZhbHVlVHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHZhbHVlVHlwZSwgXCJ0eXBlXCIpO1xuXG4gICAgICAgIHNraXAoXCI+XCIpO1xuICAgICAgICB2YXIgbmFtZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICB2YXIgZmllbGQgPSBuZXcgTWFwRmllbGQoYXBwbHlDYXNlKG5hbWUpLCBwYXJzZUlkKG5leHQoKSksIGtleVR5cGUsIHZhbHVlVHlwZSk7XG4gICAgICAgIGlmQmxvY2soZmllbGQsIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGRfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGZpZWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZU1hcEZpZWxkX2xpbmUoKSB7XG4gICAgICAgICAgICBwYXJzZUlubGluZU9wdGlvbnMoZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChmaWVsZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPbmVPZihwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBvbmVvZiA9IG5ldyBPbmVPZihhcHBseUNhc2UodG9rZW4pKTtcbiAgICAgICAgaWZCbG9jayhvbmVvZiwgZnVuY3Rpb24gcGFyc2VPbmVPZl9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ob25lb2YsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgcGFyc2VGaWVsZChvbmVvZiwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bShwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBlbm0gPSBuZXcgRW51bSh0b2tlbik7XG4gICAgICAgIGlmQmxvY2soZW5tLCBmdW5jdGlvbiBwYXJzZUVudW1fYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICBzd2l0Y2godG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZW5tLCB0b2tlbik7XG4gICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInJlc2VydmVkXCI6XG4gICAgICAgICAgICAgIHJlYWRSYW5nZXMoZW5tLnJlc2VydmVkIHx8IChlbm0ucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcGFyc2VFbnVtVmFsdWUoZW5tLCB0b2tlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChlbm0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlSWQobmV4dCgpLCB0cnVlKSxcbiAgICAgICAgICAgIGR1bW15ID0ge307XG4gICAgICAgIGlmQmxvY2soZHVtbXksIGZ1bmN0aW9uIHBhcnNlRW51bVZhbHVlX2Jsb2NrKHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihkdW1teSwgdG9rZW4pOyAvLyBza2lwXG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICB9LCBmdW5jdGlvbiBwYXJzZUVudW1WYWx1ZV9saW5lKCkge1xuICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGR1bW15KTsgLy8gc2tpcFxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZCh0b2tlbiwgdmFsdWUsIGR1bW15LmNvbW1lbnQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tID0gc2tpcChcIihcIiwgdHJ1ZSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gdG9rZW47XG4gICAgICAgIHZhciBvcHRpb24gPSBuYW1lO1xuICAgICAgICB2YXIgcHJvcE5hbWU7XG5cbiAgICAgICAgaWYgKGlzQ3VzdG9tKSB7XG4gICAgICAgICAgICBza2lwKFwiKVwiKTtcbiAgICAgICAgICAgIG5hbWUgPSBcIihcIiArIG5hbWUgKyBcIilcIjtcbiAgICAgICAgICAgIG9wdGlvbiA9IG5hbWU7XG4gICAgICAgICAgICB0b2tlbiA9IHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChmcVR5cGVSZWZSZS50ZXN0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgIHByb3BOYW1lID0gdG9rZW4uc3Vic3RyKDEpOyAvL3JlbW92ZSAnLicgYmVmb3JlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgICAgICAgICBuYW1lICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIG9wdGlvblZhbHVlID0gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUpO1xuICAgICAgICBzZXRQYXJzZWRPcHRpb24ocGFyZW50LCBvcHRpb24sIG9wdGlvblZhbHVlLCBwcm9wTmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgaWYgKHNraXAoXCJ7XCIsIHRydWUpKSB7IC8vIHsgYTogXCJmb29cIiBiIHsgYzogXCJiYXJcIiB9IH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIHdoaWxlICghc2tpcChcIn1cIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwie1wiKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lICsgXCIuXCIgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSBcIntcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUgKyBcIi5cIiArIHRva2VuLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHJlc3VsdFtwcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXS5jb25jYXQocHJldlZhbHVlKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBza2lwKFwiLFwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltcGxlVmFsdWUgPSByZWFkVmFsdWUodHJ1ZSk7XG4gICAgICAgIHNldE9wdGlvbihwYXJlbnQsIG5hbWUsIHNpbXBsZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNpbXBsZVZhbHVlO1xuICAgICAgICAvLyBEb2VzIG5vdCBlbmZvcmNlIGEgZGVsaW1pdGVyIHRvIGJlIHVuaXZlcnNhbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9wdGlvbihwYXJlbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChwYXJlbnQuc2V0T3B0aW9uKVxuICAgICAgICAgICAgcGFyZW50LnNldE9wdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICAgIGlmIChwYXJlbnQuc2V0UGFyc2VkT3B0aW9uKVxuICAgICAgICAgICAgcGFyZW50LnNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW5saW5lT3B0aW9ucyhwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNraXAoXCJbXCIsIHRydWUpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocGFyZW50LCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcbiAgICAgICAgICAgIHNraXAoXCJdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInNlcnZpY2UgbmFtZVwiKTtcblxuICAgICAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayhzZXJ2aWNlLCBmdW5jdGlvbiBwYXJzZVNlcnZpY2VfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbihzZXJ2aWNlLCB0b2tlbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcInJwY1wiKVxuICAgICAgICAgICAgICAgIHBhcnNlTWV0aG9kKHNlcnZpY2UsIHRva2VuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQoc2VydmljZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNZXRob2QocGFyZW50LCB0b2tlbikge1xuICAgICAgICAvLyBHZXQgdGhlIGNvbW1lbnQgb2YgdGhlIHByZWNlZGluZyBsaW5lIG5vdyAoaWYgb25lIGV4aXN0cykgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gbWV0aG9kIGlzIGRlZmluZWQgYWNyb3NzIG11bHRpcGxlIGxpbmVzLlxuICAgICAgICB2YXIgY29tbWVudFRleHQgPSBjbW50KCk7XG5cbiAgICAgICAgdmFyIHR5cGUgPSB0b2tlbjtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB0b2tlbixcbiAgICAgICAgICAgIHJlcXVlc3RUeXBlLCByZXF1ZXN0U3RyZWFtLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlLCByZXNwb25zZVN0cmVhbTtcblxuICAgICAgICBza2lwKFwiKFwiKTtcbiAgICAgICAgaWYgKHNraXAoXCJzdHJlYW1cIiwgdHJ1ZSkpXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtID0gdHJ1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICByZXF1ZXN0VHlwZSA9IHRva2VuO1xuICAgICAgICBza2lwKFwiKVwiKTsgc2tpcChcInJldHVybnNcIik7IHNraXAoXCIoXCIpO1xuICAgICAgICBpZiAoc2tpcChcInN0cmVhbVwiLCB0cnVlKSlcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtID0gdHJ1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0eXBlUmVmUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICByZXNwb25zZVR5cGUgPSB0b2tlbjtcbiAgICAgICAgc2tpcChcIilcIik7XG5cbiAgICAgICAgdmFyIG1ldGhvZCA9IG5ldyBNZXRob2QobmFtZSwgdHlwZSwgcmVxdWVzdFR5cGUsIHJlc3BvbnNlVHlwZSwgcmVxdWVzdFN0cmVhbSwgcmVzcG9uc2VTdHJlYW0pO1xuICAgICAgICBtZXRob2QuY29tbWVudCA9IGNvbW1lbnRUZXh0O1xuICAgICAgICBpZkJsb2NrKG1ldGhvZCwgZnVuY3Rpb24gcGFyc2VNZXRob2RfYmxvY2sodG9rZW4pIHtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKG1ldGhvZCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQobWV0aG9kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4dGVuc2lvbihwYXJlbnQsIHRva2VuKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJyZWZlcmVuY2VcIik7XG5cbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IHRva2VuO1xuICAgICAgICBpZkJsb2NrKG51bGwsIGZ1bmN0aW9uIHBhcnNlRXh0ZW5zaW9uX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIHRva2VuLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvdG8zIHx8ICF0eXBlUmVmUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcIm9wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW47XG4gICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICBjYXNlIFwicGFja2FnZVwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlUGFja2FnZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VJbXBvcnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInN5bnRheFwiOlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFoZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlU3ludGF4KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcblxuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHB0ciwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VDb21tb24ocHRyLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFyc2UuZmlsZW5hbWUgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIFwicGFja2FnZVwiICAgICA6IHBrZyxcbiAgICAgICAgXCJpbXBvcnRzXCIgICAgIDogaW1wb3J0cyxcbiAgICAgICAgIHdlYWtJbXBvcnRzICA6IHdlYWtJbXBvcnRzLFxuICAgICAgICAgc3ludGF4ICAgICAgIDogc3ludGF4LFxuICAgICAgICAgcm9vdCAgICAgICAgIDogcm9vdFxuICAgIH07XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwYXJzZWQgY29udGVudHMuXG4gKiBAbmFtZSBwYXJzZVxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFNvdXJjZSBjb250ZW50c1xuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7SVBhcnNlclJlc3VsdH0gUGFyc2VyIHJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XG4gKiBAdmFyaWF0aW9uIDJcbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xufVxuXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcbiAqL1xuUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgLy8gMXN0Li40dGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA1dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gMXN0Li4zdGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG59O1xuXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG59XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcblxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gc3RhcnQgPT09IGVuZCAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICA/IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKVxuICAgICAgICA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUm9vdDtcblxuLy8gZXh0ZW5kcyBOYW1lc3BhY2VcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG4oKFJvb3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBSb290KS5jbGFzc05hbWUgPSBcIlJvb3RcIjtcblxudmFyIEZpZWxkICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBFbnVtICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBPbmVPZiAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBUeXBlLCAgIC8vIGN5Y2xpY1xuICAgIHBhcnNlLCAgLy8gbWlnaHQgYmUgZXhjbHVkZWRcbiAgICBjb21tb247IC8vIFwiXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByb290IG5hbWVzcGFjZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUm9vdCBuYW1lc3BhY2Ugd3JhcHBpbmcgYWxsIHR5cGVzLCBlbnVtcywgc2VydmljZXMsIHN1Yi1uYW1lc3BhY2VzIGV0Yy4gdGhhdCBiZWxvbmcgdG9nZXRoZXIuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBUb3AgbGV2ZWwgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSb290KG9wdGlvbnMpIHtcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBcIlwiLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIERlZmVycmVkIGV4dGVuc2lvbiBmaWVsZHMuXG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICovXG4gICAgdGhpcy5kZWZlcnJlZCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgZmlsZSBuYW1lcyBvZiBsb2FkZWQgZmlsZXMuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhIG5hbWVzcGFjZSBkZXNjcmlwdG9yIGludG8gYSByb290IG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7SU5hbWVzcGFjZX0ganNvbiBOYW1lZXNwYWNlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWRcbiAqIEByZXR1cm5zIHtSb290fSBSb290IG5hbWVzcGFjZVxuICovXG5Sb290LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgcm9vdCkge1xuICAgIGlmICghcm9vdClcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XG4gICAgaWYgKGpzb24ub3B0aW9ucylcbiAgICAgICAgcm9vdC5zZXRPcHRpb25zKGpzb24ub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJvb3QuYWRkSlNPTihqc29uLm5lc3RlZCk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRoIG9mIGFuIGltcG9ydGVkIGZpbGUsIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnRpbmcgb3JpZ2luLlxuICogVGhpcyBtZXRob2QgZXhpc3RzIHNvIHlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93biBsb2dpYyBpbiBjYXNlIHlvdXIgaW1wb3J0cyBhcmUgc2NhdHRlcmVkIG92ZXIgbXVsdGlwbGUgZGlyZWN0b3JpZXMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gVGhlIGZpbGUgbmFtZSBvZiB0aGUgaW1wb3J0aW5nIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgVGhlIGZpbGUgbmFtZSBiZWluZyBpbXBvcnRlZFxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBSZXNvbHZlZCBwYXRoIHRvIGB0YXJnZXRgIG9yIGBudWxsYCB0byBza2lwIHRoZSBmaWxlXG4gKi9cblJvb3QucHJvdG90eXBlLnJlc29sdmVQYXRoID0gdXRpbC5wYXRoLnJlc29sdmU7XG5cbi8qKlxuICogRmV0Y2ggY29udGVudCBmcm9tIGZpbGUgcGF0aCBvciB1cmxcbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEZpbGUgcGF0aCBvciB1cmxcbiAqIEBwYXJhbSB7RmV0Y2hDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJvb3QucHJvdG90eXBlLmZldGNoID0gdXRpbC5mZXRjaDtcblxuLy8gQSBzeW1ib2wtbGlrZSBmdW5jdGlvbiB0byBzYWZlbHkgc2lnbmFsIHN5bmNocm9ub3VzIGxvYWRpbmdcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBTWU5DKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IG9wdGlvbnMgUGFyc2Ugb3B0aW9uc1xuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5Sb290LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UobG9hZCwgc2VsZiwgZmlsZW5hbWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHN5bmMgPSBjYWxsYmFjayA9PT0gU1lOQzsgLy8gdW5kb2N1bWVudGVkXG5cbiAgICAvLyBGaW5pc2hlcyBsb2FkaW5nIGJ5IGNhbGxpbmcgdGhlIGNhbGxiYWNrIChleGFjdGx5IG9uY2UpXG4gICAgZnVuY3Rpb24gZmluaXNoKGVyciwgcm9vdCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNiID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIGNiKGVyciwgcm9vdCk7XG4gICAgfVxuXG4gICAgLy8gQnVuZGxlZCBkZWZpbml0aW9uIGV4aXN0ZW5jZSBjaGVja2luZ1xuICAgIGZ1bmN0aW9uIGdldEJ1bmRsZWRGaWxlTmFtZShmaWxlbmFtZSkge1xuICAgICAgICB2YXIgaWR4ID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCJnb29nbGUvcHJvdG9idWYvXCIpO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBhbHRuYW1lID0gZmlsZW5hbWUuc3Vic3RyaW5nKGlkeCk7XG4gICAgICAgICAgICBpZiAoYWx0bmFtZSBpbiBjb21tb24pIHJldHVybiBhbHRuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3NlcyBhIHNpbmdsZSBmaWxlXG4gICAgZnVuY3Rpb24gcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhzb3VyY2UpICYmIHNvdXJjZS5jaGFyQXQoMCkgPT09IFwie1wiKVxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IEpTT04ucGFyc2Uoc291cmNlKTtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhzb3VyY2UpKVxuICAgICAgICAgICAgICAgIHNlbGYuc2V0T3B0aW9ucyhzb3VyY2Uub3B0aW9ucykuYWRkSlNPTihzb3VyY2UubmVzdGVkKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgc2VsZiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkLFxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmltcG9ydHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcGFyc2VkLmltcG9ydHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPSBnZXRCdW5kbGVkRmlsZU5hbWUocGFyc2VkLmltcG9ydHNbaV0pIHx8IHNlbGYucmVzb2x2ZVBhdGgoZmlsZW5hbWUsIHBhcnNlZC5pbXBvcnRzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaChyZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC53ZWFrSW1wb3J0cylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnNlZC53ZWFrSW1wb3J0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9IGdldEJ1bmRsZWRGaWxlTmFtZShwYXJzZWQud2Vha0ltcG9ydHNbaV0pIHx8IHNlbGYucmVzb2x2ZVBhdGgoZmlsZW5hbWUsIHBhcnNlZC53ZWFrSW1wb3J0c1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3luYyAmJiAhcXVldWVkKVxuICAgICAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpOyAvLyBvbmx5IG9uY2UgYW55d2F5XG4gICAgfVxuXG4gICAgLy8gRmV0Y2hlcyBhIHNpbmdsZSBmaWxlXG4gICAgZnVuY3Rpb24gZmV0Y2goZmlsZW5hbWUsIHdlYWspIHtcblxuICAgICAgICAvLyBTa2lwIGlmIGFscmVhZHkgbG9hZGVkIC8gYXR0ZW1wdGVkXG4gICAgICAgIGlmIChzZWxmLmZpbGVzLmluZGV4T2YoZmlsZW5hbWUpID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHNlbGYuZmlsZXMucHVzaChmaWxlbmFtZSk7XG5cbiAgICAgICAgLy8gU2hvcnRjdXQgYnVuZGxlZCBkZWZpbml0aW9uc1xuICAgICAgICBpZiAoZmlsZW5hbWUgaW4gY29tbW9uKSB7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICsrcXVldWVkO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tcXVldWVkO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSBmZXRjaCBmcm9tIGRpc2sgb3IgbmV0d29ya1xuICAgICAgICBpZiAoc3luYykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gdXRpbC5mcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUpLnRvU3RyaW5nKFwidXRmOFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICghd2VhaylcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrcXVldWVkO1xuICAgICAgICAgICAgc2VsZi5mZXRjaChmaWxlbmFtZSwgZnVuY3Rpb24oZXJyLCBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAtLXF1ZXVlZDtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHRlcm1pbmF0ZWQgbWVhbndoaWxlXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYWspXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXF1ZXVlZCkgLy8gY2FuJ3QgYmUgY292ZXJlZCByZWxpYWJseVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIHNvdXJjZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcXVldWVkID0gMDtcblxuICAgIC8vIEFzc2VtYmxpbmcgdGhlIHJvb3QgbmFtZXNwYWNlIGRvZXNuJ3QgcmVxdWlyZSB3b3JraW5nIHR5cGVcbiAgICAvLyByZWZlcmVuY2VzIGFueW1vcmUsIHNvIHdlIGNhbiBsb2FkIGV2ZXJ5dGhpbmcgaW4gcGFyYWxsZWxcbiAgICBpZiAodXRpbC5pc1N0cmluZyhmaWxlbmFtZSkpXG4gICAgICAgIGZpbGVuYW1lID0gWyBmaWxlbmFtZSBdO1xuICAgIGZvciAodmFyIGkgPSAwLCByZXNvbHZlZDsgaSA8IGZpbGVuYW1lLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAocmVzb2x2ZWQgPSBzZWxmLnJlc29sdmVQYXRoKFwiXCIsIGZpbGVuYW1lW2ldKSlcbiAgICAgICAgICAgIGZldGNoKHJlc29sdmVkKTtcblxuICAgIGlmIChzeW5jKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAoIXF1ZXVlZClcbiAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIG9wdGlvbnM6SVBhcnNlT3B0aW9ucywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIGNhbGxzIHRoZSBjYWxsYmFjay5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBOYW1lcyBvZiBvbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge1Byb21pc2U8Um9vdD59IFByb21pc2VcbiAqIEB2YXJpYXRpb24gM1xuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgW29wdGlvbnM6SVBhcnNlT3B0aW9uc10pOlByb21pc2U8Um9vdD5cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSAobm9kZSBvbmx5KS5cbiAqIEBmdW5jdGlvbiBSb290I2xvYWRTeW5jXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7SVBhcnNlT3B0aW9uc30gW29wdGlvbnNdIFBhcnNlIG9wdGlvbnMuIERlZmF1bHRzIHRvIHtAbGluayBwYXJzZS5kZWZhdWx0c30gd2hlbiBvbWl0dGVkLlxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgc3luY2hyb25vdXMgZmV0Y2hpbmcgaXMgbm90IHN1cHBvcnRlZCAoaS5lLiBpbiBicm93c2Vycykgb3IgaWYgYSBmaWxlJ3Mgc3ludGF4IGlzIGludmFsaWRcbiAqL1xuUm9vdC5wcm90b3R5cGUubG9hZFN5bmMgPSBmdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghdXRpbC5pc05vZGUpXG4gICAgICAgIHRocm93IEVycm9yKFwibm90IHN1cHBvcnRlZFwiKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkKGZpbGVuYW1lLCBvcHRpb25zLCBTWU5DKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblJvb3QucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIGlmICh0aGlzLmRlZmVycmVkLmxlbmd0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJ1bnJlc29sdmFibGUgZXh0ZW5zaW9uczogXCIgKyB0aGlzLmRlZmVycmVkLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiJ2V4dGVuZCBcIiArIGZpZWxkLmV4dGVuZCArIFwiJyBpbiBcIiArIGZpZWxkLnBhcmVudC5mdWxsTmFtZTtcbiAgICAgICAgfSkuam9pbihcIiwgXCIpKTtcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsLmNhbGwodGhpcyk7XG59O1xuXG4vLyBvbmx5IHVwcGVyY2FzZWQgKGFuZCB0aHVzIGNvbmZsaWN0LWZyZWUpIGNoaWxkcmVuIGFyZSBleHBvc2VkLCBzZWUgYmVsb3dcbnZhciBleHBvc2VSZSA9IC9eW0EtWl0vO1xuXG4vKipcbiAqIEhhbmRsZXMgYSBkZWZlcnJlZCBkZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkIGJ5IGNyZWF0aW5nIGEgc2lzdGVyIGZpZWxkIHRvIHJlcHJlc2VudCBpdCB3aXRoaW4gaXRzIGV4dGVuZGVkIHR5cGUuXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZCB3aXRpbiB0aGUgZGVjbGFyaW5nIHR5cGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgc3VjY2Vzc2Z1bGx5IGFkZGVkIHRvIHRoZSBleHRlbmRlZCB0eXBlLCBgZmFsc2VgIG90aGVyd2lzZVxuICogQGlubmVyXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIHRyeUhhbmRsZUV4dGVuc2lvbihyb290LCBmaWVsZCkge1xuICAgIHZhciBleHRlbmRlZFR5cGUgPSBmaWVsZC5wYXJlbnQubG9va3VwKGZpZWxkLmV4dGVuZCk7XG4gICAgaWYgKGV4dGVuZGVkVHlwZSkge1xuICAgICAgICB2YXIgc2lzdGVyRmllbGQgPSBuZXcgRmllbGQoZmllbGQuZnVsbE5hbWUsIGZpZWxkLmlkLCBmaWVsZC50eXBlLCBmaWVsZC5ydWxlLCB1bmRlZmluZWQsIGZpZWxkLm9wdGlvbnMpO1xuICAgICAgICBzaXN0ZXJGaWVsZC5kZWNsYXJpbmdGaWVsZCA9IGZpZWxkO1xuICAgICAgICBmaWVsZC5leHRlbnNpb25GaWVsZCA9IHNpc3RlckZpZWxkO1xuICAgICAgICBleHRlbmRlZFR5cGUuYWRkKHNpc3RlckZpZWxkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbnkgb2JqZWN0IGlzIGFkZGVkIHRvIHRoaXMgcm9vdCBvciBpdHMgc3ViLW5hbWVzcGFjZXMuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBPYmplY3QgYWRkZWRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5Sb290LnByb3RvdHlwZS5faGFuZGxlQWRkID0gZnVuY3Rpb24gX2hhbmRsZUFkZChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQpIHtcblxuICAgICAgICBpZiAoLyogYW4gZXh0ZW5zaW9uIGZpZWxkIChpbXBsaWVzIG5vdCBwYXJ0IG9mIGEgb25lb2YpICovIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCAmJiAvKiBub3QgYWxyZWFkeSBoYW5kbGVkICovICFvYmplY3QuZXh0ZW5zaW9uRmllbGQpXG4gICAgICAgICAgICBpZiAoIXRyeUhhbmRsZUV4dGVuc2lvbih0aGlzLCBvYmplY3QpKVxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucHVzaChvYmplY3QpO1xuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnVtKSB7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV0gPSBvYmplY3QudmFsdWVzOyAvLyBleHBvc2UgZW51bSB2YWx1ZXMgYXMgcHJvcGVydHkgb2YgaXRzIHBhcmVudFxuXG4gICAgfSBlbHNlIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIE9uZU9mKSkgLyogZXZlcnl0aGluZyBlbHNlIGlzIGEgbmFtZXNwYWNlICovIHtcblxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVHlwZSkgLy8gVHJ5IHRvIGhhbmRsZSBhbnkgZGVmZXJyZWQgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlZmVycmVkLmxlbmd0aDspXG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhbmRsZUV4dGVuc2lvbih0aGlzLCB0aGlzLmRlZmVycmVkW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgLyogaW5pdGlhbGl6ZXMgKi8gb2JqZWN0Lm5lc3RlZEFycmF5Lmxlbmd0aDsgKytqKSAvLyByZWN1cnNlIGludG8gdGhlIG5hbWVzcGFjZVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlQWRkKG9iamVjdC5fbmVzdGVkQXJyYXlbal0pO1xuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdDsgLy8gZXhwb3NlIG5hbWVzcGFjZSBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XG4gICAgfVxuXG4gICAgLy8gVGhlIGFib3ZlIGFsc28gYWRkcyB1cHBlcmNhc2VkIChhbmQgdGh1cyBjb25mbGljdC1mcmVlKSBuZXN0ZWQgdHlwZXMsIHNlcnZpY2VzIGFuZCBlbnVtcyBhc1xuICAgIC8vIHByb3BlcnRpZXMgb2YgbmFtZXNwYWNlcyBqdXN0IGxpa2Ugc3RhdGljIGNvZGUgZG9lcy4gVGhpcyBhbGxvd3MgdXNpbmcgYSAuZC50cyBnZW5lcmF0ZWQgZm9yXG4gICAgLy8gYSBzdGF0aWMgbW9kdWxlIHdpdGggcmVmbGVjdGlvbi1iYXNlZCBzb2x1dGlvbnMgd2hlcmUgdGhlIGNvbmRpdGlvbiBpcyBtZXQuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGFueSBvYmplY3QgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgcm9vdCBvciBpdHMgc3ViLW5hbWVzcGFjZXMuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBPYmplY3QgcmVtb3ZlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cblJvb3QucHJvdG90eXBlLl9oYW5kbGVSZW1vdmUgPSBmdW5jdGlvbiBfaGFuZGxlUmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xuXG4gICAgICAgIGlmICgvKiBhbiBleHRlbnNpb24gZmllbGQgKi8gb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoLyogYWxyZWFkeSBoYW5kbGVkICovIG9iamVjdC5leHRlbnNpb25GaWVsZCkgeyAvLyByZW1vdmUgaXRzIHNpc3RlciBmaWVsZFxuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlbnNpb25GaWVsZC5wYXJlbnQucmVtb3ZlKG9iamVjdC5leHRlbnNpb25GaWVsZCk7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4dGVuc2lvbkZpZWxkID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGNhbmNlbCB0aGUgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5kZWZlcnJlZC5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEVudW0pIHtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV07IC8vIHVuZXhwb3NlIGVudW0gdmFsdWVzXG5cbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkge1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gb2JqZWN0Lm5lc3RlZEFycmF5Lmxlbmd0aDsgKytpKSAvLyByZWN1cnNlIGludG8gdGhlIG5hbWVzcGFjZVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlUmVtb3ZlKG9iamVjdC5fbmVzdGVkQXJyYXlbaV0pO1xuXG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIGRlbGV0ZSBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXTsgLy8gdW5leHBvc2UgbmFtZXNwYWNlc1xuXG4gICAgfVxufTtcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5Sb290Ll9jb25maWd1cmUgPSBmdW5jdGlvbihUeXBlXywgcGFyc2VfLCBjb21tb25fKSB7XG4gICAgVHlwZSAgID0gVHlwZV87XG4gICAgcGFyc2UgID0gcGFyc2VfO1xuICAgIGNvbW1vbiA9IGNvbW1vbl87XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjY3Jvc3MgbW9kdWxlcy5cbiAqIEBuYW1lIHJvb3RzXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUm9vdD59XG4gKiBAZXhhbXBsZVxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXG4gKlxuICogLy8gaW4gYW5vdGhlciBtb2R1bGU6XG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcbiAqXG4gKiAvLyBpbiBhbnkgc3Vic2VxdWVudCBtb2R1bGU6XG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xuICovXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxuLy8gZXh0ZW5kcyBOYW1lc3BhY2VcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG4oKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlKS5jbGFzc05hbWUgPSBcIlNlcnZpY2VcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKSxcbiAgICB1dGlsICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIHJwYyAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBzZXJ2aWNlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBTZXJ2aWNlIG9wdGlvbnNcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UobmFtZSwgb3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogU2VydmljZSBtZXRob2RzLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxNZXRob2Q+fVxuICAgICAqL1xuICAgIHRoaXMubWV0aG9kcyA9IHt9OyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG1ldGhvZHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge01ldGhvZFtdfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tZXRob2RzQXJyYXkgPSBudWxsO1xufVxuXG4vKipcbiAqIFNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSVNlcnZpY2VcbiAqIEBleHRlbmRzIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSU1ldGhvZD59IG1ldGhvZHMgTWV0aG9kIGRlc2NyaXB0b3JzXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc2VydmljZSBmcm9tIGEgc2VydmljZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXG4gKiBAcGFyYW0ge0lTZXJ2aWNlfSBqc29uIFNlcnZpY2UgZGVzY3JpcHRvclxuICogQHJldHVybnMge1NlcnZpY2V9IENyZWF0ZWQgc2VydmljZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuU2VydmljZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKG5hbWUsIGpzb24ub3B0aW9ucyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoanNvbi5tZXRob2RzKVxuICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ubWV0aG9kcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBzZXJ2aWNlLmFkZChNZXRob2QuZnJvbUpTT04obmFtZXNbaV0sIGpzb24ubWV0aG9kc1tuYW1lc1tpXV0pKTtcbiAgICBpZiAoanNvbi5uZXN0ZWQpXG4gICAgICAgIHNlcnZpY2UuYWRkSlNPTihqc29uLm5lc3RlZCk7XG4gICAgc2VydmljZS5jb21tZW50ID0ganNvbi5jb21tZW50O1xuICAgIHJldHVybiBzZXJ2aWNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHNlcnZpY2UgdG8gYSBzZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJU2VydmljZX0gU2VydmljZSBkZXNjcmlwdG9yXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGluaGVyaXRlZCA9IE5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcywgdG9KU09OT3B0aW9ucyk7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm9wdGlvbnMgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcIm1ldGhvZHNcIiAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLm1ldGhvZHNBcnJheSwgdG9KU09OT3B0aW9ucykgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge30sXG4gICAgICAgIFwibmVzdGVkXCIgICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5uZXN0ZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRcIiAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBNZXRob2RzIG9mIHRoaXMgc2VydmljZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICogQG5hbWUgU2VydmljZSNtZXRob2RzQXJyYXlcbiAqIEB0eXBlIHtNZXRob2RbXX1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGUsIFwibWV0aG9kc0FycmF5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0aG9kc0FycmF5IHx8ICh0aGlzLl9tZXRob2RzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5tZXRob2RzKSk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGNsZWFyQ2FjaGUoc2VydmljZSkge1xuICAgIHNlcnZpY2UuX21ldGhvZHNBcnJheSA9IG51bGw7XG4gICAgcmV0dXJuIHNlcnZpY2U7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0aG9kc1tuYW1lXVxuICAgICAgICB8fCBOYW1lc3BhY2UucHJvdG90eXBlLmdldC5jYWxsKHRoaXMsIG5hbWUpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgdmFyIG1ldGhvZHMgPSB0aGlzLm1ldGhvZHNBcnJheTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyArK2kpXG4gICAgICAgIG1ldGhvZHNbaV0ucmVzb2x2ZSgpO1xuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlc29sdmUuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLmdldChvYmplY3QubmFtZSkpXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNZXRob2QpIHtcbiAgICAgICAgdGhpcy5tZXRob2RzW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNZXRob2QpIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV0gIT09IG9iamVjdClcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdO1xuICAgICAgICBvYmplY3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBydW50aW1lIHNlcnZpY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBycGMgaW1wbGVtZW50YXRpb24uXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gUlBDIHNlcnZpY2UuIFVzZWZ1bCB3aGVyZSByZXF1ZXN0cyBhbmQvb3IgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZC5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG4gICAgdmFyIHJwY1NlcnZpY2UgPSBuZXcgcnBjLlNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpO1xuICAgIGZvciAodmFyIGkgPSAwLCBtZXRob2Q7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLm1ldGhvZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IHV0aWwubGNGaXJzdCgobWV0aG9kID0gdGhpcy5fbWV0aG9kc0FycmF5W2ldKS5yZXNvbHZlKCkubmFtZSkucmVwbGFjZSgvW14kXFx3X10vZywgXCJcIik7XG4gICAgICAgIHJwY1NlcnZpY2VbbWV0aG9kTmFtZV0gPSB1dGlsLmNvZGVnZW4oW1wiclwiLFwiY1wiXSwgdXRpbC5pc1Jlc2VydmVkKG1ldGhvZE5hbWUpID8gbWV0aG9kTmFtZSArIFwiX1wiIDogbWV0aG9kTmFtZSkoXCJyZXR1cm4gdGhpcy5ycGNDYWxsKG0scSxzLHIsYylcIikoe1xuICAgICAgICAgICAgbTogbWV0aG9kLFxuICAgICAgICAgICAgcTogbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGUuY3RvcixcbiAgICAgICAgICAgIHM6IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZS5jdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcnBjU2VydmljZTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gdG9rZW5pemU7XG5cbnZhciBkZWxpbVJlICAgICAgICA9IC9bXFxze309OzpbXFxdLCdcIigpPD5dL2csXG4gICAgc3RyaW5nRG91YmxlUmUgPSAvKD86XCIoW15cIlxcXFxdKig/OlxcXFwuW15cIlxcXFxdKikqKVwiKS9nLFxuICAgIHN0cmluZ1NpbmdsZVJlID0gLyg/OicoW14nXFxcXF0qKD86XFxcXC5bXidcXFxcXSopKiknKS9nO1xuXG52YXIgc2V0Q29tbWVudFJlID0gL14gKlsqL10rICovLFxuICAgIHNldENvbW1lbnRBbHRSZSA9IC9eXFxzKlxcKj9cXC8qLyxcbiAgICBzZXRDb21tZW50U3BsaXRSZSA9IC9cXG4vZyxcbiAgICB3aGl0ZXNwYWNlUmUgPSAvXFxzLyxcbiAgICB1bmVzY2FwZVJlID0gL1xcXFwoLj8pL2c7XG5cbnZhciB1bmVzY2FwZU1hcCA9IHtcbiAgICBcIjBcIjogXCJcXDBcIixcbiAgICBcInJcIjogXCJcXHJcIixcbiAgICBcIm5cIjogXCJcXG5cIixcbiAgICBcInRcIjogXCJcXHRcIlxufTtcblxuLyoqXG4gKiBVbmVzY2FwZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byB1bmVzY2FwZVxuICogQHJldHVybnMge3N0cmluZ30gVW5lc2NhcGVkIHN0cmluZ1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBtYXAgU3BlY2lhbCBjaGFyYWN0ZXJzIG1hcFxuICogQG1lbWJlcm9mIHRva2VuaXplXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSh1bmVzY2FwZVJlLCBmdW5jdGlvbigkMCwgJDEpIHtcbiAgICAgICAgc3dpdGNoICgkMSkge1xuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJDE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmVzY2FwZU1hcFskMV0gfHwgXCJcIjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG50b2tlbml6ZS51bmVzY2FwZSA9IHVuZXNjYXBlO1xuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlTmV4dFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBOZXh0IHRva2VuIG9yIGBudWxsYCBvbiBlb2ZcbiAqL1xuXG4vKipcbiAqIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbi5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVBlZWtcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTmV4dCB0b2tlbiBvciBgbnVsbGAgb24gZW9mXG4gKi9cblxuLyoqXG4gKiBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFjay5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVB1c2hcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IHRva2VuLlxuICogQHR5cGVkZWYgVG9rZW5pemVySGFuZGxlU2tpcFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkIEV4cGVjdGVkIHRva2VuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbD1mYWxzZV0gSWYgb3B0aW9uYWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSB0b2tlbiBtYXRjaGVkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHRva2VuIGRpZG4ndCBtYXRjaCBhbmQgaXMgbm90IG9wdGlvbmFsXG4gKi9cblxuLyoqXG4gKiBHZXRzIHRoZSBjb21tZW50IG9uIHRoZSBwcmV2aW91cyBsaW5lIG9yLCBhbHRlcm5hdGl2ZWx5LCB0aGUgbGluZSBjb21tZW50IG9uIHRoZSBzcGVjaWZpZWQgbGluZS5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZUNtbnRcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGluZV0gTGluZSBudW1iZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gQ29tbWVudCB0ZXh0IG9yIGBudWxsYCBpZiBub25lXG4gKi9cblxuLyoqXG4gKiBIYW5kbGUgb2JqZWN0IHJldHVybmVkIGZyb20ge0BsaW5rIHRva2VuaXplfS5cbiAqIEBpbnRlcmZhY2UgSVRva2VuaXplckhhbmRsZVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVOZXh0fSBuZXh0IEdldHMgdGhlIG5leHQgdG9rZW4gYW5kIGFkdmFuY2VzIChgbnVsbGAgb24gZW9mKVxuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVQZWVrfSBwZWVrIFBlZWtzIGZvciB0aGUgbmV4dCB0b2tlbiAoYG51bGxgIG9uIGVvZilcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlUHVzaH0gcHVzaCBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFja1xuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVTa2lwfSBza2lwIFNraXBzIGEgdG9rZW4sIHJldHVybnMgaXRzIHByZXNlbmNlIGFuZCBhZHZhbmNlcyBvciwgaWYgbm9uLW9wdGlvbmFsIGFuZCBub3QgcHJlc2VudCwgdGhyb3dzXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZUNtbnR9IGNtbnQgR2V0cyB0aGUgY29tbWVudCBvbiB0aGUgcHJldmlvdXMgbGluZSBvciB0aGUgbGluZSBjb21tZW50IG9uIHRoZSBzcGVjaWZpZWQgbGluZSwgaWYgYW55XG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZSBDdXJyZW50IGxpbmUgbnVtYmVyXG4gKi9cblxuLyoqXG4gKiBUb2tlbml6ZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlZnVsIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBTb3VyY2UgY29udGVudHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWx0ZXJuYXRlQ29tbWVudE1vZGUgV2hldGhlciB3ZSBzaG91bGQgYWN0aXZhdGUgYWx0ZXJuYXRlIGNvbW1lbnQgcGFyc2luZyBtb2RlLlxuICogQHJldHVybnMge0lUb2tlbml6ZXJIYW5kbGV9IFRva2VuaXplciBoYW5kbGVcbiAqL1xuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCBhbHRlcm5hdGVDb21tZW50TW9kZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbGxiYWNrLXJldHVybiAqL1xuICAgIHNvdXJjZSA9IHNvdXJjZS50b1N0cmluZygpO1xuXG4gICAgdmFyIG9mZnNldCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsXG4gICAgICAgIGxpbmUgPSAxLFxuICAgICAgICBjb21tZW50VHlwZSA9IG51bGwsXG4gICAgICAgIGNvbW1lbnRUZXh0ID0gbnVsbCxcbiAgICAgICAgY29tbWVudExpbmUgPSAwLFxuICAgICAgICBjb21tZW50TGluZUVtcHR5ID0gZmFsc2UsXG4gICAgICAgIGNvbW1lbnRJc0xlYWRpbmcgPSBmYWxzZTtcblxuICAgIHZhciBzdGFjayA9IFtdO1xuXG4gICAgdmFyIHN0cmluZ0RlbGltID0gbnVsbDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciBmb3IgaWxsZWdhbCBzeW50YXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmplY3QgU3ViamVjdFxuICAgICAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3IgY3JlYXRlZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlsbGVnYWwoc3ViamVjdCkge1xuICAgICAgICByZXR1cm4gRXJyb3IoXCJpbGxlZ2FsIFwiICsgc3ViamVjdCArIFwiIChsaW5lIFwiICsgbGluZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHN0cmluZyB0aWxsIGl0cyBlbmQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmUgPSBzdHJpbmdEZWxpbSA9PT0gXCInXCIgPyBzdHJpbmdTaW5nbGVSZSA6IHN0cmluZ0RvdWJsZVJlO1xuICAgICAgICByZS5sYXN0SW5kZXggPSBvZmZzZXQgLSAxO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHNvdXJjZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwic3RyaW5nXCIpO1xuICAgICAgICBvZmZzZXQgPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHB1c2goc3RyaW5nRGVsaW0pO1xuICAgICAgICBzdHJpbmdEZWxpbSA9IG51bGw7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2hhcmFjdGVyIGF0IGBwb3NgIHdpdGhpbiB0aGUgc291cmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFyQXQocG9zKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuY2hhckF0KHBvcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBjb21tZW50IHRleHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFkaW5nIHNldCBpZiBhIGxlYWRpbmcgY29tbWVudFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q29tbWVudChzdGFydCwgZW5kLCBpc0xlYWRpbmcpIHtcbiAgICAgICAgY29tbWVudFR5cGUgPSBzb3VyY2UuY2hhckF0KHN0YXJ0KyspO1xuICAgICAgICBjb21tZW50TGluZSA9IGxpbmU7XG4gICAgICAgIGNvbW1lbnRMaW5lRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgY29tbWVudElzTGVhZGluZyA9IGlzTGVhZGluZztcbiAgICAgICAgdmFyIGxvb2tiYWNrO1xuICAgICAgICBpZiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMjsgIC8vIGFsdGVybmF0ZSBjb21tZW50IHBhcnNpbmc6IFwiLy9cIiBvciBcIi8qXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMzsgIC8vIFwiLy8vXCIgb3IgXCIvKipcIlxuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tZW50T2Zmc2V0ID0gc3RhcnQgLSBsb29rYmFjayxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgtLWNvbW1lbnRPZmZzZXQgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIChjID0gc291cmNlLmNoYXJBdChjb21tZW50T2Zmc2V0KSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50TGluZUVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXHRcIik7XG4gICAgICAgIHZhciBsaW5lcyA9IHNvdXJjZVxuICAgICAgICAgICAgLnN1YnN0cmluZyhzdGFydCwgZW5kKVxuICAgICAgICAgICAgLnNwbGl0KHNldENvbW1lbnRTcGxpdFJlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGxpbmVzW2ldID0gbGluZXNbaV1cbiAgICAgICAgICAgICAgICAucmVwbGFjZShhbHRlcm5hdGVDb21tZW50TW9kZSA/IHNldENvbW1lbnRBbHRSZSA6IHNldENvbW1lbnRSZSwgXCJcIilcbiAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgICBjb21tZW50VGV4dCA9IGxpbmVzXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKVxuICAgICAgICAgICAgLnRyaW0oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUoc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGZpbmRFbmRPZkxpbmUoc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgIC8vIHNlZSBpZiByZW1haW5pbmcgbGluZSBtYXRjaGVzIGNvbW1lbnQgcGF0dGVyblxuICAgICAgICB2YXIgbGluZVRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICAvLyBsb29rIGZvciAxIG9yIDIgc2xhc2hlcyBzaW5jZSBzdGFydE9mZnNldCB3b3VsZCBhbHJlYWR5IHBvaW50IHBhc3RcbiAgICAgICAgLy8gdGhlIGZpcnN0IHNsYXNoIHRoYXQgc3RhcnRlZCB0aGUgY29tbWVudC5cbiAgICAgICAgdmFyIGlzQ29tbWVudCA9IC9eXFxzKlxcL3sxLDJ9Ly50ZXN0KGxpbmVUZXh0KTtcbiAgICAgICAgcmV0dXJuIGlzQ29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRW5kT2ZMaW5lKGN1cnNvcikge1xuICAgICAgICAvLyBmaW5kIGVuZCBvZiBjdXJzb3IncyBsaW5lXG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBjdXJzb3I7XG4gICAgICAgIHdoaWxlIChlbmRPZmZzZXQgPCBsZW5ndGggJiYgY2hhckF0KGVuZE9mZnNldCkgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmRPZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzdHJpbmdEZWxpbSlcbiAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKCk7XG4gICAgICAgIHZhciByZXBlYXQsXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgY3VycixcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgaXNEb2MsXG4gICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gb2Zmc2V0ID09PSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh3aGl0ZXNwYWNlUmUudGVzdChjdXJyID0gY2hhckF0KG9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhckF0KG9mZnNldCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFyQXQob2Zmc2V0KSA9PT0gXCIvXCIpIHsgLy8gTGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdHJpcGxlLXNsYXNoIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9jID0gY2hhckF0KHN0YXJ0ID0gb2Zmc2V0ICsgMSkgPT09IFwiL1wiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckF0KCsrb2Zmc2V0KSAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCAtIDEsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBkb3VibGUtc2xhc2ggY29tbWVudHMsIGNvbnNvbGlkYXRpbmcgY29uc2VjdXRpdmUgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb2MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUob2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGZpbmRFbmRPZkxpbmUob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUob2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgZmluZEVuZE9mTGluZShvZmZzZXQpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGN1cnIgPSBjaGFyQXQob2Zmc2V0KSkgPT09IFwiKlwiKSB7IC8qIEJsb2NrICovXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciAvKiogKHJlZ3VsYXIgY29tbWVudCBtb2RlKSBvciAvKiAoYWx0ZXJuYXRlIGNvbW1lbnQgbW9kZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNoYXJBdChzdGFydCkgPT09IFwiKlwiO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyciA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY3VycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjaGFyQXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiAhPT0gXCIqXCIgfHwgY3VyciAhPT0gXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQgLSAyLCBpc0xlYWRpbmdDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIi9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHJlcGVhdCk7XG5cbiAgICAgICAgLy8gb2Zmc2V0ICE9PSBsZW5ndGggaWYgd2UgZ290IGhlcmVcblxuICAgICAgICB2YXIgZW5kID0gb2Zmc2V0O1xuICAgICAgICBkZWxpbVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBkZWxpbSA9IGRlbGltUmUudGVzdChjaGFyQXQoZW5kKyspKTtcbiAgICAgICAgaWYgKCFkZWxpbSlcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGggJiYgIWRlbGltUmUudGVzdChjaGFyQXQoZW5kKSkpXG4gICAgICAgICAgICAgICAgKytlbmQ7XG4gICAgICAgIHZhciB0b2tlbiA9IHNvdXJjZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgPSBlbmQpO1xuICAgICAgICBpZiAodG9rZW4gPT09IFwiXFxcIlwiIHx8IHRva2VuID09PSBcIidcIilcbiAgICAgICAgICAgIHN0cmluZ0RlbGltID0gdG9rZW47XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSB0b2tlbiBiYWNrIHRvIHRoZSBzdGFjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW5cbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1c2godG9rZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVla3MgZm9yIHRoZSBuZXh0IHRva2VuLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gVG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2tbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2tpcHMgYSB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgRXhwZWN0ZWQgdG9rZW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25hbD1mYWxzZV0gV2hldGhlciB0aGUgdG9rZW4gaXMgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIHdoZW4gc2tpcHBlZCwgYGZhbHNlYCBpZiBub3RcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiBhIHJlcXVpcmVkIHRva2VuIGlzIG5vdCBwcmVzZW50XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2tpcChleHBlY3RlZCwgb3B0aW9uYWwpIHtcbiAgICAgICAgdmFyIGFjdHVhbCA9IHBlZWsoKSxcbiAgICAgICAgICAgIGVxdWFscyA9IGFjdHVhbCA9PT0gZXhwZWN0ZWQ7XG4gICAgICAgIGlmIChlcXVhbHMpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9uYWwpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwidG9rZW4gJ1wiICsgYWN0dWFsICsgXCInLCAnXCIgKyBleHBlY3RlZCArIFwiJyBleHBlY3RlZFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb21tZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdHJhaWxpbmdMaW5lXSBMaW5lIG51bWJlciBpZiBsb29raW5nIGZvciBhIHRyYWlsaW5nIGNvbW1lbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IENvbW1lbnQgdGV4dFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNtbnQodHJhaWxpbmdMaW5lKSB7XG4gICAgICAgIHZhciByZXQgPSBudWxsO1xuICAgICAgICBpZiAodHJhaWxpbmdMaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjb21tZW50TGluZSA9PT0gbGluZSAtIDEgJiYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNvbW1lbnRUeXBlID09PSBcIipcIiB8fCBjb21tZW50TGluZUVtcHR5KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGNvbW1lbnRJc0xlYWRpbmcgPyBjb21tZW50VGV4dCA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRMaW5lIDwgdHJhaWxpbmdMaW5lKSB7XG4gICAgICAgICAgICAgICAgcGVlaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1lbnRMaW5lID09PSB0cmFpbGluZ0xpbmUgJiYgIWNvbW1lbnRMaW5lRW1wdHkgJiYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNvbW1lbnRUeXBlID09PSBcIi9cIikpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21tZW50SXNMZWFkaW5nID8gbnVsbCA6IGNvbW1lbnRUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgIG5leHQ6IG5leHQsXG4gICAgICAgIHBlZWs6IHBlZWssXG4gICAgICAgIHB1c2g6IHB1c2gsXG4gICAgICAgIHNraXA6IHNraXAsXG4gICAgICAgIGNtbnQ6IGNtbnRcbiAgICB9LCBcImxpbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZTsgfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FsbGJhY2stcmV0dXJuICovXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gVHlwZTtcblxuLy8gZXh0ZW5kcyBOYW1lc3BhY2VcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG4oKFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBUeXBlKS5jbGFzc05hbWUgPSBcIlR5cGVcIjtcblxudmFyIEVudW0gICAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgT25lT2YgICAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXG4gICAgRmllbGQgICAgID0gcmVxdWlyZShcIi4vZmllbGRcIiksXG4gICAgTWFwRmllbGQgID0gcmVxdWlyZShcIi4vbWFwZmllbGRcIiksXG4gICAgU2VydmljZSAgID0gcmVxdWlyZShcIi4vc2VydmljZVwiKSxcbiAgICBNZXNzYWdlICAgPSByZXF1aXJlKFwiLi9tZXNzYWdlXCIpLFxuICAgIFJlYWRlciAgICA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKSxcbiAgICBXcml0ZXIgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBlbmNvZGVyICAgPSByZXF1aXJlKFwiLi9lbmNvZGVyXCIpLFxuICAgIGRlY29kZXIgICA9IHJlcXVpcmUoXCIuL2RlY29kZXJcIiksXG4gICAgdmVyaWZpZXIgID0gcmVxdWlyZShcIi4vdmVyaWZpZXJcIiksXG4gICAgY29udmVydGVyID0gcmVxdWlyZShcIi4vY29udmVydGVyXCIpLFxuICAgIHdyYXBwZXJzICA9IHJlcXVpcmUoXCIuL3dyYXBwZXJzXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVmbGVjdGVkIG1lc3NhZ2UgdHlwZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBleHRlbmRzIE5hbWVzcGFjZUJhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTWVzc2FnZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBUeXBlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgZmllbGRzLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxGaWVsZD59XG4gICAgICovXG4gICAgdGhpcy5maWVsZHMgPSB7fTsgIC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBPbmVvZnMgZGVjbGFyZWQgd2l0aGluIHRoaXMgbmFtZXNwYWNlLCBpZiBhbnkuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLE9uZU9mPn1cbiAgICAgKi9cbiAgICB0aGlzLm9uZW9mcyA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBFeHRlbnNpb24gcmFuZ2VzLCBpZiBhbnkuXG4gICAgICogQHR5cGUge251bWJlcltdW119XG4gICAgICovXG4gICAgdGhpcy5leHRlbnNpb25zID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFJlc2VydmVkIHJhbmdlcywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyW118c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2VydmVkID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qP1xuICAgICAqIFdoZXRoZXIgdGhpcyB0eXBlIGlzIGEgbGVnYWN5IGdyb3VwLlxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLmdyb3VwID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIENhY2hlZCBmaWVsZHMgYnkgaWQuXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLEZpZWxkPnxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGRzQnlJZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgZmllbGRzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtGaWVsZFtdfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9maWVsZHNBcnJheSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgb25lb2ZzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtPbmVPZltdfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9vbmVvZnNBcnJheSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgY29uc3RydWN0b3IuXG4gICAgICogQHR5cGUge0NvbnN0cnVjdG9yPHt9Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N0b3IgPSBudWxsO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhUeXBlLnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBmaWVsZHMgYnkgaWQuXG4gICAgICogQG5hbWUgVHlwZSNmaWVsZHNCeUlkXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLEZpZWxkPn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmaWVsZHNCeUlkOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0J5SWQ7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVzID0gT2JqZWN0LmtleXModGhpcy5maWVsZHMpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZHNbbmFtZXNbaV1dLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IGZpZWxkLmlkO1xuXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0J5SWRbaWRdKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIGlkICsgXCIgaW4gXCIgKyB0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0J5SWRbaWRdID0gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQnlJZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWVsZHMgb2YgdGhpcyBtZXNzYWdlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gICAgICogQG5hbWUgVHlwZSNmaWVsZHNBcnJheVxuICAgICAqIEB0eXBlIHtGaWVsZFtdfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZpZWxkc0FycmF5OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmllbGRzQXJyYXkgfHwgKHRoaXMuX2ZpZWxkc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMuZmllbGRzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT25lb2ZzIG9mIHRoaXMgbWVzc2FnZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBuYW1lIFR5cGUjb25lb2ZzQXJyYXlcbiAgICAgKiBAdHlwZSB7T25lT2ZbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBvbmVvZnNBcnJheToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uZW9mc0FycmF5IHx8ICh0aGlzLl9vbmVvZnNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLm9uZW9mcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWdpc3RlcmVkIGNvbnN0cnVjdG9yLCBpZiBhbnkgcmVnaXN0ZXJlZCwgb3RoZXJ3aXNlIGEgZ2VuZXJpYyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBBc3NpZ25pbmcgYSBmdW5jdGlvbiByZXBsYWNlcyB0aGUgaW50ZXJuYWwgY29uc3RydWN0b3IuIElmIHRoZSBmdW5jdGlvbiBkb2VzIG5vdCBleHRlbmQge0BsaW5rIE1lc3NhZ2V9IHlldCwgaXRzIHByb3RvdHlwZSB3aWxsIGJlIHNldHVwIGFjY29yZGluZ2x5IGFuZCBzdGF0aWMgbWV0aG9kcyB3aWxsIGJlIHBvcHVsYXRlZC4gSWYgaXQgYWxyZWFkeSBleHRlbmRzIHtAbGluayBNZXNzYWdlfSwgaXQgd2lsbCBqdXN0IHJlcGxhY2UgdGhlIGludGVybmFsIGNvbnN0cnVjdG9yLlxuICAgICAqIEBuYW1lIFR5cGUjY3RvclxuICAgICAqIEB0eXBlIHtDb25zdHJ1Y3Rvcjx7fT59XG4gICAgICovXG4gICAgY3Rvcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N0b3IgfHwgKHRoaXMuY3RvciA9IFR5cGUuZ2VuZXJhdGVDb25zdHJ1Y3Rvcih0aGlzKSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihjdG9yKSB7XG5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9wZXIgcHJvdG90eXBlXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gY3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICBpZiAoIShwcm90b3R5cGUgaW5zdGFuY2VvZiBNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIChjdG9yLnByb3RvdHlwZSA9IG5ldyBNZXNzYWdlKCkpLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGN0b3IucHJvdG90eXBlLCBwcm90b3R5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGFzc2VzIGFuZCBtZXNzYWdlcyByZWZlcmVuY2UgdGhlaXIgcmVmbGVjdGVkIHR5cGVcbiAgICAgICAgICAgIGN0b3IuJHR5cGUgPSBjdG9yLnByb3RvdHlwZS4kdHlwZSA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIE1peCBpbiBzdGF0aWMgbWV0aG9kc1xuICAgICAgICAgICAgdXRpbC5tZXJnZShjdG9yLCBNZXNzYWdlLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhpcy5fY3RvciA9IGN0b3I7XG5cbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIGhhdmUgbm9uLWVudW1lcmFibGUgZGVmYXVsdCB2YWx1ZXMgb24gdGhlaXIgcHJvdG90eXBlXG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpOyAvLyBlbnN1cmVzIGEgcHJvcGVyIHZhbHVlXG5cbiAgICAgICAgICAgIC8vIE1lc3NhZ2VzIGhhdmUgbm9uLWVudW1lcmFibGUgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgZWFjaCB2aXJ0dWFsIG9uZW9mIGZpZWxkXG4gICAgICAgICAgICB2YXIgY3RvclByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLm9uZW9mc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGN0b3JQcm9wZXJ0aWVzW3RoaXMuX29uZW9mc0FycmF5W2ldLnJlc29sdmUoKS5uYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiB1dGlsLm9uZU9mR2V0dGVyKHRoaXMuX29uZW9mc0FycmF5W2ldLm9uZW9mKSxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiB1dGlsLm9uZU9mU2V0dGVyKHRoaXMuX29uZW9mc0FycmF5W2ldLm9uZW9mKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjdG9yLnByb3RvdHlwZSwgY3RvclByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5UeXBlLmdlbmVyYXRlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBnZW5lcmF0ZUNvbnN0cnVjdG9yKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcInBcIl0sIG10eXBlLm5hbWUpO1xuICAgIC8vIGV4cGxpY2l0bHkgaW5pdGlhbGl6ZSBtdXRhYmxlIG9iamVjdC9hcnJheSBmaWVsZHMgc28gdGhhdCB0aGVzZSBhcmVuJ3QganVzdCBpbmhlcml0ZWQgZnJvbSB0aGUgcHJvdG90eXBlXG4gICAgZm9yICh2YXIgaSA9IDAsIGZpZWxkOyBpIDwgbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICgoZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV0pLm1hcCkgZ2VuXG4gICAgICAgICAgICAoXCJ0aGlzJXM9e31cIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKSk7XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSBnZW5cbiAgICAgICAgICAgIChcInRoaXMlcz1bXVwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpKTtcbiAgICByZXR1cm4gZ2VuXG4gICAgKFwiaWYocClmb3IodmFyIGtzPU9iamVjdC5rZXlzKHApLGk9MDtpPGtzLmxlbmd0aDsrK2kpaWYocFtrc1tpXV0hPW51bGwpXCIpIC8vIG9taXQgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgKFwidGhpc1trc1tpXV09cFtrc1tpXV1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufTtcblxuZnVuY3Rpb24gY2xlYXJDYWNoZSh0eXBlKSB7XG4gICAgdHlwZS5fZmllbGRzQnlJZCA9IHR5cGUuX2ZpZWxkc0FycmF5ID0gdHlwZS5fb25lb2ZzQXJyYXkgPSBudWxsO1xuICAgIGRlbGV0ZSB0eXBlLmVuY29kZTtcbiAgICBkZWxldGUgdHlwZS5kZWNvZGU7XG4gICAgZGVsZXRlIHR5cGUudmVyaWZ5O1xuICAgIHJldHVybiB0eXBlO1xufVxuXG4vKipcbiAqIE1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJVHlwZVxuICogQGV4dGVuZHMgSU5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJT25lT2Y+fSBbb25lb2ZzXSBPbmVvZiBkZXNjcmlwdG9yc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxJRmllbGQ+fSBmaWVsZHMgRmllbGQgZGVzY3JpcHRvcnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW11bXX0gW2V4dGVuc2lvbnNdIEV4dGVuc2lvbiByYW5nZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW11bXX0gW3Jlc2VydmVkXSBSZXNlcnZlZCByYW5nZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyb3VwPWZhbHNlXSBXaGV0aGVyIGEgbGVnYWN5IGdyb3VwIG9yIG5vdFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1lc3NhZ2UgdHlwZSBmcm9tIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXNzYWdlIG5hbWVcbiAqIEBwYXJhbSB7SVR5cGV9IGpzb24gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtUeXBlfSBDcmVhdGVkIG1lc3NhZ2UgdHlwZVxuICovXG5UeXBlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciB0eXBlID0gbmV3IFR5cGUobmFtZSwganNvbi5vcHRpb25zKTtcbiAgICB0eXBlLmV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnM7XG4gICAgdHlwZS5yZXNlcnZlZCA9IGpzb24ucmVzZXJ2ZWQ7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5maWVsZHMpLFxuICAgICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICB0eXBlLmFkZChcbiAgICAgICAgICAgICggdHlwZW9mIGpzb24uZmllbGRzW25hbWVzW2ldXS5rZXlUeXBlICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IE1hcEZpZWxkLmZyb21KU09OXG4gICAgICAgICAgICA6IEZpZWxkLmZyb21KU09OICkobmFtZXNbaV0sIGpzb24uZmllbGRzW25hbWVzW2ldXSlcbiAgICAgICAgKTtcbiAgICBpZiAoanNvbi5vbmVvZnMpXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm9uZW9mcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmFkZChPbmVPZi5mcm9tSlNPTihuYW1lc1tpXSwganNvbi5vbmVvZnNbbmFtZXNbaV1dKSk7XG4gICAgaWYgKGpzb24ubmVzdGVkKVxuICAgICAgICBmb3IgKG5hbWVzID0gT2JqZWN0LmtleXMoanNvbi5uZXN0ZWQpLCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkID0ganNvbi5uZXN0ZWRbbmFtZXNbaV1dO1xuICAgICAgICAgICAgdHlwZS5hZGQoIC8vIG1vc3QgdG8gbGVhc3QgbGlrZWx5XG4gICAgICAgICAgICAgICAgKCBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLnZhbHVlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTZXJ2aWNlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBOYW1lc3BhY2UuZnJvbUpTT04gKShuYW1lc1tpXSwgbmVzdGVkKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIGlmIChqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zLmxlbmd0aClcbiAgICAgICAgdHlwZS5leHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zO1xuICAgIGlmIChqc29uLnJlc2VydmVkICYmIGpzb24ucmVzZXJ2ZWQubGVuZ3RoKVxuICAgICAgICB0eXBlLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICBpZiAoanNvbi5ncm91cClcbiAgICAgICAgdHlwZS5ncm91cCA9IHRydWU7XG4gICAgaWYgKGpzb24uY29tbWVudClcbiAgICAgICAgdHlwZS5jb21tZW50ID0ganNvbi5jb21tZW50O1xuICAgIHJldHVybiB0eXBlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG1lc3NhZ2UgdHlwZSB0byBhIG1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SVR5cGV9IE1lc3NhZ2UgdHlwZSBkZXNjcmlwdG9yXG4gKi9cblR5cGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGluaGVyaXRlZCA9IE5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcywgdG9KU09OT3B0aW9ucyk7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgICAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm9wdGlvbnMgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcIm9uZW9mc1wiICAgICAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLm9uZW9mc0FycmF5LCB0b0pTT05PcHRpb25zKSxcbiAgICAgICAgXCJmaWVsZHNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7IHJldHVybiAhb2JqLmRlY2xhcmluZ0ZpZWxkOyB9KSwgdG9KU09OT3B0aW9ucykgfHwge30sXG4gICAgICAgIFwiZXh0ZW5zaW9uc1wiICwgdGhpcy5leHRlbnNpb25zICYmIHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGggPyB0aGlzLmV4dGVuc2lvbnMgOiB1bmRlZmluZWQsXG4gICAgICAgIFwicmVzZXJ2ZWRcIiAgICwgdGhpcy5yZXNlcnZlZCAmJiB0aGlzLnJlc2VydmVkLmxlbmd0aCA/IHRoaXMucmVzZXJ2ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiZ3JvdXBcIiAgICAgICwgdGhpcy5ncm91cCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwibmVzdGVkXCIgICAgICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5uZXN0ZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRcIiAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHlwZS5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgdmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzQXJyYXksIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgZmllbGRzLmxlbmd0aClcbiAgICAgICAgZmllbGRzW2krK10ucmVzb2x2ZSgpO1xuICAgIHZhciBvbmVvZnMgPSB0aGlzLm9uZW9mc0FycmF5OyBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG9uZW9mcy5sZW5ndGgpXG4gICAgICAgIG9uZW9mc1tpKytdLnJlc29sdmUoKTtcbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UeXBlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmZpZWxkc1tuYW1lXVxuICAgICAgICB8fCB0aGlzLm9uZW9mcyAmJiB0aGlzLm9uZW9mc1tuYW1lXVxuICAgICAgICB8fCB0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXVxuICAgICAgICB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgbmVzdGVkIG9iamVjdCB0byB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIGFkZFxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbmVzdGVkIG9iamVjdCB3aXRoIHRoaXMgbmFtZSBvciwgaWYgYSBmaWVsZCwgd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGEgZmllbGQgd2l0aCB0aGlzIGlkXG4gKi9cblR5cGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIGlmICh0aGlzLmdldChvYmplY3QubmFtZSkpXG4gICAgICAgIHRocm93IEVycm9yKFwiZHVwbGljYXRlIG5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTk9URTogRXh0ZW5zaW9uIGZpZWxkcyBhcmVuJ3QgYWN0dWFsIGZpZWxkcyBvbiB0aGUgZGVjbGFyaW5nIHR5cGUsIGJ1dCBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgLy8gVGhlIHJvb3Qgb2JqZWN0IHRha2VzIGNhcmUgb2YgYWRkaW5nIGRpc3RpbmN0IHNpc3Rlci1maWVsZHMgdG8gdGhlIHJlc3BlY3RpdmUgZXh0ZW5kZWRcbiAgICAgICAgLy8gdHlwZSBpbnN0ZWFkLlxuXG4gICAgICAgIC8vIGF2b2lkcyBjYWxsaW5nIHRoZSBnZXR0ZXIgaWYgbm90IGFic29sdXRlbHkgbmVjZXNzYXJ5IGJlY2F1c2UgaXQncyBjYWxsZWQgcXVpdGUgZnJlcXVlbnRseVxuICAgICAgICBpZiAodGhpcy5fZmllbGRzQnlJZCA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRoaXMuX2ZpZWxkc0J5SWRbb2JqZWN0LmlkXSA6IHRoaXMuZmllbGRzQnlJZFtvYmplY3QuaWRdKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBvYmplY3QuaWQgKyBcIiBpbiBcIiArIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1Jlc2VydmVkSWQob2JqZWN0LmlkKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaWQgXCIgKyBvYmplY3QuaWQgKyBcIiBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pc1Jlc2VydmVkTmFtZShvYmplY3QubmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgb2JqZWN0Lm5hbWUgKyBcIicgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgICAgICBpZiAob2JqZWN0LnBhcmVudClcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnQucmVtb3ZlKG9iamVjdCk7XG4gICAgICAgIHRoaXMuZmllbGRzW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0Lm1lc3NhZ2UgPSB0aGlzO1xuICAgICAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZW9mcylcbiAgICAgICAgICAgIHRoaXMub25lb2ZzID0ge307XG4gICAgICAgIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0Lm9uQWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIG5lc3RlZCBvYmplY3QgZnJvbSB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgb2JqZWN0YCBpcyBub3QgYSBtZW1iZXIgb2YgdGhpcyB0eXBlXG4gKi9cblR5cGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQgJiYgb2JqZWN0LmV4dGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFNlZSBUeXBlI2FkZCBmb3IgdGhlIHJlYXNvbiB3aHkgZXh0ZW5zaW9uIGZpZWxkcyBhcmUgZXhjbHVkZWQgaGVyZS5cblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcyB8fCB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV0gIT09IG9iamVjdClcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpZWxkc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF0aGlzLm9uZW9mcyB8fCB0aGlzLm9uZW9mc1tvYmplY3QubmFtZV0gIT09IG9iamVjdClcbiAgICAgICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9uZW9mc1tvYmplY3QubmFtZV07XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSBudWxsO1xuICAgICAgICBvYmplY3Qub25SZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIGlkIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblR5cGUucHJvdG90eXBlLmlzUmVzZXJ2ZWRJZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRJZChpZCkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZElkKHRoaXMucmVzZXJ2ZWQsIGlkKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG5UeXBlLnByb3RvdHlwZS5pc1Jlc2VydmVkTmFtZSA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lKHRoaXMucmVzZXJ2ZWQsIG5hbWUpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKi9cblR5cGUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IocHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIFNldHMgdXAge0BsaW5rIFR5cGUjZW5jb2RlfGVuY29kZX0sIHtAbGluayBUeXBlI2RlY29kZXxkZWNvZGV9IGFuZCB7QGxpbmsgVHlwZSN2ZXJpZnl8dmVyaWZ5fS5cbiAqIEByZXR1cm5zIHtUeXBlfSBgdGhpc2BcbiAqL1xuVHlwZS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAvLyBTZXRzIHVwIGV2ZXJ5dGhpbmcgYXQgb25jZSBzbyB0aGF0IHRoZSBwcm90b3R5cGUgY2hhaW4gZG9lcyBub3QgaGF2ZSB0byBiZSByZS1ldmFsdWF0ZWRcbiAgICAvLyBtdWx0aXBsZSB0aW1lcyAoVjgsIHNvZnQtZGVvcHQgcHJvdG90eXBlLWNoZWNrKS5cblxuICAgIHZhciBmdWxsTmFtZSA9IHRoaXMuZnVsbE5hbWUsXG4gICAgICAgIHR5cGVzICAgID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICB0eXBlcy5wdXNoKHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKS5yZXNvbHZlZFR5cGUpO1xuXG4gICAgLy8gUmVwbGFjZSBzZXR1cCBtZXRob2RzIHdpdGggdHlwZS1zcGVjaWZpYyBnZW5lcmF0ZWQgZnVuY3Rpb25zXG4gICAgdGhpcy5lbmNvZGUgPSBlbmNvZGVyKHRoaXMpKHtcbiAgICAgICAgV3JpdGVyIDogV3JpdGVyLFxuICAgICAgICB0eXBlcyAgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMuZGVjb2RlID0gZGVjb2Rlcih0aGlzKSh7XG4gICAgICAgIFJlYWRlciA6IFJlYWRlcixcbiAgICAgICAgdHlwZXMgIDogdHlwZXMsXG4gICAgICAgIHV0aWwgICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLnZlcmlmeSA9IHZlcmlmaWVyKHRoaXMpKHtcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy5mcm9tT2JqZWN0ID0gY29udmVydGVyLmZyb21PYmplY3QodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLnRvT2JqZWN0ID0gY29udmVydGVyLnRvT2JqZWN0KHRoaXMpKHtcbiAgICAgICAgdHlwZXMgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgOiB1dGlsXG4gICAgfSk7XG5cbiAgICAvLyBJbmplY3QgY3VzdG9tIHdyYXBwZXJzIGZvciBjb21tb24gdHlwZXNcbiAgICB2YXIgd3JhcHBlciA9IHdyYXBwZXJzW2Z1bGxOYW1lXTtcbiAgICBpZiAod3JhcHBlcikge1xuICAgICAgICB2YXIgb3JpZ2luYWxUaGlzID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICAgICAgLy8gaWYgKHdyYXBwZXIuZnJvbU9iamVjdCkge1xuICAgICAgICAgICAgb3JpZ2luYWxUaGlzLmZyb21PYmplY3QgPSB0aGlzLmZyb21PYmplY3Q7XG4gICAgICAgICAgICB0aGlzLmZyb21PYmplY3QgPSB3cmFwcGVyLmZyb21PYmplY3QuYmluZChvcmlnaW5hbFRoaXMpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICh3cmFwcGVyLnRvT2JqZWN0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbFRoaXMudG9PYmplY3QgPSB0aGlzLnRvT2JqZWN0O1xuICAgICAgICAgICAgdGhpcy50b09iamVjdCA9IHdyYXBwZXIudG9PYmplY3QuYmluZChvcmlnaW5hbFRoaXMpO1xuICAgICAgICAvLyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgVHlwZSN2ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT58T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gKiBAcmV0dXJucyB7V3JpdGVyfSB3cml0ZXJcbiAqL1xuVHlwZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlX3NldHVwKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcik7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgVHlwZSN2ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7TWVzc2FnZTx7fT58T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSBpbnN0YW5jZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gKiBAcmV0dXJucyB7V3JpdGVyfSB3cml0ZXJcbiAqL1xuVHlwZS5wcm90b3R5cGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIgJiYgd3JpdGVyLmxlbiA/IHdyaXRlci5mb3JrKCkgOiB3cml0ZXIpLmxkZWxpbSgpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBvZiB0aGUgbWVzc2FnZSwgaWYga25vd24gYmVmb3JlaGFuZFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gKiBAdGhyb3dzIHt1dGlsLlByb3RvY29sRXJyb3I8e30+fSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqL1xuVHlwZS5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlX3NldHVwKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5kZWNvZGUocmVhZGVyLCBsZW5ndGgpOyAvLyBvdmVycmlkZXMgdGhpcyBtZXRob2Rcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge1JlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBEZWNvZGVkIG1lc3NhZ2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gKiBAdGhyb3dzIHt1dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICovXG5UeXBlLnByb3RvdHlwZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgUmVhZGVyKSlcbiAgICAgICAgcmVhZGVyID0gUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgZmllbGQgdmFsdWVzIGFyZSB2YWxpZCBhbmQgdGhhdCByZXF1aXJlZCBmaWVsZHMgYXJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gKi9cblR5cGUucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeV9zZXR1cChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS52ZXJpZnkobWVzc2FnZSk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtNZXNzYWdlPHt9Pn0gTWVzc2FnZSBpbnN0YW5jZVxuICovXG5UeXBlLnByb3RvdHlwZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmZyb21PYmplY3Qob2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ29udmVyc2lvbiBvcHRpb25zIGFzIHVzZWQgYnkge0BsaW5rIFR5cGUjdG9PYmplY3R9IGFuZCB7QGxpbmsgTWVzc2FnZS50b09iamVjdH0uXG4gKiBAaW50ZXJmYWNlIElDb252ZXJzaW9uT3B0aW9uc1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xvbmdzXSBMb25nIGNvbnZlcnNpb24gdHlwZS5cbiAqIFZhbGlkIHZhbHVlcyBhcmUgYFN0cmluZ2AgYW5kIGBOdW1iZXJgICh0aGUgZ2xvYmFsIHR5cGVzKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIGlzIGEgcG9zc2libHkgdW5zYWZlIG51bWJlciB3aXRob3V0IGFuZCBhIHtAbGluayBMb25nfSB3aXRoIGEgbG9uZyBsaWJyYXJ5LlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2VudW1zXSBFbnVtIHZhbHVlIGNvbnZlcnNpb24gdHlwZS5cbiAqIE9ubHkgdmFsaWQgdmFsdWUgaXMgYFN0cmluZ2AgKHRoZSBnbG9iYWwgdHlwZSkuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCBpcyB0aGUgbnVtZXJpYyBpZC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtieXRlc10gQnl0ZXMgdmFsdWUgY29udmVyc2lvbiB0eXBlLlxuICogVmFsaWQgdmFsdWVzIGFyZSBgQXJyYXlgIGFuZCAoYSBiYXNlNjQgZW5jb2RlZCkgYFN0cmluZ2AgKHRoZSBnbG9iYWwgdHlwZXMpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggdXN1YWxseSBpcyBhIEJ1ZmZlciB1bmRlciBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIHRoZSBicm93c2VyLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVmYXVsdHM9ZmFsc2VdIEFsc28gc2V0cyBkZWZhdWx0IHZhbHVlcyBvbiB0aGUgcmVzdWx0aW5nIG9iamVjdFxuICogQHByb3BlcnR5IHtib29sZWFufSBbYXJyYXlzPWZhbHNlXSBTZXRzIGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyByZXBlYXRlZCBmaWVsZHMgZXZlbiBpZiBgZGVmYXVsdHM9ZmFsc2VgXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvYmplY3RzPWZhbHNlXSBTZXRzIGVtcHR5IG9iamVjdHMgZm9yIG1pc3NpbmcgbWFwIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29uZW9mcz1mYWxzZV0gSW5jbHVkZXMgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHNldCB0byB0aGUgcHJlc2VudCBmaWVsZCdzIG5hbWUsIGlmIGFueVxuICogQHByb3BlcnR5IHtib29sZWFufSBbanNvbj1mYWxzZV0gUGVyZm9ybXMgYWRkaXRpb25hbCBKU09OIGNvbXBhdGliaWxpdHkgY29udmVyc2lvbnMsIGkuZS4gTmFOIGFuZCBJbmZpbml0eSB0byBzdHJpbmdzXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9Pn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGZ1bmN0aW9uIGFzIHJldHVybmVkIGJ5IHtAbGluayBUeXBlLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIFR5cGVEZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IHRhcmdldCBUYXJnZXQgY29uc3RydWN0b3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqL1xuXG4vKipcbiAqIFR5cGUgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZU5hbWVdIFR5cGUgbmFtZSwgZGVmYXVsdHMgdG8gdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZVxuICogQHJldHVybnMge1R5cGVEZWNvcmF0b3I8VD59IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKi9cblR5cGUuZCA9IGZ1bmN0aW9uIGRlY29yYXRlVHlwZSh0eXBlTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiB0eXBlRGVjb3JhdG9yKHRhcmdldCkge1xuICAgICAgICB1dGlsLmRlY29yYXRlVHlwZSh0YXJnZXQsIHR5cGVOYW1lKTtcbiAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvbW1vbiB0eXBlIGNvbnN0YW50cy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHR5cGVzID0gZXhwb3J0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG52YXIgcyA9IFtcbiAgICBcImRvdWJsZVwiLCAgIC8vIDBcbiAgICBcImZsb2F0XCIsICAgIC8vIDFcbiAgICBcImludDMyXCIsICAgIC8vIDJcbiAgICBcInVpbnQzMlwiLCAgIC8vIDNcbiAgICBcInNpbnQzMlwiLCAgIC8vIDRcbiAgICBcImZpeGVkMzJcIiwgIC8vIDVcbiAgICBcInNmaXhlZDMyXCIsIC8vIDZcbiAgICBcImludDY0XCIsICAgIC8vIDdcbiAgICBcInVpbnQ2NFwiLCAgIC8vIDhcbiAgICBcInNpbnQ2NFwiLCAgIC8vIDlcbiAgICBcImZpeGVkNjRcIiwgIC8vIDEwXG4gICAgXCJzZml4ZWQ2NFwiLCAvLyAxMVxuICAgIFwiYm9vbFwiLCAgICAgLy8gMTJcbiAgICBcInN0cmluZ1wiLCAgIC8vIDEzXG4gICAgXCJieXRlc1wiICAgICAvLyAxNFxuXTtcblxuZnVuY3Rpb24gYmFrZSh2YWx1ZXMsIG9mZnNldCkge1xuICAgIHZhciBpID0gMCwgbyA9IHt9O1xuICAgIG9mZnNldCB8PSAwO1xuICAgIHdoaWxlIChpIDwgdmFsdWVzLmxlbmd0aCkgb1tzW2kgKyBvZmZzZXRdXSA9IHZhbHVlc1tpKytdO1xuICAgIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEJhc2ljIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdHJpbmc9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYnl0ZXM9MiBMZGVsaW0gd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmJhc2ljID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMSxcbiAgICAvKiBmbG9hdCAgICAqLyA1LFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMCxcbiAgICAvKiBzdHJpbmcgICAqLyAyLFxuICAgIC8qIGJ5dGVzICAgICovIDJcbl0pO1xuXG4vKipcbiAqIEJhc2ljIHR5cGUgZGVmYXVsdHMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MCBEb3VibGUgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTAgRmxvYXQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgSW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFVpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgU2ludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTAgRml4ZWQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9MCBTZml4ZWQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBJbnQ2NCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVWludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MCBGaXhlZDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0wIFNmaXhlZDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYm9vbD1mYWxzZSBCb29sIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHJpbmc9XCJcIiBTdHJpbmcgZGVmYXVsdFxuICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPn0gYnl0ZXM9QXJyYXkoMCkgQnl0ZXMgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudWxsfSBtZXNzYWdlPW51bGwgTWVzc2FnZSBkZWZhdWx0XG4gKi9cbnR5cGVzLmRlZmF1bHRzID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMCxcbiAgICAvKiBmbG9hdCAgICAqLyAwLFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDAsXG4gICAgLyogc2ZpeGVkMzIgKi8gMCxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAwLFxuICAgIC8qIHNmaXhlZDY0ICovIDAsXG4gICAgLyogYm9vbCAgICAgKi8gZmFsc2UsXG4gICAgLyogc3RyaW5nICAgKi8gXCJcIixcbiAgICAvKiBieXRlcyAgICAqLyB1dGlsLmVtcHR5QXJyYXksXG4gICAgLyogbWVzc2FnZSAgKi8gbnVsbFxuXSk7XG5cbi8qKlxuICogQmFzaWMgbG9uZyB0eXBlIHdpcmUgdHlwZXMuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICovXG50eXBlcy5sb25nID0gYmFrZShbXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxXG5dLCA3KTtcblxuLyoqXG4gKiBBbGxvd2VkIHR5cGVzIGZvciBtYXAga2V5cyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMubWFwS2V5ID0gYmFrZShbXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDJcbl0sIDIpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIHBhY2tlZCByZXBlYXRlZCBmaWVsZHMgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdpcmUgdHlwZS5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZG91YmxlPTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmbG9hdD01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gYm9vbD0wIFZhcmludCB3aXJlIHR5cGVcbiAqL1xudHlwZXMucGFja2VkID0gYmFrZShbXG4gICAgLyogZG91YmxlICAgKi8gMSxcbiAgICAvKiBmbG9hdCAgICAqLyA1LFxuICAgIC8qIGludDMyICAgICovIDAsXG4gICAgLyogdWludDMyICAgKi8gMCxcbiAgICAvKiBzaW50MzIgICAqLyAwLFxuICAgIC8qIGZpeGVkMzIgICovIDUsXG4gICAgLyogc2ZpeGVkMzIgKi8gNSxcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDEsXG4gICAgLyogYm9vbCAgICAgKi8gMFxuXSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBWYXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgcm9vdHMgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcblxudmFyIFR5cGUsIC8vIGN5Y2xpY1xuICAgIEVudW07XG5cbnV0aWwuY29kZWdlbiA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9jb2RlZ2VuXCIpO1xudXRpbC5mZXRjaCAgID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2ZldGNoXCIpO1xudXRpbC5wYXRoICAgID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3BhdGhcIik7XG5cbi8qKlxuICogTm9kZSdzIGZzIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XG4gKi9cbnV0aWwuZnMgPSB1dGlsLmlucXVpcmUoXCJmc1wiKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QncyB2YWx1ZXMgdG8gYW4gYXJyYXkuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgT2JqZWN0IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtBcnJheS48Kj59IENvbnZlcnRlZCBhcnJheVxuICovXG51dGlsLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgdmFyIGtleXMgID0gT2JqZWN0LmtleXMob2JqZWN0KSxcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwga2V5cy5sZW5ndGgpXG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSBvYmplY3Rba2V5c1tpbmRleCsrXV07XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBrZXlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZWlyIHJlc3BlY3RpdmUgdmFsdWUgdG8gYW4gb2JqZWN0LCBvbWl0dGluZyB1bmRlZmluZWQgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheS48Kj59IGFycmF5IEFycmF5IHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gQ29udmVydGVkIG9iamVjdFxuICovXG51dGlsLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QoYXJyYXkpIHtcbiAgICB2YXIgb2JqZWN0ID0ge30sXG4gICAgICAgIGluZGV4ICA9IDA7XG4gICAgd2hpbGUgKGluZGV4IDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBhcnJheVtpbmRleCsrXSxcbiAgICAgICAgICAgIHZhbCA9IGFycmF5W2luZGV4KytdO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBzYWZlUHJvcEJhY2tzbGFzaFJlID0gL1xcXFwvZyxcbiAgICBzYWZlUHJvcFF1b3RlUmUgICAgID0gL1wiL2c7XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgYSByZXNlcnZlZCB3b3JkIGluIEpTLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlc2VydmVkLCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzUmVzZXJ2ZWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkKG5hbWUpIHtcbiAgICByZXR1cm4gL14oPzpkb3xpZnxpbnxmb3J8bGV0fG5ld3x0cnl8dmFyfGNhc2V8ZWxzZXxlbnVtfGV2YWx8ZmFsc2V8bnVsbHx0aGlzfHRydWV8dm9pZHx3aXRofGJyZWFrfGNhdGNofGNsYXNzfGNvbnN0fHN1cGVyfHRocm93fHdoaWxlfHlpZWxkfGRlbGV0ZXxleHBvcnR8aW1wb3J0fHB1YmxpY3xyZXR1cm58c3RhdGljfHN3aXRjaHx0eXBlb2Z8ZGVmYXVsdHxleHRlbmRzfGZpbmFsbHl8cGFja2FnZXxwcml2YXRlfGNvbnRpbnVlfGRlYnVnZ2VyfGZ1bmN0aW9ufGFyZ3VtZW50c3xpbnRlcmZhY2V8cHJvdGVjdGVkfGltcGxlbWVudHN8aW5zdGFuY2VvZikkLy50ZXN0KG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2FmZSBwcm9wZXJ0eSBhY2Nlc3NvciBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gU2FmZSBhY2Nlc3NvclxuICovXG51dGlsLnNhZmVQcm9wID0gZnVuY3Rpb24gc2FmZVByb3AocHJvcCkge1xuICAgIGlmICghL15bJFxcd19dKyQvLnRlc3QocHJvcCkgfHwgdXRpbC5pc1Jlc2VydmVkKHByb3ApKVxuICAgICAgICByZXR1cm4gXCJbXFxcIlwiICsgcHJvcC5yZXBsYWNlKHNhZmVQcm9wQmFja3NsYXNoUmUsIFwiXFxcXFxcXFxcIikucmVwbGFjZShzYWZlUHJvcFF1b3RlUmUsIFwiXFxcXFxcXCJcIikgKyBcIlxcXCJdXCI7XG4gICAgcmV0dXJuIFwiLlwiICsgcHJvcDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byB1cHBlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLnVjRmlyc3QgPSBmdW5jdGlvbiB1Y0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxudmFyIGNhbWVsQ2FzZVJlID0gL18oW2Etel0pL2c7XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgdG8gY2FtZWwgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5jYW1lbENhc2UgPSBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgMSlcbiAgICAgICAgICsgc3RyLnN1YnN0cmluZygxKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoY2FtZWxDYXNlUmUsIGZ1bmN0aW9uKCQwLCAkMSkgeyByZXR1cm4gJDEudG9VcHBlckNhc2UoKTsgfSk7XG59O1xuXG4vKipcbiAqIENvbXBhcmVzIHJlZmxlY3RlZCBmaWVsZHMgYnkgaWQuXG4gKiBAcGFyYW0ge0ZpZWxkfSBhIEZpcnN0IGZpZWxkXG4gKiBAcGFyYW0ge0ZpZWxkfSBiIFNlY29uZCBmaWVsZFxuICogQHJldHVybnMge251bWJlcn0gQ29tcGFyaXNvbiB2YWx1ZVxuICovXG51dGlsLmNvbXBhcmVGaWVsZHNCeUlkID0gZnVuY3Rpb24gY29tcGFyZUZpZWxkc0J5SWQoYSwgYikge1xuICAgIHJldHVybiBhLmlkIC0gYi5pZDtcbn07XG5cbi8qKlxuICogRGVjb3JhdG9yIGhlbHBlciBmb3IgdHlwZXMgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXG4gKiBAcmV0dXJucyB7VHlwZX0gUmVmbGVjdGVkIHR5cGVcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHByb3BlcnR5IHtSb290fSByb290IERlY29yYXRvcnMgcm9vdFxuICovXG51dGlsLmRlY29yYXRlVHlwZSA9IGZ1bmN0aW9uIGRlY29yYXRlVHlwZShjdG9yLCB0eXBlTmFtZSkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGN0b3IuJHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVOYW1lICYmIGN0b3IuJHR5cGUubmFtZSAhPT0gdHlwZU5hbWUpIHtcbiAgICAgICAgICAgIHV0aWwuZGVjb3JhdGVSb290LnJlbW92ZShjdG9yLiR0eXBlKTtcbiAgICAgICAgICAgIGN0b3IuJHR5cGUubmFtZSA9IHR5cGVOYW1lO1xuICAgICAgICAgICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKGN0b3IuJHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdG9yLiR0eXBlO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKCFUeXBlKVxuICAgICAgICBUeXBlID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcblxuICAgIHZhciB0eXBlID0gbmV3IFR5cGUodHlwZU5hbWUgfHwgY3Rvci5uYW1lKTtcbiAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQodHlwZSk7XG4gICAgdHlwZS5jdG9yID0gY3RvcjsgLy8gc2V0cyB1cCAuZW5jb2RlLCAuZGVjb2RlIGV0Yy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3RvciwgXCIkdHlwZVwiLCB7IHZhbHVlOiB0eXBlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIFwiJHR5cGVcIiwgeyB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG52YXIgZGVjb3JhdGVFbnVtSW5kZXggPSAwO1xuXG4vKipcbiAqIERlY29yYXRvciBoZWxwZXIgZm9yIGVudW1zIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgRW51bSBvYmplY3RcbiAqIEByZXR1cm5zIHtFbnVtfSBSZWZsZWN0ZWQgZW51bVxuICovXG51dGlsLmRlY29yYXRlRW51bSA9IGZ1bmN0aW9uIGRlY29yYXRlRW51bShvYmplY3QpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChvYmplY3QuJHR5cGUpXG4gICAgICAgIHJldHVybiBvYmplY3QuJHR5cGU7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghRW51bSlcbiAgICAgICAgRW51bSA9IHJlcXVpcmUoXCIuL2VudW1cIik7XG5cbiAgICB2YXIgZW5tID0gbmV3IEVudW0oXCJFbnVtXCIgKyBkZWNvcmF0ZUVudW1JbmRleCsrLCBvYmplY3QpO1xuICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZChlbm0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIFwiJHR5cGVcIiwgeyB2YWx1ZTogZW5tLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gZW5tO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgYnkgcHJvcGVydHkgcGF0aC4gSWYgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0cywgaXQgaXMgdHVybmVkIHRvIGFuIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBkb3QgJy4nIGRlbGltaXRlZCBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG51dGlsLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoZHN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHNldFByb3AoZHN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZHN0W3BhcnRdID0gc2V0UHJvcChkc3RbcGFydF0gfHwge30sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBkc3RbcGFydF07XG4gICAgICAgICAgICBpZiAocHJldlZhbHVlKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KHByZXZWYWx1ZSkuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgIGRzdFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImRzdCBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgICBpZiAoIXBhdGgpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInBhdGggbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICBwYXRoID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgcmV0dXJuIHNldFByb3AoZHN0LCBwYXRoLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciByb290IChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIHV0aWwuZGVjb3JhdGVSb290XG4gKiBAdHlwZSB7Um9vdH1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkodXRpbCwgXCJkZWNvcmF0ZVJvb3RcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByb290c1tcImRlY29yYXRlZFwiXSB8fCAocm9vdHNbXCJkZWNvcmF0ZWRcIl0gPSBuZXcgKHJlcXVpcmUoXCIuL3Jvb3RcIikpKCkpO1xuICAgIH1cbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gdmVyaWZpZXI7XG5cbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIGludmFsaWQoZmllbGQsIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZpZWxkLm5hbWUgKyBcIjogXCIgKyBleHBlY3RlZCArIChmaWVsZC5yZXBlYXRlZCAmJiBleHBlY3RlZCAhPT0gXCJhcnJheVwiID8gXCJbXVwiIDogZmllbGQubWFwICYmIGV4cGVjdGVkICE9PSBcIm9iamVjdFwiID8gXCJ7azpcIitmaWVsZC5rZXlUeXBlK1wifVwiIDogXCJcIikgKyBcIiBleHBlY3RlZFwiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgdmVyaWZpZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIFZhcmlhYmxlIHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcmVmKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSB7IGdlblxuICAgICAgICAgICAgKFwic3dpdGNoKCVzKXtcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiZW51bSB2YWx1ZVwiKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlcyksIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikgZ2VuXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc1trZXlzW2pdXSk7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgIChcIntcIilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgZT10eXBlc1slaV0udmVyaWZ5KCVzKTtcIiwgZmllbGRJbmRleCwgcmVmKVxuICAgICAgICAgICAgICAgIChcImlmKGUpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqK2VcIiwgZmllbGQubmFtZSArIFwiLlwiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc0ludGVnZXIoJXMpJiYhKCVzJiZ1dGlsLmlzSW50ZWdlciglcy5sb3cpJiZ1dGlsLmlzSW50ZWdlciglcy5oaWdoKSkpXCIsIHJlZiwgcmVmLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmdcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJudW1iZXJcXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwibnVtYmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJib29sZWFuXFxcIilcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJvb2xlYW5cIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc1N0cmluZyglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJzdHJpbmdcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCEoJXMmJnR5cGVvZiAlcy5sZW5ndGg9PT1cXFwibnVtYmVyXFxcInx8dXRpbC5pc1N0cmluZyglcykpKVwiLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJ1ZmZlclwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBrZXkgdmVyaWZpZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlLZXkoZ2VuLCBmaWVsZCwgcmVmKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICBzd2l0Y2ggKGZpZWxkLmtleVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkzMlJlLnRlc3QoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXk2NFJlLnRlc3QoJXMpKVwiLCByZWYpIC8vIHNlZSBjb21tZW50IGFib3ZlOiB4IGlzIG9rLCBkIGlzIG5vdFxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlcnxMb25nIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJvb2xlYW4ga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB2ZXJpZmllciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiB2ZXJpZmllcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG5cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIl0sIG10eXBlLm5hbWUgKyBcIiR2ZXJpZnlcIilcbiAgICAoXCJpZih0eXBlb2YgbSE9PVxcXCJvYmplY3RcXFwifHxtPT09bnVsbClcIilcbiAgICAgICAgKFwicmV0dXJuJWpcIiwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgdmFyIG9uZW9mcyA9IG10eXBlLm9uZW9mc0FycmF5LFxuICAgICAgICBzZWVuRmlyc3RGaWVsZCA9IHt9O1xuICAgIGlmIChvbmVvZnMubGVuZ3RoKSBnZW5cbiAgICAoXCJ2YXIgcD17fVwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHJlZiAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgICAgIChcImlmKCVzIT1udWxsJiZtLmhhc093blByb3BlcnR5KCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAvLyBtYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5pc09iamVjdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcIm9iamVjdFwiKSlcbiAgICAgICAgICAgIChcInZhciBrPU9iamVjdC5rZXlzKCVzKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGsubGVuZ3RoOysraSl7XCIpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCBcImtbaV1cIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgaSwgcmVmICsgXCJba1tpXV1cIilcbiAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheSglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImFycmF5XCIpKVxuICAgICAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKXtcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltpXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXF1aXJlZCBvciBwcmVzZW50IGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnBhcnRPZikge1xuICAgICAgICAgICAgICAgIHZhciBvbmVvZlByb3AgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLnBhcnRPZi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbkZpcnN0RmllbGRbZmllbGQucGFydE9mLm5hbWVdID09PSAxKSBnZW5cbiAgICAgICAgICAgIChcImlmKHAlcz09PTEpXCIsIG9uZW9mUHJvcClcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBmaWVsZC5wYXJ0T2YubmFtZSArIFwiOiBtdWx0aXBsZSB2YWx1ZXNcIik7XG4gICAgICAgICAgICAgICAgc2VlbkZpcnN0RmllbGRbZmllbGQucGFydE9mLm5hbWVdID0gMTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgIChcInAlcz0xXCIsIG9uZW9mUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgICAgIChcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbnVsbFwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogV3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxJV3JhcHBlcj59XG4gKiBAY29uc3RcbiAqL1xudmFyIHdyYXBwZXJzID0gZXhwb3J0cztcblxudmFyIE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlXCIpO1xuXG4vKipcbiAqIEZyb20gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXG4gKiBAdHlwZWRlZiBXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGhpcyBUeXBlXG4gKi9cblxuLyoqXG4gKiBUbyBvYmplY3QgY29udmVydGVyIHBhcnQgb2YgYW4ge0BsaW5rIElXcmFwcGVyfS5cbiAqIEB0eXBlZGVmIFdyYXBwZXJUb09iamVjdENvbnZlcnRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXNzYWdlPHt9Pn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqIEB0aGlzIFR5cGVcbiAqL1xuXG4vKipcbiAqIENvbW1vbiB0eXBlIHdyYXBwZXIgcGFydCBvZiB7QGxpbmsgd3JhcHBlcnN9LlxuICogQGludGVyZmFjZSBJV3JhcHBlclxuICogQHByb3BlcnR5IHtXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlcn0gW2Zyb21PYmplY3RdIEZyb20gb2JqZWN0IGNvbnZlcnRlclxuICogQHByb3BlcnR5IHtXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJ9IFt0b09iamVjdF0gVG8gb2JqZWN0IGNvbnZlcnRlclxuICovXG5cbi8vIEN1c3RvbSB3cmFwcGVyIGZvciBBbnlcbndyYXBwZXJzW1wiLmdvb2dsZS5wcm90b2J1Zi5BbnlcIl0gPSB7XG5cbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgICAvLyB1bndyYXAgdmFsdWUgdHlwZSBpZiBtYXBwZWRcbiAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3RbXCJAdHlwZVwiXSkge1xuICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdFtcIkB0eXBlXCJdLnN1YnN0cmluZyhvYmplY3RbXCJAdHlwZVwiXS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBkb2VzIG5vdCBhY2NlcHQgbGVhZGluZyBcIi5cIlxuICAgICAgICAgICAgICAgIHZhciB0eXBlX3VybCA9IG9iamVjdFtcIkB0eXBlXCJdLmNoYXJBdCgwKSA9PT0gXCIuXCIgP1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbXCJAdHlwZVwiXS5zdWJzdHIoMSkgOiBvYmplY3RbXCJAdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBwcmVmaXggaXMgb3B0aW9uYWwsIGJ1dCBwYXRoIHNlcGVyYXRvciBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlX3VybC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmwgPSBcIi9cIiArIHR5cGVfdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybDogdHlwZV91cmwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlLmVuY29kZSh0eXBlLmZyb21PYmplY3Qob2JqZWN0KSkuZmluaXNoKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHByZWZpeFxuICAgICAgICB2YXIgZ29vZ2xlQXBpID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tL1wiO1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8vIGRlY29kZSB2YWx1ZSBpZiByZXF1ZXN0ZWQgYW5kIHVubWFwcGVkXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiBtZXNzYWdlLnR5cGVfdXJsICYmIG1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICBuYW1lID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcobWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIHRoZSBwcmVmaXggdXNlZFxuICAgICAgICAgICAgcHJlZml4ID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcoMCwgbWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHR5cGUuZGVjb2RlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JhcCB2YWx1ZSBpZiB1bm1hcHBlZFxuICAgICAgICBpZiAoIShtZXNzYWdlIGluc3RhbmNlb2YgdGhpcy5jdG9yKSAmJiBtZXNzYWdlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG1lc3NhZ2UuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lWzBdID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgbWVzc2FnZS4kdHlwZS5mdWxsTmFtZS5zdWJzdHIoMSkgOiBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0eXBlLmdvb2dsZWFwaXMuY29tIHByZWZpeCBpZiBubyBwcmVmaXggaXMgdXNlZFxuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IGdvb2dsZUFwaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyBtZXNzYWdlTmFtZTtcbiAgICAgICAgICAgIG9iamVjdFtcIkB0eXBlXCJdID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsImNvbnN0IHF1aWNrU2VsZWN0ID0gcmVxdWlyZSgnLi9zcmMvcXVpY2tTZWxlY3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1aWNrU2VsZWN0XG4iLCJjb25zdCByYW5kSW50QmV0d2VlbiA9IChtaW4sIG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KSArIG1pblxuXG5jb25zdCBkZWZhdWx0QWNjZXNzb3IgPSBlbGVtZW50ID0+IGVsZW1lbnRcblxuY29uc3QgY2hlY2tBcmd1bWVudHMgPSAoYXJyYXksIGssIGFjY2Vzc29yKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHRocm93IG5ldyBFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhIGphdmFzY3JpcHQgYXJyYXkhJylcbiAgaWYgKHR5cGVvZiBrICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2Vjb25kIGFyZ3VtZW50IHNob3VsZCBiZSBhIGphdmFzY3JpcHQgbnVtYmVyIScpXG4gIGlmICh0eXBlb2YgYWNjZXNzb3IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignVGhlIHRoaXJkIGFyZ3VtZW50IHNob3VsZCBiZSBhIGphdmFzY3JpcHQgZnVuY3Rpb24hJylcbiAgaWYgKGFycmF5Lmxlbmd0aCA8IGspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0sgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gYXJyYXkgbGVuZ3RoIScpXG4gIH1cbn1cblxuLyoqXG4gKiBRdWlja3NlbGVjdFxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVpY2tzZWxlY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gRGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IGsgLSBQb3NpdGlvbiBvZiBzbWFsbGVzdCBlbGVtZW50IChzdGFydHMgZnJvbSAwKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYWNjZXNzb3IgLSBGdW5jdGlvbiB3aGljaCByZXR1cm4gdmFsdWUgZm9yIHByb2Nlc3NpbmcgKG9wdGlvbmFsKVxuICovXG5jb25zdCBxdWlja1NlbGVjdCA9IChhcnJheSwgaywgYWNjZXNzb3IgPSBkZWZhdWx0QWNjZXNzb3IpID0+IHtcbiAgY2hlY2tBcmd1bWVudHMoYXJyYXksIGssIGFjY2Vzc29yKVxuICBpZiAoYXJyYXkubGVuZ3RoID09PSAxICYmIGsgPT09IDApIHJldHVybiBhcnJheVswXVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcGl2b3QgPSBhY2Nlc3NvcihhcnJheVtyYW5kSW50QmV0d2VlbigwLCBhcnJheS5sZW5ndGggLSAxKV0pXG4gICAgY29uc3QgbG93cyA9IFtdXG4gICAgY29uc3QgaGlnaHMgPSBbXVxuICAgIGNvbnN0IHBpdm90cyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGFjY2Vzc29yKGFycmF5W2ldKSA8IHBpdm90KSBsb3dzLnB1c2goYXJyYXlbaV0pXG4gICAgICBpZiAoYWNjZXNzb3IoYXJyYXlbaV0pID4gcGl2b3QpIGhpZ2hzLnB1c2goYXJyYXlbaV0pXG4gICAgICBpZiAoYWNjZXNzb3IoYXJyYXlbaV0pID09PSBwaXZvdCkgcGl2b3RzLnB1c2goYXJyYXlbaV0pXG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICBpZiAoayA8IGxvd3MubGVuZ3RoKSB7XG4gICAgICBhcnJheSA9IGxvd3NcbiAgICB9IGVsc2UgaWYgKGsgPCBsb3dzLmxlbmd0aCArIHBpdm90cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwaXZvdHNbMF1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkgPSBoaWdoc1xuICAgICAgayA9IGsgLSBsb3dzLmxlbmd0aCAtIHBpdm90cy5sZW5ndGhcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVpY2tTZWxlY3RcbiIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7QmFzZVdpZGdldH0gZnJvbSAnLi9Db21wb25lbnRzL0Jhc2VXaWRnZXQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuL0NvbXBvbmVudHMvQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQge1Rvb2xiYXJ9IGZyb20gJy4vQ29tcG9uZW50cy9Ub29sYmFyJztcbmltcG9ydCB7UGxvdDJkUGF0aHNXaWRnZXR9IGZyb20gJy4vQ29tcG9uZW50cy9QbG90MmRQYXRoc1dpZGdldCc7XG5pbXBvcnQge01ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldH0gZnJvbSAnLi9Db21wb25lbnRzL01ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldCc7XG5pbXBvcnQge0ltYWdlU2VsZWN0aW9uV2lkZ2V0fSBmcm9tICcuL0NvbXBvbmVudHMvSW1hZ2VTZWxlY3Rpb25XaWRnZXQnO1xuaW1wb3J0IHtMYXlvdXRGcmFtZXdvcmt9IGZyb20gJy4vTGF5b3V0RnJhbWV3b3JrJztcbmltcG9ydCB7RnJhbWUsIENvbXBvbmVudFR5cGUsIENvbXBvbmVudEluaXRJbmZvLCBBcmd1bWVudHMsIEFwcERhdGF9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtLZXllZFRyYWNrRGVyaXZhdGlvbkZ1bmN0aW9uLCBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9ufSBmcm9tICcuL2RldmxpYi9EZXZMaWJUeXBlcyc7XG5pbXBvcnQge0RhdGFFdmVudHN9IGZyb20gJy4vRGF0YU1vZGVsL0RhdGFFdmVudHMnO1xuaW1wb3J0IHsgRGV0YWlsZWREaXN0cmlidXRpb25XaWRnZXQgfSBmcm9tICcuL0NvbXBvbmVudHMvRGV0YWlsZWREaXN0cmlidXRpb25XaWRnZXQnO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSAnLi9kZXZsaWIvRGV2bGliVFNVdGlsJztcbmltcG9ydCB7IG9wZW5EQiwgZGVsZXRlREIsIHdyYXAsIHVud3JhcCwgSURCUERhdGFiYXNlIH0gZnJvbSAnaWRiJztcbmltcG9ydCB7IEN1cnZlTGlzdCB9IGZyb20gJy4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5cbmV4cG9ydCBjbGFzcyBBcHA8RGF0YVR5cGUgZXh0ZW5kcyBBcHBEYXRhPERhdGFTcGVjVHlwZT4sIERhdGFTcGVjVHlwZT4ge1xuXHRcblx0Y29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCxcblx0XHRcdFx0ZnJvbUNzdk9iamVjdDogKFxuXHRcdFx0XHRcdGRhdGE6IGQzLkRTVlJvd0FycmF5PHN0cmluZz4sXG5cdFx0XHRcdFx0ZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9uczogS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbltdLFxuXHRcdFx0XHRcdGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnM6IEtleWVkUG9pbnREZXJpdmF0aW9uRnVuY3Rpb25bXSxcblx0XHRcdFx0XHRkYXRhU3BlYzogRGF0YVNwZWNUeXBlXG5cdFx0XHRcdFx0KSA9PiBEYXRhVHlwZSxcblx0XHRcdFx0ZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9uczogS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbltdLFxuXHRcdFx0XHRkZXJpdmVkUG9pbnREYXRhRnVuY3Rpb25zOiBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uW10pIHtcblx0XHR0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cdFx0dGhpcy5fY29tcG9uZW50TGlzdCA9IFtdO1xuXHRcdHRoaXMuX2xheW91dEZyYW1ld29yayA9IG5ldyBMYXlvdXRGcmFtZXdvcmsoY29udGFpbmVyKTtcblx0XHR0aGlzLl9kYXRhRnJvbUNTVk9iamVjdCA9IGZyb21Dc3ZPYmplY3Q7XG5cblx0XHR0aGlzLl90cmFja0Rlcml2YXRpb25GdW5jdGlvbnMgPSBkZXJpdmVkVHJhY2tEYXRhRnVuY3Rpb25zO1xuXHRcdHRoaXMuX3BvaW50RGVyaXZhdGlvbkZ1bmN0aW9ucyA9IGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnM7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihEYXRhRXZlbnRzLmJydXNoQ2hhbmdlLCAoZTogRXZlbnQpID0+IHt0aGlzLm9uQnJ1c2hDaGFuZ2UoKX0pO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoRGF0YUV2ZW50cy5zZWxlY3Rpb25Ub0ZpbHRlciwgKGU6IEV2ZW50KSA9PiB7dGhpcy5vblNlbGVjdGlvblRvRmlsdGVyKCl9KTtcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKERhdGFFdmVudHMuYXBwbHlOZXdGaWx0ZXIsIChlOiBFdmVudCkgPT4ge3RoaXMub25BcHBseU5ld0ZpbHRlcigpfSk7XG5cdH1cblxuXHRcblx0cHJpdmF0ZSBfZGF0YSA6IERhdGFUeXBlO1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IERhdGFUeXBlIHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fVxuXG5cdHByaXZhdGUgX2ZpbHRlcmVkRGF0YSA6IERhdGFUeXBlO1xuXHRwdWJsaWMgZ2V0IGZpbHRlcmVkRGF0YSgpIDogRGF0YVR5cGUge1xuXHRcdHJldHVybiB0aGlzLl9maWx0ZXJlZERhdGE7XG5cdH1cblxuXHRwcml2YXRlIF9jb250YWluZXIgOiBIVE1MRWxlbWVudDtcblx0cHVibGljIGdldCBjb250YWluZXIoKSA6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29tcG9uZW50TGlzdCA6IEJhc2VDb21wb25lbnRbXTtcblx0cHVibGljIGdldCBjb21wb25lbnRMaXN0KCkgOiBCYXNlQ29tcG9uZW50W10ge1xuXHRcdHJldHVybiB0aGlzLl9jb21wb25lbnRMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbGF5b3V0RnJhbWV3b3JrIDogTGF5b3V0RnJhbWV3b3JrO1xuXHRwdWJsaWMgZ2V0IGxheW91dEZyYW1ld29yaygpIDogTGF5b3V0RnJhbWV3b3JrIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF5b3V0RnJhbWV3b3JrO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29tcG9uZW50Q29udGFpbmVycyA6IE1hcDxIVE1MRWxlbWVudCwgQ29tcG9uZW50SW5pdEluZm8gfCBDb21wb25lbnRUeXBlPjtcblx0cHVibGljIGdldCBjb21wb25lbnRDb250YWluZXJzKCkgOiBNYXA8SFRNTEVsZW1lbnQsIENvbXBvbmVudEluaXRJbmZvIHwgQ29tcG9uZW50VHlwZT4ge1xuXHRcdHJldHVybiB0aGlzLl9jb21wb25lbnRDb250YWluZXJzO1xuXHR9XG5cblx0cHJpdmF0ZSBfZGF0YUZyb21DU1ZPYmplY3QgOiAoZGF0YTogZDMuRFNWUm93QXJyYXk8c3RyaW5nPiwgZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9uczogS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbltdLCBkZXJpdmVkUG9pbnREYXRhRnVuY3Rpb25zOiBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uW10sIGRhdGFTcGVjOiBEYXRhU3BlY1R5cGUpID0+IERhdGFUeXBlO1xuXHRwdWJsaWMgZ2V0IGRhdGFGcm9tQ1NWT2JqZWN0KCkgOiAoZGF0YTogZDMuRFNWUm93QXJyYXk8c3RyaW5nPiwgZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9uczogS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbltdLCBkZXJpdmVkUG9pbnREYXRhRnVuY3Rpb25zOiBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uW10sIGRhdGFTcGVjOiBEYXRhU3BlY1R5cGUpID0+IERhdGFUeXBle1xuXHRcdHJldHVybiB0aGlzLl9kYXRhRnJvbUNTVk9iamVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3RyYWNrRGVyaXZhdGlvbkZ1bmN0aW9ucyA6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXTtcblx0cHVibGljIGdldCB0cmFja0Rlcml2YXRpb25GdW5jdGlvbnMoKSA6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX3RyYWNrRGVyaXZhdGlvbkZ1bmN0aW9ucztcblx0fVxuXG5cdHByaXZhdGUgX3BvaW50RGVyaXZhdGlvbkZ1bmN0aW9ucyA6IEtleWVkUG9pbnREZXJpdmF0aW9uRnVuY3Rpb25bXTtcblx0cHVibGljIGdldCBwb2ludERlcml2YXRpb25GdW5jdGlvbnMoKSA6IEtleWVkUG9pbnREZXJpdmF0aW9uRnVuY3Rpb25bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50RGVyaXZhdGlvbkZ1bmN0aW9ucztcblx0fVxuXG5cdHByaXZhdGUgX2RhdGFTdG9yZSA6IElEQlBEYXRhYmFzZTx1bmtub3duPjtcblx0cHVibGljIGdldCBkYXRhU3RvcmUoKSA6IElEQlBEYXRhYmFzZTx1bmtub3duPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGFTdG9yZTtcblx0fVxuXG5cdHB1YmxpYyBhc3luYyBJbml0RGF0YVN0b3JlKCk6IFByb21pc2U8dm9pZD5cblx0e1xuXHRcdGNvbnN0IGRhdGFTdG9yZSA9IGF3YWl0IG9wZW5EQignbG9vbi1kYicsIHVuZGVmaW5lZCwge1xuXHRcdFx0dXBncmFkZShkYiwgX29sZFZlcnNpb24sIF9uZXdWZXJzaW9uLCBfdHJhbnNhY3Rpb24pXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucygndHJhY2tzJykpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkYi5jcmVhdGVPYmplY3RTdG9yZSgndHJhY2tzJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKCdpbWFnZXMnKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdpbWFnZXMnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuX2RhdGFTdG9yZSA9IGRhdGFTdG9yZTtcblx0fVxuXG5cdHB1YmxpYyBJbml0aWFsaXplTGF5b3V0KGZyYW1lOiBGcmFtZTxDb21wb25lbnRJbml0SW5mbyB8IENvbXBvbmVudFR5cGU+KTogdm9pZFxuXHR7XG5cdFx0Ly8gY29uc29sZS5sb2coZnJhbWUpO1xuXHRcdHRoaXMuX2NvbXBvbmVudENvbnRhaW5lcnMgPSB0aGlzLmxheW91dEZyYW1ld29yay5Jbml0aWFsaXplTGF5b3V0KGZyYW1lKTtcblx0XHREZXZsaWJUU1V0aWwubGF1bmNoU3Bpbm5lcigpO1xuXHRcdGZvciAobGV0IFtjb250YWluZXIsIGNvbXBvbmVudEluZm9dIG9mIHRoaXMuY29tcG9uZW50Q29udGFpbmVycylcblx0XHR7XG5cdFx0XHR0aGlzLkluaXRpYWxpemVDb21wb25lbnQoY29tcG9uZW50SW5mbywgY29udGFpbmVyKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIEluaXRpYWxpemVDb21wb25lbnQoY29tcG9udGVudEluZm86IENvbXBvbmVudEluaXRJbmZvIHwgQ29tcG9uZW50VHlwZSwgY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IHZvaWRcblx0e1xuXHRcdGxldCBuZXdDb21wb25lbnQ6IEJhc2VDb21wb25lbnQ7XG5cdFx0bGV0IGNvbXBvbmVudFR5cGU6IENvbXBvbmVudFR5cGU7XG5cdFx0bGV0IGluaXRBcmdzOiBBcmd1bWVudHMgfCBudWxsID0gbnVsbDtcblx0XHRpZiAodHlwZW9mKGNvbXBvbnRlbnRJbmZvKSA9PT0gXCJzdHJpbmdcIilcblx0XHR7XG5cdFx0XHRjb21wb25lbnRUeXBlID0gY29tcG9udGVudEluZm87XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRjb21wb25lbnRUeXBlID0gY29tcG9udGVudEluZm8udHlwZTtcblx0XHRcdGluaXRBcmdzID0gY29tcG9udGVudEluZm8uaW5pdEFyZ3M7XG5cdFx0fVxuXHRcdHN3aXRjaCAoY29tcG9uZW50VHlwZSkge1xuXHRcdFx0Y2FzZSBDb21wb25lbnRUeXBlLlBsb3QyZFBhdGhzV2lkZ2V0OlxuXHRcdFx0XHRsZXQgc3F1YXJlQXNwZWN0UmF0aW8gPSB0cnVlO1xuXHRcdFx0XHRpZiAodHlwZW9mKGluaXRBcmdzLnNxdWFyZUFzcGVjdFJhdGlvKSAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzcXVhcmVBc3BlY3RSYXRpbyA9IGluaXRBcmdzLnNxdWFyZUFzcGVjdFJhdGlvO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGRlZmF1bHRPcHRpb24gPSAwO1xuXHRcdFx0XHRuZXdDb21wb25lbnQgPSBuZXcgUGxvdDJkUGF0aHNXaWRnZXQoY29udGFpbmVyLCBpbml0QXJncy5xdWlja1BpY2tPcHRpb25zLCBkZWZhdWx0T3B0aW9uLCBzcXVhcmVBc3BlY3RSYXRpbyk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBDb21wb25lbnRUeXBlLk1ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldDpcblx0XHRcdFx0bmV3Q29tcG9uZW50ID0gbmV3IE1ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldChjb250YWluZXIsIGluaXRBcmdzLm1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBDb21wb25lbnRUeXBlLkltYWdlU2VsZWN0aW9uV2lkZ2V0OlxuXHRcdFx0XHRuZXdDb21wb25lbnQgPSBuZXcgSW1hZ2VTZWxlY3Rpb25XaWRnZXQoY29udGFpbmVyLCBpbml0QXJncy5zYW1wbGluZ1N0cmF0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIENvbXBvbmVudFR5cGUuRGV0YWlsZWREaXN0cmlidXRpb246XG5cdFx0XHRcdG5ld0NvbXBvbmVudCA9IG5ldyBEZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldChjb250YWluZXIsIGluaXRBcmdzLm1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCwgaW5pdEFyZ3MuYXR0cmlidXRlS2V5KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIENvbXBvbmVudFR5cGUuVG9vbGJhcjpcblx0XHRcdFx0bmV3Q29tcG9uZW50ID0gbmV3IFRvb2xiYXIoY29udGFpbmVyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBDYW5ub3QgSW5pdGlhbGl6ZSBDb21wb25lbnQgb2YgdHlwZTogJHtjb21wb25lbnRUeXBlfWApO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dGhpcy5jb21wb25lbnRMaXN0LnB1c2gobmV3Q29tcG9uZW50KTtcblx0fVxuXG5cdHB1YmxpYyBMb2FkRGF0YXNldChkYXRhc2V0SWQ6IHN0cmluZyk6IHZvaWRcblx0e1xuXHRcdHRoaXMuZmV0Y2hKc29uKGAke2RhdGFzZXRJZH0uanNvbmApO1xuXHR9XG5cdFxuXHRwcml2YXRlIGFzeW5jIGZldGNoSnNvbihmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPlxuXHR7XG5cdFx0YXdhaXQgZDMuanNvbihcIi4uLy4uLy4uL2RhdGEvXCIgKyBmaWxlbmFtZSkudGhlbihhc3luYyAoZGF0YTogYW55KSA9PlxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmRhdGFTdG9yZSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IHN0b3JlID0gdGhpcy5kYXRhU3RvcmUudHJhbnNhY3Rpb24oJ3RyYWNrcycsICdyZWFkb25seScpLm9iamVjdFN0b3JlKCd0cmFja3MnKTtcblx0XHRcdFx0bGV0IHN0b3JlZEFsbERhdGEgPSBhd2FpdCBzdG9yZS5nZXQoZGF0YS5nb29nbGVEcml2ZUlkKTtcblx0XHRcdFx0aWYgKHN0b3JlZEFsbERhdGEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmluaXREYXRhKHN0b3JlZEFsbERhdGEsIGRhdGEpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5mZXRjaENzdihgJHtkYXRhLmdvb2dsZURyaXZlSWR9L21hc3NPdmVyVGltZS5jc3ZgLCBkYXRhLCBkYXRhLmdvb2dsZURyaXZlSWQpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBhc3luYyBmZXRjaENzdihmaWxlbmFtZTogc3RyaW5nLCBkYXRhU3BlYzogRGF0YVNwZWNUeXBlLCBrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cblx0e1xuXHRcdGF3YWl0IGQzLmNzdihcIi4uLy4uLy4uL2RhdGEvXCIgKyBmaWxlbmFtZSkudGhlbihhc3luYyBkYXRhID0+XG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuZGF0YVN0b3JlKVxuXHRcdFx0e1xuXHRcdFx0XHRhd2FpdCB0aGlzLmRhdGFTdG9yZS5wdXQ8YW55PigndHJhY2tzJywgZGF0YSwga2V5KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5pdERhdGEoZGF0YSwgZGF0YVNwZWMpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0RGF0YShkYXRhOiBkMy5EU1ZSb3dBcnJheTxzdHJpbmc+LCBkYXRhU3BlYzogRGF0YVNwZWNUeXBlKTogdm9pZFxuXHR7XHRcblx0XHRsZXQgYWxsRGF0YTogRGF0YVR5cGUgPSB0aGlzLmRhdGFGcm9tQ1NWT2JqZWN0KGRhdGEsIHRoaXMudHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25zLCB0aGlzLnBvaW50RGVyaXZhdGlvbkZ1bmN0aW9ucywgZGF0YVNwZWMpO1xuXHRcdGFsbERhdGEuQXBwbHlEZWZhdWx0RmlsdGVycygpO1xuXHRcdGFsbERhdGEuQXBwbHlOZXdGaWx0ZXIoKTtcblx0XHRsZXQgZmlsdGVyZWREYXRhID0gYWxsRGF0YS5DcmVhdGVGaWx0ZXJlZEN1cnZlTGlzdCgpIGFzIERhdGFUeXBlO1xuXG5cdFx0Ly8gcmVtb3ZlIGluQnJ1c2ggYXR0cmlidXRlcyBzZXQgb24gdHJhY2tzIGJhc2VkIG9uIGNvbmRpdGlvbnMgZmlsdGVyc1xuXHRcdC8vIHRoaXMgaXMgbmVlZGVkIHRvIGdldCB0aGUgYXBwcm9wcmlhdGUgZmlsdGVyZWQgZGF0YSBpbiB0aGUgY29uZGl0aW9uXG5cdFx0Ly8gY3VydmUgbWF0cml4IHdpZGdldC5cblx0XHRhbGxEYXRhLk9uQnJ1c2hDaGFuZ2UoKTtcblx0XHR0aGlzLlNldERhdGEoZmlsdGVyZWREYXRhLCBhbGxEYXRhKTtcblx0fVxuXG5cdHB1YmxpYyBTZXREYXRhKGZpbHRlcmVkRGF0YTogRGF0YVR5cGUsIGFsbERhdGE6IERhdGFUeXBlKTogdm9pZFxuXHR7XG5cdFx0Y29uc29sZS5sb2coXCJBcHAuU2V0RGF0YTogXCIpO1xuXHRcdGNvbnNvbGUubG9nKGFsbERhdGEpO1xuXHRcdHRoaXMuX2ZpbHRlcmVkRGF0YSA9IGZpbHRlcmVkRGF0YTtcblx0XHR0aGlzLl9kYXRhID0gYWxsRGF0YTtcblx0XHRmb3IgKGxldCBjb21wb25lbnQgb2YgdGhpcy5jb21wb25lbnRMaXN0KVxuXHRcdHtcblx0XHRcdGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBCYXNlV2lkZ2V0KVxuXHRcdFx0e1xuXHRcdFx0XHRcdGNvbXBvbmVudC5TZXREYXRhKGZpbHRlcmVkRGF0YSwgYWxsRGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIE9uV2luZG93UmVzaXplKCk6IHZvaWRcblx0e1xuXHRcdGZvciAobGV0IGNvbXBvbmVudCBvZiB0aGlzLmNvbXBvbmVudExpc3QpXG5cdFx0e1xuXHRcdFx0Y29tcG9uZW50LlJlc2l6ZSgpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgb25CcnVzaENoYW5nZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmZpbHRlcmVkRGF0YS5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0Zm9yIChsZXQgY29tcG9uZW50IG9mIHRoaXMuY29tcG9uZW50TGlzdClcblx0XHR7XG5cdFx0XHRpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgQmFzZVdpZGdldClcblx0XHRcdHtcblx0XHRcdFx0Y29tcG9uZW50Lk9uQnJ1c2hDaGFuZ2UoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG9uU2VsZWN0aW9uVG9GaWx0ZXIoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5kYXRhLkNvbnN1bWVGaWx0ZXJzKHRoaXMuZmlsdGVyZWREYXRhKTtcblx0XHRsZXQgZmlsdGVyZWREYXRhID0gdGhpcy5maWx0ZXJlZERhdGEuQ3JlYXRlRmlsdGVyZWRDdXJ2ZUxpc3QoKSBhcyBEYXRhVHlwZTtcblx0XHR0aGlzLlNldERhdGEoZmlsdGVyZWREYXRhLCB0aGlzLmRhdGEpO1xuXHR9XG5cblx0cHJpdmF0ZSBvbkFwcGx5TmV3RmlsdGVyKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuZGF0YS5BcHBseU5ld0ZpbHRlcigpO1xuXHRcdGxldCBmaWx0ZXJlZERhdGEgPSB0aGlzLmRhdGEuQ3JlYXRlRmlsdGVyZWRDdXJ2ZUxpc3QoKSBhcyBEYXRhVHlwZTtcblx0XHRcblx0XHQvLyByZW1vdmUgaW5CcnVzaCBhdHRyaWJ1dGVzIHNldCBvbiB0cmFja3MgYmFzZWQgb24gY29uZGl0aW9ucyBmaWx0ZXJzXG5cdFx0Ly8gdGhpcyBpcyBuZWVkZWQgdG8gZ2V0IHRoZSBhcHByb3ByaWF0ZSBmaWx0ZXJlZCBkYXRhIGluIHRoZSBjb25kaXRpb25cblx0XHQvLyBjdXJ2ZSBtYXRyaXggd2lkZ2V0LlxuXHRcdHRoaXMuZGF0YS5PbkJydXNoQ2hhbmdlKCk7XG5cblx0XHR0aGlzLlNldERhdGEoZmlsdGVyZWREYXRhLCB0aGlzLmRhdGEpO1xuXHR9XG5cbn0iLCJleHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvbXBvbmVudCB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEVsZW1lbnQsIC4uLnByb3BzOiBhbnlbXSlcblx0e1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHR0aGlzLl9jb21wb25lbnRJbmRleCA9IEJhc2VDb21wb25lbnQuX2NvbXBvbmVudENvdW50O1xuXHRcdEJhc2VDb21wb25lbnQuX2NvbXBvbmVudENvdW50Kys7XG5cdFx0dGhpcy5pbml0UHJvcHMocHJvcHMpO1xuXHRcdHRoaXMuc2V0V2lkdGhIZWlnaHQoKTtcblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXG5cdHByaXZhdGUgX2NvbnRhaW5lciA6IEVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY29udGFpbmVyKCkgOiBFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfd2lkdGggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgd2lkdGgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9XG5cblx0cHJpdmF0ZSBfaGVpZ2h0IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGhlaWdodCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faGVpZ2h0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY29tcG9uZW50SW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgQ29tcG9uZW50SWQoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArIFwiX1wiICsgdGhpcy5fY29tcG9uZW50SW5kZXg7XG5cdH1cdFxuXG5cdHByaXZhdGUgc3RhdGljIF9jb21wb25lbnRDb3VudDogbnVtYmVyID0gMDtcblxuXHRwcm90ZWN0ZWQgaW5pdFByb3BzKHByb3BzPzogYW55W10pOiB2b2lkXG5cdHtcblx0XHRcblx0fVxuXG5cdHByb3RlY3RlZCBpbml0KCk6IHZvaWRcblx0e1xuXHRcdGxldCBub3RJbXBsZW1lbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdG5vdEltcGxlbWVudERpdi50ZXh0Q29udGVudCA9IGBDbGFzcyAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gaGFzIG5vdCBpbXBsZW1lbnQgJ2luaXQnIGZ1bmN0aW9uYDtcblx0XHRub3RJbXBsZW1lbnREaXYuY2xhc3NMaXN0LmFkZChcIm5vdEltcGxlbWVudGVkV2FybmluZ1wiKTtcblx0XHR0aGlzLmNvbnRhaW5lci5pbm5lckhUTUwgPSBudWxsO1xuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKG5vdEltcGxlbWVudERpdik7XG5cdH1cblxuXHRwdWJsaWMgUmVzaXplKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuc2V0V2lkdGhIZWlnaHQoKTtcblx0XHR0aGlzLk9uUmVzaXplKCk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0V2lkdGhIZWlnaHQoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fd2lkdGggPSB0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gbnVsbDtcblx0XHRsZXQgbm90SW1wbGVtZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRub3RJbXBsZW1lbnREaXYudGV4dENvbnRlbnQgPSBgUmVzaXplZCB0bzogKCR7dGhpcy53aWR0aH0sICR7dGhpcy5oZWlnaHR9KVxub3ZlcnJpZGUgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9Lk9uUmVzaXplRHJhdygpIHRvIGVuc3VyZSBjb250ZW50IGlzIHJlc2l6ZWQgY29ycmVjdGx5YDtcblx0XHRub3RJbXBsZW1lbnREaXYuY2xhc3NMaXN0LmFkZChcIm5vdEltcGxlbWVudGVkV2FybmluZ1wiKTtcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChub3RJbXBsZW1lbnREaXYpO1xuXHR9XG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4vQmFzZUNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJnaW4gfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0ICB7IERldmxpYlRTVXRpbCB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUU1V0aWwnO1xuaW1wb3J0IHsgQXBwRGF0YSwgRmFjZXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHcm91cEJ5V2lkZ2V0IH0gZnJvbSAnLi9Hcm91cEJ5V2lkZ2V0JztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VXaWRnZXQ8RGF0YVR5cGUgZXh0ZW5kcyBBcHBEYXRhPERhdGFTcGVjVHlwZT4sIERhdGFTcGVjVHlwZT4gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcblx0XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogRWxlbWVudCwgY2FuRmFjZXQ6IGJvb2xlYW4gPSBmYWxzZSwgLi4ucHJvcHM6IGFueVtdKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCAuLi5wcm9wcyk7XG5cdFx0dGhpcy5fY2FuRmFjZXQgPSBjYW5GYWNldDtcblx0XHRpZiAoY2FuRmFjZXQpXG5cdFx0e1xuXHRcdFx0dGhpcy5hZGRGYWNldEJ1dHRvbigpO1xuXHRcdH1cblx0XHR0aGlzLmluaXRCdXR0b25MaXN0Q29udGFpbmVyKCk7XHRcdFxuXHRcdHRoaXMuX2RhdGFTdXBlcnNldCA9IG51bGw7XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdncm91cEJ5Q2hhbmdlZCcsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuc2hvd2luZ0ZhY2V0UG9wdXApXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZHJhd0ZhY2V0ZWREYXRhKGUuZGV0YWlsLmZsYXRGYWNldExpc3QpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuX3Nob3dpbmdGYWNldFBvcHVwID0gZmFsc2U7XG5cdH1cblxuXHRwcml2YXRlIF9kYXRhIDogRGF0YVR5cGUgfCBudWxsO1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IERhdGFUeXBlIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH1cblxuXHRwcml2YXRlIF9kYXRhU3VwZXJzZXQgOiBEYXRhVHlwZSB8IG51bGw7XG5cdHB1YmxpYyBnZXQgZGF0YVN1cGVyc2V0KCkgOiBEYXRhVHlwZSB8IG51bGwge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhU3VwZXJzZXQ7XG5cdH1cblxuXHRwdWJsaWMgZ2V0IGZ1bGxEYXRhKCkgOiBEYXRhVHlwZSB8IG51bGwge1xuXHRcdGlmICh0aGlzLl9kYXRhU3VwZXJzZXQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YVN1cGVyc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kYXRhO1xuXHR9XG5cblx0cHJvdGVjdGVkIF9tYXJnaW4gOiBNYXJnaW47XG5cdHB1YmxpYyBnZXQgbWFyZ2luKCkgOiBNYXJnaW4ge1xuXHRcdHJldHVybiB0aGlzLl9tYXJnaW47XG5cdH1cblxuXHRwcml2YXRlIF92aXpXaWR0aCA6IG51bWJlcjtcblx0cHVibGljIGdldCB2aXpXaWR0aCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fdml6V2lkdGg7XG5cdH1cblxuXHRwcml2YXRlIF92aXpIZWlnaHQgOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgdml6SGVpZ2h0KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl92aXpIZWlnaHQ7XG5cdH1cblxuXHRwcml2YXRlIF9jYW5GYWNldCA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgY2FuRmFjZXQoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9jYW5GYWNldDtcblx0fVxuXG5cdHB1YmxpYyBzZXQgY2FuRmFjZXQodjogYm9vbGVhbikge1xuXHRcdGlmICghdilcblx0XHR7XG5cdFx0XHR0aGlzLnJlbW92ZUZhY2V0QnV0dG9uKCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NhbkZhY2V0ID0gdjtcblx0fVxuXG5cdHByaXZhdGUgX3Nob3dpbmdGYWNldFBvcHVwIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBzaG93aW5nRmFjZXRQb3B1cCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3Nob3dpbmdGYWNldFBvcHVwO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnV0dG9uTGlzdCA6IEhUTUxCdXR0b25FbGVtZW50W107XG5cdHB1YmxpYyBnZXQgYnV0dG9uTGlzdCgpIDogSFRNTEJ1dHRvbkVsZW1lbnRbXSB7XG5cdFx0aWYgKCF0aGlzLl9idXR0b25MaXN0KVxuXHRcdHtcblx0XHRcdHRoaXMuX2J1dHRvbkxpc3QgPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2J1dHRvbkxpc3Q7XG5cdH1cblx0XG5cdHByaXZhdGUgX2J1dHRvbkxpc3RDb250YWluZXIgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBidXR0b25MaXN0Q29udGFpbmVyKCkgOiBIVE1MRGl2RWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2J1dHRvbkxpc3RDb250YWluZXI7XG5cdH1cblxuXHRwcml2YXRlIF9mYWNldEJ1dHRvbiA6IEhUTUxCdXR0b25FbGVtZW50O1xuXHRwdWJsaWMgZ2V0IGZhY2V0QnV0dG9uKCkgOiBIVE1MQnV0dG9uRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZhY2V0QnV0dG9uO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9sYXJnZVBvcHVwT3V0ZXIgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBsYXJnZVBvcHVwT3V0ZXIoKSA6IEhUTUxEaXZFbGVtZW50IHtcblx0XHRpZiAodGhpcy5fbGFyZ2VQb3B1cE91dGVyKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9sYXJnZVBvcHVwT3V0ZXI7XG5cdFx0fVxuXHRcdGxldCBsYXJnZVBvcHVwT3V0ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFyZ2VQb3B1cENvbnRhaW5lck91dGVyJyk7XG5cdFx0aWYgKGxhcmdlUG9wdXBPdXRlcilcblx0XHR7XG5cdFx0XHR0aGlzLl9sYXJnZVBvcHVwT3V0ZXIgPSBsYXJnZVBvcHVwT3V0ZXIgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdFx0XHRyZXR1cm4gdGhpcy5fbGFyZ2VQb3B1cE91dGVyO1xuXHRcdH1cblx0XHR0aGlzLmluaXRMYXJnZVBvcHVwKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2xhcmdlUG9wdXBPdXRlcjtcblx0fVxuXG5cdHByaXZhdGUgX2xhcmdlUG9wdXAgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBsYXJnZVBvcHVwKCkgOiBIVE1MRGl2RWxlbWVudCB7XG5cdFx0aWYgKHRoaXMuX2xhcmdlUG9wdXApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMuX2xhcmdlUG9wdXA7XG5cdFx0fVxuXHRcdGxldCBsYXJnZVBvcHVwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhcmdlUG9wdXBDb250YWluZXInKTtcblx0XHRpZiAobGFyZ2VQb3B1cClcblx0XHR7XG5cdFx0XHR0aGlzLl9sYXJnZVBvcHVwID0gbGFyZ2VQb3B1cCBhcyBIVE1MRGl2RWxlbWVudDtcblx0XHRcdHJldHVybiB0aGlzLl9sYXJnZVBvcHVwO1xuXHRcdH1cblx0XHR0aGlzLmluaXRMYXJnZVBvcHVwKCk7XG5cdFx0cmV0dXJuIHRoaXMuX2xhcmdlUG9wdXA7XG5cdH1cblx0XG5cdHByaXZhdGUgX2xhcmdlUG9wdXBDb250ZW50IDogSFRNTERpdkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgbGFyZ2VQb3B1cENvbnRlbnQoKSA6IEhUTUxEaXZFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fbGFyZ2VQb3B1cENvbnRlbnQ7XG5cdH1cblxuXHRwcm90ZWN0ZWQgaW5pdFByb3BzKHByb3BzPzogYW55W10pOiB2b2lkXG5cdHtcblx0XHR0aGlzLnNldE1hcmdpbigpO1xuXHR9XG5cblx0cHJvdGVjdGVkIHNldE1hcmdpbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tYXJnaW4gPSB7XG5cdFx0XHR0b3A6IDIwLFxuXHRcdFx0cmlnaHQ6IDIwLFxuXHRcdFx0Ym90dG9tOiAyMCxcblx0XHRcdGxlZnQ6IDIwXG5cdFx0fVxuXHR9XG5cblx0cHVibGljIFNldERhdGEoZGF0YTogRGF0YVR5cGUsIGRhdGFTdXBlcnNldD86IERhdGFUeXBlKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0aWYgKGRhdGFTdXBlcnNldClcblx0XHR7XG5cdFx0XHR0aGlzLl9kYXRhU3VwZXJzZXQgPSBkYXRhU3VwZXJzZXQ7XG5cdFx0fVxuXHRcdGxldCBmYWNldE9wdGlvbnMgPSBkYXRhLkdldEZhY2V0T3B0aW9ucygpO1xuXHRcdGlmIChmYWNldE9wdGlvbnMubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHRoaXMuY2FuRmFjZXQgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5PbkRhdGFDaGFuZ2UoKTtcblx0fVxuXG5cdHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdGNvbnNvbGUubG9nKCdiYXNlOiBPbkJydXNoQ2hhbmdlJyk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgc2V0V2lkdGhIZWlnaHQoKTogdm9pZFxuXHR7XG5cdFx0c3VwZXIuc2V0V2lkdGhIZWlnaHQoKTtcblx0XHR0aGlzLl92aXpXaWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLm1hcmdpbi5sZWZ0IC0gdGhpcy5tYXJnaW4ucmlnaHQ7XG5cdFx0dGhpcy5fdml6SGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSB0aGlzLm1hcmdpbi50b3AgLSB0aGlzLm1hcmdpbi5ib3R0b207XG5cdH1cblxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgT25EYXRhQ2hhbmdlKCk6IHZvaWRcblxuXHRwcm90ZWN0ZWQgYWJzdHJhY3QgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8RGF0YVR5cGUsIERhdGFTcGVjVHlwZT5cblxuXHRwcml2YXRlIGluaXRCdXR0b25MaXN0Q29udGFpbmVyKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX2J1dHRvbkxpc3RDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0aGlzLmJ1dHRvbkxpc3RDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbm9EaXNwJyk7XG5cdFx0bGV0IHN0eWxlID0gdGhpcy5idXR0b25MaXN0Q29udGFpbmVyLnN0eWxlO1xuXG5cdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdHN0eWxlLnJpZ2h0ID0gJzBweCc7XG5cdFx0c3R5bGUudG9wID0gJzBweCc7XHRcdFxuXHRcdHN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cdFx0c3R5bGUuZGlzcGxheSA9ICdmbGV4Jztcblx0XHRzdHlsZS5mbGV4RGlyZWN0aW9uID0gJ3Jvdy1yZXZlcnNlJztcblxuXHRcdHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLm9uTW91c2VFbnRlcigpKTtcblxuXHRcdHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLm9uTW91c2VMZWF2ZSgpKTtcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmJ1dHRvbkxpc3RDb250YWluZXIpO1xuXHRcdFxuXHRcdGZvciAobGV0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbkxpc3QpXG5cdFx0e1xuXHRcdFx0dGhpcy5idXR0b25MaXN0Q29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBhZGRGYWNldEJ1dHRvbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9mYWNldEJ1dHRvbiA9IHRoaXMuQWRkQnV0dG9uKCdsYXllci1ncm91cCcsICdGYWNldCBjaGFydCBieSBjb25kaXRpb25zJywgKCkgPT5cblx0XHR7XG5cdFx0XHR0aGlzLmRyYXdGYWNldENvbnRlbnQoKTtcblx0XHR9KTtcblx0fVxuXG5cdHB1YmxpYyBBZGRCdXR0b24oaWNvbktleTogc3RyaW5nLCB0b29sdGlwOiBzdHJpbmcsIGNhbGxiYWNrOiAoZXY6IE1vdXNlRXZlbnQpID0+IHZvaWQsIHRpdGxlPzogc3RyaW5nKTogSFRNTEJ1dHRvbkVsZW1lbnRcblx0e1xuXHRcdGxldCBidXR0b24gPSBEZXZsaWJUU1V0aWwuZ2V0SWNvbkJ1dHRvbihpY29uS2V5LCBjYWxsYmFjaywgdGl0bGUpO1xuXHRcdGJ1dHRvbi50aXRsZSA9IHRvb2x0aXA7XG5cdFx0YnV0dG9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcblx0XHR0aGlzLmJ1dHRvbkxpc3QudW5zaGlmdChidXR0b24pO1xuXHRcdHJldHVybiBidXR0b247XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUZhY2V0QnV0dG9uKCk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmZhY2V0QnV0dG9uKVxuXHRcdHtcdFxuXHRcdFx0dGhpcy5idXR0b25MaXN0Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuZmFjZXRCdXR0b24pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgb25Nb3VzZUVudGVyKCk6ICgpID0+IHZvaWRcblx0e1xuXHRcdHJldHVybiAoKSA9PiBEZXZsaWJUU1V0aWwuc2hvdyh0aGlzLmJ1dHRvbkxpc3RDb250YWluZXIpO1xuXHR9XG5cblx0cHJpdmF0ZSBvbk1vdXNlTGVhdmUoKTogKCkgPT4gdm9pZFxuXHR7XG5cdFx0cmV0dXJuICgpID0+IERldmxpYlRTVXRpbC5oaWRlKHRoaXMuYnV0dG9uTGlzdENvbnRhaW5lcik7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZHJhd0ZhY2V0Q29udGVudCgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmxhcmdlUG9wdXAuaW5uZXJIVE1MID0gbnVsbDtcblxuXHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMubGFyZ2VQb3B1cE91dGVyKTtcblx0XHR0aGlzLl9zaG93aW5nRmFjZXRQb3B1cCA9IHRydWU7XG5cdFx0Y29uc3QgZ3JvdXBCeVdpZGdldCA9IG5ldyBHcm91cEJ5V2lkZ2V0KGQzLnNlbGVjdCh0aGlzLmxhcmdlUG9wdXApKTtcblx0XHRncm91cEJ5V2lkZ2V0LnVwZGF0ZUdyb3VwQnlPcHRpb25zKHRoaXMuZGF0YSwgdHJ1ZSk7XG5cblx0XHRsZXQgY29udGVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGNvbnRlbnRDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbGFyZ2VQb3B1cENvbnRlbnQnKTtcblx0XHR0aGlzLmxhcmdlUG9wdXAuYXBwZW5kQ2hpbGQoY29udGVudENvbnRhaW5lcik7XG5cdFx0dGhpcy5fbGFyZ2VQb3B1cENvbnRlbnQgPSBjb250ZW50Q29udGFpbmVyO1xuXHRcdHRoaXMuZHJhd0ZhY2V0ZWREYXRhKGdyb3VwQnlXaWRnZXQuZ2V0RmxhdEZhY2V0TGlzdCgpKTtcblx0fVxuXG5cdHByb3RlY3RlZCBkcmF3RmFjZXRlZERhdGEoZmFjZXRMaXN0OiBGYWNldFtdKTogdm9pZFxuXHR7XG5cdFx0Y29uc3Qgd2lkdGg6IHN0cmluZyA9ICc1MDBweCc7XG5cdFx0Y29uc3QgaGVpZ2h0OiBzdHJpbmcgPSAnMjUwcHgnO1xuXHRcdHRoaXMuZHJhd0ZhY2V0ZWREYXRhRGVmYXVsdChmYWNldExpc3QsIHdpZHRoLCBoZWlnaHQpO1xuXHR9XG5cblx0cHJvdGVjdGVkIGRyYXdGYWNldGVkRGF0YURlZmF1bHQoZmFjZXRMaXN0OiBGYWNldFtdLCB3aWR0aDogc3RyaW5nLCBoZWlnaHQ6IHN0cmluZyk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmxhcmdlUG9wdXBDb250ZW50KVxuXHRcdHtcblx0XHRcdHRoaXMubGFyZ2VQb3B1cENvbnRlbnQuaW5uZXJIVE1MID0gbnVsbDtcblx0XHR9XG5cdFx0Zm9yIChsZXQgZmFjZXQgb2YgZmFjZXRMaXN0KVxuXHRcdHtcblx0XHRcdHRoaXMuZHJhd1NpbmdsZUZhY2V0ZWREYXRhKGZhY2V0Lm5hbWUuam9pbignICcpLCBmYWNldC5kYXRhLCB3aWR0aCwgaGVpZ2h0KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGRyYXdTaW5nbGVGYWNldGVkRGF0YSh0aXRsZTogc3RyaW5nLCBkYXRhOiBEYXRhVHlwZSwgd2lkdGg6IHN0cmluZywgaGVpZ2h0OiBzdHJpbmcpOiB2b2lkXG5cdHtcblx0XHRsZXQgb3V0ZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRvdXRlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdvdXRlckZhY2V0Q29udGFpbmVyJyk7XG5cdFx0b3V0ZXJDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRvdXRlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG5cblx0XHQvLyB0aGlzLmxhcmdlUG9wdXBDb250ZW50LmFwcGVuZENoaWxkKG91dGVyQ29udGFpbmVyKTtcblx0XHRcblx0XHRsZXQgdGl0bGVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0aXRsZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmYWNldFRpdGxlJylcblx0XHR0aXRsZUNvbnRhaW5lci5pbm5lclRleHQgPSB0aXRsZTtcblxuXHRcdG91dGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcblxuXHRcdGxldCBuZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRuZXdDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZmFjZXRDb250YWluZXInKTtcblx0XG5cdFx0b3V0ZXJDb250YWluZXIuYXBwZW5kQ2hpbGQobmV3Q29udGFpbmVyKTtcblxuXHRcdHRoaXMubGFyZ2VQb3B1cENvbnRlbnQuYXBwZW5kQ2hpbGQob3V0ZXJDb250YWluZXIpO1xuXHRcdHRoaXMuaW5pdFN1YldpZGdldChuZXdDb250YWluZXIsIHRpdGxlLCBkYXRhKTtcblx0fVxuXG5cdHByaXZhdGUgaW5pdFN1YldpZGdldChuZXdDb250YWluZXI6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIGRhdGE6IERhdGFUeXBlKTogdm9pZFxuXHR7XG5cdFx0bGV0IHN1YldpZGdldCA9IHRoaXMuQ2xvbmUobmV3Q29udGFpbmVyKTtcblx0XHRzdWJXaWRnZXQuY2FuRmFjZXQgPSBmYWxzZTtcblx0XHRzdWJXaWRnZXQuU2V0RGF0YShkYXRhLCB0aGlzLmRhdGEpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0TGFyZ2VQb3B1cCgpOiB2b2lkXG5cdHtcblx0XHRsZXQgbGFyZ2VQb3B1cE91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0bGFyZ2VQb3B1cE91dGVyLmlkID0gXCJsYXJnZVBvcHVwQ29udGFpbmVyT3V0ZXJcIjtcblx0XHRsYXJnZVBvcHVwT3V0ZXIuY2xhc3NMaXN0LmFkZCgnbGFyZ2VQb3B1cENvbnRhaW5lck91dGVyJyk7XG5cdFx0bGFyZ2VQb3B1cE91dGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT5cblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLmxhcmdlUG9wdXBPdXRlcik7XG5cdFx0XHR0aGlzLl9zaG93aW5nRmFjZXRQb3B1cCA9IGZhbHNlO1xuXHRcdH0pO1xuXG5cdFx0bGV0IGxhcmdlUG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRsYXJnZVBvcHVwLmlkID0gJ2xhcmdlUG9wdXBDb250YWluZXInO1xuXHRcdGxhcmdlUG9wdXAuY2xhc3NMaXN0LmFkZCgnbGFyZ2VQb3B1cENvbnRhaW5lcicpO1xuXHRcdGxhcmdlUG9wdXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXY6IEV2ZW50KSA9PiBcblx0XHR7XG5cdFx0XHRldi5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9KTtcblx0XHR0aGlzLl9sYXJnZVBvcHVwID0gbGFyZ2VQb3B1cDtcblx0XHRsYXJnZVBvcHVwT3V0ZXIuYXBwZW5kQ2hpbGQobGFyZ2VQb3B1cCk7XG5cblx0XHREZXZsaWJUU1V0aWwuaGlkZShsYXJnZVBvcHVwT3V0ZXIpO1xuXHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGFyZ2VQb3B1cE91dGVyKTtcblx0XHR0aGlzLl9sYXJnZVBvcHVwT3V0ZXIgPSBsYXJnZVBvcHVwT3V0ZXIgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBQb2ludENvbGxlY3Rpb24gfSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IEJhc2VXaWRnZXQgfSBmcm9tICcuL0Jhc2VXaWRnZXQnO1xuaW1wb3J0IHsgTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLCBEYXRhc2V0U3BlYywgRmFjZXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBTdmdTZWxlY3Rpb24sIE5EaW0sIEh0bWxTZWxlY3Rpb24gfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5cbmludGVyZmFjZSBCb3hwbG90U3RhdHMge1xuICAgIG1lZGlhbjogbnVtYmVyLFxuICAgIHF1YXJ0aWxlUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgd2hpc2tlclJhbmdlOiBbbnVtYmVyLCBudW1iZXJdXG59XG5cbmV4cG9ydCBjbGFzcyBEZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldCBleHRlbmRzIEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz4ge1xuXG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgY29udGFpbmVyOiBFbGVtZW50LFxuICAgICAgICBtZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw6IE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCxcbiAgICAgICAgYXR0cmlidXRlS2V5OiBzdHJpbmcsIFxuICAgICAgICBpc0Nsb25lOiBib29sZWFuID0gZmFsc2UpXG4gICAge1xuICAgICAgICBzdXBlcihjb250YWluZXIsIHRydWUpO1xuICAgICAgICB0aGlzLl9tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwgPSBtZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWw7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZUtleSA9IGF0dHJpYnV0ZUtleTtcbiAgICAgICAgdGhpcy5zZXRMYWJlbCgpO1xuXHRcdHRoaXMuX2lzQ2xvbmUgPSBpc0Nsb25lO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBDbG9uZShjb250YWluZXI6IEhUTUxFbGVtZW50KTogQmFzZVdpZGdldDxDdXJ2ZUxpc3QsIERhdGFzZXRTcGVjPlxuICAgIHtcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IERldGFpbGVkRGlzdHJpYnV0aW9uV2lkZ2V0KGNvbnRhaW5lciwgdGhpcy5tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwsIHRoaXMuYXR0cmlidXRlS2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuXHRwcml2YXRlIF9pc0Nsb25lIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpc0Nsb25lKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faXNDbG9uZTtcblx0fVxuXG4gICAgcHJpdmF0ZSBfbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsIDogTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsO1xuICAgIHB1YmxpYyBnZXQgbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsKCkgOiBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9hdHRyaWJ1dGVLZXkgOiBzdHJpbmc7XG4gICAgcHVibGljIGdldCBhdHRyaWJ1dGVLZXkoKSA6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVLZXk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfcG9pbnRDb2xsZWN0aW9uIDogUG9pbnRDb2xsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgcG9pbnRDb2xsZWN0aW9uKCkgOiBQb2ludENvbGxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRDb2xsZWN0aW9uO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2Z1bGxQb2ludENvbGxlY3Rpb24gOiBQb2ludENvbGxlY3Rpb247XG4gICAgcHVibGljIGdldCBmdWxsUG9pbnRDb2xsZWN0aW9uKCkgOiBQb2ludENvbGxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVsbFBvaW50Q29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9yYW5kb21Ob2lzZUxpc3QgOiBudW1iZXJbXTtcbiAgICBwdWJsaWMgZ2V0IHJhbmRvbU5vaXNlTGlzdCgpIDogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFuZG9tTm9pc2VMaXN0O1xuICAgIH0gICAgXG5cbiAgICBwcml2YXRlIF9zY2FsZVggOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG4gICAgcHVibGljIGdldCBzY2FsZVgoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2NhbGVZIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuICAgIHB1YmxpYyBnZXQgc2NhbGVZKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVZO1xuICAgIH1cblxuXHRwcml2YXRlIF9zdmdTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgc3ZnU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zdmdTZWxlY3Q7XG5cdH1cblxuICAgIHByaXZhdGUgX21haW5Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBtYWluR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX21haW5Hcm91cFNlbGVjdDtcbiAgICB9XG5cblx0cHJpdmF0ZSBfY2FudmFzRWxlbWVudCA6IEhUTUxDYW52YXNFbGVtZW50O1xuXHRwdWJsaWMgZ2V0IGNhbnZhc0VsZW1lbnQoKSA6IEhUTUxDYW52YXNFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzRWxlbWVudDtcblx0fVxuICAgIFxuICAgIHByaXZhdGUgX3RvdGFsQm94cGxvdENvbnRhaW5lclNlbGVjdE91dGxpbmUgOiBTdmdTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCB0b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3RPdXRsaW5lKCkgOiBTdmdTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0T3V0bGluZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF90b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCB0b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3Q7XG4gICAgfSAgXG5cbiAgICBwcml2YXRlIF9maWx0ZXJlZEJveHBsb3RDb250YWluZXJTZWxlY3RPdXRsaW5lIDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0T3V0bGluZSgpIDogU3ZnU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdE91dGxpbmU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0O1xuICAgIH0gICAgXG5cblx0cHJpdmF0ZSBfYnJ1c2hHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBicnVzaEdyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaEdyb3VwU2VsZWN0O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdCA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBib3hwbG90U3RhdHNQb3B1cFNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdDtcbiAgICB9XG4gICAgcHVibGljIHNldCBib3hwbG90U3RhdHNQb3B1cFNlbGVjdCh2IDogSHRtbFNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLl9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdCA9IHY7XG4gICAgfVxuICAgIFxuXG5cdHByaXZhdGUgX2F4aXNQYWRkaW5nIDogIG51bWJlcjtcblx0cHVibGljIGdldCBheGlzUGFkZGluZygpIDogIG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2F4aXNQYWRkaW5nO1xuXHR9XG5cblx0cHJpdmF0ZSBfeEF4aXNHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4QXhpc0dyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94QXhpc0dyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeExhYmVsVGV4dFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4TGFiZWxUZXh0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94TGFiZWxUZXh0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2ggOiBkMy5CcnVzaEJlaGF2aW9yPGFueT47XG5cdHB1YmxpYyBnZXQgYnJ1c2goKSA6IGQzLkJydXNoQmVoYXZpb3I8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF90b3RhbEJveHBsb3RTdGF0cyA6IEJveHBsb3RTdGF0cztcbiAgICBwdWJsaWMgZ2V0IHRvdGFsQm94cGxvdFN0YXRzKCkgOiBCb3hwbG90U3RhdHMge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxCb3hwbG90U3RhdHM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmlsdGVyZWRCb3hwbG90U3RhdHMgOiBCb3hwbG90U3RhdHM7XG4gICAgcHVibGljIGdldCBmaWx0ZXJlZEJveHBsb3RTdGF0cygpIDogQm94cGxvdFN0YXRzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkQm94cGxvdFN0YXRzO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zY2F0dGVycGxvdFBhZGRpbmcgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBzY2F0dGVycGxvdFBhZGRpbmcoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2F0dGVycGxvdFBhZGRpbmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYmV0d2VlbkJveHBsb3RQYWRkaW5nIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgYmV0d2VlbkJveHBsb3RQYWRkaW5nKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmV0d2VlbkJveHBsb3RQYWRkaW5nO1xuICAgIH1cblxuXHRwcm90ZWN0ZWQgc2V0TWFyZ2luKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX21hcmdpbiA9IHtcblx0XHRcdHRvcDogNixcblx0XHRcdHJpZ2h0OiA4LFxuXHRcdFx0Ym90dG9tOiA1Nixcblx0XHRcdGxlZnQ6IDhcblx0XHR9XG5cdH1cblxuICAgIHB1YmxpYyBpbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX3NjYXR0ZXJwbG90UGFkZGluZyA9IDg7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX2NhbnZhc0VsZW1lbnQgPSBjb250YWluZXJTZWxlY3RcbiAgICAgICAgICAgIC5hcHBlbmQoJ3hodG1sOmNhbnZhcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgdGhpcy52aXpXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQgLSAyICogdGhpcy5zY2F0dGVycGxvdFBhZGRpbmcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICBgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH1weCwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnNjYXR0ZXJwbG90UGFkZGluZ31weCk7YClcbiAgICAgICAgICAgIC5ub2RlKCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIFxuICAgICAgICAvLyBJIG9yaWdpbmFsbHkgcHV0IHRoZSBjYW52YXMgaW5zaWRlIHRoZSBzdmcgaW4gYSBmb3JlaWduT2JqZWN0LiBUaGlzIGRpZG4ndCB3b3JrIGJlY2F1c2VcbiAgICAgICAgLy8gb2YgQ2hyb21lIGJ1ZyAxNDg0OTlcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTQ4NDk5XG5cbiAgICAgICAgdGhpcy5fc3ZnU2VsZWN0ID0gY29udGFpbmVyU2VsZWN0LmFwcGVuZChcInN2Z1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKVxuICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQpXG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLCAnei1pbmRleDogMDsnKTtcblxuICAgICAgICB0aGlzLl9ib3hwbG90U3RhdHNQb3B1cFNlbGVjdCA9IGNvbnRhaW5lclNlbGVjdC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnYm94cGxvdFN0YXRzUG9wdXAnLCB0cnVlKTtcblxuICAgICAgICB0aGlzLmhpZGVCb3hwbG90U3RhdHNQb3B1cCgpO1xuXG4gICAgICAgIHRoaXMuX21haW5Hcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy5zY2F0dGVycGxvdFBhZGRpbmd9KWApO1xuXG4gICAgICAgIHRoaXMuX3RvdGFsQm94cGxvdENvbnRhaW5lclNlbGVjdE91dGxpbmUgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApXG4gICAgICAgICAgICAuY2xhc3NlZCgnYm94cGxvdC1jb250YWluZXInLCB0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLl90b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApXG4gICAgICAgICAgICAuY2xhc3NlZCgnYm94cGxvdC1jb250YWluZXInLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9maWx0ZXJlZEJveHBsb3RDb250YWluZXJTZWxlY3RPdXRsaW5lID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2JveHBsb3QtY29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2JveHBsb3QtY29udGFpbmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5fYnJ1c2hHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKVxuXHRcdFx0LmNsYXNzZWQoXCJicnVzaENvbnRhaW5lclwiLCB0cnVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLl9heGlzUGFkZGluZyA9IDQ7XG4gICAgICAgIHRoaXMuX3hBeGlzR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIHRoaXMuYXhpc1BhZGRpbmd9KWApXG4gICAgICAgICAgICAuY2xhc3NlZChcImxhYmVsQ29sb3JcIiwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fYmV0d2VlbkJveHBsb3RQYWRkaW5nID0gNDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldExhYmVsKCk6IHZvaWRcblx0e1x0XG5cdFx0dGhpcy5feExhYmVsVGV4dFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgndGV4dCcpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKVxuICAgICAgICAgICAgLnRleHQodGhpcy5hdHRyaWJ1dGVLZXkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkxhYmVscygpOiB2b2lkXG4gICAge1xuXHRcdGxldCBidWZmZXJGb3JBeGlzID0gMzIgKyB0aGlzLmF4aXNQYWRkaW5nOztcblx0XHR0aGlzLnhMYWJlbFRleHRTZWxlY3Rcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdCArIHRoaXMudml6V2lkdGggLyAyfSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIGJ1ZmZlckZvckF4aXN9KWApO1xuICAgIH1cblxuXG5cbiAgICBwdWJsaWMgT25EYXRhQ2hhbmdlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UgTWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLlBvaW50OlxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50Q29sbGVjdGlvbiA9IHRoaXMuZGF0YSBhcyBQb2ludENvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFBvaW50Q29sbGVjdGlvbiA9IHRoaXMuZnVsbERhdGEgYXMgUG9pbnRDb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwuQ3VydmU6XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRDb2xsZWN0aW9uID0gdGhpcy5kYXRhLmN1cnZlQ29sbGVjdGlvbiBhcyBQb2ludENvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFBvaW50Q29sbGVjdGlvbiA9IHRoaXMuZnVsbERhdGEuY3VydmVDb2xsZWN0aW9uIGFzIFBvaW50Q29sbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGV0YWlsZWREaXN0cmlidXRpb24gbmVlZHMgYSB2YWxpZCBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWxcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRDb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsUG9pbnRDb2xsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JhbmRvbU5vaXNlTGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9pbnRDb2xsZWN0aW9uLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJhbmRvbU5vaXNlTGlzdC5wdXNoKE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVG90YWxCb3hwbG90U3RhdHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsZXMoKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIHRoaXMuc2hvd0xhYmVsKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUb3RhbEJveHBsb3RTdGF0cygpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdmFsaWROdW1iZXJzOiBudW1iZXJbXSA9IHRoaXMucG9pbnRDb2xsZWN0aW9uLkFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChkID0+IGQuZ2V0KHRoaXMuYXR0cmlidXRlS2V5KSkgLy8gZ2V0IGFjdHVhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZCA9PiAhaXNOYU4oZCkpIC8vIGZpbHRlciBvdXQgTmFOIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpOyAvLyBkMy5xdWFudGlsZSByZXF1aXJlcyBpdCB0byBiZSBzb3J0ZWQuIFRoaXMgY291bGQgdGVjaG5pY2FsbHkgYmUgZG9uZSBmYXN0ZXIgd2l0aG91dCBzb3J0aW5nLlxuXG4gICAgICAgIHRoaXMuX3RvdGFsQm94cGxvdFN0YXRzID0gRGV0YWlsZWREaXN0cmlidXRpb25XaWRnZXQuY2FsY3VsYXRlQm94cGxvdFN0YXRzKHZhbGlkTnVtYmVycyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVGaWx0ZXJlZEJveHBsb3RTdGF0cygpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdmFsaWRCcnVzaGVkTnVtYmVyczogbnVtYmVyW10gPSB0aGlzLnBvaW50Q29sbGVjdGlvbi5BcnJheVxuICAgICAgICAgICAgLmZpbHRlcihkID0+IGQuaW5CcnVzaClcbiAgICAgICAgICAgIC5tYXAoZCA9PiBkLmdldCh0aGlzLmF0dHJpYnV0ZUtleSkpIC8vIGdldCBhY3R1YWwgdmFsdWVcbiAgICAgICAgICAgIC5maWx0ZXIoZCA9PiAhaXNOYU4oZCkpIC8vIGZpbHRlciBvdXQgTmFOIHZhbHVlcy5cbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYik7IC8vIGQzLnF1YW50aWxlIHJlcXVpcmVzIGl0IHRvIGJlIHNvcnRlZC4gVGhpcyBjb3VsZCB0ZWNobmljYWxseSBiZSBkb25lIGZhc3RlciB3aXRob3V0IHNvcnRpbmcuXG5cbiAgICAgICAgdGhpcy5fZmlsdGVyZWRCb3hwbG90U3RhdHMgPSBEZXRhaWxlZERpc3RyaWJ1dGlvbldpZGdldC5jYWxjdWxhdGVCb3hwbG90U3RhdHModmFsaWRCcnVzaGVkTnVtYmVycyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlQm94cGxvdFN0YXRzKG51bWJlcnM6IG51bWJlcltdKTogQm94cGxvdFN0YXRzXG4gICAge1xuICAgICAgICBjb25zdCBtZWRpYW4gPSBkMy5tZWRpYW4obnVtYmVycyk7XG4gICAgICAgIGxldCBsb3dRdWFydGlsZSA9IGQzLnF1YW50aWxlKG51bWJlcnMsIDAuMjUpO1xuICAgICAgICBsZXQgaGlnaFF1YXJ0aWxlID0gZDMucXVhbnRpbGUobnVtYmVycywgMC43NSk7XG4gICAgICAgIGNvbnN0IHF1YXJ0aWxlUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gPSBbbG93UXVhcnRpbGUsIGhpZ2hRdWFydGlsZV07XG4gICAgICAgIFxuICAgICAgICBsZXQgaW50ZXJRdWFydGlsZVJhbmdlID0gaGlnaFF1YXJ0aWxlIC0gbG93UXVhcnRpbGU7XG4gICAgICAgIGxldCBsb3dXaGlza2VyICA9IGxvd1F1YXJ0aWxlICAtIDEuNSAqIGludGVyUXVhcnRpbGVSYW5nZTtcbiAgICAgICAgbGV0IGhpZ2hXaGlza2VyID0gaGlnaFF1YXJ0aWxlICsgMS41ICogaW50ZXJRdWFydGlsZVJhbmdlO1xuICAgICAgICBjb25zdCB3aGlza2VyUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gPSBbbG93V2hpc2tlciwgaGlnaFdoaXNrZXJdO1xuXG4gICAgICAgIGxldCBib3hwbG90U3RhdHM6IEJveHBsb3RTdGF0cyA9IHtcbiAgICAgICAgICAgIG1lZGlhbjogbWVkaWFuLFxuICAgICAgICAgICAgcXVhcnRpbGVSYW5nZTogcXVhcnRpbGVSYW5nZSxcbiAgICAgICAgICAgIHdoaXNrZXJSYW5nZTogd2hpc2tlclJhbmdlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJveHBsb3RTdGF0cztcblxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlU2NhbGVzKCk6IHZvaWRcbiAgICB7XG5cdFx0bGV0IGRhdGE6IFBvaW50Q29sbGVjdGlvbjtcblx0XHRpZiAodGhpcy5pc0Nsb25lKVxuXHRcdHtcblx0XHRcdGRhdGEgPSB0aGlzLmZ1bGxQb2ludENvbGxlY3Rpb247XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRkYXRhID0gdGhpcy5wb2ludENvbGxlY3Rpb247XG5cdFx0fVxuXG4gICAgICAgIGxldCBkaXN0cmlidXRpb25NaW5NYXggPSBkYXRhLmdldE1pbk1heCh0aGlzLmF0dHJpYnV0ZUtleSk7XG4gICAgICAgIC8vIGxldCBkaXN0cmlidXRpb25NaW5NYXggPSB0aGlzLnBvaW50Q29sbGVjdGlvbi5nZXRNaW5NYXgodGhpcy5hdHRyaWJ1dGVLZXkpO1xuICAgICAgICB0aGlzLl9zY2FsZVggPSBkMy5zY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRvbWFpbihkaXN0cmlidXRpb25NaW5NYXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIHRoaXMudml6V2lkdGhdKTtcblxuXG4gICAgICAgIHRoaXMuX3NjYWxlWSA9IGQzLnNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPigpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZG9tYWluKFswLCAxXSkgLy8gYm91bmRzIG9mIE1hdGgucmFuZG9tXG4gICAgICAgICAgICAgICAgICAgICAgICAucmFuZ2UoW3RoaXMudml6SGVpZ2h0IC0gMiAqIHRoaXMuc2NhdHRlcnBsb3RQYWRkaW5nLCAwXSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3KCk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgLy8gaXQncyBwcm9iYWJseSBmYXN0ZXIgdG8gZmlsdGVyIG91dCBhbGwgdGhlIE5hTnMgb25jZSB0aGFuIG5vRGlzcCB0aGVtIGFsbC4gVGhlcmUgbWlnaHQgYmUgYXMgbWFueSBhcyA1MCUgTmFOc1xuICAgICAgICBsZXQgdmFsaWRQb2ludHMgPSB0aGlzLnBvaW50Q29sbGVjdGlvbi5BcnJheS5maWx0ZXIoZCA9PiAhaXNOYU4oZC5nZXQodGhpcy5hdHRyaWJ1dGVLZXkpKSk7XG5cbiAgICAgICAgLy8gZHJhdyBqaXR0ZXJlZCBzY2F0dGVycGxvdFxuICAgICAgICBjb25zdCBjYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsMCwgdGhpcy52aXpXaWR0aCwgdGhpcy52aXpIZWlnaHQgLSAyICogdGhpcy5zY2F0dGVycGxvdFBhZGRpbmcpO1xuICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgPSAwLjY7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRQb2ludHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBwb2ludCA9IHZhbGlkUG9pbnRzW2ldO1xuICAgICAgICAgICAgbGV0IHggPSB0aGlzLnNjYWxlWChwb2ludC5nZXQodGhpcy5hdHRyaWJ1dGVLZXkpKTtcbiAgICAgICAgICAgIGxldCB5ID0gdGhpcy5zY2FsZVkodGhpcy5yYW5kb21Ob2lzZUxpc3RbaV0pO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDAuNTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhLmJydXNoQXBwbGllZClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgc21hbGxCb3hwbG90SGVpZ2h0ID0gKHRoaXMudml6SGVpZ2h0IC0gdGhpcy5iZXR3ZWVuQm94cGxvdFBhZGRpbmcpIC8gMjtcbiAgICAgICAgICAgIHRoaXMuZHJhd0JveHBsb3QodGhpcy50b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3RPdXRsaW5lLCB0aGlzLnRvdGFsQm94cGxvdFN0YXRzLCAwLCBzbWFsbEJveHBsb3RIZWlnaHQsIHRydWUpOyAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZHJhd0JveHBsb3QodGhpcy50b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3QsIHRoaXMudG90YWxCb3hwbG90U3RhdHMsIDAsIHNtYWxsQm94cGxvdEhlaWdodCk7ICAgICAgIFxuICAgICAgICAgICAgdGhpcy5kcmF3Qm94cGxvdCh0aGlzLmZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdE91dGxpbmUsIHRoaXMuZmlsdGVyZWRCb3hwbG90U3RhdHMsIHNtYWxsQm94cGxvdEhlaWdodCArIHRoaXMuYmV0d2VlbkJveHBsb3RQYWRkaW5nLCBzbWFsbEJveHBsb3RIZWlnaHQsIHRydWUsIHRydWUpXG4gICAgICAgICAgICB0aGlzLmRyYXdCb3hwbG90KHRoaXMuZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0LCB0aGlzLmZpbHRlcmVkQm94cGxvdFN0YXRzLCBzbWFsbEJveHBsb3RIZWlnaHQgKyB0aGlzLmJldHdlZW5Cb3hwbG90UGFkZGluZywgc21hbGxCb3hwbG90SGVpZ2h0LCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRCb3hwbG90Q29udGFpbmVyU2VsZWN0T3V0bGluZS5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRyYXdCb3hwbG90KHRoaXMudG90YWxCb3hwbG90Q29udGFpbmVyU2VsZWN0T3V0bGluZSwgdGhpcy50b3RhbEJveHBsb3RTdGF0cywgMCwgdGhpcy52aXpIZWlnaHQsIHRydWUpOyAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZHJhd0JveHBsb3QodGhpcy50b3RhbEJveHBsb3RDb250YWluZXJTZWxlY3QsIHRoaXMudG90YWxCb3hwbG90U3RhdHMsIDAsIHRoaXMudml6SGVpZ2h0KTsgICAgICAgXG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdE91dGxpbmUuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkQm94cGxvdENvbnRhaW5lclNlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhd0F4aXMoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkxhYmVscygpO1xuICAgIH1cblxuXHRwcm90ZWN0ZWQgZHJhd0ZhY2V0ZWREYXRhKGZhY2V0TGlzdDogRmFjZXRbXSk6IHZvaWRcblx0e1xuICAgICAgICB0aGlzLmRyYXdGYWNldGVkRGF0YURlZmF1bHQoZmFjZXRMaXN0LCBcIjk1JVwiLCBcIjEyMHB4XCIpO1xuXHR9XG5cbiAgICBwcml2YXRlIHNob3dMYWJlbCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnhMYWJlbFRleHRTZWxlY3QuY2xhc3NlZCgnbm9EaXNwJywgZmFsc2UpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0JveHBsb3QoY29udGFpbmVyU2VsZWN0OiBTdmdTZWxlY3Rpb24sIGJveHBsb3RTdGF0czogQm94cGxvdFN0YXRzLCB0b3A6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIG91dGxpbmU6IGJvb2xlYW4gPSBmYWxzZSwgc2VsZWN0aW9uOiBib29sZWFuID0gZmFsc2UpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBNZWRpYW5cbiAgICAgICAgY29udGFpbmVyU2VsZWN0LnNlbGVjdEFsbCgnLmJveHBsb3RNZWRpYW5MaW5lJylcbiAgICAgICAgICAgIC5kYXRhPG51bWJlcj4oW2JveHBsb3RTdGF0cy5tZWRpYW5dKVxuICAgICAgICAgIC5qb2luKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4gdGhpcy5zY2FsZVgoZCkpXG4gICAgICAgICAgICAuYXR0cigneTEnLCB0b3ApXG4gICAgICAgICAgICAuYXR0cigneDInLCBkID0+IHRoaXMuc2NhbGVYKGQpKVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgdG9wICsgaGVpZ2h0KVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2JveHBsb3RNZWRpYW5MaW5lJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdXRsaW5lJywgb3V0bGluZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3Rpb24nLCBzZWxlY3Rpb24pO1xuXG4gICAgICAgIC8vIElRUiBCb3hcbiAgICAgICAgY29udGFpbmVyU2VsZWN0LnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAuZGF0YTxbbnVtYmVyLCBudW1iZXJdPihbYm94cGxvdFN0YXRzLnF1YXJ0aWxlUmFuZ2VdKVxuICAgICAgICAgIC5qb2luKCdyZWN0JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdJUVItQm94JywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3Rpb24nLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAuY2xhc3NlZCgnb3V0bGluZScsIG91dGxpbmUpXG4gICAgICAgICAgICAuYXR0cigneCcsIGQgPT4gdGhpcy5zY2FsZVgoZFswXSkpXG4gICAgICAgICAgICAuYXR0cigneScsIHRvcClcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGQgPT4gdGhpcy5zY2FsZVgoZFsxXSkgLSB0aGlzLnNjYWxlWChkWzBdKSlcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsICgpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Qm94cGxvdFN0YXRzUG9wdXAoYm94cGxvdFN0YXRzLCBjb250YWluZXJTZWxlY3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCAoKSA9PiBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVCb3hwbG90U3RhdHNQb3B1cCgpXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgIC8vIEhvcml6b250YWwgd2hpc2tlciBsaW5lc1xuICAgICAgICBjb25zdCB2ZXJ0TWlkZGxlID0gdG9wICsgKGhlaWdodCAvIDIpO1xuICAgICAgICBjb250YWluZXJTZWxlY3Quc2VsZWN0QWxsKCcuYm94cGxvdFdoaXNrZXJzJylcbiAgICAgICAgICAgIC5kYXRhPFtudW1iZXIsIG51bWJlcl0+KFtcbiAgICAgICAgICAgICAgICBbYm94cGxvdFN0YXRzLndoaXNrZXJSYW5nZVswXSwgYm94cGxvdFN0YXRzLnF1YXJ0aWxlUmFuZ2VbMF1dLFxuICAgICAgICAgICAgICAgIFtib3hwbG90U3RhdHMud2hpc2tlclJhbmdlWzFdLCBib3hwbG90U3RhdHMucXVhcnRpbGVSYW5nZVsxXV1dKVxuICAgICAgICAgIC5qb2luKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4gdGhpcy5zY2FsZVgoZFswXSkpXG4gICAgICAgICAgICAuYXR0cigneTEnLCB2ZXJ0TWlkZGxlKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB0aGlzLnNjYWxlWChkWzFdKSlcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHZlcnRNaWRkbGUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnc2VsZWN0aW9uJywgc2VsZWN0aW9uKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ291dGxpbmUnLCBvdXRsaW5lKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2JveHBsb3RXaGlza2VycycsIHRydWUpO1xuXG4gICAgICAgIC8vIHZlcnRpY2FsIHdoaXNrZXIgZW5kcG9pbnRzXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlU2l6ZSA9IDAuNjY7IC8vIGhlaWdodCBvZiB3aGlza2VyIGVuZHBvaW50cyBjb21wYXJlZCB0byBib3ggaGVpZ2h0XG4gICAgICAgIGNvbnN0IHBhZFNpemUgPSBoZWlnaHQgKiAoMSAtIHJlbGF0aXZlU2l6ZSkgLyAyO1xuICAgICAgICBjb250YWluZXJTZWxlY3Quc2VsZWN0QWxsKCcuYm94cGxvdFdoaXNrZXJFbmRzJylcbiAgICAgICAgICAgIC5kYXRhPG51bWJlcj4oYm94cGxvdFN0YXRzLndoaXNrZXJSYW5nZSlcbiAgICAgICAgICAuam9pbignbGluZScpXG4gICAgICAgICAgICAuYXR0cigneDEnLCBkID0+IHRoaXMuc2NhbGVYKGQpKVxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgdG9wICsgcGFkU2l6ZSlcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIGQgPT4gdGhpcy5zY2FsZVgoZCkpXG4gICAgICAgICAgICAuYXR0cigneTInLCB0b3AgKyBoZWlnaHQgLSBwYWRTaXplKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGlvbicsIHNlbGVjdGlvbilcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdXRsaW5lJywgb3V0bGluZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdib3hwbG90V2hpc2tlckVuZHMnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNob3dCb3hwbG90U3RhdHNQb3B1cChib3hwbG90U3RhdHM6IEJveHBsb3RTdGF0cywgYm94cGxvdENvbnRhaW5lcjogU3ZnU2VsZWN0aW9uKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5ib3hwbG90U3RhdHNQb3B1cFNlbGVjdC5odG1sKG51bGwpO1xuICAgICAgICBjb25zdCBib3VuZFJlY3QgPSBib3hwbG90Q29udGFpbmVyLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0XG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLCBgbGVmdDogJHsoYm91bmRSZWN0LmxlZnQgKyBib3VuZFJlY3QucmlnaHQpIC8gMn1weDsgdG9wOiR7Ym91bmRSZWN0LmJvdHRvbX1weGApO1xuXG4gICAgICAgIHRoaXMuYm94cGxvdFN0YXRzUG9wdXBTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2JveHBsb3RTdGF0c1BvcHVwLXExJylcbiAgICAgICAgICAgIC50ZXh0KCdRMTogJyArIGJveHBsb3RTdGF0cy5xdWFydGlsZVJhbmdlWzBdLnRvRml4ZWQoNCkpO1xuXG4gICAgICAgIHRoaXMuYm94cGxvdFN0YXRzUG9wdXBTZWxlY3QuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2JveHBsb3RTdGF0c1BvcHVwLW1lZGlhbicpXG4gICAgICAgICAgICAudGV4dCgnTWVkaWFuOiAnICsgYm94cGxvdFN0YXRzLm1lZGlhbi50b0ZpeGVkKDQpKTtcblxuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0LmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsICdib3hwbG90U3RhdHNQb3B1cC1xMycpXG4gICAgICAgICAgICAudGV4dCgnUTM6ICcgKyBib3hwbG90U3RhdHMucXVhcnRpbGVSYW5nZVsxXS50b0ZpeGVkKDQpKTtcblxuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0LmNsYXNzZWQoJ25vRGlzcCcsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhpZGVCb3hwbG90U3RhdHNQb3B1cCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmJveHBsb3RTdGF0c1BvcHVwU2VsZWN0LmNsYXNzZWQoJ25vRGlzcCcsIHRydWUpO1xuICAgIH1cblxuXHRwcml2YXRlIGRyYXdBeGlzKCk6IHZvaWRcblx0e1xuICAgICAgICB0aGlzLnhBeGlzR3JvdXBTZWxlY3RcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgKyB0aGlzLmF4aXNQYWRkaW5nfSlgKVxuXHRcdFx0LmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlWCkpO1xuXHR9XG5cbiAgICBwdWJsaWMgT25SZXNpemUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdmdTZWxlY3RcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLmNhbnZhc0VsZW1lbnQpXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMudml6SGVpZ2h0IC0gMiAqIHRoaXMuc2NhdHRlcnBsb3RQYWRkaW5nKVxuICBcbiAgICAgICAgdGhpcy51cGRhdGVTY2FsZXMoKTtcbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuXG4gICAgcHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVGaWx0ZXJlZEJveHBsb3RTdGF0cygpO1xuICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBPcHRpb25TZWxlY3QgfSBmcm9tIFwiLi9PcHRpb25TZWxlY3RcIjtcbmltcG9ydCB7IEh0bWxTZWxlY3Rpb24sIEJ1dHRvblByb3BzIH0gZnJvbSBcIi4uL2RldmxpYi9EZXZMaWJUeXBlc1wiO1xuaW1wb3J0IHsgQXBwRGF0YSwgRmFjZXQgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IERldmxpYlRTVXRpbCB9IGZyb20gXCIuLi9kZXZsaWIvRGV2bGliVFNVdGlsXCI7XG5pbXBvcnQgeyBDdXJ2ZUxpc3QgfSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVMaXN0JztcblxuZXhwb3J0IGNsYXNzIEdyb3VwQnlXaWRnZXRcbntcblxuXHRwcml2YXRlIHN0YXRpYyBfY29tcG9uZW50Q291bnQ6IG51bWJlciA9IDA7XG5cbiAgICBwcml2YXRlIF9vdXRlckNvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBvdXRlckNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdXRlckNvbnRhaW5lcjtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfaW5uZXJDb21wb25lbnRJZCA6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IGlubmVyQ29tcG9uZW50SWQoKSA6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lckNvbXBvbmVudElkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21haW5Db250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgbWFpbkNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWluQ29udGFpbmVyO1xuICAgIH0gICAgXG5cbiAgICBwcml2YXRlIF9ncm91cEJ5T3V0ZXJDb250YWluZXJMaXN0IDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGdyb3VwQnlPdXRlckNvbnRhaW5lckxpc3QoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBCeU91dGVyQ29udGFpbmVyTGlzdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9kYXRhIDogQXBwRGF0YTxhbnk+O1xuICAgIHB1YmxpYyBnZXQgZGF0YSgpIDogQXBwRGF0YTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgZGF0YSh2IDogQXBwRGF0YTxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0IDogc3RyaW5nW107XG4gICAgcHVibGljIGdldCBncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdCgpIDogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3Q7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX2dyb3VwQnlPcHRpb25TZWxlY3RMaXN0IDogT3B0aW9uU2VsZWN0W107XG4gICAgcHVibGljIGdldCBncm91cEJ5T3B0aW9uU2VsZWN0TGlzdCgpIDogT3B0aW9uU2VsZWN0W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBCeU9wdGlvblNlbGVjdExpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBjdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0KCk6IG51bWJlcltdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEJ5T3B0aW9uU2VsZWN0TGlzdC5tYXAob3B0aW9uU2VsZWN0ID0+IG9wdGlvblNlbGVjdC5jdXJyZW50U2VsZWN0aW9uSW5kZXgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEh0bWxTZWxlY3Rpb24pXG4gICAge1xuICAgICAgICB0aGlzLl9vdXRlckNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fbWFpbkNvbnRhaW5lciA9IHRoaXMub3V0ZXJDb250YWluZXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2dyb3VwQnlNYWluQ29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5faW5uZXJDb21wb25lbnRJZCA9ICdncm91cEJ5SW5uZXJDb250YWluZXJfJyArIEdyb3VwQnlXaWRnZXQuX2NvbXBvbmVudENvdW50ICsgJ18nO1xuICAgICAgICBHcm91cEJ5V2lkZ2V0Ll9jb21wb25lbnRDb3VudCsrO1xuXG4gICAgICAgIHRoaXMuX2dyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0ID0gW107XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50SWQoKTtcbiAgICAgICAgdGhpcy5kcmF3TGluZXMoWzBdKTtcbiAgICAgICAgdGhpcy5hZGRHcm91cEJ5TGluZSgpOyAvLyBkcmF3IHR3byBsaW5lcyBieSBkZWZhdWx0XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3TGluZXMocHJldmlvdXNTZWxlY3Rpb25zOiBudW1iZXJbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX2dyb3VwQnlPdXRlckNvbnRhaW5lckxpc3QgPSB0aGlzLm1haW5Db250YWluZXIuc2VsZWN0QWxsPEhUTUxFbGVtZW50LCBhbnk+KCcuZ3JvdXBCeUVsZW1lbnRDb250YWluZXInKVxuICAgICAgICAgICAgLmRhdGEodGhpcy5ncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdClcbiAgICAgICAgICAgIC5qb2luKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2dyb3VwQnlFbGVtZW50Q29udGFpbmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5ncm91cEJ5T3V0ZXJDb250YWluZXJMaXN0Lmh0bWwobnVsbCk7XG5cbiAgICAgICAgdGhpcy5ncm91cEJ5T3V0ZXJDb250YWluZXJMaXN0LmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdncm91cEJ5Q29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzbWFsbFRleHQnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgZCA9PiBkKTtcblxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLmdyb3VwQnlPdXRlckNvbnRhaW5lckxpc3RcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsIGkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGljb25LZXk6IHN0cmluZztcbiAgICAgICAgICAgICAgICBsZXQgY2FsbGJhY2s6IChldjogTW91c2VFdmVudCkgPT4gdm9pZDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGljb25LZXkgPSAncGx1cyc7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gKCkgPT4gc2VsZi5hZGRHcm91cEJ5TGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpY29uS2V5ID0gJ21pbnVzJ1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9ICgpID0+IHNlbGYucmVtb3ZlR3JvdXBCeUxpbmUoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpY29uQnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24oaWNvbktleSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGljb25CdXR0b24uY2xhc3NMaXN0LmFkZCgnY29tcGFjdCcpO1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5ub2RlKCkuYXBwZW5kQ2hpbGQoaWNvbkJ1dHRvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ncm91cEJ5T3B0aW9uU2VsZWN0TGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXJJZDogc3RyaW5nID0gdGhpcy5ncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdFtpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbjogbnVtYmVyO1xuICAgICAgICAgICAgaWYgKGkgPCBwcmV2aW91c1NlbGVjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHByZXZpb3VzU2VsZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSB0aGlzLmdldEZpcnN0VW5zZWxlY3RlZE9wdGlvbihwcmV2aW91c1NlbGVjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxhYmVsOiBzdHJpbmc7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IFwiR3JvdXAgYnlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9ICdhbmQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9wdGlvblNlbGVjdCA9IG5ldyBPcHRpb25TZWxlY3QoY29udGFpbmVySWQsIGxhYmVsLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLmdyb3VwQnlPcHRpb25TZWxlY3RMaXN0LnB1c2gob3B0aW9uU2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUdyb3VwQnlPcHRpb25zKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZpcnN0VW5zZWxlY3RlZE9wdGlvbihzZWxlY3Rpb25zOiBudW1iZXJbXSk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IG1heEluZGV4OiBudW1iZXI7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gdGhpcy5kYXRhLkdldEZhY2V0T3B0aW9ucygpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1heEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FuZGlkYXRlID0gMDtcbiAgICAgICAgd2hpbGUgKHNlbGVjdGlvbnMuaW5jbHVkZXMoY2FuZGlkYXRlKSAmJiBjYW5kaWRhdGUgPD0gbWF4SW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZEdyb3VwQnlMaW5lKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0aW9ucyA9IHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4TGlzdDtcbiAgICAgICAgY29uc3QgYWRkZWQgPSB0aGlzLmFkZENvbXBvbmVudElkKCk7XG4gICAgICAgIGlmICghYWRkZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdMaW5lcyhwcmV2aW91c1NlbGVjdGlvbnMpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYWRkQ29tcG9uZW50SWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZFeGlzdGluZ0xpbmVzID0gdGhpcy5ncm91cEJ5SW5uZXJDb25haW5lcklkTGlzdC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBmYWNldE9wdGlvbnMgPSB0aGlzLmRhdGEuR2V0RmFjZXRPcHRpb25zKCk7XG4gICAgICAgICAgICBpZiAoZmFjZXRPcHRpb25zLmxlbmd0aCA9PT0gbnVtYmVyT2ZFeGlzdGluZ0xpbmVzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld0lkID0gdGhpcy5pbm5lckNvbXBvbmVudElkICsgbnVtYmVyT2ZFeGlzdGluZ0xpbmVzO1xuICAgICAgICB0aGlzLmdyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0LnB1c2gobmV3SWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbW92ZUdyb3VwQnlMaW5lKGxpbmVJbmRleDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb25zID0gdGhpcy5jdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0O1xuICAgICAgICBwcmV2aW91c1NlbGVjdGlvbnMuc3BsaWNlKGxpbmVJbmRleCwgMSk7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwQnlJbm5lckNvbmFpbmVySWRMaXN0Lmxlbmd0aCA+IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBCeUlubmVyQ29uYWluZXJJZExpc3QucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmF3TGluZXMocHJldmlvdXNTZWxlY3Rpb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlR3JvdXBCeU9wdGlvbnMoZGF0YTogQXBwRGF0YTxhbnk+LCBza2lwRXZlbnRUcmlnZ2VyOiBib29sZWFuID0gZmFsc2UpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICAgICAgbGV0IGZhY2V0T3B0aW9ucyA9IGRhdGEuR2V0RmFjZXRPcHRpb25zKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ncm91cEJ5T3B0aW9uU2VsZWN0TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGJ1dHRvblByb3BzTGlzdDogQnV0dG9uUHJvcHNbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZmFjZXRPcHRpb24gb2YgZmFjZXRPcHRpb25zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBidXR0b25Qcm9wczogQnV0dG9uUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBmYWNldE9wdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5vbkdyb3VwU2VsZWN0aW9uKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnV0dG9uUHJvcHNMaXN0LnB1c2goYnV0dG9uUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ncm91cEJ5T3B0aW9uU2VsZWN0TGlzdFtpXS5vbkRhdGFDaGFuZ2UoYnV0dG9uUHJvcHNMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNraXBFdmVudFRyaWdnZXIpXG4gICAgICAgIHsgICBcbiAgICAgICAgICAgIHRoaXMub25Hcm91cFNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkdyb3VwU2VsZWN0aW9uKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IGZsYXRGYWNldExpc3QgPSB0aGlzLmdldEZsYXRGYWNldExpc3QoKTtcbiAgICAgICAgY29uc3QgY29sb3JMb29rdXAgPSB0aGlzLmdldENvbG9yTG9va3VwKCk7XG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50OiBDdXN0b21FdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZ3JvdXBCeUNoYW5nZWQnLCB7IGRldGFpbDpcbiAgICAgICAge1xuICAgICAgICAgICAgZ3JvdXBJbmRleDogdGhpcy5jdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0LFxuICAgICAgICAgICAgZmxhdEZhY2V0TGlzdDogZmxhdEZhY2V0TGlzdCxcbiAgICAgICAgICAgIGNvbG9yTG9va3VwOiBjb2xvckxvb2t1cFxuICAgICAgICB9fSk7XG4gICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRGbGF0RmFjZXRMaXN0KCk6IEZhY2V0W11cbiAgICB7XG4gICAgICAgIGxldCBmbGF0RmFjZXRMaXN0OiBGYWNldFtdID0gW3tuYW1lOiBbXSwgZGF0YTogdGhpcy5kYXRhfV07XG4gICAgICAgIGxldCBuZXN0ZWRGYWNldExpc3Q6IEZhY2V0W11bXSA9IFtdOyAvLyBvbmx5IGdldCB0aGUgbGFzdCB0d28gbGF5ZXJzIG9mIHRoZSBmYWNldGluZ1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4TGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5jdXJyZW50U2VsZWN0aW9uSW5kZXhMaXN0W2ldO1xuICAgICAgICAgICAgbGV0IG5leHRMaXN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB7bmFtZTogbmFtZVNvRmFyLCBkYXRhOiBkYXRhfSBvZiBmbGF0RmFjZXRMaXN0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBmYWNldE9wdGlvbnMgPSBkYXRhLkdldEZhY2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50T3B0aW9uID0gZmFjZXRPcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBsZXQgc3ViRmFjZXRzOiBGYWNldFtdID0gY3VycmVudE9wdGlvbi5HZXRGYWNldHMoKTtcbiAgICAgICAgICAgICAgICBzdWJGYWNldHMgPSBzdWJGYWNldHMubWFwKGZhY2V0ID0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TmFtZSA9IG5hbWVTb0Zhci5tYXAoeCA9PiB4KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TmFtZS5wdXNoKC4uLmZhY2V0Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuZXdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmFjZXQuZGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmV4dExpc3QucHVzaCguLi5zdWJGYWNldHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhdEZhY2V0TGlzdCA9IG5leHRMaXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZsYXRGYWNldExpc3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvckxvb2t1cCgpOiBNYXA8c3RyaW5nLCBzdHJpbmc+XG5cdHtcbiAgICAgICAgY29uc3QgY29sb3JMb29rdXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuICAgICAgICBpZiAoISh0aGlzLmRhdGEgYXMgQ3VydmVMaXN0KS5kZWZhdWx0RmFjZXRBeGlzVGlja3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xvckxvb2t1cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB5QXhpc1RpY2tzOiBjb25kaXRpb24xTGFiZWxzLFxuICAgICAgICAgICAgeEF4aXNUaWNrczogY29uZGl0aW9uMkxhYmVsc1xuICAgICAgICB9ID0gKHRoaXMuZGF0YSBhcyBDdXJ2ZUxpc3QpLmRlZmF1bHRGYWNldEF4aXNUaWNrcztcblxuICAgICAgICBjb25zdCBmaXJzdEZhY2V0SW5kZXggPSB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleExpc3RbMF07XG4gICAgICAgIGNvbnN0IGxhYmVsczogc3RyaW5nW10gPSBmaXJzdEZhY2V0SW5kZXggPT09IDEgPyBjb25kaXRpb24yTGFiZWxzIDogY29uZGl0aW9uMUxhYmVscztcbiAgICAgICAgY29uc3QgY29udHJvbE5hbWVzID0gR3JvdXBCeVdpZGdldC5nZXRDb250cm9sTmFtZXMoKTtcbiAgICAgICAgY29uc3QgY29udHJvbENvbG9yID0gR3JvdXBCeVdpZGdldC5nZXRDb250cm9sQ29sb3IoKTtcbiAgICAgICAgY29uc3Qge3NjaGVtZTogY29sb3JTY2hlbWUsIHNraXBJbmRpY2VzOiBza2lwQ29sb3JzfSA9IEdyb3VwQnlXaWRnZXQuZ2V0Q29sb3JTY2hlbWUoKTtcbiAgICAgICAgbGV0IGNvbG9ySW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBsYWJlbCBvZiBsYWJlbHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdoaWxlIChza2lwQ29sb3JzLmhhcyhjb2xvckluZGV4KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2xvckluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29sb3JJbmRleCA9IGNvbG9ySW5kZXggJSBjb2xvclNjaGVtZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGNvbnRyb2xOYW1lcy5oYXMobGFiZWwpID8gY29udHJvbENvbG9yIDogY29sb3JTY2hlbWVbY29sb3JJbmRleCsrXTtcbiAgICAgICAgICAgIGNvbG9yTG9va3VwLnNldChsYWJlbCwgY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xvckxvb2t1cDtcblx0fVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q29udHJvbE5hbWVzKCk6IFNldDxzdHJpbmc+XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFNldDxzdHJpbmc+KFtcbiAgICAgICAgICAgICdETVNPJyxcbiAgICAgICAgICAgICdFdGhhbm9sJyxcbiAgICAgICAgICAgICcwLjAgdW0nXG4gICAgICAgIF0pXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q29udHJvbENvbG9yKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuICdncmV5JztcbiAgICB9XG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q29sb3JTY2hlbWUoKToge3NjaGVtZTogcmVhZG9ubHkgc3RyaW5nW10sIHNraXBJbmRpY2VzOiBTZXQ8bnVtYmVyPn1cbiAgICB7XG4gICAgICAgIHJldHVybiB7c2NoZW1lOiBkMy5zY2hlbWVTZXQxLCBza2lwSW5kaWNlczogbmV3IFNldDxudW1iZXI+KFs1LCA4XSl9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Q29sb3IobGFiZWxzOiBzdHJpbmdbXSwgY29sb3JMb29rdXA6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiBzdHJpbmdcblx0e1xuXHRcdGZvciAobGV0IGtleSBvZiBsYWJlbHMpXG5cdFx0e1xuXHRcdFx0aWYgKGNvbG9yTG9va3VwLmhhcyhrZXkpKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gY29sb3JMb29rdXAuZ2V0KGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAnZ3JleSc7XG5cdH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQge1N2Z1NlbGVjdGlvbn0gZnJvbSAnLi4vZGV2bGliL0RldkxpYlR5cGVzJztcbmltcG9ydCB7QmFzZVdpZGdldH0gZnJvbSAnLi9CYXNlV2lkZ2V0JztcbmltcG9ydCB7IFBvaW50Q29sbGVjdGlvbiB9IGZyb20gJy4uL0RhdGFNb2RlbC9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgTkRpbSB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUeXBlcyc7XG5pbXBvcnQgeyBEYXRhc2V0U3BlYywgdmFsdWVGaWx0ZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBEZXZsaWJBbGdvIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYkFsZ28nO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlRTVXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBIaXN0b2dyYW1XaWRnZXQgZXh0ZW5kcyBCYXNlV2lkZ2V0PFBvaW50Q29sbGVjdGlvbiwgRGF0YXNldFNwZWM+IHtcblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRjb250YWluZXI6IEhUTUxFbGVtZW50LFxuXHRcdHZhbHVlS2V5OiBzdHJpbmcsXG5cdFx0Y2FuQnJ1c2g6IGJvb2xlYW4gPSB0cnVlLFxuXHRcdGluY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uOiBib29sZWFuID0gZmFsc2UsXG5cdFx0aXNDbG9uZTogYm9vbGVhbiA9IGZhbHNlKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCB0cnVlLCBjYW5CcnVzaCwgaW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24pO1xuXHRcdHRoaXMuX3ZhbHVlS2V5ID0gdmFsdWVLZXk7XG5cdFx0dGhpcy5zZXRMYWJlbCgpO1xuXHRcdHRoaXMuX2lzQ2xvbmUgPSBpc0Nsb25lO1xuXHR9XG5cbiAgICBwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8UG9pbnRDb2xsZWN0aW9uLCBEYXRhc2V0U3BlYz5cbiAgICB7XG5cdFx0Y29uc3QgY2FuQnJ1c2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IGNsb25lID0gbmV3IEhpc3RvZ3JhbVdpZGdldChjb250YWluZXIsIHRoaXMudmFsdWVLZXksIGNhbkJydXNoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cblx0cHJpdmF0ZSBfaXNDbG9uZSA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaXNDbG9uZSgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzQ2xvbmU7XG5cdH1cblxuXHRwcm90ZWN0ZWQgaW5pdFByb3BzKHByb3BzPzogYW55W10pOiB2b2lkXG5cdHtcblx0XHRzdXBlci5pbml0UHJvcHMoKTtcblx0XHR0aGlzLl9jYW5CcnVzaCA9IHByb3BzWzBdO1xuXHRcdHRoaXMuX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uID0gcHJvcHNbMV07XG5cdH1cblxuXHRwcml2YXRlIF92YWx1ZUtleSA6IHN0cmluZztcblx0cHVibGljIGdldCB2YWx1ZUtleSgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVLZXk7XG5cdH1cblx0XG5cdHByaXZhdGUgX3NvcnRlZERhdGEgOiBORGltW107XG5cdHB1YmxpYyBnZXQgc29ydGVkRGF0YSgpIDogTkRpbVtdIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydGVkRGF0YTtcblx0fVxuXG5cdHByaXZhdGUgX3N2Z1NlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBzdmdTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N2Z1NlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX21haW5Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBtYWluR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX21haW5Hcm91cFNlbGVjdDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfdG90YWxIaXN0b2dyYW1Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB0b3RhbEhpc3RvZ3JhbUdyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl90b3RhbEhpc3RvZ3JhbUdyb3VwU2VsZWN0O1xuXHR9XG5cdFxuXHRwcml2YXRlIF9icnVzaGVkSGlzdG9ncmFtR3JvdXBTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgYnJ1c2hlZEhpc3RvZ3JhbUdyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaGVkSGlzdG9ncmFtR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF90b3RhbEtERUdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHRvdGFsS0RFR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvdGFsS0RFR3JvdXBTZWxlY3Q7XG5cdH1cblx0XG5cdHByaXZhdGUgX2JydXNoZWRLREVHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBicnVzaGVkS0RFR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoZWRLREVHcm91cFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX2NhbkJydXNoIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBjYW5CcnVzaCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbkJydXNoO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2hHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBicnVzaEdyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaEdyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfYXhpc0dyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGF4aXNHcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fYXhpc0dyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbGFiZWxUZXh0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGxhYmVsVGV4dFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWxUZXh0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhbGVYIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IHNjYWxlWCgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGVYO1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhbGVZSGlzdG9ncmFtQWJzb2x1dGUgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVZSGlzdG9ncmFtQWJzb2x1dGUoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYWxlWUhpc3RvZ3JhbUFic29sdXRlO1xuXHR9XG5cdHByaXZhdGUgX3NjYWxlWUhpc3RvZ3JhbVJlbGF0aXZlIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IHNjYWxlWUhpc3RvZ3JhbVJlbGF0aXZlKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVlIaXN0b2dyYW1SZWxhdGl2ZTtcblx0fVxuXG5cdHByaXZhdGUgX3NjYWxlWUtkZUFic29sdXRlIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IHNjYWxlWUtkZUFic29sdXRlKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVlLZGVBYnNvbHV0ZTtcblx0fVxuXHRwcml2YXRlIF9zY2FsZVlLZGVSZWxhdGl2ZSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcblx0cHVibGljIGdldCBzY2FsZVlLZGVSZWxhdGl2ZSgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhbGVZS2RlUmVsYXRpdmU7XG5cdH1cblxuXG5cdHByaXZhdGUgX2FsbEJpbnMgOiBkMy5CaW48TkRpbSwgbnVtYmVyPltdO1xuXHRwdWJsaWMgZ2V0IGFsbEJpbnMoKSA6IGQzLkJpbjxORGltLCBudW1iZXI+W10ge1xuXHRcdHJldHVybiB0aGlzLl9hbGxCaW5zO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9icnVzaGVkQmlucyA6IGQzLkJpbjxORGltLCBudW1iZXI+W107XG5cdHB1YmxpYyBnZXQgYnJ1c2hlZEJpbnMoKSA6IGQzLkJpbjxORGltLCBudW1iZXI+W10ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaGVkQmlucztcblx0fVxuXHRwdWJsaWMgc2V0IGJydXNoZWRCaW5zKHYgOiBkMy5CaW48TkRpbSwgbnVtYmVyPltdKSB7XG5cdFx0dGhpcy5fYnJ1c2hlZEJpbnMgPSB2O1xuXHR9XG5cblx0cHJpdmF0ZSBfYWxsUGF0aFBvaW50cyA6IFtudW1iZXIsIG51bWJlcl1bXTtcblx0cHVibGljIGdldCBhbGxQYXRoUG9pbnRzKCkgOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuXHRcdHJldHVybiB0aGlzLl9hbGxQYXRoUG9pbnRzO1xuXHR9XG5cblx0cHJpdmF0ZSBfbWF4RGVuc2l0eUFsbCA6IG51bWJlcjtcblx0cHVibGljIGdldCBtYXhEZW5zaXR5QWxsKCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9tYXhEZW5zaXR5QWxsO1xuXHR9XHRcblxuXHRwcml2YXRlIF9icnVzaGVkUGF0aFBvaW50cyA6IFtudW1iZXIsIG51bWJlcl1bXTtcblx0cHVibGljIGdldCBicnVzaGVkUGF0aFBvaW50cygpIDogW251bWJlciwgbnVtYmVyXVtdIHtcblx0XHRyZXR1cm4gdGhpcy5fYnJ1c2hlZFBhdGhQb2ludHM7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaGVkUG9pbnRzTGVuZ3RoIDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGJydXNoZWRQb2ludHNMZW5ndGgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoZWRQb2ludHNMZW5ndGg7XG5cdH1cdFxuXG5cdHByaXZhdGUgX2F4aXNQYWRkaW5nIDogIG51bWJlcjtcblx0cHVibGljIGdldCBheGlzUGFkZGluZygpIDogIG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2F4aXNQYWRkaW5nO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2ggOiBkMy5CcnVzaEJlaGF2aW9yPGFueT47XG5cdHB1YmxpYyBnZXQgYnJ1c2goKSA6IGQzLkJydXNoQmVoYXZpb3I8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoO1xuXHR9XG5cdFxuXHRcblx0cHJpdmF0ZSBfdXNlSGlzdG9ncmFtQnV0dG9uIDogSFRNTEJ1dHRvbkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgdXNlSGlzdG9ncmFtQnV0dG9uKCkgOiBIVE1MQnV0dG9uRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX3VzZUhpc3RvZ3JhbUJ1dHRvbjtcblx0fVxuXG5cdHByaXZhdGUgX3VzZUtERUJ1dHRvbiA6IEhUTUxCdXR0b25FbGVtZW50O1xuXHRwdWJsaWMgZ2V0IHVzZUtERUJ1dHRvbigpIDogSFRNTEJ1dHRvbkVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl91c2VLREVCdXR0b247XG5cdH1cblx0XG5cdHByaXZhdGUgc3RhdGljIF91c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0gOiBib29sZWFuID0gZmFsc2U7XG5cdFxuXHRwcml2YXRlIHN0YXRpYyBnZXQgdXNlS2RlSW5zdGVhZE9mSGlzdG9ncmFtKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gSGlzdG9ncmFtV2lkZ2V0Ll91c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW07XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBzZXQgdXNlS2RlSW5zdGVhZE9mSGlzdG9ncmFtKHYgOiBib29sZWFuKSB7XG5cdFx0SGlzdG9ncmFtV2lkZ2V0Ll91c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0gPSB2O1xuXHRcdGxldCBldmVudCA9IG5ldyBFdmVudCgnc3dpdGNoQmV0d2VlbktkZUFuZEhpc3RvZ3JhbScpO1xuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9XHRcblx0XG5cdFxuXHRwcml2YXRlIF91c2VBYnNvbHV0ZUJ1dHRvbiA6IEhUTUxCdXR0b25FbGVtZW50O1xuXHRwdWJsaWMgZ2V0IHVzZUFic29sdXRlQnV0dG9uKCkgOiBIVE1MQnV0dG9uRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX3VzZUFic29sdXRlQnV0dG9uO1xuXHR9XG5cblx0cHJpdmF0ZSBfdXNlUmVsYXRpdmVCdXR0b24gOiBIVE1MQnV0dG9uRWxlbWVudDtcblx0cHVibGljIGdldCB1c2VSZWxhdGl2ZUJ1dHRvbigpIDogSFRNTEJ1dHRvbkVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl91c2VSZWxhdGl2ZUJ1dHRvbjtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIF91c2VBYnNvbHV0ZVNjYWxpbmcgOiBib29sZWFuID0gdHJ1ZTtcblx0XG5cdHByaXZhdGUgc3RhdGljIGdldCB1c2VBYnNvbHV0ZVNjYWxpbmcoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBIaXN0b2dyYW1XaWRnZXQuX3VzZUFic29sdXRlU2NhbGluZztcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIHNldCB1c2VBYnNvbHV0ZVNjYWxpbmcodiA6IGJvb2xlYW4pIHtcblx0XHRIaXN0b2dyYW1XaWRnZXQuX3VzZUFic29sdXRlU2NhbGluZyA9IHY7XG5cdFx0bGV0IGV2ZW50ID0gbmV3IEV2ZW50KCdzd2l0Y2hCZXR3ZWVuQWJzb2x1dGVBbmRSZWxhdGl2ZVNjYWxpbmcnKTtcblx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblx0fVxuXG5cdFxuXHRwcml2YXRlIF9pbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbiA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24oKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbjtcblx0fVxuXHRwdWJsaWMgc2V0IGluY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uKHYgOiBib29sZWFuKSB7XG5cdFx0dGhpcy5faW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24gPSB2O1xuXHR9XG5cdFxuXG5cdHByb3RlY3RlZCBzZXRNYXJnaW4oKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fbWFyZ2luID0ge1xuXHRcdFx0dG9wOiA2LFxuXHRcdFx0cmlnaHQ6IDgsXG5cdFx0XHRib3R0b206IDUwLFxuXHRcdFx0bGVmdDogOFxuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBpbml0KCk6IHZvaWRcblx0e1xuXHRcdFxuXHRcdHRoaXMuaW5pdEtERUhJc3RvZ3JhbVRvZ2dsZSgpO1xuXHRcdHRoaXMuaW5pdEFic29sdXRlUmVsYXRpdmVUb2dnbGUoKTtcblx0XHRpZiAodGhpcy5pbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbilcblx0XHR7XG5cdFx0XHR0aGlzLmluaXRFeGVtcGxhclRyYWNrQnV0dG9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc3ZnU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMuY29udGFpbmVyKS5hcHBlbmQoXCJzdmdcIilcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgdGhpcy53aWR0aClcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0KTtcblxuXHRcdHRoaXMuX21haW5Hcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKTtcblx0XHRcblx0XHRpZiAodGhpcy5jYW5CcnVzaClcblx0XHR7XG5cdFx0XHR0aGlzLl9icnVzaEdyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYClcblx0XHRcdFx0LmNsYXNzZWQoXCJicnVzaENvbnRhaW5lclwiLCB0cnVlKTtcblxuXHRcdFx0dGhpcy5fYnJ1c2ggPSBkMy5icnVzaFgoKVxuXHRcdFx0XHQuZXh0ZW50KFtbMCwgMF0sIFt0aGlzLnZpeldpZHRoLCB0aGlzLnZpekhlaWdodF1dKVxuXHRcdFx0XHQub24oXCJlbmRcIiwgKCkgPT4geyB0aGlzLmJydXNoSGFuZGxlcigpIH0pO1xuXHRcdFxuXHRcdFx0dGhpcy5icnVzaEdyb3VwU2VsZWN0LmNhbGwodGhpcy5icnVzaCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG90YWxIaXN0b2dyYW1Hcm91cFNlbGVjdCA9IHRoaXMubWFpbkdyb3VwU2VsZWN0LmFwcGVuZCgnZycpO1xuXHRcdHRoaXMuX2JydXNoZWRIaXN0b2dyYW1Hcm91cFNlbGVjdCA9IHRoaXMubWFpbkdyb3VwU2VsZWN0LmFwcGVuZCgnZycpO1xuXG5cdFx0dGhpcy5fdG90YWxLREVHcm91cFNlbGVjdCA9IHRoaXMubWFpbkdyb3VwU2VsZWN0LmFwcGVuZCgnZycpO1xuXHRcdHRoaXMuX2JydXNoZWRLREVHcm91cFNlbGVjdCA9IHRoaXMubWFpbkdyb3VwU2VsZWN0LmFwcGVuZCgnZycpO1xuXG5cdFx0dGhpcy5fYXhpc1BhZGRpbmcgPSAyO1xuXG5cdFx0dGhpcy5fYXhpc0dyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCdnJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgKyB0aGlzLmF4aXNQYWRkaW5nfSlgKVxuXHRcdFx0LmNsYXNzZWQoJ2xhYmVsQ29sb3InLCB0cnVlKTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2V4ZW1wbGFyQXR0cmlidXRlQ2hhbmdlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcblx0XHR7XG5cdFx0XHRsZXQgbmV3RXhlbXBsYXJBdHRyaWJ1dGUgPSBlLmRldGFpbDtcblx0XHRcdGlmIChuZXdFeGVtcGxhckF0dHJpYnV0ZSA9PT0gdGhpcy52YWx1ZUtleSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgaW5pdEtERUhJc3RvZ3JhbVRvZ2dsZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl91c2VIaXN0b2dyYW1CdXR0b24gPSB0aGlzLkFkZEJ1dHRvbignY2hhcnQtYmFyJywgJ0NoYW5nZSB0byBoaXN0b2dyYW1zJywgKCkgPT5cblx0XHR7XG5cdFx0XHRIaXN0b2dyYW1XaWRnZXQudXNlS2RlSW5zdGVhZE9mSGlzdG9ncmFtID0gZmFsc2U7XG5cdFx0fSk7XG5cdFx0XG5cdFx0dGhpcy5fdXNlS0RFQnV0dG9uID0gdGhpcy5BZGRCdXR0b24oJ2NoYXJ0LWFyZWEnLCAnQ2hhbmdlIHRvIGtlcm5lbCBkZW5zaXR5IHBsb3RzJywgKCkgPT5cblx0XHR7XG5cdFx0XHRIaXN0b2dyYW1XaWRnZXQudXNlS2RlSW5zdGVhZE9mSGlzdG9ncmFtID0gdHJ1ZTtcblx0XHR9KTtcblx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0LnVzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbSlcblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnVzZUtERUJ1dHRvbik7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnVzZUhpc3RvZ3JhbUJ1dHRvbik7XG5cdFx0fVxuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3dpdGNoQmV0d2VlbktkZUFuZEhpc3RvZ3JhbScsIChlOiBFdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0aWYgKEhpc3RvZ3JhbVdpZGdldC51c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0pXG5cdFx0XHR7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMudXNlSGlzdG9ncmFtQnV0dG9uKTtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VLREVCdXR0b24pO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnVzZUhpc3RvZ3JhbUJ1dHRvbik7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMudXNlS0RFQnV0dG9uKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuT25EYXRhQ2hhbmdlKCk7XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIGluaXRBYnNvbHV0ZVJlbGF0aXZlVG9nZ2xlKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3VzZUFic29sdXRlQnV0dG9uID0gdGhpcy5BZGRCdXR0b24oJ2hhc2h0YWcnLCAnQ2hhbmdlIHRvIGFic29sdXRlIGNvbXBhcmlzb24gb2Ygc2VsZWN0aW9ucy4nLCAoKSA9PlxuXHRcdHtcblx0XHRcdEhpc3RvZ3JhbVdpZGdldC51c2VBYnNvbHV0ZVNjYWxpbmcgPSB0cnVlO1xuXHRcdH0pO1xuXHRcdFxuXHRcdHRoaXMuX3VzZVJlbGF0aXZlQnV0dG9uID0gdGhpcy5BZGRCdXR0b24oJ3BlcmNlbnQnLCAnQ2hhbmdlIHRvIHJlbGF0aXZlIGNvbXBhcmlzb24gb2Ygc2VsZWN0aW9ucy4nLCAoKSA9PlxuXHRcdHtcblx0XHRcdEhpc3RvZ3JhbVdpZGdldC51c2VBYnNvbHV0ZVNjYWxpbmcgPSBmYWxzZTtcblx0XHR9KTtcblx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0LnVzZUFic29sdXRlU2NhbGluZylcblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnVzZUFic29sdXRlQnV0dG9uKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMudXNlUmVsYXRpdmVCdXR0b24pO1xuXHRcdH1cblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3N3aXRjaEJldHdlZW5BYnNvbHV0ZUFuZFJlbGF0aXZlU2NhbGluZycsIChlOiBFdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcIm5vRGlzcFwiKSlcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEhpc3RvZ3JhbVdpZGdldC51c2VBYnNvbHV0ZVNjYWxpbmcpXG5cdFx0XHR7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMudXNlUmVsYXRpdmVCdXR0b24pO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnVzZUFic29sdXRlQnV0dG9uKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy51c2VSZWxhdGl2ZUJ1dHRvbik7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMudXNlQWJzb2x1dGVCdXR0b24pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKEhpc3RvZ3JhbVdpZGdldC51c2VLZGVJbnN0ZWFkT2ZIaXN0b2dyYW0pXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZHJhd0FsbEtERShmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZHJhd0FsbEhpc3RvZ3JhbXMoW10sIHRydWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0RXhlbXBsYXJUcmFja0J1dHRvbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLkFkZEJ1dHRvbigncm9ja2V0JywgJ1NhbXBsZSBuZXcgZXhlbXBsYXJzIGZyb20gdGhpcyBhdHRyaWJ1dGUuJywgYXN5bmMgKCkgPT5cblx0XHR7XG5cdFx0XHRsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2xhdW5jaEV4ZW1wbGFyQ3VydmUnLCB7ZGV0YWlsOiB0aGlzLnZhbHVlS2V5fSk7XG5cdFx0XHREZXZsaWJUU1V0aWwubGF1bmNoU3Bpbm5lcigpO1xuXHRcdFx0YXdhaXQgRGV2bGliVFNVdGlsLm1ha2VBc3luYygoKSA9PiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KSk7XG5cdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIHNldExhYmVsKCk6IHZvaWRcblx0e1x0XG5cdFx0Y29uc3QgYnVmZmVyRm9yQXhpcyA9IDMyICsgdGhpcy5heGlzUGFkZGluZztcblx0XHR0aGlzLl9sYWJlbFRleHRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0ICsgdGhpcy52aXpXaWR0aCAvIDJ9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0ICsgYnVmZmVyRm9yQXhpc30pYClcblx0XHRcdC5jbGFzc2VkKCdheGlzTGFiZWwnLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ2xhYmVsQ29sb3InLCB0cnVlKVxuXHRcdFx0LnRleHQodGhpcy52YWx1ZUtleSk7XG5cdH1cblxuXHRwdWJsaWMgT25EYXRhQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJub0Rpc3BcIikpXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgdmFsaWROdW1iZXJzID0gdGhpcy5kYXRhLkFycmF5LmZpbHRlcihkID0+ICFpc05hTihkLmdldCh0aGlzLnZhbHVlS2V5KSkpO1x0XG5cdFx0dGhpcy5fYWxsQmlucyA9IHRoaXMuY2FsY3VsYXRlQmlucyh2YWxpZE51bWJlcnMpO1xuXHRcdHRoaXMudXBkYXRlU2NhbGVzKHZhbGlkTnVtYmVycy5sZW5ndGgpO1xuXHRcdGlmIChIaXN0b2dyYW1XaWRnZXQuX3VzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbSlcblx0XHR7XG5cdFx0XHRsZXQgc2hhbGxvd0NvcHkgPSBbLi4udmFsaWROdW1iZXJzXTtcblx0XHRcdGNvbnN0IGtleSA9IHRoaXMudmFsdWVLZXk7XG5cdFx0XHR0aGlzLl9zb3J0ZWREYXRhID0gc2hhbGxvd0NvcHkuc29ydCgoYSxiKSA9PiBkMy5hc2NlbmRpbmcoYS5nZXQoa2V5KSwgYi5nZXQoa2V5KSkpO1xuXG5cdFx0XHR0aGlzLl9hbGxQYXRoUG9pbnRzID0gdGhpcy5rZGUodGhpcy5zb3J0ZWREYXRhKTtcblx0XHRcdHRoaXMuX21heERlbnNpdHlBbGwgPSBkMy5tYXgodGhpcy5hbGxQYXRoUG9pbnRzLCBkID0+IGRbMV0pO1xuXHRcdFx0dGhpcy5kcmF3QWxsS0RFKGZhbHNlKVxuXHRcdFx0dGhpcy5yZW1vdmVIaXN0b2dyYW1zKCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLmRyYXdBbGxIaXN0b2dyYW1zKHZhbGlkTnVtYmVycyk7XG5cdFx0XHR0aGlzLnJlbW92ZUtERXMoKTtcblx0XHR9XG5cblx0XHR0aGlzLmRyYXdBeGlzKCk7XG5cdH1cblxuXHRwcml2YXRlIGNhbGN1bGF0ZUJpbnMocG9pbnRzOiBORGltW10pOiBkMy5CaW48TkRpbSwgbnVtYmVyPltdXG5cdHtcblx0XHRsZXQgYmlucyA9IEhpc3RvZ3JhbVdpZGdldC5jYWxjdWxhdGVCaW5zKHBvaW50cywgdGhpcy52YWx1ZUtleSwgdGhpcy5mdWxsRGF0YSk7XG5cdFx0cmV0dXJuIGJpbnM7XG5cdH1cblxuXG5cdHB1YmxpYyBzdGF0aWMgY2FsY3VsYXRlQmlucyhwb2ludHM6IE5EaW1bXSwgdmFsdWVLZXk6IHN0cmluZywgZnVsbERhdGE6IFBvaW50Q29sbGVjdGlvbiwgbnVtQmlucz86IG51bWJlciwgc2tpcE5pY2U6IGJvb2xlYW4gPSBmYWxzZSk6IGQzLkJpbjxORGltLCBudW1iZXI+W11cblx0e1xuXHRcdGxldCBjb3VudDogbnVtYmVyO1xuXHRcdGlmIChudW1CaW5zKVxuXHRcdHtcblx0XHRcdGNvdW50ID0gbnVtQmlucztcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGNvdW50ID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoZnVsbERhdGEubGVuZ3RoKSkgLyAzO1xuXHRcdH1cblx0XHRsZXQgbWluTWF4ID0gZnVsbERhdGEuZ2V0TWluTWF4KHZhbHVlS2V5KTtcblx0XHRsZXQgeCA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4obWluTWF4KTtcblxuXHRcdGxldCB0aHJlc2hvbGRzOiBudW1iZXJbXTtcblx0XHRpZiAoIXNraXBOaWNlKVxuXHRcdHtcblx0XHRcdHggPSB4Lm5pY2UoY291bnQpO1xuXHRcdFx0dGhyZXNob2xkcyA9IHgudGlja3MoY291bnQpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhyZXNob2xkcyA9IGQzLnJhbmdlKG1pbk1heFswXSwgbWluTWF4WzFdLCAobWluTWF4WzFdIC0gbWluTWF4WzBdKSAvIGNvdW50KTtcblx0XHR9XG5cblx0XHRsZXQgYmlucyA9IGQzLmhpc3RvZ3JhbTxORGltLCBudW1iZXI+KClcblx0XHRcdC5kb21haW4oeC5kb21haW4oKSBhcyBbbnVtYmVyLCBudW1iZXJdKVxuXHRcdFx0LnRocmVzaG9sZHModGhyZXNob2xkcylcblx0XHRcdC52YWx1ZShkID0+IGQuZ2V0KHZhbHVlS2V5KSlcblx0XHRcdChwb2ludHMpO1xuXG5cdFx0Ly8gYWNjb3VudCBmb3IgZGVnZW5lcmF0ZSBsYXN0IGJpbiAtXy1cblx0XHRsZXQgdWx0aW1hdGVCaW4gPSBiaW5zW2JpbnMubGVuZ3RoIC0gMV07XG5cdFx0aWYgKHVsdGltYXRlQmluLngwID09PSB1bHRpbWF0ZUJpbi54MSlcblx0XHR7XG5cdFx0XHRsZXQgcGVudWx0aW1hdGVCaW4gPSBiaW5zW2JpbnMubGVuZ3RoIC0gMl1cblx0XHRcdGlmIChwZW51bHRpbWF0ZUJpbilcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgdWx0aW1hdGVCaW4pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwZW51bHRpbWF0ZUJpbi5wdXNoKHBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYmlucztcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlSGlzdG9ncmFtcygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnRvdGFsSGlzdG9ncmFtR3JvdXBTZWxlY3QuaHRtbChudWxsKTtcblx0XHR0aGlzLmJydXNoZWRIaXN0b2dyYW1Hcm91cFNlbGVjdC5odG1sKG51bGwpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3QWxsSGlzdG9ncmFtcyh2YWxpZE51bWJlcnM/OiBORGltW10sIHNraXBSZWNhbGN1bGF0aW9uID0gZmFsc2UpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKFwibm9EaXNwXCIpKVxuXHRcdHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCFza2lwUmVjYWxjdWxhdGlvbilcblx0XHR7XG5cdFx0XHRsZXQgYnJ1c2hlZE51bWJlcnMgPSB2YWxpZE51bWJlcnMuZmlsdGVyKGQgPT4gZC5pbkJydXNoKTtcblx0XHRcdGlmICh2YWxpZE51bWJlcnMubGVuZ3RoID09PSBicnVzaGVkTnVtYmVycy5sZW5ndGgpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuYnJ1c2hlZEhpc3RvZ3JhbUdyb3VwU2VsZWN0Lmh0bWwobnVsbCk7XG5cdFx0XHRcdHRoaXMuX2JydXNoZWRCaW5zID0gW11cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5fYnJ1c2hlZEJpbnMgPSB0aGlzLmNhbGN1bGF0ZUJpbnMoYnJ1c2hlZE51bWJlcnMpO1xuXHRcdFx0fVx0XG5cdFx0XHRcblx0XHRcdGxldCBiaWdnZXN0QmluUmVsYXRpdmVBbGwgPSBkMy5tYXgodGhpcy5hbGxCaW5zLCBkID0+IGQubGVuZ3RoIC8gdmFsaWROdW1iZXJzLmxlbmd0aCk7XG5cdFx0XHRsZXQgYmlnZ2VzdEJpblJlbGF0aXZlQnJ1c2hlZCA9IGQzLm1heCh0aGlzLmJydXNoZWRCaW5zLCBkID0+IGQubGVuZ3RoIC8gYnJ1c2hlZE51bWJlcnMubGVuZ3RoKTtcblx0XHRcdHRoaXMuX3NjYWxlWUhpc3RvZ3JhbVJlbGF0aXZlID0gZDMuc2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+KClcblx0XHRcdFx0LmRvbWFpbihbMCwgZDMubWF4KFtiaWdnZXN0QmluUmVsYXRpdmVBbGwsIGJpZ2dlc3RCaW5SZWxhdGl2ZUJydXNoZWRdKV0pXG5cdFx0XHRcdC5yYW5nZShbMCwgdGhpcy52aXpIZWlnaHRdKTtcblx0XHR9XG5cblxuXHRcdHRoaXMuZHJhd0hpc3RvZ3JhbSh0aGlzLnRvdGFsSGlzdG9ncmFtR3JvdXBTZWxlY3QsIHRoaXMuYWxsQmlucyk7XG5cdFx0dGhpcy5kcmF3SGlzdG9ncmFtKHRoaXMuYnJ1c2hlZEhpc3RvZ3JhbUdyb3VwU2VsZWN0LCB0aGlzLmJydXNoZWRCaW5zLCB0cnVlKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0hpc3RvZ3JhbShzZWxlY3Q6IFN2Z1NlbGVjdGlvbiwgYmluczogZDMuQmluPE5EaW0sIG51bWJlcj5bXSwgaW5CcnVzaDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0aWYgKGJpbnMubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHNlbGVjdC5odG1sKG51bGwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgcGF0aFBvaW50cyA9IHRoaXMuZ2V0SGlzdG9ncmFtU2t5bGluZShiaW5zKTtcblx0XHRsZXQgbGluZUZ1bmMgPSBkMy5saW5lKClcblx0XHRcdC54KGQgPT4gZFswXSlcblx0XHRcdC55KGQgPT4gZFsxXSlcblx0XHRcdC5kZWZpbmVkKGQgPT4gZFswXSAhPT0gbnVsbCk7XG5cblxuXHRcdHNlbGVjdC5zZWxlY3RBbGwoJ3BhdGgnKVxuXHRcdFx0LmRhdGEoW2xpbmVGdW5jKHBhdGhQb2ludHMpXSlcblx0XHRcdC5qb2luKCdwYXRoJylcblx0XHRcdC5jbGFzc2VkKCdrZGVQYXRoJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdpbkJydXNoJywgaW5CcnVzaClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5hdHRyKCdkJywgZCA9PiBkKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0SGlzdG9ncmFtU2t5bGluZShiaW5zOiBkMy5CaW48TkRpbSwgbnVtYmVyPltdLCBzaW5nbGVXaWR0aDogbnVtYmVyID0gMTgpOiBbbnVtYmVyLCBudW1iZXJdW11cblx0e1xuXHRcdGxldCBwYXRoUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcblxuXHRcdGlmIChiaW5zLmxlbmd0aCA9PT0gMSlcblx0XHR7XG5cdFx0XHRsZXQgbGVmdCA9ICh0aGlzLnZpeldpZHRoIC0gc2luZ2xlV2lkdGgpIC8gMjtcblx0XHRcdGxldCByaWdodCA9ICh0aGlzLnZpeldpZHRoICsgc2luZ2xlV2lkdGgpIC8gMlxuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFtsZWZ0LCB0aGlzLnZpekhlaWdodF0pO1xuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFtsZWZ0LCAwXSk7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3JpZ2h0LCAwXSk7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3JpZ2h0LCB0aGlzLnZpekhlaWdodF0pO1xuXHRcdFx0cmV0dXJuIHBhdGhQb2ludHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdG90YWxDb3VudCA9IGQzLnN1bShiaW5zLCBiaW4gPT4gYmluLmxlbmd0aCk7XG5cblx0XHRmb3IgKGxldCBiaW4gb2YgYmlucylcblx0XHR7XG5cdFx0XHRsZXQgeDE6IG51bWJlciA9IHRoaXMuc2NhbGVYKGJpbi54MCk7XG5cdFx0XHRsZXQgb2Zmc2V0OiBudW1iZXI7XG5cdFx0XHRpZiAoSGlzdG9ncmFtV2lkZ2V0LnVzZUFic29sdXRlU2NhbGluZylcblx0XHRcdHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5zY2FsZVlIaXN0b2dyYW1BYnNvbHV0ZShiaW4ubGVuZ3RoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5zY2FsZVlIaXN0b2dyYW1SZWxhdGl2ZShiaW4ubGVuZ3RoIC8gdG90YWxDb3VudCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgeTogbnVtYmVyID0gdGhpcy52aXpIZWlnaHQgLSBvZmZzZXQ7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3gxLCB5XSk7XG5cblx0XHRcdGlmIChiaW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgc3BsaXRQb2ludDogW251bWJlciwgbnVtYmVyXSA9IFtudWxsLCBudWxsXTtcblx0XHRcdFx0cGF0aFBvaW50cy5wdXNoKHNwbGl0UG9pbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgeDI6IG51bWJlciA9IHRoaXMuc2NhbGVYKGJpbi54MSk7XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3gyLCB5XSk7XG5cdFx0fVxuXHRcdFxuXG5cdFx0cGF0aFBvaW50cy51bnNoaWZ0KFswLCB0aGlzLnZpekhlaWdodF0pO1xuXHRcdHBhdGhQb2ludHMucHVzaChbdGhpcy52aXpXaWR0aCwgdGhpcy52aXpIZWlnaHRdKTtcblxuXHRcdHJldHVybiBwYXRoUG9pbnRzO1xuXHR9XG5cblxuXHRwcml2YXRlIHJlbW92ZUtERXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy50b3RhbEtERUdyb3VwU2VsZWN0Lmh0bWwobnVsbCk7XG5cdFx0dGhpcy5icnVzaGVkS0RFR3JvdXBTZWxlY3QuaHRtbChudWxsKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0FsbEtERShmaWx0ZXJDaGFuZ2VkOiBib29sZWFuKTogdm9pZFxuXHR7XG5cblx0XHRsZXQgYnJ1c2hlZFBvaW50cyA9IHRoaXMuc29ydGVkRGF0YS5maWx0ZXIoZCA9PiBkLmluQnJ1c2gpO1xuXHRcdHRoaXMuX2JydXNoZWRQYXRoUG9pbnRzID0gdGhpcy5rZGUoYnJ1c2hlZFBvaW50cyk7XG5cdFx0dGhpcy5fYnJ1c2hlZFBvaW50c0xlbmd0aCA9IGJydXNoZWRQb2ludHMubGVuZ3RoO1xuXG5cdFx0bGV0IG1heERvbWFpbiA9IHRoaXMubWF4RGVuc2l0eUFsbDtcblx0XHRpZiAoIUhpc3RvZ3JhbVdpZGdldC51c2VBYnNvbHV0ZVNjYWxpbmcpXG5cdFx0e1xuXHRcdFx0bGV0IG1heFZhbEJydXNoZWQgPSBkMy5tYXgodGhpcy5icnVzaGVkUGF0aFBvaW50cywgZCA9PiBkWzFdKTtcblx0XHRcdG1heERvbWFpbiA9IGQzLm1heChbbWF4RG9tYWluLCBtYXhWYWxCcnVzaGVkXSlcblx0XHR9XG5cblx0XHR0aGlzLl9zY2FsZVlLZGVSZWxhdGl2ZSA9IGQzLnNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPigpXG5cdFx0XHQuZG9tYWluKFswLCBtYXhEb21haW5dKVxuXHRcdFx0LnJhbmdlKFt0aGlzLnZpekhlaWdodCwgMF0pO1xuXG5cdFx0aWYgKCFmaWx0ZXJDaGFuZ2VkIHx8IEhpc3RvZ3JhbVdpZGdldC51c2VBYnNvbHV0ZVNjYWxpbmcpXG5cdFx0e1x0XG5cdFx0XHR0aGlzLmRyYXdLREUodGhpcy5zb3J0ZWREYXRhLmxlbmd0aCwgdGhpcy5hbGxQYXRoUG9pbnRzLCBmYWxzZSwgdGhpcy50b3RhbEtERUdyb3VwU2VsZWN0KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuYnJ1c2hlZFBvaW50c0xlbmd0aCA9PT0gdGhpcy5zb3J0ZWREYXRhLmxlbmd0aClcblx0XHR7XG5cdFx0XHR0aGlzLmJydXNoZWRLREVHcm91cFNlbGVjdC5odG1sKG51bGwpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5kcmF3S0RFKHRoaXMuYnJ1c2hlZFBvaW50c0xlbmd0aCwgdGhpcy5icnVzaGVkUGF0aFBvaW50cywgdHJ1ZSwgdGhpcy5icnVzaGVkS0RFR3JvdXBTZWxlY3QpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgZHJhd0tERShudW1Qb2ludHM6IG51bWJlciwgcGF0aFBvaW50czogW251bWJlciwgbnVtYmVyXVtdLCBpbkJydXNoOiBib29sZWFuLCBzZWxlY3Q6IFN2Z1NlbGVjdGlvbik6IHZvaWRcblx0e1xuXHRcdGxldCB5RnVuYzogKGQ6IFtudW1iZXIsIG51bWJlcl0pID0+IG51bWJlcjtcblxuXHRcdGlmIChIaXN0b2dyYW1XaWRnZXQudXNlQWJzb2x1dGVTY2FsaW5nKVxuXHRcdHtcblx0XHRcdHlGdW5jID0gZCA9PiB0aGlzLnNjYWxlWUtkZVJlbGF0aXZlKChudW1Qb2ludHMgLyB0aGlzLnNvcnRlZERhdGEubGVuZ3RoICkgKiBkWzFdKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHlGdW5jID0gZCA9PiB0aGlzLnNjYWxlWUtkZVJlbGF0aXZlKGRbMV0pXG5cdFx0fVxuXG5cdFx0bGV0IGxpbmVGdW5jID0gZDMubGluZSgpXG5cdFx0XHQvLyAuY3VydmUoZDMuY3VydmVCYXNpcylcblx0XHRcdC54KGQgPT4gdGhpcy5zY2FsZVgoZFswXSkpXG5cdFx0XHQueSh5RnVuYylcblxuXHRcdHNlbGVjdC5zZWxlY3RBbGwoJ3BhdGgnKVxuXHRcdFx0LmRhdGEoW2xpbmVGdW5jKHBhdGhQb2ludHMpXSlcblx0XHRcdC5qb2luKCdwYXRoJylcblx0XHRcdC5jbGFzc2VkKCdrZGVQYXRoJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdpbkJydXNoJywgaW5CcnVzaClcblx0XHRcdC50cmFuc2l0aW9uKClcblx0XHRcdC5hdHRyKCdkJywgZCA9PiBkKTtcblx0fVxuXG5cdHByaXZhdGUga2RlKHBvaW50czogTkRpbVtdKTogW251bWJlciwgbnVtYmVyXVtdXG5cdHtcblx0XHQvLyBBc3N1bWVzIHRoYXQgcG9pbnRzIGlzIHNvcnRlZCBiYXNlZCBvbiB2YWx1ZUtleVxuXHRcdGNvbnN0IGtlcm5lbDogRnVuY3Rpb24gPSB0aGlzLmVwYW5lY2huaWtvdjtcblx0XHRsZXQgW2xvdywgaGlnaF0gPSB0aGlzLnNjYWxlWC5kb21haW4oKTtcblx0XHRjb25zdCBiYW5kd2lkdGg6IG51bWJlciA9IDAuMDEgKiAoaGlnaCAtIGxvdyk7XG5cdFx0bGV0IHRpY2tzID0gdGhpcy5zY2FsZVgudGlja3MoMTAwKTtcblxuXHRcdGxldCBwYXRoUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcblx0XHRmb3IgKGxldCB0IG9mIHRpY2tzKVxuXHRcdHtcblx0XHRcdC8vIGdldCBpbmRleCB3aXRoIHZhbHVlIGNsb3Nlc3QgdG8gdFxuXHRcdFx0bGV0IGNvbXBhcmVGdW5jdGlvbiA9IERldmxpYkFsZ28uY29tcGFyZVByb3BlcnR5PE5EaW0+KHQsIChwb2ludDogTkRpbSkgPT4gXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBwb2ludC5nZXQodGhpcy52YWx1ZUtleSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0bGV0IHN0YXJ0SW5kZXg6IG51bWJlcjtcblx0XHRcdGxldCBzZWFyY2hSZXN1bHQ6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl0gPSBEZXZsaWJBbGdvLkJpbmFyeVNlYXJjaEluZGV4KHBvaW50cywgY29tcGFyZUZ1bmN0aW9uKTtcblx0XG5cdFx0XHRpZiAodHlwZW9mIHNlYXJjaFJlc3VsdCA9PT0gXCJudW1iZXJcIilcblx0XHRcdHtcblx0XHRcdFx0c3RhcnRJbmRleCA9IHNlYXJjaFJlc3VsdDtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgW2lkeDEsIGlkeDJdID0gc2VhcmNoUmVzdWx0O1xuXHRcdFx0XHRpZiAodHlwZW9mIGlkeDEgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdGFydEluZGV4ID0gaWR4MTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRzdGFydEluZGV4ID0gaWR4Mjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRsZXQga2VybmVsU3VtID0gMDtcblx0XHRcdC8vIGxvb2sgZm9yd2FyZFxuXHRcdFx0Zm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggKyAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgcG9pbnQgPSBwb2ludHNbaV07XG5cdFx0XHRcdGxldCB1OiBudW1iZXIgPSAodCAtIHBvaW50LmdldCh0aGlzLnZhbHVlS2V5KSkgLyBiYW5kd2lkdGg7XG5cdFx0XHRcdGlmIChNYXRoLmFicyh1KSA+IDEpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXJuZWxTdW0gKz0ga2VybmVsKHUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb29rIGJhY2t3YXJkXG5cdFx0XHRmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA+PSAwOyBpLS0pXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBwb2ludCA9IHBvaW50c1tpXTtcblx0XHRcdFx0bGV0IHU6IG51bWJlciA9ICh0IC0gcG9pbnQuZ2V0KHRoaXMudmFsdWVLZXkpKSAvIGJhbmR3aWR0aDtcblx0XHRcdFx0aWYgKE1hdGguYWJzKHUpID4gMSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtlcm5lbFN1bSArPSBrZXJuZWwodSk7XG5cdFx0XHR9XG5cdFx0XHRwYXRoUG9pbnRzLnB1c2goW3QsIGtlcm5lbFN1bSAvIHBvaW50cy5sZW5ndGhdKTtcblx0XHR9XG5cblx0XHRwYXRoUG9pbnRzLnVuc2hpZnQoW2xvdywgMF0pO1xuXHRcdHBhdGhQb2ludHMucHVzaChbaGlnaCwgMF0pO1xuXHRcdHJldHVybiBwYXRoUG9pbnRzO1xuXHR9XG5cblx0cHJpdmF0ZSBlcGFuZWNobmlrb3YodTogbnVtYmVyKTogbnVtYmVyXG5cdHtcblx0XHQvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tlcm5lbF8oc3RhdGlzdGljcykjS2VybmVsX2Z1bmN0aW9uc19pbl9jb21tb25fdXNlXG5cdFx0aWYgKE1hdGguYWJzKHUpIDw9IDEpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIDAuNzUgKiAoMSAtIHUgKiB1KTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVNjYWxlcyh0b3RhbENvdW50OiBudW1iZXIpOiB2b2lkXG5cdHtcblxuXHRcdGxldCBtaW5CaW5Cb3VuZGFyeSA9IHRoaXMuYWxsQmluc1swXS54MDtcblx0XHRsZXQgbWF4QmluQm91bmRhcnkgPSB0aGlzLmFsbEJpbnNbdGhpcy5hbGxCaW5zLmxlbmd0aCAtIDFdLngxO1xuXG5cdFx0dGhpcy5fc2NhbGVYID0gZDMuc2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+KClcblx0XHRcdC5kb21haW4oW21pbkJpbkJvdW5kYXJ5LCBtYXhCaW5Cb3VuZGFyeV0pXG5cdFx0XHQucmFuZ2UoWzAsIHRoaXMudml6V2lkdGhdKTtcblxuXHRcdGxldCBiaWdnZXN0QmluQ291bnQgPSBkMy5tYXgodGhpcy5hbGxCaW5zLCBkID0+IGQubGVuZ3RoKTtcblx0XHR0aGlzLl9zY2FsZVlIaXN0b2dyYW1BYnNvbHV0ZSA9IGQzLnNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPigpXG5cdFx0XHQuZG9tYWluKFswLCBiaWdnZXN0QmluQ291bnRdKVxuXHRcdFx0LnJhbmdlKFswLCB0aGlzLnZpekhlaWdodF0pO1xuXHR9XG5cblx0cHVibGljIE1vdmVCcnVzaChuZXdSYW5nZTogW251bWJlciwgbnVtYmVyXSB8IG51bGwpOiB2b2lkXG5cdHtcblx0XHRpZiAobmV3UmFuZ2UpXG5cdFx0e1xuXHRcdFx0bmV3UmFuZ2VbMF0gPSB0aGlzLnNjYWxlWChuZXdSYW5nZVswXSk7XG5cdFx0XHRuZXdSYW5nZVsxXSA9IHRoaXMuc2NhbGVYKG5ld1JhbmdlWzFdKTtcblx0XHR9XG5cdFx0dGhpcy5icnVzaEdyb3VwU2VsZWN0LmNhbGwodGhpcy5icnVzaC5tb3ZlLCBuZXdSYW5nZSk7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdBeGlzKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuYXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuY2FsbChkMy5heGlzQm90dG9tKHRoaXMuc2NhbGVYKS50aWNrcyg1KSlcblx0fVxuXG5cdHByb3RlY3RlZCBPblJlc2l6ZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLk9uRGF0YUNoYW5nZSgpO1xuXHR9XG5cblx0cHJpdmF0ZSBicnVzaEhhbmRsZXIoKTogIHZvaWRcblx0e1xuXHRcdGNvbnN0IHNlbGVjdGlvbjogW251bWJlciwgbnVtYmVyXSB8IG51bGwgIHwgdW5kZWZpbmVkID0gZDMuZXZlbnQuc2VsZWN0aW9uO1xuXHRcdGlmICh0eXBlb2Ygc2VsZWN0aW9uID09PSBcInVuZGVmaW5lZFwiIHx8IHNlbGVjdGlvbiA9PT0gbnVsbClcblx0XHR7XG5cdFx0XHR0aGlzLmRhdGEucmVtb3ZlQnJ1c2godGhpcy5Db21wb25lbnRJZCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBbbWluQm91bmQsIG1heEJvdW5kXSA9IHNlbGVjdGlvbjtcblx0XHRsZXQgbWluViA9IHRoaXMuc2NhbGVYLmludmVydChtaW5Cb3VuZCk7XG5cdFx0bGV0IG1heFYgPSB0aGlzLnNjYWxlWC5pbnZlcnQobWF4Qm91bmQpO1xuXG5cdFx0bGV0IHZhbHVlRmlsdGVyOiB2YWx1ZUZpbHRlciA9IHtcblx0XHRcdGtleTogdGhpcy52YWx1ZUtleSxcblx0XHRcdGJvdW5kOiBbbWluViwgbWF4Vl1cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYWRkQnJ1c2godGhpcy5Db21wb25lbnRJZCwgdmFsdWVGaWx0ZXIpO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcIm5vRGlzcFwiKSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmIChIaXN0b2dyYW1XaWRnZXQuX3VzZUtkZUluc3RlYWRPZkhpc3RvZ3JhbSlcblx0XHR7XG5cdFx0XHQvLyB0aGlzLmRyYXdCcnVzaGVkS0RFKCk7XG5cdFx0XHR0aGlzLmRyYXdBbGxLREUodHJ1ZSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRsZXQgdmFsaWROdW1iZXJzID0gdGhpcy5kYXRhLkFycmF5LmZpbHRlcihkID0+ICFpc05hTihkLmdldCh0aGlzLnZhbHVlS2V5KSkpO1xuXHRcdFx0dGhpcy5kcmF3QWxsSGlzdG9ncmFtcyh2YWxpZE51bWJlcnMpO1xuXHRcdH1cblx0fVxuXG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBIdG1sU2VsZWN0aW9uLCBTdmdTZWxlY3Rpb24gfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHsgQmFzZVdpZGdldCB9IGZyb20gJy4vQmFzZVdpZGdldCc7XG5pbXBvcnQgeyBJbWFnZVN0YWNrV2lkZ2V0IH0gZnJvbSAnLi9JbWFnZVN0YWNrV2lkZ2V0JztcbmltcG9ydCB7IEltYWdlTWV0YURhdGEgfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VNZXRhRGF0YSc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3QgfSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVMaXN0JztcbmltcG9ydCB7IERhdGFzZXRTcGVjLCBGYWNldCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEltYWdlRnJhbWUgfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VGcmFtZSc7XG5pbXBvcnQgeyBEZXZsaWJNYXRoIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYk1hdGgnO1xuaW1wb3J0IHsgUmljaFRvb2x0aXAgfSBmcm9tICcuL1JpY2hUb29sdGlwJztcbmltcG9ydCB7IEltYWdlTG9jYXRpb24gfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VMb2NhdGlvbic7XG5pbXBvcnQgeyBHcm91cEJ5V2lkZ2V0IH0gZnJvbSAnLi9Hcm91cEJ5V2lkZ2V0JztcbmltcG9ydCB7IEltYWdlU3RhY2tEYXRhUmVxdWVzdCB9IGZyb20gJy4uL0RhdGFNb2RlbC9JbWFnZVN0YWNrRGF0YVJlcXVlc3QnO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlRTVXRpbCc7XG5cbmV4cG9ydCBjbGFzcyBJbWFnZVNlbGVjdGlvbldpZGdldCBleHRlbmRzIEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz4ge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHNhbXBsaW5nU3RyYXRPcHRpb25zOiB7XCJzdHJhdFwiOiAobnVtYmVyW10gfCBudW1iZXIpLCBcImxhYmVsXCI6IHN0cmluZ31bXSwgaXNDbG9uZTogYm9vbGVhbiA9IGZhbHNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCBmYWxzZSwgc2FtcGxpbmdTdHJhdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9pc0Nsb25lID0gaXNDbG9uZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz5cbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VTZWxlY3Rpb25XaWRnZXQoY29udGFpbmVyLCB0aGlzLnNhbXBsaW5nU3RyYXRPcHRpb25zLCB0cnVlKTtcbiAgICB9XG5cblx0cHJpdmF0ZSBfaXNDbG9uZSA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaXNDbG9uZSgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzQ2xvbmU7XG5cdH1cblxuICAgIHByaXZhdGUgX2ltYWdlTWV0YURhdGEgOiBJbWFnZU1ldGFEYXRhO1xuICAgIHB1YmxpYyBnZXQgaW1hZ2VNZXRhRGF0YSgpIDogSW1hZ2VNZXRhRGF0YSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZU1ldGFEYXRhO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9pbWFnZVN0YWNrRGF0YVJlcXVlc3QgOiBJbWFnZVN0YWNrRGF0YVJlcXVlc3Q7XG4gICAgcHVibGljIGdldCBpbWFnZVN0YWNrRGF0YVJlcXVlc3QoKSA6IEltYWdlU3RhY2tEYXRhUmVxdWVzdCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVN0YWNrRGF0YVJlcXVlc3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5uZXJDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgaW5uZXJDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJDb250YWluZXI7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2ltYWdlVHJhY2tDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgaW1hZ2VUcmFja0NvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVRyYWNrQ29udGFpbmVyO1xuICAgIH0gICAgXG5cbiAgICBwcml2YXRlIF9sb2NhdGlvblNlbGVjdGlvbkNvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBsb2NhdGlvblNlbGVjdGlvbkNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvblNlbGVjdGlvbkNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tZW51QmFyQ29udGFpbmVyIDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IG1lbnVCYXJDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVudUJhckNvbnRhaW5lcjtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfbGVnZW5kQ29udGVudENvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBsZWdlbmRDb250ZW50Q29udGFpbmVyKCkgOiBIdG1sU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZ2VuZENvbnRlbnRDb250YWluZXI7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2dyb3VwQnlXaWRnZXQgOiBHcm91cEJ5V2lkZ2V0O1xuICAgIHB1YmxpYyBnZXQgZ3JvdXBCeVdpZGdldCgpIDogR3JvdXBCeVdpZGdldCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cEJ5V2lkZ2V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2xvY2F0aW9uTGlzdENvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBsb2NhdGlvbkxpc3RDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25MaXN0Q29udGFpbmVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ltYWdlU3RhY2tDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgaW1hZ2VTdGFja0NvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVN0YWNrQ29udGFpbmVyO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9pbWFnZVN0YWNrV2lkZ2V0IDogSW1hZ2VTdGFja1dpZGdldDtcbiAgICBwdWJsaWMgZ2V0IGltYWdlU3RhY2tXaWRnZXQoKSA6IEltYWdlU3RhY2tXaWRnZXQge1xuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VTdGFja1dpZGdldDtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRMb2NhdGlvbklkIDogbnVtYmVyIHwgbnVsbDtcbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGVkTG9jYXRpb25JZCgpIDogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZExvY2F0aW9uSWQ7XG4gICAgfVxuICAgIFxuICAgIC8vIGxvY2F0aW9uIElEIGZvciBob3ZlcmVkIHRyYWNrXG4gICAgcHJpdmF0ZSBfaG92ZXJlZExvY2F0aW9uSWQgOiBudW1iZXIgfCBudWxsO1xuICAgIHB1YmxpYyBnZXQgaG92ZXJlZExvY2F0aW9uSWQoKSA6IG51bWJlciB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJlZExvY2F0aW9uSWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnJhbWVUb29sdGlwIDogUmljaFRvb2x0aXA7XG4gICAgcHVibGljIGdldCBmcmFtZVRvb2x0aXAoKSA6IFJpY2hUb29sdGlwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lVG9vbHRpcDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mcmFtZUhlaWdodCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lSGVpZ2h0KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVIZWlnaHQ7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX2ZyYW1lSGVpZ2h0U2VsZWN0ZWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBmcmFtZUhlaWdodFNlbGVjdGVkKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVIZWlnaHRTZWxlY3RlZDtcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfZnJhbWVNYXJnaW5Ub3BCb3QgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBmcmFtZU1hcmdpblRvcEJvdCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lTWFyZ2luVG9wQm90O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9mcmFtZVNjYWxlWCA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lU2NhbGVYKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVTY2FsZVg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnJhbWVTY2FsZUhlaWdodCA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lU2NhbGVIZWlnaHQoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZVNjYWxlSGVpZ2h0O1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9ob3ZlcmVkTG9jRnJhbWUgOiBbbnVtYmVyLCBudW1iZXJdIHwgbnVsbDtcbiAgICBwdWJsaWMgZ2V0IGhvdmVyZWRMb2NGcmFtZSgpIDogW251bWJlciwgbnVtYmVyXSB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJlZExvY0ZyYW1lO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zZWxlY3RlZExvY0ZyYW1lIDogW251bWJlciwgbnVtYmVyXTtcbiAgICBwdWJsaWMgZ2V0IHNlbGVjdGVkTG9jRnJhbWUoKSA6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRMb2NGcmFtZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9ob3ZlcmVkTG9jSWQgOiBudW1iZXIgfCBudWxsO1xuICAgIHB1YmxpYyBnZXQgaG92ZXJlZExvY0lkKCkgOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvdmVyZWRMb2NJZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zYW1wbGluZ1N0cmF0T3B0aW9ucyA6IHtcInN0cmF0XCI6IChudW1iZXJbXSB8IG51bWJlciksIFwibGFiZWxcIjogc3RyaW5nfVtdO1xuICAgIHB1YmxpYyBnZXQgc2FtcGxpbmdTdHJhdE9wdGlvbnMoKSA6IHtcInN0cmF0XCI6IChudW1iZXJbXSB8IG51bWJlciksIFwibGFiZWxcIjogc3RyaW5nfVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsaW5nU3RyYXRPcHRpb25zO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpbml0UHJvcHMocHJvcHM/OiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLmluaXRQcm9wcygpO1xuICAgICAgICB0aGlzLl9zYW1wbGluZ1N0cmF0T3B0aW9ucyA9IHByb3BzWzBdO1xuICAgIH1cblxuXHRwdWJsaWMgaW5pdCgpOiB2b2lkXG5cdHtcbiAgICAgICAgdGhpcy5fZnJhbWVIZWlnaHQgPSAzMjsgLy8gaGFyZGNvZGVkIGJhc2VkIG9uIENTU1xuICAgICAgICB0aGlzLl9mcmFtZUhlaWdodFNlbGVjdGVkID0gMzI7IC8vIGFsc28gYmFzZWQgb24gQ1NTXG4gICAgICAgIHRoaXMuX2ZyYW1lTWFyZ2luVG9wQm90ID0gMTI7XG4gICAgICAgIHRoaXMuX2ZyYW1lVG9vbHRpcCA9IG5ldyBSaWNoVG9vbHRpcCgwLCAwKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRMb2NGcmFtZSA9IFsxLCAxXTtcbiAgICAgICAgdGhpcy5faG92ZXJlZExvY0ZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG92ZXJlZExvY0lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5uZXJDb250YWluZXIgPSBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpLmFwcGVuZCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW5uZXJDb250YWluZXIuY2xhc3NlZCgnaW1hZ2VTZWxlY3Rpb25Db250YWluZXInLCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9pbWFnZVRyYWNrQ29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMuY29udGFpbmVyKS5hcHBlbmQoJ2RpdicpO1xuICAgICAgICB0aGlzLmltYWdlVHJhY2tDb250YWluZXJcbiAgICAgICAgICAgIC5jbGFzc2VkKCdpbWFnZVRyYWNrQ29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fbG9jYXRpb25TZWxlY3Rpb25Db250YWluZXIgPSB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdsb2NhdGlvblNlbGVjdGlvbkNvbnRhaW5lcicsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX21lbnVCYXJDb250YWluZXIgPSB0aGlzLmxvY2F0aW9uU2VsZWN0aW9uQ29udGFpbmVyLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdtZW51QmFyQ29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIFxuICAgICAgICBkb2N1bWVudC5vbmtleWRvd24gPSAoZXZlbnQpID0+IHt0aGlzLmhhbmRsZUtleURvd24oZXZlbnQpfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2dyb3VwQnlXaWRnZXQgPSBuZXcgR3JvdXBCeVdpZGdldCh0aGlzLm1lbnVCYXJDb250YWluZXIpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGVnZW5kQnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24oJ3F1ZXN0aW9uLWNpcmNsZScsICgpID0+IFxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzaG93TGVnZW5kID0gdGhpcy5sZWdlbmRDb250ZW50Q29udGFpbmVyLmNsYXNzZWQoJ25vRGlzcCcpXG4gICAgICAgICAgICBkMy5zZWxlY3QobGVnZW5kQnV0dG9uKS5jbGFzc2VkKCdzZWxlY3RlZCcsIHNob3dMZWdlbmQpO1xuICAgICAgICAgICAgdGhpcy5sZWdlbmRDb250ZW50Q29udGFpbmVyLmNsYXNzZWQoJ25vRGlzcCcsICFzaG93TGVnZW5kKTtcbiAgICAgICAgfSwgJ0xlZ2VuZCcpO1xuICAgICAgICB0aGlzLm1lbnVCYXJDb250YWluZXIubm9kZSgpLmFwcGVuZENoaWxkKGxlZ2VuZEJ1dHRvbik7XG5cbiAgICAgICAgdGhpcy5fbGVnZW5kQ29udGVudENvbnRhaW5lciA9IHRoaXMubWVudUJhckNvbnRhaW5lci5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbGVnZW5kQ29udGVudENvbnRhaW5lcicsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmxlZ2VuZENvbnRlbnRDb250YWluZXIuYXBwZW5kKCdpbWcnKVxuICAgICAgICAgICAgLmF0dHIoJ3NyYycsICcvc3RhdGljL2Fzc2V0cy9pbWFnZS1zZWxlY3Rpb24tbGVnZW5kLnBuZycpO1xuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uTGlzdENvbnRhaW5lciA9IHRoaXMubG9jYXRpb25TZWxlY3Rpb25Db250YWluZXIuYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2xvY2F0aW9uTGlzdENvbnRhaW5lcicsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlU3RhY2tDb250YWluZXIgPSB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdpbWFnZVN0YWNrQ29udGFpbmVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdvdmVyZmxvdy1zY3JvbGwnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5faW1hZ2VTdGFja1dpZGdldCA9IG5ldyBJbWFnZVN0YWNrV2lkZ2V0KHRoaXMuaW1hZ2VTdGFja0NvbnRhaW5lci5ub2RlKCksIHRoaXMuaW1hZ2VUcmFja0NvbnRhaW5lci5ub2RlKCksIHRoaXMudml6SGVpZ2h0LCB0aGlzLnNhbXBsaW5nU3RyYXRPcHRpb25zKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmcmFtZUhvdmVyQ2hhbmdlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbG9jSWQgPSBlLmRldGFpbC5sb2NhdGlvbklkO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVJZCA9IGUuZGV0YWlsLmZyYW1lSWQ7XG4gICAgICAgICAgICBjb25zdCBjZWxsSWQgPSBlLmRldGFpbC5jZWxsSWQ7XG4gICAgICAgICAgICB0aGlzLm9uSG92ZXJMb2NhdGlvbkZyYW1lKGxvY0lkLCBmcmFtZUlkLCBjZWxsSWQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9jRnJhbWVDbGlja2VkJywgKGU6IEN1c3RvbUV2ZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBsb2NJZCA9IGUuZGV0YWlsLmxvY2F0aW9uSWQ7XG4gICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gZS5kZXRhaWwuZnJhbWVJZDtcbiAgICAgICAgICAgIHRoaXMub25DbGlja0xvY2F0aW9uRnJhbWUobG9jSWQsIGZyYW1lSWQpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ltYWdlU2VsZWN0aW9uUmVkcmF3JywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21hbnVhbFBpblRvZ2dsZScsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0e1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbGxFeHRyYWN0ZWREb3RzKCk7XG5cdFx0fSk7XG5cbiAgICAgICAgdGhpcy5PblJlc2l6ZSgpO1xuXHR9XG5cblx0cHVibGljIE9uRGF0YUNoYW5nZSgpXG5cdHtcbiAgICAgICAgdGhpcy5faW1hZ2VNZXRhRGF0YSA9IEltYWdlTWV0YURhdGEuZnJvbVBvaW50Q29sbGVjdGlvbih0aGlzLmZ1bGxEYXRhKTtcbiAgICAgICAgdGhpcy5faW1hZ2VTdGFja0RhdGFSZXF1ZXN0ID0gbmV3IEltYWdlU3RhY2tEYXRhUmVxdWVzdCh0aGlzLmRhdGEuU3BlY2lmaWNhdGlvbi5nb29nbGVEcml2ZUlkKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRMb2NhdGlvbklkID0gdGhpcy5pbWFnZU1ldGFEYXRhLmxvY2F0aW9uTGlzdFswXS5sb2NhdGlvbklkO1xuICAgICAgICB0aGlzLmdyb3VwQnlXaWRnZXQudXBkYXRlR3JvdXBCeU9wdGlvbnModGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy5faG92ZXJlZExvY2F0aW9uSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNldEltYWdlU3RhY2tXaWRnZXQodHJ1ZSk7XG4gICAgICAgIHRoaXMuT25CcnVzaENoYW5nZSgpO1xuXG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBzZXRJbWFnZVN0YWNrV2lkZ2V0KHNraXBJbWFnZVRyYWNrRHJhdyA9IGZhbHNlKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3QgW2xvY0lkLCBmcmFtZUlkXSA9IHRoaXMuc2VsZWN0ZWRMb2NGcmFtZTtcbiAgICAgICAgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0SW1hZ2UobG9jSWQsIGZyYW1lSWQsICh0b3AsIGxlZnQsIGJsb2IpID0+IFxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmltYWdlU3RhY2tXaWRnZXQuU2V0SW1hZ2VQcm9wZXJ0aWVzKHNraXBJbWFnZVRyYWNrRHJhdywgYmxvYik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKTtcbiAgICAgICAgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LlNldERhdGEodGhpcy5kYXRhLCB0aGlzLmZ1bGxEYXRhLCBjdXJyZW50TG9jYXRpb24sIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LCBza2lwSW1hZ2VUcmFja0RyYXcpO1xuICAgIH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG4gICAgICAgIGNvbnN0IHRvcEhlaWdodE1heCA9IDAuNSAqIHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBib3RIZWlnaHRNYXggPSB0aGlzLmhlaWdodCAtIHRvcEhlaWdodE1heDtcbiAgICAgICAgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0Lk9uUmVzaXplKHRvcEhlaWdodE1heCwgYm90SGVpZ2h0TWF4LCB0aGlzLndpZHRoKTtcbiAgICAgICAgdGhpcy5sb2NhdGlvblNlbGVjdGlvbkNvbnRhaW5lclxuICAgICAgICAgICAgLmNsYXNzZWQoJ292ZXJmbG93LXNjcm9sbCcsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignc3R5bGUnLCBgbWF4LWhlaWdodDogJHt0b3BIZWlnaHRNYXh9cHhgKVxuICAgICAgICB0aGlzLmltYWdlVHJhY2tDb250YWluZXJcbiAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsXG4gICAgICAgICAgICBgbWF4LXdpZHRoOiAke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICBtYXgtaGVpZ2h0OiAke2JvdEhlaWdodE1heH1weDtcbiAgICAgICAgICAgIHdpZHRoOiAke3RoaXMud2lkdGh9cHg7XG4gICAgICAgICAgICBoZWlnaHQ6ICR7Ym90SGVpZ2h0TWF4fXB4O2ApXG5cdH1cblxuICAgIHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW1hZ2VNZXRhRGF0YS51cGRhdGVJbkJydXNoUHJvcCh0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0Lk9uQnJ1c2hDaGFuZ2UoKTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBkcmF3KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubG9jYXRpb25MaXN0Q29udGFpbmVyLmh0bWwobnVsbCk7XG4gICAgICAgIHRoaXMuZHJhd0ZhY2V0UmVjdXJzZSh0aGlzLmdyb3VwQnlXaWRnZXQuY3VycmVudFNlbGVjdGlvbkluZGV4TGlzdCk7XG4gICAgICAgIHRoaXMuZHJhd1NlbGVjdGVkRG90cygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0ZhY2V0UmVjdXJzZShcbiAgICAgICAgcmVtYWluaW5nU3ViRmFjZXRJbmRpY2VzOiBudW1iZXJbXSxcbiAgICAgICAgdmVydGljYWxQb3NpdGlvbjogbnVtYmVyID0gMCxcbiAgICAgICAgZmFjZXQ/OiBGYWNldCxcbiAgICAgICAgY29udGFpbmVyU2VsZWN0aW9uPzogSHRtbFNlbGVjdGlvbik6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lcjogSHRtbFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGNvbnRhaW5lclNlbGVjdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyU2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5sb2NhdGlvbkxpc3RDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmluZ1N1YkZhY2V0SW5kaWNlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd1Rlcm1pbmFsRmFjZXQoY29udGFpbmVyLCBmYWNldC5uYW1lLmpvaW4oJyAnKSwgZmFjZXQuZGF0YSwgdmVydGljYWxQb3NpdGlvbiwgMCk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkYXRhOiBDdXJ2ZUxpc3Q7XG4gICAgICAgIGlmIChmYWNldClcbiAgICAgICAge1xuICAgICAgICAgICAgZGF0YSA9IGZhY2V0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmFjZXRJbmRleCA9IHJlbWFpbmluZ1N1YkZhY2V0SW5kaWNlc1swXTtcbiAgICAgICAgbGV0IGZhY2V0T3B0aW9ucyA9IGRhdGEuR2V0RmFjZXRPcHRpb25zKCk7XG5cbiAgICAgICAgbGV0IGhhcmRDb2RlZE9wdGlvbiA9IGZhY2V0T3B0aW9uc1tmYWNldEluZGV4XTtcbiAgICAgICAgbGV0IGZhY2V0TGlzdCA9IGhhcmRDb2RlZE9wdGlvbi5HZXRGYWNldHMoKTtcbiAgICAgICAgbGV0IGdyb3VwZXJEaXZcbiAgICAgICAgaWYgKGZhY2V0KVxuICAgICAgICB7XG4gICAgICAgICAgICBncm91cGVyRGl2ICA9IHRoaXMuZHJhd0dyb3VwZXJGYWNldChjb250YWluZXIsIGZhY2V0Lm5hbWUuam9pbignICcpLCB2ZXJ0aWNhbFBvc2l0aW9uLCByZW1haW5pbmdTdWJGYWNldEluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRQb3NpdGlvbiA9IHZlcnRpY2FsUG9zaXRpb247XG4gICAgICAgIGxldCB0aGlzQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjaGlsZEZhY2V0IG9mIGZhY2V0TGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRQb3NpdGlvbisrO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5kcmF3RmFjZXRSZWN1cnNlKHJlbWFpbmluZ1N1YkZhY2V0SW5kaWNlcy5zbGljZSgxKSwgY2hpbGRQb3NpdGlvbiwgY2hpbGRGYWNldCwgZ3JvdXBlckRpdik7XG4gICAgICAgICAgICB0aGlzQ291bnQgKz0gY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNDb3VudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdHcm91cGVyRmFjZXQoY29udGFpbmVyU2VsZWN0aW9uOiBIdG1sU2VsZWN0aW9uLCBuYW1lOiBzdHJpbmcsIHZlcnRpY2FsUG9zaXRpb246IG51bWJlciwgekluZGV4OiBudW1iZXIpOiBIdG1sU2VsZWN0aW9uXG4gICAge1xuICAgICAgICB0aGlzLmRyYXdUaXRsZUVsZW1lbnQoY29udGFpbmVyU2VsZWN0aW9uLCBuYW1lLCB2ZXJ0aWNhbFBvc2l0aW9uLCB6SW5kZXgpO1xuXG4gICAgICAgIGNvbnN0IGdyb3VwZXJEaXYgPSBjb250YWluZXJTZWxlY3Rpb24uYXBwZW5kKCdkaXYnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2xvY2F0aW9uTGlzdEdyb3VwZXInLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZ3JvdXBlckRpdjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdUaXRsZUVsZW1lbnQoY29udGFpbmVyU2VsZWN0aW9uOiBIdG1sU2VsZWN0aW9uLCBuYW1lOiBzdHJpbmcsIHZlcnRpY2FsUG9zaXRpb246IG51bWJlciwgekluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCB0b3BQb3MgPSAodmVydGljYWxQb3NpdGlvbiAtIDEpICogMTk7XG5cbiAgICAgICAgbGV0IHN0eWxlU3RyaW5nID0gYHRvcDogJHt0b3BQb3N9cHg7YDtcbiAgICAgICAgaWYgKHpJbmRleCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0eWxlU3RyaW5nICs9IGAgei1pbmRleDogJHt6SW5kZXh9O2A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VTdGFja1dpZGdldC5jb2xvckxvb2t1cC5oYXMobmFtZSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBjb2xvclN0cmluZyA9IEdyb3VwQnlXaWRnZXQuZ2V0Q29sb3IoW25hbWVdICwgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmNvbG9yTG9va3VwKTtcbiAgICAgICAgICAgIGxldCBjb2xvciA9IGQzLmhzbChjb2xvclN0cmluZyk7XG5cbiAgICAgICAgICAgIHN0eWxlU3RyaW5nICs9IGBjb2xvcjogJHtjb2xvci5kYXJrZXIoMS4wKS50b1N0cmluZygpfTtgXG4gICAgICAgICAgICBjb2xvci5sID0gMC45NTtcblxuICAgICAgICAgICAgc3R5bGVTdHJpbmcgKz0gYGJhY2tncm91bmQ6ICR7Y29sb3IudG9TdHJpbmcoKX07YFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyU2VsZWN0aW9uLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgIC50ZXh0KG5hbWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbG9jYXRpb25MaXN0Q2F0VGl0bGUnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgc3R5bGVTdHJpbmcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd1Rlcm1pbmFsRmFjZXQoY29udGFpbmVyU2VsZWN0aW9uOiBIdG1sU2VsZWN0aW9uLCBuYW1lOiBzdHJpbmcsIGRhdGE6IEN1cnZlTGlzdCwgdmVydGljYWxQb3NpdGlvbjogbnVtYmVyLCB6SW5kZXg6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlRWxlbWVudChjb250YWluZXJTZWxlY3Rpb24sIG5hbWUsIHZlcnRpY2FsUG9zaXRpb24sIHpJbmRleCk7XG5cbiAgICAgICAgY29uc3Qgc3ViTGlzdENvbnRhaW5lciA9IGNvbnRhaW5lclNlbGVjdGlvbi5hcHBlbmQoJ3VsJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzdWJMaXN0Q29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgbGV0IGxvY2F0aW9uTGlzdDogbnVtYmVyW10gPSBkYXRhLmxvY2F0aW9uTGlzdDtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VTdGFja1dpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxvY2F0aW9uTGlzdCA9IGxvY2F0aW9uTGlzdC5maWx0ZXIobG9jID0+IHRoaXMuaW1hZ2VTdGFja1dpZGdldC5leGVtcGxhckxvY2F0aW9ucy5oYXMobG9jKSlcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYXRpb25MaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RFbGVtZW50ID0gc3ViTGlzdENvbnRhaW5lci5zZWxlY3RBbGwoJ2xpJylcbiAgICAgICAgICAgIC5kYXRhKGxvY2F0aW9uTGlzdClcbiAgICAgICAgICAgIC5qb2luKCdsaScpO1xuXG4gICAgICAgIGxldCBjb3VudFRvUGVyY2VudDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+XG4gICAgICAgIGlmICghdGhpcy5kYXRhLmJydXNoQXBwbGllZClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbWF4VG90YWxDZWxscyA9IGQzLm1heCh0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25MaXN0LCBsb2MgPT4gbG9jLnRvdGFsQ291bnQpO1xuICAgICAgICAgICAgY291bnRUb1BlcmNlbnQgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgbWF4VG90YWxDZWxsc10pXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCAxLjBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG1heEluQnJ1c2hDZWxscyA9IGQzLm1heCh0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25MaXN0LCBsb2MgPT4gbG9jLmluQnJ1c2hDb3VudCk7XG4gICAgICAgICAgICBjb3VudFRvUGVyY2VudCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBtYXhJbkJydXNoQ2VsbHNdKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgMS4wXSk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0RWxlbWVudC5odG1sKG51bGwpXG4gICAgICAgICAgICAuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2xvY2F0aW9uQnV0dG9uJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCd0b2dnbGVCdXR0b24nLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZCA9PiBkID09IHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgZCA9PiAnaW1hZ2VMb2NhdGlvbi0nICsgZClcbiAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsIGQgPT4gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSB0aGlzLmRhdGEuYnJ1c2hBcHBsaWVkID8gY291bnRUb1BlcmNlbnQobG9jYXRpb24uaW5CcnVzaENvdW50KSA6IGNvdW50VG9QZXJjZW50KGxvY2F0aW9uLnRvdGFsQ291bnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3AgPSAoMSAtIHBlcmNlbnQpICogMTAwXG4gICAgICAgICAgICAgICAgY29uc3QgYmFyQ29sb3IgPSAnI0VEQ0FDOSc7IC8vIGxpZ2h0ZXIgZmlyZWJyaWNrXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gbGVmdCwgcmdiYSgyNTUsMjU1LDI1NSwwKSwgcmdiYSgyNTUsMjU1LDI1NSwwKSAke3N0b3B9JSwgJHtiYXJDb2xvcn0sICR7c3RvcH0lLCAke2JhckNvbG9yfSlgXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGQgPT4gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsaWNrTG9jYXRpb24oZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB3cmFwZXJTZWxlY3Rpb24gPSBsaXN0RWxlbWVudC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZnJhbWVMaXN0Q29udGFpbmVyJywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gZ2V0dGluZyB0aGUgZmlyc3Qgb25lLCB0aGV5IHNob3VsZCBhbGwgYmUgdGhlIHNhbWVcbiAgICAgICAgY29uc3QgYmJveCA9IHdyYXBlclNlbGVjdGlvbi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IG1pbmlXaWR0aCA9IGJib3gud2lkdGg7XG5cbiAgICAgICAgY29uc3Qgc3ZnU2VsZWN0aW9uID0gd3JhcGVyU2VsZWN0aW9uLmFwcGVuZCgnc3ZnJylcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIG1pbmlXaWR0aClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBkID0+IGQgPT09IHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkID8gdGhpcy5mcmFtZUhlaWdodFNlbGVjdGVkIDogdGhpcy5mcmFtZUhlaWdodClcbiAgICAgICAgICAgIC5hdHRyKCdpZCcsIGQgPT4gJ2ZyYW1lVGlja3NWaXotJyArIGQpXG4gICAgICAgICAgICAuYXR0cignZGF0YS1sb2NJZCcsIGQgPT4gZClcbiAgICAgICAgICAgIC5vbignbW91c2VsZWF2ZScsICgpID0+IFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvdmVyZWRMb2NJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlRnJhbWVUb29sdGlwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVIb3ZlckRvdHMoc3ZnU2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUhvdmVyZWRMb2NhdGlvbihudWxsKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgY29uc3QgbWFyZ2luVyA9IDQ7XG4gICAgICAgIGNvbnN0IGZyYW1lRXh0ZW50OiBbbnVtYmVyLCBudW1iZXJdID0gdGhpcy5mdWxsRGF0YS5nZXRNaW5NYXgoJ0ZyYW1lIElEJyk7XG4gICAgICAgIHRoaXMuX2ZyYW1lU2NhbGVYID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgLmRvbWFpbihmcmFtZUV4dGVudClcbiAgICAgICAgICAgIC5yYW5nZShbbWFyZ2luVywgbWluaVdpZHRoIC0gIG1hcmdpblddKTtcblxuICAgICAgICBsZXQgZG9tYWluTWF4OiBudW1iZXI7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYnJ1c2hBcHBsaWVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBkb21haW5NYXggPSBkMy5tYXgodGhpcy5pbWFnZU1ldGFEYXRhLmxvY2F0aW9uTGlzdCwgaW1nTG9jPT4gZDMubWF4KGltZ0xvYy5mcmFtZUxpc3QsIGZyYW1lID0+IGZyYW1lLmluQnJ1c2hDb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZG9tYWluTWF4ID0gZDMubWF4KHRoaXMuaW1hZ2VNZXRhRGF0YS5sb2NhdGlvbkxpc3QsIGltZ0xvYz0+IGQzLm1heChpbWdMb2MuZnJhbWVMaXN0LCBmcmFtZSA9PiBmcmFtZS50b3RhbENvdW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzY2FsZUxpbmVXaWR0aCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oWzAsIGRvbWFpbk1heF0pXG4gICAgICAgICAgICAucmFuZ2UoWzEuMCwgMy4wXSk7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVTY2FsZUhlaWdodCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oWzAsIGRvbWFpbk1heF0pXG4gICAgICAgICAgICAucmFuZ2UoWzEsIHRoaXMuZnJhbWVIZWlnaHQgLSAyICogdGhpcy5mcmFtZU1hcmdpblRvcEJvdF0pO1xuXG4gICAgICAgIHN2Z1NlbGVjdGlvbi5zZWxlY3RBbGwoJ2xpbmUnKVxuICAgICAgICAgICAgLmRhdGEoZCA9PiB0aGlzLmdldEZyYW1lTGlzdChkKSlcbiAgICAgICAgICAgIC5qb2luKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIGQgPT4gdGhpcy5mcmFtZVNjYWxlWChkLmZyYW1lSWQpKVxuICAgICAgICAgICAgLmF0dHIoJ3gyJywgZCA9PiB0aGlzLmZyYW1lU2NhbGVYKGQuZnJhbWVJZCkpXG4gICAgICAgICAgICAuYXR0cigneTEnLCBkID0+IFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvU2NhbGUgPSB0aGlzLmRhdGEuYnJ1c2hBcHBsaWVkID8gZC5pbkJydXNoQ291bnQgOiBkLnRvdGFsQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5mcmFtZUhlaWdodCAtIHRoaXMuZnJhbWVTY2FsZUhlaWdodCh0b1NjYWxlKSkgLyAyO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cigneTInLCBkID0+IFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvU2NhbGUgPSB0aGlzLmRhdGEuYnJ1c2hBcHBsaWVkID8gZC5pbkJydXNoQ291bnQgOiBkLnRvdGFsQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lSGVpZ2h0IC0gKHRoaXMuZnJhbWVIZWlnaHQgLSB0aGlzLmZyYW1lU2NhbGVIZWlnaHQodG9TY2FsZSkpIC8gMlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgZCA9PiB0aGlzLmRhdGEuYnJ1c2hBcHBsaWVkID8gc2NhbGVMaW5lV2lkdGgoZC5pbkJydXNoQ291bnQpIDogc2NhbGVMaW5lV2lkdGgoZC50b3RhbENvdW50KSlcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBkID0+IGQuaW5CcnVzaCA/ICdmaXJlYnJpY2snIDogJ2JsYWNrJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCd0aWNrTWFyaycsIHRydWUpO1xuICAgIFxuXG5cbiAgICAgICAgbGV0IHN2Z0xpc3QgPSBzdmdTZWxlY3Rpb24ubm9kZXMoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdmdMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gc3ZnTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IGxvY0lkID0gK3N2Z0VsZW1lbnQuZGF0YXNldFsnbG9jSWQnXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlU3RhY2tXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0V4dHJhY3RlZERvdHMoZDMuc2VsZWN0KHN2Z0VsZW1lbnQpLCBsb2NJZCwgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmV4ZW1wbGFyRnJhbWVzLmdldChsb2NJZCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdmdFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChldmVudDogTW91c2VFdmVudCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkTG9jSWQgPSBsb2NJZDtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZVggPSBldmVudC5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUlkID0gdGhpcy5mcmFtZVNjYWxlWC5pbnZlcnQobW91c2VYKTtcbiAgICAgICAgICAgICAgICBmcmFtZUlkID0gRGV2bGliTWF0aC5jbGFtcChNYXRoLnJvdW5kKGZyYW1lSWQpLCBmcmFtZUV4dGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhvdmVyTG9jYXRpb25GcmFtZShsb2NJZCwgZnJhbWVJZCwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VYID0gZXZlbnQub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVJZCA9IHRoaXMuZnJhbWVTY2FsZVguaW52ZXJ0KG1vdXNlWCk7XG4gICAgICAgICAgICAgICAgZnJhbWVJZCA9IERldmxpYk1hdGguY2xhbXAoTWF0aC5yb3VuZChmcmFtZUlkKSwgZnJhbWVFeHRlbnQpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMub25DbGlja0xvY2F0aW9uRnJhbWUobG9jSWQsIGZyYW1lSWQpO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2xvY0ZyYW1lQ2xpY2tlZCcsIHsgZGV0YWlsOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbklkOiBsb2NJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSWQ6IGZyYW1lSWRcbiAgICAgICAgICAgICAgICAgICAgfX0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cdHByaXZhdGUgaGFuZGxlS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWRcblx0e1xuICAgICAgICBsZXQgbmV3SW5kZXg6IG51bWJlcjtcbiAgICAgICAgLy8gY29uc3QgW2xvY0lkLCBmcmFtZUlkXSA9IHRoaXMuaG92ZXJlZExvY0ZyYW1lO1xuICAgICAgICBjb25zdCBbbG9jSWQsIGZyYW1lSWRdID0gdGhpcy5zZWxlY3RlZExvY0ZyYW1lO1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuaW1hZ2VNZXRhRGF0YS5sb2NhdGlvbkxvb2t1cC5nZXQobG9jSWQpO1xuICAgICAgICBsZXQgbmV4dEZyYW1lSWQ6IG51bWJlcjtcblx0XHRzd2l0Y2ggKGV2ZW50LmtleUNvZGUpXG5cdFx0e1xuICAgICAgICAgICAgY2FzZSAzNzogLy8gbGVmdFxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkZyYW1lSWQgPSBsb2NhdGlvbi5mcmFtZUxpc3RbMF0uZnJhbWVJZDtcbiAgICAgICAgICAgICAgICBuZXh0RnJhbWVJZCA9IE1hdGgubWF4KGZyYW1lSWQgLSAxLCBtaW5GcmFtZUlkKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLm9uQ2xpY2tMb2NhdGlvbkZyYW1lKGxvY0lkLCBuZXh0RnJhbWVJZCk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2xvY0ZyYW1lQ2xpY2tlZCcsIHsgZGV0YWlsOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbklkOiBsb2NJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSWQ6IG5leHRGcmFtZUlkXG4gICAgICAgICAgICAgICAgICAgIH19KSk7XG5cdFx0XHRcdGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTogLy8gcmlnaHRcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhGcmFtZUlkID0gbG9jYXRpb24uZnJhbWVMaXN0W2xvY2F0aW9uLmZyYW1lTGlzdC5sZW5ndGggLSAxXS5mcmFtZUlkO1xuICAgICAgICAgICAgICAgIG5leHRGcmFtZUlkID0gTWF0aC5taW4oZnJhbWVJZCArIDEsIG1heEZyYW1lSWQpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMub25DbGlja0xvY2F0aW9uRnJhbWUobG9jSWQsIG5leHRGcmFtZUlkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnbG9jRnJhbWVDbGlja2VkJywgeyBkZXRhaWw6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uSWQ6IGxvY0lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWVJZDogbmV4dEZyYW1lSWRcbiAgICAgICAgICAgICAgICAgICAgfX0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblx0XHR9XG5cdH1cblxuICAgIHByaXZhdGUgb25Ib3ZlckxvY2F0aW9uRnJhbWUobG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIgfCBudWxsLCBjZWxsSWQ6IHN0cmluZyB8IG51bGwsIHNob3dUb29sdGlwOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5faG92ZXJlZExvY0ZyYW1lID0gW2xvY2F0aW9uSWQsIGZyYW1lSWRdO1xuICAgICAgICBjb25zdCBsYXN0U3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5ob3ZlcmVkTG9jYXRpb25JZCkgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyRG90cyhsYXN0U3ZnQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3ZlckJhcihsYXN0U3ZnQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgbG9jYXRpb25JZCkgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICB0aGlzLmNoYW5nZUhvdmVyZWRMb2NhdGlvbihsb2NhdGlvbklkKTtcblxuICAgICAgICB0aGlzLmZyYW1lVG9vbHRpcC5IaWRlKCk7XG4gICAgICAgIGlmIChmcmFtZUlkID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3dUb29sdGlwKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBiYm94ID0gc3ZnQ29udGFpbmVyLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHhQb3MgPSBiYm94LnJpZ2h0O1xuICAgICAgICAgICAgY29uc3QgeVBvcyA9IGJib3gudG9wICsgYmJveC5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgY29uc3QgaHRtbFN0cmluZyA9IHRoaXMuY3JlYXRlVG9vbHRpcENvbnRlbnQobG9jYXRpb25JZCwgZnJhbWVJZCk7XG4gICAgICAgICAgICB0aGlzLmZyYW1lVG9vbHRpcC5TaG93KGh0bWxTdHJpbmcsIHhQb3MsIHlQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0hvdmVyRG90cyhzdmdDb250YWluZXIsIGxvY2F0aW9uSWQsIGZyYW1lSWQpO1xuICAgICAgICB0aGlzLmRyYXdGcmFtZVJhbmdlKHN2Z0NvbnRhaW5lciwgY2VsbElkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdGcmFtZVJhbmdlKHN2Z0NvbnRhaW5lcjogU3ZnU2VsZWN0aW9uLCBjZWxsSWQ6IHN0cmluZyB8IG51bGwpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoY2VsbElkID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUhvdmVyQmFyKHN2Z0NvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VydmUgPSB0aGlzLmZ1bGxEYXRhLmN1cnZlTG9va3VwLmdldChjZWxsSWQpO1xuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gY3VydmUucG9pbnRMaXN0WzBdO1xuICAgICAgICBjb25zdCBsb3dGcmFtZUlkID0gZmlyc3RQb2ludC5nZXQoXCJGcmFtZSBJRFwiKTtcbiAgICAgICAgY29uc3QgbG9jSWQgPSBmaXJzdFBvaW50LmdldCgnTG9jYXRpb24gSUQnKVxuICAgICAgICBjb25zdCBsb2NhdGlvbjogSW1hZ2VMb2NhdGlvbiA9IHRoaXMuaW1hZ2VNZXRhRGF0YS5sb2NhdGlvbkxvb2t1cC5nZXQobG9jSWQpO1xuICAgICAgICBjb25zdCBmcmFtZUxvdzogSW1hZ2VGcmFtZSA9IGxvY2F0aW9uLmZyYW1lTG9va3VwLmdldChsb3dGcmFtZUlkKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGxhc3RQb2ludCA9IGN1cnZlLnBvaW50TGlzdFtjdXJ2ZS5wb2ludExpc3QubGVuZ3RoIC0gMV1cbiAgICAgICAgY29uc3QgaGlnaEZyYW1lSWQgPSBsYXN0UG9pbnQuZ2V0KFwiRnJhbWUgSURcIik7XG4gICAgICAgIGNvbnN0IGZyYW1lSGlnaDogSW1hZ2VGcmFtZSA9IGxvY2F0aW9uLmZyYW1lTG9va3VwLmdldChoaWdoRnJhbWVJZCk7XG5cbiAgICAgICAgY29uc3QgeExvdyA9IHRoaXMuZnJhbWVTY2FsZVgobG93RnJhbWVJZCk7XG4gICAgICAgIGNvbnN0IHhIaWdoID0gdGhpcy5mcmFtZVNjYWxlWChoaWdoRnJhbWVJZCk7XG5cbiAgICAgICAgY29uc3QgaDEgPSAodGhpcy5mcmFtZVNjYWxlSGVpZ2h0KGZyYW1lTG93LmluQnJ1c2hDb3VudCkgKyB0aGlzLmZyYW1lSGVpZ2h0KSAvIDI7XG4gICAgICAgIGNvbnN0IGgyID0gKHRoaXMuZnJhbWVTY2FsZUhlaWdodChmcmFtZUhpZ2guaW5CcnVzaENvdW50KSArIHRoaXMuZnJhbWVIZWlnaHQpIC8gMjtcblxuICAgICAgICBjb25zdCBiZXR3ZWVuVGlja01hcmdpbiA9IDI7XG4gICAgICAgIGNvbnN0IGZyb21Cb3R0b21NYXJnaW4gPSA2O1xuXG4gICAgICAgIGNvbnN0IHkxID0gaDEgKyBiZXR3ZWVuVGlja01hcmdpbjtcbiAgICAgICAgY29uc3QgeTIgPSB0aGlzLmZyYW1lSGVpZ2h0U2VsZWN0ZWQgLSBmcm9tQm90dG9tTWFyZ2luO1xuICAgICAgICBjb25zdCB5MyA9IGgyICsgYmV0d2VlblRpY2tNYXJnaW47XG5cbiAgICAgICAgY29uc3QgcG9pbnRMaXN0OiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXG4gICAgICAgICAgICBbeExvdywgeTFdLFxuICAgICAgICAgICAgW3hMb3csIHkyXSxcbiAgICAgICAgICAgIFt4SGlnaCwgeTJdLFxuICAgICAgICAgICAgW3hIaWdoLCB5M11cbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBsaW5lRnVuY3Rpb24gPSBkMy5saW5lPFtudW1iZXIsIG51bWJlcl0+KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLngoZCA9PiBkWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAueShkID0+IGRbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKTtcblxuICAgICAgICBjb25zdCBwYXRoOiBzdHJpbmcgPSBsaW5lRnVuY3Rpb24ocG9pbnRMaXN0KTtcbiAgICAgICAgXG4gICAgICAgIHN2Z0NvbnRhaW5lci5zZWxlY3RBbGwoJy5ob3ZlckJhcicpXG4gICAgICAgICAgICAuZGF0YShbcGF0aF0pXG4gICAgICAgICAgICAuam9pbigncGF0aCcpXG4gICAgICAgICAgICAuYXR0cignZCcsIHBhdGgpXG4gICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXJCYXInLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbW92ZUhvdmVyQmFyKHN2Z0NvbnRhaW5lcjogU3ZnU2VsZWN0aW9uKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3ZnQ29udGFpbmVyLnNlbGVjdEFsbCgnLmhvdmVyQmFyJykucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVBbGxFeHRyYWN0ZWREb3RzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG8gdGhpcyBzaG91bGQgYmUgbW9yZSB0YXJnZXRlZC5cbiAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIC8vIHRoaXMuZHJhd0V4dHJhY3RlZERvdHMoZDMuc2VsZWN0KHN2Z0VsZW1lbnQpLCBsb2NJZCwgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmV4ZW1wbGFyRnJhbWVzLmdldChsb2NJZCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0V4dHJhY3RlZERvdHMoc3ZnQ29udGFpbmVyOiBTdmdTZWxlY3Rpb24sIGxvY2F0aW9uSWQ6IG51bWJlciwgZnJhbWVTZXQ6IFNldDxudW1iZXI+KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGZyYW1lTGlzdCA9IEFycmF5LmZyb20oZnJhbWVTZXQpO1xuICAgICAgICBsZXQgeHlMaXN0OiBbbnVtYmVyLCBudW1iZXJdW10gPSBmcmFtZUxpc3QubWFwKGZyYW1lID0+IHRoaXMuZ2V0RG90Q2VudGVycyhsb2NhdGlvbklkLCBmcmFtZSlbMF0pO1xuICAgICAgICBjb25zdCBkb3RSID0gMS41O1xuICAgICAgICBzdmdDb250YWluZXIuc2VsZWN0QWxsKCcuZXh0cmFjdERvdCcpXG4gICAgICAgICAgICAuZGF0YSh4eUxpc3QpXG4gICAgICAgICAgICAuam9pbignY2lyY2xlJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdleHRyYWN0RG90JywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCdjeCcsIGQgPT4gZFswXSlcbiAgICAgICAgICAgIC5hdHRyKCdjeScsIGQgPT4gZFsxXSlcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyNFQ0VDRUMnKVxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG4gICAgICAgICAgICAuYXR0cigncicsIGRvdFIpXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDAuNilcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0hvdmVyRG90cyhzdmdDb250YWluZXI6IFN2Z1NlbGVjdGlvbiwgbG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCB4eVBvc2l0aW9uczogW251bWJlciwgbnVtYmVyXVtdID0gdGhpcy5nZXREb3RDZW50ZXJzKGxvY2F0aW9uSWQsIGZyYW1lSWQpO1xuICAgICAgICBjb25zdCBkb3RSID0gMjtcbiAgICAgICAgc3ZnQ29udGFpbmVyLnNlbGVjdEFsbCgnLmhvdmVyRG90JylcbiAgICAgICAgICAgIC5kYXRhKHh5UG9zaXRpb25zKVxuICAgICAgICAgICAgLmpvaW4oJ2NpcmNsZScpXG4gICAgICAgICAgICAuY2xhc3NlZCgnaG92ZXJEb3QnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ2N4JywgZCA9PiBkWzBdKVxuICAgICAgICAgICAgLmF0dHIoJ2N5JywgZCA9PiBkWzFdKVxuICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnI0VDRUNFQycpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZG90UilcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd1NlbGVjdGVkRG90cygpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZnJhbWVTY2FsZVgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbG9jYXRpb25JZCwgZnJhbWVJZF0gPSB0aGlzLnNlbGVjdGVkTG9jRnJhbWU7XG4gICAgICAgIGNvbnN0IHh5UG9zaXRpb25zOiBbbnVtYmVyLCBudW1iZXJdW10gPXRoaXMuZ2V0RG90Q2VudGVycyhsb2NhdGlvbklkLCBmcmFtZUlkKTtcbiAgICAgICAgY29uc3QgZG90UiA9IDM7XG5cbiAgICAgICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgbG9jYXRpb25JZCkgYXMgU3ZnU2VsZWN0aW9uO1xuICAgICAgICBzdmdDb250YWluZXIuc2VsZWN0QWxsKCcuc2VsZWN0ZWREb3QnKVxuICAgICAgICAgICAgLmRhdGEoeHlQb3NpdGlvbnMpXG4gICAgICAgICAgICAuam9pbignY2lyY2xlJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdzZWxlY3RlZERvdCcsIHRydWUpXG4gICAgICAgICAgICAuYXR0cignY3gnLCBkID0+IGRbMF0pXG4gICAgICAgICAgICAuYXR0cignY3knLCBkID0+IGRbMV0pXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICdibGFjaycpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgICAgIC5hdHRyKCdyJywgZG90UilcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAwLjUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0RG90Q2VudGVycyhsb2NhdGlvbklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl1bXVxuICAgIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmltYWdlTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KGxvY2F0aW9uSWQpLmZyYW1lTG9va3VwLmdldChmcmFtZUlkKTtcbiAgICAgICAgY29uc3QgeFBvcyA9IHRoaXMuZnJhbWVTY2FsZVgoZnJhbWVJZCk7XG4gICAgICAgIGNvbnN0IHRpY2tIZWlnaHQgPSB0aGlzLmZyYW1lU2NhbGVIZWlnaHQoZnJhbWUuaW5CcnVzaENvdW50KTtcbiAgICAgICAgY29uc3QgZG90UiA9IDI7XG4gICAgICAgIGNvbnN0IGRvdE1hcmdpbiA9IDM7XG4gICAgICAgIGNvbnN0IG1hcmdpbiA9ICh0aGlzLmZyYW1lSGVpZ2h0IC0gdGlja0hlaWdodCkgLyAyXG4gICAgICAgIGNvbnN0IHlQb3MxID0gbWFyZ2luIC0gZG90UiAtIGRvdE1hcmdpbjtcbiAgICAgICAgY29uc3QgeVBvczIgPSBtYXJnaW4gKyB0aWNrSGVpZ2h0ICsgZG90UiArIGRvdE1hcmdpbjtcbiAgICAgICAgcmV0dXJuIFtbeFBvcywgeVBvczFdLCBbeFBvcywgeVBvczJdXTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbW92ZUhvdmVyRG90cyhzdmdDb250YWluZXI6IFN2Z1NlbGVjdGlvbik6IHZvaWRcbiAgICB7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5zZWxlY3RBbGwoJy5ob3ZlckRvdCcpLnJlbW92ZSgpO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIHJlbW92ZUN1cnJlbnRTZWxlY3RlZERvdHMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3Qgc3ZnQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5zZWxlY3RlZExvY0ZyYW1lWzBdKSBhcyBTdmdTZWxlY3Rpb247XG4gICAgICAgIHN2Z0NvbnRhaW5lci5zZWxlY3RBbGwoJy5zZWxlY3RlZERvdCcpLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25DbGlja0xvY2F0aW9uKGxvY2F0aW9uSWQ6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChsb2NhdGlvbklkID09PSB0aGlzLnNlbGVjdGVkTG9jYXRpb25JZClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlTG9jYXRpb25TZWxlY3Rpb24obG9jYXRpb25JZCk7XG4gICAgICAgIGNvbnN0IHNraXBJbWFnZVRyYWNrRHJhdyA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0SW1hZ2VTdGFja1dpZGdldChza2lwSW1hZ2VUcmFja0RyYXcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgb25DbGlja0xvY2F0aW9uRnJhbWUobG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgW29sZExvY0lkLCBvbGRGcmFtZUlkXSA9IHRoaXMuc2VsZWN0ZWRMb2NGcmFtZTtcbiAgICAgICAgaWYgKG9sZExvY0lkID09PSBsb2NhdGlvbklkICYmIG9sZEZyYW1lSWQgPT09IGZyYW1lSWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2xpY2tMb2NhdGlvbihsb2NhdGlvbklkKTtcbiAgICAgICAgdGhpcy5pbWFnZVN0YWNrV2lkZ2V0LmNoYW5nZVNlbGVjdGVkSW1hZ2UoZnJhbWVJZCAtIDEpOyAvLyBtYXRsYWJcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZERvdHMobG9jYXRpb25JZCwgZnJhbWVJZCk7XG4gICAgICAgIHRoaXMuaW1hZ2VTdGFja1dpZGdldC5pbWFnZVRyYWNrV2lkZ2V0LnVwZGF0ZUN1cnJlbnRGcmFtZUluZGljYXRvcihmcmFtZUlkKTtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSB1cGRhdGVTZWxlY3RlZERvdHMobG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRTZWxlY3RlZERvdHMoKTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRMb2NGcmFtZSA9IFtsb2NhdGlvbklkLCBmcmFtZUlkXTtcbiAgICAgICAgdGhpcy5kcmF3U2VsZWN0ZWREb3RzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVUb29sdGlwQ29udGVudChsb2NhdGlvbklkOiBudW1iZXIsIGZyYW1lSWQ6IG51bWJlcik6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgY29uc3QgbGFiZWxWYWx1ZUxpc3Q6IFtzdHJpbmcsIHN0cmluZ11bXSA9IFtcbiAgICAgICAgICAgIFsnTG9jYXRpb24nLCBsb2NhdGlvbklkLnRvU3RyaW5nKCldLFxuXHRcdFx0WydGcmFtZScsIGZyYW1lSWQudG9TdHJpbmcoKV0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBSaWNoVG9vbHRpcC5jcmVhdGVMYWJlbFZhbHVlTGlzdENvbnRlbnQobGFiZWxWYWx1ZUxpc3QpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZUZyYW1lVG9vbHRpcCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmZyYW1lVG9vbHRpcC5IaWRlKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGcmFtZUxpc3QobG9jYXRpb25JZDogbnVtYmVyKTogSW1hZ2VGcmFtZVtdXG4gICAge1xuICAgICAgICBjb25zdCBpbWFnZUxvY2F0aW9uID0gdGhpcy5pbWFnZU1ldGFEYXRhLmxvY2F0aW9uTG9va3VwLmdldChsb2NhdGlvbklkKTtcbiAgICAgICAgcmV0dXJuIGltYWdlTG9jYXRpb24uZnJhbWVMaXN0O1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hhbmdlTG9jYXRpb25TZWxlY3Rpb24obmV3SWQ6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBsYXN0U2VsZWN0ZWQgPSBkMy5zZWxlY3QoXCIjaW1hZ2VMb2NhdGlvbi1cIiArIHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKTtcbiAgICAgICAgbGFzdFNlbGVjdGVkLmNsYXNzZWQoJ3NlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICBsZXQgbGFzdFNlbGVjdGVkRnJhbWVUaWNrVml6ID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5zZWxlY3RlZExvY2F0aW9uSWQpO1xuICAgICAgICBsYXN0U2VsZWN0ZWRGcmFtZVRpY2tWaXouYXR0cignaGVpZ2h0JywgdGhpcy5mcmFtZUhlaWdodCk7XG5cblxuICAgICAgICB0aGlzLl9zZWxlY3RlZExvY2F0aW9uSWQgPSBuZXdJZDtcblxuICAgICAgICBsZXQgbmV3U2VsZWN0ZWQgPSBkMy5zZWxlY3QoXCIjaW1hZ2VMb2NhdGlvbi1cIiArIHRoaXMuc2VsZWN0ZWRMb2NhdGlvbklkKTtcbiAgICAgICAgbmV3U2VsZWN0ZWQuY2xhc3NlZCgnc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgbGV0IG5ld1NlbGVjdGVkRnJhbWVUaWNrVml6ID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5zZWxlY3RlZExvY2F0aW9uSWQpO1xuICAgICAgICBuZXdTZWxlY3RlZEZyYW1lVGlja1Zpei5hdHRyKCdoZWlnaHQnLCB0aGlzLmZyYW1lSGVpZ2h0U2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hhbmdlSG92ZXJlZExvY2F0aW9uKG5ld0lkOiBudW1iZXIgfCBudWxsKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJlZExvY2F0aW9uSWQgIT09IG51bGwpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgbGV0IGxhc3RTZWxlY3RlZCA9IGQzLnNlbGVjdChcIiNpbWFnZUxvY2F0aW9uLVwiICsgdGhpcy5ob3ZlcmVkTG9jYXRpb25JZCk7XG4gICAgICAgICAgICBsYXN0U2VsZWN0ZWQuY2xhc3NlZCgnaG92ZXJlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvdmVyZWRMb2NhdGlvbklkICE9PSB0aGlzLnNlbGVjdGVkTG9jYXRpb25JZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFNlbGVjdGVkRnJhbWVUaWNrVml6ID0gZDMuc2VsZWN0KCcjZnJhbWVUaWNrc1Zpei0nICsgdGhpcy5ob3ZlcmVkTG9jYXRpb25JZCk7XG4gICAgICAgICAgICAgICAgbGFzdFNlbGVjdGVkRnJhbWVUaWNrVml6LmF0dHIoJ2hlaWdodCcsIHRoaXMuZnJhbWVIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faG92ZXJlZExvY2F0aW9uSWQgPSBuZXdJZDtcblxuICAgICAgICBpZiAodGhpcy5ob3ZlcmVkTG9jYXRpb25JZCAhPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IG5ld1NlbGVjdGVkID0gZDMuc2VsZWN0KFwiI2ltYWdlTG9jYXRpb24tXCIgKyB0aGlzLmhvdmVyZWRMb2NhdGlvbklkKTtcbiAgICAgICAgICAgIG5ld1NlbGVjdGVkLmNsYXNzZWQoJ2hvdmVyZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIGxldCBuZXdTZWxlY3RlZEZyYW1lVGlja1ZpeiA9IGQzLnNlbGVjdCgnI2ZyYW1lVGlja3NWaXotJyArIHRoaXMuaG92ZXJlZExvY2F0aW9uSWQpO1xuICAgICAgICAgICAgbmV3U2VsZWN0ZWRGcmFtZVRpY2tWaXouYXR0cignaGVpZ2h0JywgdGhpcy5mcmFtZUhlaWdodFNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgKiBhcyBxdWlja1NlbGVjdCBmcm9tICdxdWlja3NlbGVjdC5qcyc7XG5pbXBvcnQgeyBIdG1sU2VsZWN0aW9uIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJztcbmltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRORCc7XG5pbXBvcnQgeyBJbWFnZUxvY2F0aW9uIH0gZnJvbSAnLi4vRGF0YU1vZGVsL0ltYWdlTG9jYXRpb24nO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5pbXBvcnQgeyBSaWNoVG9vbHRpcCB9IGZyb20gJy4uL0NvbXBvbmVudHMvUmljaFRvb2x0aXAnO1xuaW1wb3J0IHsgSW1hZ2VUcmFja1dpZGdldCB9IGZyb20gJy4vSW1hZ2VUcmFja1dpZGdldCc7XG5pbXBvcnQgeyBDdXJ2ZU5EIH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTkQnO1xuaW1wb3J0IHsgSW1hZ2VMYWJlbHMsIEltYWdlU3RhY2tEYXRhUmVxdWVzdCwgUm93IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0ltYWdlU3RhY2tEYXRhUmVxdWVzdCc7XG5pbXBvcnQgeyBEZXZsaWJUU1V0aWwgfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVFNVdGlsJztcbmltcG9ydCB7IGNvbmRpdGlvbkV4ZW1wbGFyLCBGYWNldCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEltYWdlU3RhY2tXaWRnZXQge1xuXG5cdGNvbnN0cnVjdG9yKFxuXHRcdGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG5cdFx0aW1hZ2VUcmFja0NvbnRhaW5lcjogSFRNTEVsZW1lbnQsXG5cdFx0bWF4SGVpZ2h0OiBudW1iZXIsXG5cdFx0c2FtcGxpbmdTdHJhdE9wdGlvbnM6IHtcInN0cmF0XCI6IChudW1iZXJbXSB8IG51bWJlciksIFwibGFiZWxcIjogc3RyaW5nfVtdKVxuXHR7XG5cdFx0dGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXHRcdHRoaXMuX2ltYWdlVHJhY2tXaWRnZXQgPSBuZXcgSW1hZ2VUcmFja1dpZGdldChpbWFnZVRyYWNrQ29udGFpbmVyLCB0aGlzLCBzYW1wbGluZ1N0cmF0T3B0aW9ucyk7XG5cdFx0dGhpcy5fbWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdHRoaXMuaW5pdCgpO1xuXHRcdHRoaXMuX2NlbGxIb3ZlcmVkID0gMDtcblx0XHR0aGlzLl9zZWxlY3RlZEltZ0luZGV4ID0gMDtcblx0XHRjb25zb2xlLmxvZyhkMyk7XG5cdFx0Y29uc29sZS5sb2codGhpcyk7XG5cdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBSaWNoVG9vbHRpcCgpO1xuXHRcdHRoaXMuX2V4ZW1wbGFyQXR0cmlidXRlID0gJ0F2Zy4gTWFzcyAocGcpJzsgLy8gVE9ETyBjaGFuZ2UgZGVmYXVsdFxuXHRcdHRoaXMuX2luRXhlbXBsYXJNb2RlID0gdHJ1ZTtcblx0XHR0aGlzLl9pbkNvbmRlbnNlZE1vZGUgPSB0cnVlO1xuXHRcdHRoaXMuX2NvbmRlbnNlZE1vZGVDb3VudCA9IDc7XG5cdFx0dGhpcy5fZXhlbXBsYXJMb2NhdGlvbnMgPSBuZXcgU2V0KCk7XG5cdFx0dGhpcy5fZXhlbXBsYXJGcmFtZXMgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5fY29sb3JMb29rdXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXHRcdHRoaXMuX2ZhY2V0TGlzdCA9IFtdO1xuXHRcdHRoaXMuX21hbnVhbGx5UGlubmVkVHJhY2tzID0gW107XG5cdFx0dGhpcy5fbW91c2VQb3MgPSBudWxsO1xuXHRcdHRoaXMuc2V0TnVtRXhlbXBsYXJzKCk7XG5cdH1cblxuXHRwcml2YXRlIHNldE51bUV4ZW1wbGFycygpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBjdXJyZW50U3RyYXQgPSB0aGlzLmltYWdlVHJhY2tXaWRnZXQuY3VycmVudFNhbXBsaW5nU3RhdGVneS5zdHJhdDtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50U3RyYXQpKVxuXHRcdHtcblx0XHRcdHRoaXMuX251bUV4ZW1wbGFycyA9IGN1cnJlbnRTdHJhdC5sZW5ndGg7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLl9udW1FeGVtcGxhcnMgPSBjdXJyZW50U3RyYXQ7XG5cdFx0fVxuXHRcdHRoaXMuX251bUV4ZW1wbGFycyArPSB0aGlzLmltYWdlVHJhY2tXaWRnZXQubWFudWFsU2FtcGxlVmFsdWVzLmxlbmd0aDtcblx0fVxuXG5cdHByaXZhdGUgX2NvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY29udGFpbmVyKCk6IEhUTUxFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfaW1hZ2VUcmFja1dpZGdldDogSW1hZ2VUcmFja1dpZGdldDtcblx0cHVibGljIGdldCBpbWFnZVRyYWNrV2lkZ2V0KCk6IEltYWdlVHJhY2tXaWRnZXQge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZVRyYWNrV2lkZ2V0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbWF4SGVpZ2h0OiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgbWF4SGVpZ2h0KCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX21heEhlaWdodDtcblx0fVxuXG5cdHByaXZhdGUgX2ltYWdlTG9jYXRpb246IEltYWdlTG9jYXRpb247XG5cdHB1YmxpYyBnZXQgaW1hZ2VMb2NhdGlvbigpOiBJbWFnZUxvY2F0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VMb2NhdGlvbjtcblx0fVxuXG5cdHByaXZhdGUgX2ltYWdlU3RhY2tCbG9iOiBCbG9iO1xuXHRwdWJsaWMgZ2V0IGltYWdlU3RhY2tCbG9iKCk6IEJsb2Ige1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZVN0YWNrQmxvYjtcblx0fVxuXG5cdHB1YmxpYyBnZXQgbnVtUGl4ZWxzSW5UaWxlKCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGggKiB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZUhlaWdodDtcblx0fVxuXG5cdHB1YmxpYyBnZXQgZmlyc3RJbmRleCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLm51bVBpeGVsc0luVGlsZSAqIHRoaXMuc2VsZWN0ZWRJbWdJbmRleDtcblx0fVxuXG5cdHByaXZhdGUgX2ltYWdlU3RhY2tMYWJlbFVybDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGltYWdlU3RhY2tMYWJlbFVybCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZVN0YWNrTGFiZWxVcmw7XG5cdH1cblxuXHRwcml2YXRlIF9pbWFnZVN0YWNrV2lkdGg6IG51bWJlcjtcblx0cHVibGljIGdldCBpbWFnZVN0YWNrV2lkdGgoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VTdGFja1dpZHRoO1xuXHR9XG5cblx0cHJpdmF0ZSBfaW1hZ2VTdGFja0hlaWdodDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGltYWdlU3RhY2tIZWlnaHQoKTogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2VTdGFja0hlaWdodDtcblx0fVxuXG5cdHByaXZhdGUgX3NlbGVjdGVkSW1nSW5kZXg6IG51bWJlcjtcblx0cHVibGljIGdldCBzZWxlY3RlZEltZ0luZGV4KCk6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkSW1nSW5kZXg7XG5cdH1cblxuXHRwcml2YXRlIF9pbm5lckNvbnRhaW5lcjogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBpbm5lckNvbnRhaW5lcigpOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5faW5uZXJDb250YWluZXI7XG5cdH1cblxuXHRwcml2YXRlIF9jb25kaXRpb25MYWJlbCA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgY29uZGl0aW9uTGFiZWwoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9jb25kaXRpb25MYWJlbDtcblx0fVxuXG5cdHByaXZhdGUgX2xvY2F0aW9uTGFiZWw6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgbG9jYXRpb25MYWJlbCgpOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbG9jYXRpb25MYWJlbDtcblx0fVxuXG5cdHByaXZhdGUgX2ZyYW1lTGFiZWw6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgZnJhbWVMYWJlbCgpOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fZnJhbWVMYWJlbDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfdG9nZ2xlT3B0aW9uc0NvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgdG9nZ2xlT3B0aW9uc0NvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3RvZ2dsZU9wdGlvbnNDb250YWluZXI7XG5cdH1cblxuXHRwcml2YXRlIF9sZWdlbmRUb2dnbGVDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGxlZ2VuZFRvZ2dsZUNvbnRhaW5lcigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2xlZ2VuZFRvZ2dsZUNvbnRhaW5lcjtcblx0fVxuXHRcblx0cHJpdmF0ZSBfc2hvd091dGxpbmVUb2dnbGUgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHNob3dPdXRsaW5lVG9nZ2xlKCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fc2hvd091dGxpbmVUb2dnbGU7XG5cdH1cblxuXHRwcml2YXRlIF9pbnZlcnRJbWFnZVRvZ2dsZSA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgaW52ZXJ0SW1hZ2VUb2dnbGUoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnRJbWFnZVRvZ2dsZTtcblx0fVxuXG5cdC8vIHRocmVlIGNvbG9yIGxlZ2VuZCB0b2dnbGVzXG5cdHByaXZhdGUgX2xlZ2VuZFRvZ2dsZVNlbGVjdGVkIDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBsZWdlbmRUb2dnbGVTZWxlY3RlZCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2xlZ2VuZFRvZ2dsZVNlbGVjdGVkO1xuXHR9XG5cblx0cHJpdmF0ZSBfbGVnZW5kVG9nZ2xlRmlsdGVyZWRPdXQgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGxlZ2VuZFRvZ2dsZUZpbHRlcmVkT3V0KCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbGVnZW5kVG9nZ2xlRmlsdGVyZWRPdXQ7XG5cdH1cblxuXHRwcml2YXRlIF9sZWdlbmRUb2dnbGVOb3RTZWxlY3RlZCA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgbGVnZW5kVG9nZ2xlTm90U2VsZWN0ZWQoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9sZWdlbmRUb2dnbGVOb3RTZWxlY3RlZDtcblx0fVx0XG5cdFxuXHRwcml2YXRlIF9pbWFnZUFuZExlZ2VuZENvbnRhaW5lciA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgaW1hZ2VBbmRMZWdlbmRDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZUFuZExlZ2VuZENvbnRhaW5lcjtcblx0fVxuXG5cdHByaXZhdGUgX3NlbGVjdGVkSW1hZ2VDb250YWluZXI6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgc2VsZWN0ZWRJbWFnZUNvbnRhaW5lcigpOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbWFnZUNvbnRhaW5lcjtcblx0fVxuXG5cdHByaXZhdGUgX3NlbGVjdGVkSW1hZ2VDYW52YXM6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgc2VsZWN0ZWRJbWFnZUNhbnZhcygpOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbWFnZUNhbnZhcztcblx0fVxuXG5cdHByaXZhdGUgX2NhbnZhc0NvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblx0cHVibGljIGdldCBjYW52YXNDb250ZXh0KCk6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhc0NvbnRleHQ7XG5cdH1cblxuXHRwcml2YXRlIF9kYXRhOiBDdXJ2ZUxpc3Q7XG5cdHB1YmxpYyBnZXQgZGF0YSgpOiBDdXJ2ZUxpc3Qge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBfZnVsbERhdGE6IEN1cnZlTGlzdDtcblx0cHVibGljIGdldCBmdWxsRGF0YSgpOiBDdXJ2ZUxpc3Qge1xuXHRcdHJldHVybiB0aGlzLl9mdWxsRGF0YTtcblx0fVxuXG5cdHByaXZhdGUgX2ltYWdlU3RhY2tEYXRhUmVxdWVzdDogSW1hZ2VTdGFja0RhdGFSZXF1ZXN0O1xuXHRwdWJsaWMgZ2V0IGltYWdlU3RhY2tEYXRhUmVxdWVzdCgpOiBJbWFnZVN0YWNrRGF0YVJlcXVlc3Qge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZVN0YWNrRGF0YVJlcXVlc3Q7XG5cdH1cblxuXHRwcml2YXRlIF9kZWZhdWx0Q2FudmFzU3RhdGU6IEltYWdlRGF0YTtcblx0cHVibGljIGdldCBkZWZhdWx0Q2FudmFzU3RhdGUoKTogSW1hZ2VEYXRhIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmYXVsdENhbnZhc1N0YXRlO1xuXHR9XG5cblx0cHJpdmF0ZSBfY2VsbEhvdmVyZWQ6IG51bWJlcjtcblx0cHVibGljIGdldCBjZWxsSG92ZXJlZCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9jZWxsSG92ZXJlZDtcblx0fVxuXG5cdHByaXZhdGUgX3Rvb2x0aXA6IFJpY2hUb29sdGlwO1xuXHRwdWJsaWMgZ2V0IHRvb2x0aXAoKTogUmljaFRvb2x0aXAge1xuXHRcdHJldHVybiB0aGlzLl90b29sdGlwO1xuXHR9XG5cblx0cHJpdmF0ZSBfZXhlbXBsYXJBdHRyaWJ1dGU6IHN0cmluZztcblx0cHVibGljIGdldCBleGVtcGxhckF0dHJpYnV0ZSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9leGVtcGxhckF0dHJpYnV0ZTtcblx0fVxuXG5cdHByaXZhdGUgX2luRXhlbXBsYXJNb2RlOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGluRXhlbXBsYXJNb2RlKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pbkV4ZW1wbGFyTW9kZTtcblx0fVxuXG5cdHByaXZhdGUgX2luQ29uZGVuc2VkTW9kZTogYm9vbGVhbjtcblx0cHVibGljIGdldCBpbkNvbmRlbnNlZE1vZGUoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luQ29uZGVuc2VkTW9kZTtcblx0fVxuXG5cdHByaXZhdGUgX2NvbmRlbnNlZE1vZGVDb3VudDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGNvbmRlbnNlZE1vZGVDb3VudCgpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9jb25kZW5zZWRNb2RlQ291bnQ7XG5cdH1cblxuXHRwcml2YXRlIF9leGVtcGxhckxvY2F0aW9uczogU2V0PG51bWJlcj47XG5cdHB1YmxpYyBnZXQgZXhlbXBsYXJMb2NhdGlvbnMoKTogU2V0PG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9leGVtcGxhckxvY2F0aW9ucztcblx0fVxuXG5cdHByaXZhdGUgX2V4ZW1wbGFyRnJhbWVzOiBNYXA8bnVtYmVyLCBTZXQ8bnVtYmVyPj47XG5cdHB1YmxpYyBnZXQgZXhlbXBsYXJGcmFtZXMoKTogTWFwPG51bWJlciwgU2V0PG51bWJlcj4+IHtcblx0XHRyZXR1cm4gdGhpcy5fZXhlbXBsYXJGcmFtZXM7XG5cdH1cblxuXHRwcml2YXRlIF9mYWNldExpc3Q6IEZhY2V0W107XG5cdHB1YmxpYyBnZXQgZmFjZXRMaXN0KCk6IEZhY2V0W10ge1xuXHRcdHJldHVybiB0aGlzLl9mYWNldExpc3Q7XG5cdH1cblxuXHRwcml2YXRlIF9jb2xvckxvb2t1cCA6IE1hcDxzdHJpbmcsIHN0cmluZz47XG5cdHB1YmxpYyBnZXQgY29sb3JMb29rdXAoKSA6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9jb2xvckxvb2t1cDtcblx0fVxuXG5cdHByaXZhdGUgX251bUV4ZW1wbGFyczogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IG51bUV4ZW1wbGFycygpOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9udW1FeGVtcGxhcnM7XG5cdH1cblxuXHRwcml2YXRlIF9tYW51YWxseVBpbm5lZFRyYWNrcyA6IEN1cnZlTkRbXTtcblx0cHVibGljIGdldCBtYW51YWxseVBpbm5lZFRyYWNrcygpIDogQ3VydmVORFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFudWFsbHlQaW5uZWRUcmFja3M7XG5cdH1cblxuXHRwcml2YXRlIF9tb3VzZVBvcyA6IHtvZmZzZXQ6IFtudW1iZXIsIG51bWJlcl0sIHBhZ2U6IFtudW1iZXIsIG51bWJlcl19IHwgbnVsbDtcblx0cHVibGljIGdldCBtb3VzZVBvcygpIDoge29mZnNldDogW251bWJlciwgbnVtYmVyXSwgcGFnZTogW251bWJlciwgbnVtYmVyXX0gfCBudWxsIHtcblx0XHRyZXR1cm4gdGhpcy5fbW91c2VQb3M7XG5cdH1cblxuXHRwdWJsaWMgaW5pdCgpOiB2b2lkIHtcblx0XHRjb25zdCBjb250YWluZXJTZWxlY3QgPSBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpO1xuXG5cdFx0Y29uc3QgbG9jYXRpb25GcmFtZUxhYmVsQ29udGFpbmVyID0gY29udGFpbmVyU2VsZWN0LmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCdsb2NhdGlvbkZyYW1lTGFiZWxDb250YWluZXInLCB0cnVlKTtcblxuXHRcdHRoaXMuX2lubmVyQ29udGFpbmVyID0gY29udGFpbmVyU2VsZWN0LmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCdpbm5lckNvbnRhaW5lcicsIHRydWUpO1xuXG5cdFx0Y29uc3QgbG9jYXRpb25GcmFtZUxhYmVsID0gbG9jYXRpb25GcmFtZUxhYmVsQ29udGFpbmVyLmFwcGVuZCgnaDMnKVxuXHRcdFx0LmNsYXNzZWQoJ2xvY2F0aW9uRnJhbWVMYWJlbCcsIHRydWUpO1xuXG5cdFx0bG9jYXRpb25GcmFtZUxhYmVsLm5vZGUoKS5hcHBlbmQoJ0NvbmRpdGlvbjogJyk7XG5cdFx0dGhpcy5fY29uZGl0aW9uTGFiZWwgPSBsb2NhdGlvbkZyYW1lTGFiZWwuYXBwZW5kKCdzcGFuJylcblx0XHRcdC5jbGFzc2VkKCdsb2NhdGlvbkZyYW1lTGFiZWxWYWx1ZScsIHRydWUpO1xuXG5cdFx0bG9jYXRpb25GcmFtZUxhYmVsLm5vZGUoKS5hcHBlbmQoJ0xvY2F0aW9uOiAnKTtcblx0XHR0aGlzLl9sb2NhdGlvbkxhYmVsID0gbG9jYXRpb25GcmFtZUxhYmVsLmFwcGVuZCgnc3BhbicpXG5cdFx0XHQuY2xhc3NlZCgnbG9jYXRpb25GcmFtZUxhYmVsVmFsdWUnLCB0cnVlKTtcblxuXHRcdGxvY2F0aW9uRnJhbWVMYWJlbC5ub2RlKCkuYXBwZW5kKCdGcmFtZTogJyk7XG5cdFx0dGhpcy5fZnJhbWVMYWJlbCA9IGxvY2F0aW9uRnJhbWVMYWJlbC5hcHBlbmQoJ3NwYW4nKVxuXHRcdFx0LmNsYXNzZWQoJ2xvY2F0aW9uRnJhbWVMYWJlbFZhbHVlJywgdHJ1ZSk7XG5cblx0XHR0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2JykuYXR0cignc3R5bGUnLCAnZmxleC1ncm93OiAxOycpO1xuXHRcdHRoaXMuX3RvZ2dsZU9wdGlvbnNDb250YWluZXIgPSB0aGlzLmlubmVyQ29udGFpbmVyLmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCd0b2dnbGVPcHRpb25zJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdzbWFsbFRleHQnLCB0cnVlKTtcblxuXG5cdFx0Y29uc3Qgb3V0bGluZUlkID0gJ2ltYWdlVG9nZ2xlLW91dGxpbmVzJztcblx0XHR0aGlzLl9zaG93T3V0bGluZVRvZ2dsZSA9IHRoaXMudG9nZ2xlT3B0aW9uc0NvbnRhaW5lci5hcHBlbmQoJ2lucHV0Jylcblx0XHRcdC5hdHRyKCd0eXBlJywgJ2NoZWNrYm94Jylcblx0XHRcdC5vbignY2hhbmdlJywgKCkgPT4gXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuT25CcnVzaENoYW5nZSgpO1xuXHRcdFx0fSlcblx0XHRcdC5hdHRyKCdpZCcsIG91dGxpbmVJZCk7XG5cdFx0dGhpcy50b2dnbGVPcHRpb25zQ29udGFpbmVyLmFwcGVuZCgnbGFiZWwnKVxuXHRcdFx0LmF0dHIoJ2ZvcicsIG91dGxpbmVJZClcblx0XHRcdC50ZXh0KCdTaG93IE91dGxpbmVzJyk7XG5cblx0XHQodGhpcy5zaG93T3V0bGluZVRvZ2dsZS5ub2RlKCkgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IHRydWU7XG5cdFx0XG5cdFx0Y29uc3QgaW52ZXJ0SWQgPSAnaW1hZ2VUb2dnbGUtaW52ZXJ0Jztcblx0XHR0aGlzLl9pbnZlcnRJbWFnZVRvZ2dsZSA9IHRoaXMudG9nZ2xlT3B0aW9uc0NvbnRhaW5lci5hcHBlbmQoJ2lucHV0Jylcblx0XHRcdC5hdHRyKCd0eXBlJywgJ2NoZWNrYm94Jylcblx0XHRcdC5vbignY2hhbmdlJywgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0bGV0IG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnZlcnRJZCkgYXMgSFRNTElucHV0RWxlbWVudDtcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEltYWdlQ29udGFpbmVyLmNsYXNzZWQoJ2ludmVydCcsIG5vZGUuY2hlY2tlZCk7XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5jbGFzc2VkKCdpbnZlcnQnLCBub2RlLmNoZWNrZWQpO1xuXHRcdFx0XHR0aGlzLnVwZGF0ZUNhbnZhcygpO1xuXHRcdFx0fSlcblx0XHRcdC5hdHRyKCdpZCcsIGludmVydElkKTtcblx0XHR0aGlzLnRvZ2dsZU9wdGlvbnNDb250YWluZXIuYXBwZW5kKCdsYWJlbCcpXG5cdFx0XHQuYXR0cignZm9yJywgaW52ZXJ0SWQpXG5cdFx0XHQudGV4dCgnSW52ZXJ0Jyk7XG5cblxuXHRcdHRoaXMuX2ltYWdlQW5kTGVnZW5kQ29udGFpbmVyID0gdGhpcy5pbm5lckNvbnRhaW5lci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgnaW1hZ2VBbmRMZWdlbmRDb250YWluZXInLCB0cnVlKTtcblxuXHRcdHRoaXMuX3NlbGVjdGVkSW1hZ2VDb250YWluZXIgPSB0aGlzLmltYWdlQW5kTGVnZW5kQ29udGFpbmVyLmFwcGVuZCgnZGl2Jylcblx0XHRcdC5jbGFzc2VkKCdub1NocmluaycsIHRydWUpO1xuXG5cdFx0dGhpcy5pbm5lckNvbnRhaW5lci5hcHBlbmQoJ2RpdicpLmF0dHIoJ3N0eWxlJywgJ2ZsZXgtZ3JvdzogMjsnKTtcblxuXHRcdHRoaXMuX3NlbGVjdGVkSW1hZ2VDYW52YXMgPSB0aGlzLnNlbGVjdGVkSW1hZ2VDb250YWluZXIuYXBwZW5kKCdjYW52YXMnKVxuXG5cdFx0dGhpcy5zZWxlY3RlZEltYWdlQ2FudmFzLm5vZGUoKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZTogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0dGhpcy5vbkNhbnZhc01vdXNlTW92ZShlKVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5zZWxlY3RlZEltYWdlQ2FudmFzLm5vZGUoKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlOiBNb3VzZUV2ZW50KSA9PiB7XG5cdFx0XHR0aGlzLm9uQ2FudmFzQ2xpY2soZSlcblx0XHR9KTtcblxuXHRcdHRoaXMuX2NhbnZhc0NvbnRleHQgPSAodGhpcy5zZWxlY3RlZEltYWdlQ2FudmFzLm5vZGUoKSBhcyBIVE1MQ2FudmFzRWxlbWVudCkuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdHRoaXMuc2VsZWN0ZWRJbWFnZUNvbnRhaW5lclxuXHRcdFx0Lm9uKCdtb3VzZWxlYXZlJywgKCkgPT4ge1xuXHRcdFx0XHR0aGlzLl9tb3VzZVBvcyA9IG51bGw7XG5cdFx0XHRcdHRoaXMuaGlkZVNlZ21lbnRIb3ZlcigpO1xuXHRcdFx0fSk7XG5cblx0XHQvLyBhZGQgdGhyZWUgdG9nZ2xlcyBmb3IgYSBsZWdlbmQgYW5kIHRvIGhpZGUgb25seSBzb21lIG91dGxpbmVzXG5cdFx0dGhpcy5fbGVnZW5kVG9nZ2xlQ29udGFpbmVyID0gdGhpcy5pbWFnZUFuZExlZ2VuZENvbnRhaW5lci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgndG9nZ2xlT3B0aW9ucycsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgndmVydGljYWwnLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ3NtYWxsVGV4dCcsIHRydWUpO1xuXG5cdFx0dGhpcy5sZWdlbmRUb2dnbGVDb250YWluZXIuYXBwZW5kKCdkaXYnKS5hdHRyKCdzdHlsZScsICdmbGV4LWdyb3c6IDE7Jyk7IC8vIHRvIGNlbnRlciBsZWdlbmQuXG5cblx0XHR0aGlzLl9sZWdlbmRUb2dnbGVTZWxlY3RlZCA9IHRoaXMubGVnZW5kVG9nZ2xlQ29udGFpbmVyLmFwcGVuZCgnaW5wdXQnKVxuXHRcdFx0LmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKVxuXHRcdFx0Lm9uKCdjaGFuZ2UnLCAoKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNsYXNzZWQoJ25vRGlzcCcsIHRydWUpXG5cdFx0XHQuYXR0cignaWQnLCAnbGVnZW5kVG9nZ2xlLXNlbGVjdGVkJyk7XG5cdFx0dGhpcy5sZWdlbmRUb2dnbGVDb250YWluZXIuYXBwZW5kKCdsYWJlbCcpXG5cdFx0XHQuYXR0cignZm9yJywgJ2xlZ2VuZFRvZ2dsZS1zZWxlY3RlZCcpXG5cdFx0XHQuY2xhc3NlZCgnY29sb3JMZWdlbmRMYWJlbCcsdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdyZWQnLCB0cnVlKVxuXHRcdFx0LnRleHQoJ1NlbGVjdGVkJyk7XG5cdFx0KHRoaXMubGVnZW5kVG9nZ2xlU2VsZWN0ZWQubm9kZSgpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuXG5cblx0XHR0aGlzLl9sZWdlbmRUb2dnbGVGaWx0ZXJlZE91dCA9IHRoaXMubGVnZW5kVG9nZ2xlQ29udGFpbmVyLmFwcGVuZCgnaW5wdXQnKVxuXHRcdFx0LmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKVxuXHRcdFx0Lm9uKCdjaGFuZ2UnLCAoKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNsYXNzZWQoJ25vRGlzcCcsIHRydWUpXG5cdFx0XHQuYXR0cignaWQnLCAnbGVnZW5kVG9nZ2xlLWZpbHRlcmVkT3V0Jyk7XG5cdFx0dGhpcy5sZWdlbmRUb2dnbGVDb250YWluZXIuYXBwZW5kKCdsYWJlbCcpXG5cdFx0XHQuYXR0cignZm9yJywgJ2xlZ2VuZFRvZ2dsZS1maWx0ZXJlZE91dCcpXG5cdFx0XHQuY2xhc3NlZCgnY29sb3JMZWdlbmRMYWJlbCcsdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdncmVlbicsIHRydWUpXG5cdFx0XHQudGV4dCgnRmlsdGVyZWQgT3V0Jyk7XG5cdFx0KHRoaXMubGVnZW5kVG9nZ2xlRmlsdGVyZWRPdXQubm9kZSgpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0cnVlO1xuXG5cblx0XHR0aGlzLl9sZWdlbmRUb2dnbGVOb3RTZWxlY3RlZCA9IHRoaXMubGVnZW5kVG9nZ2xlQ29udGFpbmVyLmFwcGVuZCgnaW5wdXQnKVxuXHRcdFx0LmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKVxuXHRcdFx0Lm9uKCdjaGFuZ2UnLCAoKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0XHR9KVxuXHRcdFx0LmNsYXNzZWQoJ25vRGlzcCcsIHRydWUpXG5cdFx0XHQuYXR0cignaWQnLCAnbGVnZW5kVG9nZ2xlLW5vdFNlbGVjdGVkJyk7XG5cdFx0dGhpcy5sZWdlbmRUb2dnbGVDb250YWluZXIuYXBwZW5kKCdsYWJlbCcpXG5cdFx0XHQuYXR0cignZm9yJywgJ2xlZ2VuZFRvZ2dsZS1ub3RTZWxlY3RlZCcpXG5cdFx0XHQuY2xhc3NlZCgnY29sb3JMZWdlbmRMYWJlbCcsdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdibHVlJywgdHJ1ZSlcblx0XHRcdC50ZXh0KCdOb3QgU2VsZWN0ZWQnKTtcblx0XHQodGhpcy5sZWdlbmRUb2dnbGVOb3RTZWxlY3RlZC5ub2RlKCkgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IHRydWU7XG5cblx0XHR0aGlzLmxlZ2VuZFRvZ2dsZUNvbnRhaW5lci5hcHBlbmQoJ2RpdicpLmF0dHIoJ3N0eWxlJywgJ2ZsZXgtZ3JvdzogMTsnKTsgLy8gdG8gY2VudGVyIGxlZ2VuZC5cblxuXHRcdHRoaXMuaW1hZ2VUcmFja1dpZGdldC5pbml0KCk7XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzYW1wbGluZ1N0cmF0ZWd5Q2hhbmdlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcblx0XHR7XG5cdFx0XHR0aGlzLnNldE51bUV4ZW1wbGFycygpO1xuXHRcdFx0dGhpcy51cGRhdGVUcmFja3NDYW52YXMoKTtcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpbWFnZVNlbGVjdGlvblJlZHJhdycpKTtcblx0XHR9KTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xhdW5jaEV4ZW1wbGFyQ3VydmUnLCAoZTogQ3VzdG9tRXZlbnQpID0+IHtcblx0XHRcdHRoaXMuX2V4ZW1wbGFyQXR0cmlidXRlID0gZS5kZXRhaWw7XG5cdFx0XHR0aGlzLmltYWdlVHJhY2tXaWRnZXQubWFudWFsU2FtcGxlVmFsdWVzID0gW107XG5cdFx0XHR0aGlzLnNldE51bUV4ZW1wbGFycygpO1xuXHRcdFx0bGV0IGJ1dHRvbkNoYW5nZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2VNb2RlU2VsZWN0JywgeyBkZXRhaWw6IDAgfSk7XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGJ1dHRvbkNoYW5nZUV2ZW50KTtcblxuXHRcdFx0bGV0IG1vZGVDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbW9kZUNoYW5nZScsIHtcblx0XHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdFx0aW5Db25kZW5zZWRNb2RlOiB0cnVlLFxuXHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChtb2RlQ2hhbmdlRXZlbnQpO1xuXHRcdH0pO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW9kZUNoYW5nZScsIChlOiBDdXN0b21FdmVudCkgPT4ge1xuXHRcdFx0dGhpcy5faW5FeGVtcGxhck1vZGUgPSBlLmRldGFpbC5pbkV4ZW1wbGFyTW9kZTtcblx0XHRcdHRoaXMuX2luQ29uZGVuc2VkTW9kZSA9IGUuZGV0YWlsLmluQ29uZGVuc2VkTW9kZTtcblx0XHRcdHRoaXMudXBkYXRlVHJhY2tzQ2FudmFzKCk7XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnaW1hZ2VTZWxlY3Rpb25SZWRyYXcnKSk7XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZXhlbXBsYXJBdHRyaWJ1dGVDaGFuZ2UnLCB7IGRldGFpbDogdGhpcy5pbkV4ZW1wbGFyTW9kZSA/IHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUgOiBudWxsIH0pKTtcblx0XHR9KTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2dyb3VwQnlDaGFuZ2VkJywgYXN5bmMgKGU6IEN1c3RvbUV2ZW50KSA9PiB7XG5cdFx0XHRsZXQgcG9wdXBDb250YWluZXIgPSBkMy5zZWxlY3QoJyNsYXJnZVBvcHVwQ29udGFpbmVyT3V0ZXInKTtcblx0XHRcdGlmICghcG9wdXBDb250YWluZXIuZW1wdHkoKSAmJiAhcG9wdXBDb250YWluZXIuY2xhc3NlZCgnbm9EaXNwJykpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0RGV2bGliVFNVdGlsLmxhdW5jaFNwaW5uZXIoKTtcblx0XHRcdGF3YWl0IERldmxpYlRTVXRpbC5tYWtlQXN5bmMoKCkgPT4gdGhpcy5fZmFjZXRMaXN0ID0gZS5kZXRhaWwuZmxhdEZhY2V0TGlzdCk7XG5cdFx0XHR0aGlzLl9jb2xvckxvb2t1cCA9IGUuZGV0YWlsLmNvbG9yTG9va3VwO1xuXHRcdFx0dGhpcy51cGRhdGVUcmFja3NDYW52YXMoKTtcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpbWFnZVNlbGVjdGlvblJlZHJhdycpKTtcblx0XHR9KTtcblx0fVxuXG5cdHB1YmxpYyBTZXREYXRhKGRhdGE6IEN1cnZlTGlzdCwgZnVsbERhdGE6IEN1cnZlTGlzdCwgaW1hZ2VMb2NhdGlvbjogSW1hZ2VMb2NhdGlvbiwgaW1hZ2VTdGFja0RhdGFSZXF1ZXN0OiBJbWFnZVN0YWNrRGF0YVJlcXVlc3QsIHNraXBJbWFnZVRyYWNrRHJhdyA9IGZhbHNlKTogdm9pZCB7XG5cdFx0dGhpcy5fZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy5fZnVsbERhdGEgPSBmdWxsRGF0YTtcblx0XHR0aGlzLl9pbWFnZVN0YWNrRGF0YVJlcXVlc3QgPSBpbWFnZVN0YWNrRGF0YVJlcXVlc3Q7XG5cdFx0dGhpcy5fc2VsZWN0ZWRJbWdJbmRleCA9IDA7XG5cdFx0dGhpcy5faW1hZ2VMb2NhdGlvbiA9IGltYWdlTG9jYXRpb247XG5cdFx0dGhpcy5TZXRJbWFnZVByb3BlcnRpZXMoc2tpcEltYWdlVHJhY2tEcmF3KTsgLy8gZGVmYXVsdCB2YWx1ZXMgYmVmb3JlIGltYWdlIGxvYWRcblx0XHR0aGlzLmRyYXcoc2tpcEltYWdlVHJhY2tEcmF3KTtcblx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZXhlbXBsYXJBdHRyaWJ1dGVDaGFuZ2UnLCB7IGRldGFpbDogdGhpcy5pbkV4ZW1wbGFyTW9kZSA/IHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUgOiBudWxsIH0pKTtcblx0fVxuXG5cdHB1YmxpYyBTZXRJbWFnZVByb3BlcnRpZXMoc2tpcEltYWdlVHJhY2tEcmF3OiBib29sZWFuLCBibG9iPzogQmxvYiwgaW1hZ2VXaWR0aD86IG51bWJlciwgaW1hZ2VIZWlnaHQ/OiBudW1iZXIsIG51bUNvbHVtbnM/OiBudW1iZXIsIHNjYWxlRmFjdG9yPzogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0Ly8gZGVmYXVsdCB2YWx1ZXMgZm9yIHdoZW4gbG9hZGluZywgb3IgaWYgaW1hZ2UgaXNuJ3QgZm91bmRcblx0XHRpZiAoIWltYWdlV2lkdGgpIHsgaW1hZ2VXaWR0aCA9IDI1NjsgfVxuXHRcdGlmICghaW1hZ2VIZWlnaHQpIHsgaW1hZ2VIZWlnaHQgPSAyNTY7IH1cblx0XHRpZiAoIW51bUNvbHVtbnMpIHsgbnVtQ29sdW1ucyA9IDEwOyB9XG5cdFx0dGhpcy5faW1hZ2VTdGFja0Jsb2IgPSBibG9iO1xuXHRcdHRoaXMuZHJhdyhza2lwSW1hZ2VUcmFja0RyYXcpO1xuXHR9XG5cblx0cHVibGljIGRyYXcoc2tpcEltYWdlVHJhY2tEcmF3ID0gZmFsc2UpOiB2b2lkIHtcblx0XHR0aGlzLmRyYXdTZWxlY3RlZEltYWdlKHNraXBJbWFnZVRyYWNrRHJhdyk7XG5cdFx0dGhpcy51cGRhdGVMb2NhdGlvbkZyYW1lTGFiZWwoKTtcblx0fVxuXG5cdHB1YmxpYyBPbkJydXNoQ2hhbmdlKCk6IHZvaWQge1xuXHRcdHRoaXMuZHJhdyh0cnVlKTtcblx0XHR0aGlzLmltYWdlVHJhY2tXaWRnZXQuT25CcnVzaENoYW5nZSgpO1xuXHR9XG5cblx0cHVibGljIGRyYXdVcGRhdGUoKTogdm9pZCB7XG5cdFx0dGhpcy51cGRhdGVCYWNrZ3JvdW5kUG9zaXRpb24odGhpcy5zZWxlY3RlZEltZ0luZGV4KTtcblx0XHR0aGlzLnVwZGF0ZUNhbnZhcyh0aGlzLmluRXhlbXBsYXJNb2RlKTtcblx0XHR0aGlzLnVwZGF0ZUxvY2F0aW9uRnJhbWVMYWJlbCgpO1xuXHRcdHRoaXMudXBkYXRlQmFzZWRPbk1vdXNlUG9zaXRpb24odHJ1ZSk7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdTZWxlY3RlZEltYWdlKHNraXBJbWFnZVRyYWNrRHJhdyA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5zZXRJbWFnZUlubGluZVN0eWxlKHRoaXMuc2VsZWN0ZWRJbWdJbmRleCk7XG5cdFx0dGhpcy51cGRhdGVDYW52YXMoc2tpcEltYWdlVHJhY2tEcmF3KTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlTG9jYXRpb25GcmFtZUxhYmVsKCk6IHZvaWRcblx0e1xuXHRcdGNvbnN0IGxvY0lkID0gdGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpO1xuXHRcdGNvbnN0IGxhYmVsTGlzdCA9IHRoaXMuZnVsbERhdGEuaW52ZXJzZUxvY2F0aW9uTWFwLmdldChsb2NJZCk7XG5cdFx0dGhpcy5jb25kaXRpb25MYWJlbC50ZXh0KGxhYmVsTGlzdC5qb2luKCcgJykpO1xuXHRcdHRoaXMubG9jYXRpb25MYWJlbC50ZXh0KGxvY0lkKTtcblx0XHR0aGlzLmZyYW1lTGFiZWwudGV4dCh0aGlzLmdldEN1cnJlbnRGcmFtZUlkKCkpO1xuXHR9XG5cblx0cHVibGljIGdldEN1cnJlbnRMb2NhdGlvbklkKCk6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuaW1hZ2VMb2NhdGlvbi5sb2NhdGlvbklkO1xuXHR9XG5cblx0cHVibGljIGdldEN1cnJlbnRGcmFtZUlkKCk6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuc2VsZWN0ZWRJbWdJbmRleCArIDE7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUNhbnZhcyhza2lwSW1hZ2VUcmFja0RyYXcgPSBmYWxzZSk6IHZvaWRcblx0e1xuXHRcdGlmICghdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5zZWxlY3RlZEltYWdlQ2FudmFzXG5cdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZVdpZHRoKVxuXHRcdFx0LmF0dHIoJ2hlaWdodCcsIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0KTtcblxuXHRcdGlmICgodGhpcy5zaG93T3V0bGluZVRvZ2dsZS5ub2RlKCkgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZClcblx0XHR7XG5cdFx0XHR0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8uZ2V0TGFiZWwodGhpcy5nZXRDdXJyZW50TG9jYXRpb25JZCgpLCB0aGlzLnNlbGVjdGVkSW1nSW5kZXgsXG5cdFx0XHRcdChkYXRhOiBJbWFnZUxhYmVscywgZmlyc3RJbmRleDogbnVtYmVyKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5jcmVhdGVPdXRsaW5lSW1hZ2UoZGF0YSwgZmlyc3RJbmRleCk7XG5cdFx0XHRcdFx0dGhpcy5kcmF3RGVmYXVsdENhbnZhcygpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuY2xlYXJDYW52YXMoKTtcblx0XHR9XG5cdFx0dGhpcy5kcmF3UGlubmVkQ2VsbE1hcmtlcnMoKTtcblxuXG5cdFx0bGV0IGxvY0lkID0gdGhpcy5pbWFnZUxvY2F0aW9uLmxvY2F0aW9uSWQ7XG5cdFx0aWYgKCFza2lwSW1hZ2VUcmFja0RyYXcpIHtcblx0XHRcdHRoaXMudXBkYXRlVHJhY2tzQ2FudmFzKCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVUcmFja3NDYW52YXMoKTogdm9pZFxuXHR7XG5cdFx0bGV0IGF1dG9DdXJ2ZUxpc3Q6IGNvbmRpdGlvbkV4ZW1wbGFyPEN1cnZlTkQ+W107XG5cdFx0bGV0IGV2ZW50VG9EaXNwYXRjaCA9IG51bGw7XG5cdFx0aWYgKHRoaXMuaW5FeGVtcGxhck1vZGUpIHtcblx0XHRcdHRoaXMuZXhlbXBsYXJMb2NhdGlvbnMuY2xlYXIoKTtcblx0XHRcdHRoaXMuZXhlbXBsYXJGcmFtZXMuY2xlYXIoKTtcblx0XHRcdGF1dG9DdXJ2ZUxpc3QgPSB0aGlzLmdldEV4ZW1wbGFyQ3VydmVzKCk7XG5cdFx0XHRsZXQganVzdERhdGEgPSBhdXRvQ3VydmVMaXN0Lm1hcChkID0+IGQuZGF0YSk7XG5cdFx0XHRmb3IgKGxldCBjdXJ2ZUxpc3Qgb2YgW2p1c3REYXRhLCB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzXSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgY3VydmUgb2YgY3VydmVMaXN0KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgZmlyc3RQb2ludCA9IGN1cnZlLnBvaW50TGlzdFswXTtcblx0XHRcdFx0XHRjb25zdCBsb2NJZCA9IGZpcnN0UG9pbnQuZ2V0KCdMb2NhdGlvbiBJRCcpXG5cdFx0XHRcdFx0dGhpcy5leGVtcGxhckxvY2F0aW9ucy5hZGQobG9jSWQpO1xuXHRcdFx0XHRcdGlmICghdGhpcy5leGVtcGxhckZyYW1lcy5oYXMobG9jSWQpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmV4ZW1wbGFyRnJhbWVzLnNldChsb2NJZCwgbmV3IFNldCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGV0IGZyYW1lU2V0ID0gdGhpcy5leGVtcGxhckZyYW1lcy5nZXQobG9jSWQpO1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb25kZW5zZWRNb2RlQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgcG9pbnQ6IFBvaW50TkQgPSB0aGlzLmltYWdlVHJhY2tXaWRnZXQuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUoY3VydmUsIGkpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZnJhbWU6IG51bWJlciA9IHBvaW50LmdldCgnRnJhbWUgSUQnKTtcblx0XHRcdFx0XHRcdGZyYW1lU2V0LmFkZChmcmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXRoaXMuZXhlbXBsYXJMb2NhdGlvbnMuaGFzKHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSkpXG5cdFx0XHR7XG5cdFx0XHRcdGV2ZW50VG9EaXNwYXRjaCA9IG5ldyBDdXN0b21FdmVudCgnbG9jRnJhbWVDbGlja2VkJywgeyBkZXRhaWw6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2NhdGlvbklkOiBqdXN0RGF0YVswXS5wb2ludExpc3RbMF0uZ2V0KCdMb2NhdGlvbiBJRCcpLFxuXHRcdFx0XHRcdGZyYW1lSWQ6IGp1c3REYXRhWzBdLnBvaW50TGlzdFswXS5nZXQoJ0ZyYW1lIElEJylcblx0XHRcdFx0fX0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGF1dG9DdXJ2ZUxpc3QgPSB0aGlzLmdldEN1cnZlc0Jhc2VkT25Qb2ludHNBdEN1cnJlbnRGcmFtZSgpO1xuXHRcdFx0dGhpcy5leGVtcGxhckxvY2F0aW9ucy5jbGVhcigpO1xuXHRcdFx0dGhpcy5leGVtcGxhckZyYW1lcy5jbGVhcigpO1xuXHRcdH1cblx0XHR0aGlzLmltYWdlVHJhY2tXaWRnZXQuZHJhdyhhdXRvQ3VydmVMaXN0LCB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzKTtcblx0XHRpZiAoZXZlbnRUb0Rpc3BhdGNoKVxuXHRcdHtcblx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRUb0Rpc3BhdGNoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdldEV4ZW1wbGFyQ3VydmVzKCk6IGNvbmRpdGlvbkV4ZW1wbGFyPEN1cnZlTkQ+W11cblx0e1xuXHRcdGxldCBjdXJ2ZUxpc3Q6IGNvbmRpdGlvbkV4ZW1wbGFyPEN1cnZlTkQ+W10gPSBbXTtcblx0XHRjb25zdCB0cmFja0xlbmd0aEtleSA9ICdUcmFjayBMZW5ndGgnO1xuXHRcdGZvciAobGV0IGZhY2V0IG9mIHRoaXMuZmFjZXRMaXN0KSB7XG5cdFx0XHRsZXQgZmFjZXREYXRhOiBDdXJ2ZUxpc3QgPSBmYWNldC5kYXRhO1xuXHRcdFx0bGV0IHRyYWNrcyA9IGZhY2V0RGF0YS5jdXJ2ZUxpc3Q7XG5cdFx0XHRsZXQgbnVtQ3VydmVzID0gdHJhY2tzLmxlbmd0aDtcblx0XHRcdGNvbnN0IHNhbXBsaW5nU3RhdCA9IHRoaXMuaW1hZ2VUcmFja1dpZGdldC5jdXJyZW50U2FtcGxpbmdTdGF0ZWd5LnN0cmF0O1xuXHRcdFx0bGV0IHBlcmNlbnRhZ2VzOiBudW1iZXJbXTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHNhbXBsaW5nU3RhdCkpXG5cdFx0XHR7XG5cdFx0XHRcdHBlcmNlbnRhZ2VzID0gc2FtcGxpbmdTdGF0O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRwZXJjZW50YWdlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsaW5nU3RhdDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGVyY2VudGFnZXMucHVzaChNYXRoLnJhbmRvbSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY29uZGl0aW9uTGlzdDogY29uZGl0aW9uRXhlbXBsYXI8Q3VydmVORD5bXSA9IFtdXG5cdFx0XHRmb3IgKGxldCBwIG9mIHBlcmNlbnRhZ2VzKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgaW5kZXggPSBNYXRoLnJvdW5kKChudW1DdXJ2ZXMgLSAxKSAqIHApO1xuXHRcdFx0XHRsZXQgZXhlbXBsYXJDdXJ2ZTogQ3VydmVORCA9IHF1aWNrU2VsZWN0KHRyYWNrcywgaW5kZXgsIChjdXJ2ZTogQ3VydmVORCkgPT4gY3VydmUuZ2V0KHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUpKTtcblx0XHRcdFx0Y29uZGl0aW9uTGlzdC5wdXNoKHtkYXRhOiBleGVtcGxhckN1cnZlLCB0eXBlOiAnYXV0byd9KTtcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IHZhbCBvZiB0aGlzLmltYWdlVHJhY2tXaWRnZXQubWFudWFsU2FtcGxlVmFsdWVzKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgY2xvc2VzdEN1cnZlID0gdGhpcy5nZXRDbG9zZXN0Q3VydmUodHJhY2tzLCB2YWwsIHRoaXMuZXhlbXBsYXJBdHRyaWJ1dGUpO1xuXHRcdFx0XHRjb25kaXRpb25MaXN0LnB1c2goe2RhdGE6IGNsb3Nlc3RDdXJ2ZSwgdHlwZTogJ21hbnVhbCcsIGFuY2hvclZhbDogdmFsfSk7XHRcblx0XHRcdH1cblx0XHRcdGNvbmRpdGlvbkxpc3Quc29ydCgoYSwgYikgPT4gYS5kYXRhLmdldCh0aGlzLmV4ZW1wbGFyQXR0cmlidXRlKSAtIGIuZGF0YS5nZXQodGhpcy5leGVtcGxhckF0dHJpYnV0ZSkpO1xuXHRcdFx0Y3VydmVMaXN0LnB1c2goLi4uY29uZGl0aW9uTGlzdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnZlTGlzdFxuXHR9XG5cblx0cHJpdmF0ZSBnZXRDbG9zZXN0Q3VydmUoY3VydmVMaXN0OiBDdXJ2ZU5EW10sIHZhbHVlOiBudW1iZXIsIGF0dHJpYnV0ZTogc3RyaW5nKTogQ3VydmVORFxuXHR7XG5cdFx0bGV0IGNsb3Nlc3RDdXJ2ZTogQ3VydmVORCA9IG51bGw7XG5cdFx0bGV0IHNtYWxsZXN0RGlmZmVyZW5jZSA9IEluZmluaXR5O1xuXHRcdGZvciAobGV0IGN1cnZlIG9mIGN1cnZlTGlzdClcblx0XHR7XG5cdFx0XHRsZXQgZGlmZiA9IE1hdGguYWJzKGN1cnZlLmdldChhdHRyaWJ1dGUpIC0gdmFsdWUpO1xuXHRcdFx0aWYgKGRpZmYgPCBzbWFsbGVzdERpZmZlcmVuY2UpXG5cdFx0XHR7XG5cdFx0XHRcdHNtYWxsZXN0RGlmZmVyZW5jZSA9IGRpZmY7XG5cdFx0XHRcdGNsb3Nlc3RDdXJ2ZSA9IGN1cnZlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2xvc2VzdEN1cnZlO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRDdXJ2ZXNCYXNlZE9uUG9pbnRzQXRDdXJyZW50RnJhbWUoKTogY29uZGl0aW9uRXhlbXBsYXI8Q3VydmVORD5bXSB7XG5cdFx0bGV0IGN1cnZlTGlzdDogY29uZGl0aW9uRXhlbXBsYXI8Q3VydmVORD5bXSA9IFtdO1xuXHRcdGNvbnN0IHBvaW50c0F0RnJhbWUgPSB0aGlzLmRhdGEuR2V0Q2VsbHNBdEZyYW1lKHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSwgdGhpcy5nZXRDdXJyZW50RnJhbWVJZCgpKVxuXHRcdGZvciAobGV0IHBvaW50IG9mIHBvaW50c0F0RnJhbWUpIHtcblx0XHRcdGN1cnZlTGlzdC5wdXNoKHtkYXRhOiBwb2ludC5wYXJlbnQsIHR5cGU6ICdhdXRvJ30pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3VydmVMaXN0XG5cdH1cblxuXHRwcml2YXRlIGNyZWF0ZU91dGxpbmVJbWFnZShyb3dBcnJheTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcik6IHZvaWQge1xuXHRcdGlmICghdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IG15SW1hZ2VEYXRhID0gdGhpcy5jYW52YXNDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC50aWxlV2lkdGgsIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVIZWlnaHQpO1xuXG5cdFx0Zm9yIChsZXQgcm93SWR4ID0gZmlyc3RJbmRleDsgcm93SWR4IDwgZmlyc3RJbmRleCArIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVIZWlnaHQ7IHJvd0lkeCsrKSB7XG5cdFx0XHRsZXQgcm93OiBSb3cgPSByb3dBcnJheS5yb3dMaXN0W3Jvd0lkeF07XG5cdFx0XHRmb3IgKGxldCBsYWJlbFJ1biBvZiByb3cucm93KSB7XG5cdFx0XHRcdGZvciAobGV0IGNvbElkeCA9IGxhYmVsUnVuLnN0YXJ0OyBjb2xJZHggPCBsYWJlbFJ1bi5zdGFydCArIGxhYmVsUnVuLmxlbmd0aDsgY29sSWR4KyspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5pc0JvcmRlcihsYWJlbFJ1bi5sYWJlbCwgcm93SWR4LCBjb2xJZHgsIHJvd0FycmF5KSkge1xuXG5cdFx0XHRcdFx0XHRsZXQgZmxhdElkeCA9IChyb3dJZHggLSBmaXJzdEluZGV4KSAqIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVXaWR0aCArIGNvbElkeDtcblx0XHRcdFx0XHRcdGZsYXRJZHggKj0gNDtcblx0XHRcdFx0XHRcdGxldCBbY2VsbCwgX2luZGV4XSA9IHRoaXMuZ2V0Q2VsbChsYWJlbFJ1bi5sYWJlbCwgdGhpcy5kYXRhKTtcblx0XHRcdFx0XHRcdGxldCB7Y29sb3I6IGNvbG9yLCBzaG93OiBzaG93fT0gdGhpcy5nZXRDZWxsQ29sb3IoY2VsbCk7XG5cdFx0XHRcdFx0XHRpZiAoc2hvdylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0bGV0IFtyLCBnLCBiXSA9IGNvbG9yO1xuXHRcdFx0XHRcdFx0XHRteUltYWdlRGF0YS5kYXRhW2ZsYXRJZHhdID0gcjtcblx0XHRcdFx0XHRcdFx0bXlJbWFnZURhdGEuZGF0YVtmbGF0SWR4ICsgMV0gPSBnO1xuXHRcdFx0XHRcdFx0XHRteUltYWdlRGF0YS5kYXRhW2ZsYXRJZHggKyAyXSA9IGI7XG5cdFx0XHRcdFx0XHRcdG15SW1hZ2VEYXRhLmRhdGFbZmxhdElkeCArIDNdID0gMjU1O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2RlZmF1bHRDYW52YXNTdGF0ZSA9IG15SW1hZ2VEYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3RGVmYXVsdENhbnZhcygpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5kZWZhdWx0Q2FudmFzU3RhdGUpXG5cdFx0e1x0XG5cdFx0XHR0aGlzLmNhbnZhc0NvbnRleHQucHV0SW1hZ2VEYXRhKHRoaXMuZGVmYXVsdENhbnZhc1N0YXRlLCAwLCAwKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGRyYXdQaW5uZWRDZWxsTWFya2VycygpOiB2b2lkXG5cdHtcblxuXHRcdGZvciAobGV0IHRyYWNrIG9mIHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgdHJhY2sucG9pbnRMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocG9pbnQuZ2V0KCdMb2NhdGlvbiBJRCcpICE9PSB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbklkKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocG9pbnQuZ2V0KCdGcmFtZSBJRCcpID09PSB0aGlzLmdldEN1cnJlbnRGcmFtZUlkKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmRyYXdDZWxsQ2VudGVyKHBvaW50LCAzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgY2xlYXJDYW52YXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5jYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmltYWdlU3RhY2tXaWR0aCwgdGhpcy5pbWFnZVN0YWNrSGVpZ2h0KTtcblx0XHR0aGlzLl9kZWZhdWx0Q2FudmFzU3RhdGUgPSB0aGlzLmNhbnZhc0NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVXaWR0aCwgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QudGlsZUhlaWdodCk7XG5cdH1cblxuXHRwdWJsaWMgaXNCb3JkZXIobGFiZWw6IG51bWJlciwgcm93SWR4OiBudW1iZXIsIGNvbElkeDogbnVtYmVyLCByb3dBcnJheTogSW1hZ2VMYWJlbHMpOiBib29sZWFuXG5cdHtcblx0XHRsZXQgbmVpZ2hib3JJbmRpY2VzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcblx0XHQvLyA0LW5laWdoYm9yXG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCAtIDEsIGNvbElkeF0pO1xuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHggKyAxLCBjb2xJZHhdKTtcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4LCBjb2xJZHggLSAxXSk7XG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCwgY29sSWR4ICsgMV0pO1xuXHRcdC8vIDgtbmVpZ2hib3Jcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4IC0gMSwgY29sSWR4IC0gMV0pO1xuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHggKyAxLCBjb2xJZHggLSAxXSk7XG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCArIDEsIGNvbElkeCAtIDFdKTtcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4IC0gMSwgY29sSWR4ICsgMV0pO1xuXHRcdC8vIDEyLW5laWdoYm9yXG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCAtIDIsIGNvbElkeF0pO1xuXHRcdG5laWdoYm9ySW5kaWNlcy5wdXNoKFtyb3dJZHggKyAyLCBjb2xJZHhdKTtcblx0XHRuZWlnaGJvckluZGljZXMucHVzaChbcm93SWR4LCBjb2xJZHggLSAyXSk7XG5cdFx0bmVpZ2hib3JJbmRpY2VzLnB1c2goW3Jvd0lkeCwgY29sSWR4ICsgMl0pO1xuXG5cblx0XHRmb3IgKGxldCBbckksIGNJXSBvZiBuZWlnaGJvckluZGljZXMpIHtcblx0XHRcdGlmIChySSA8IDBcblx0XHRcdFx0fHwgckkgPj0gcm93QXJyYXkucm93TGlzdC5sZW5ndGhcblx0XHRcdFx0fHwgY0kgPCAwXG5cdFx0XHRcdHx8IGNJID49IHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnRpbGVXaWR0aCkge1xuXHRcdFx0XHQvLyBuZWlnaGJvciBvdXQgb2YgYm91bmRzIG9mIHRpbGVcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRsZXQgblZhbCA9IEltYWdlU3RhY2tEYXRhUmVxdWVzdC5nZXRMYWJlbFZhbHVlKHJJLCBjSSwgcm93QXJyYXkpO1xuXHRcdFx0aWYgKG5WYWwgIT09IGxhYmVsKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHByaXZhdGUgb25DYW52YXNNb3VzZU1vdmUoZTogTW91c2VFdmVudCk6IHZvaWRcblx0e1xuXHRcdGlmICghdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QgfHwgIXRoaXMuZGVmYXVsdENhbnZhc1N0YXRlKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX21vdXNlUG9zID0ge29mZnNldDogW2Uub2Zmc2V0WCwgZS5vZmZzZXRZXSwgcGFnZTogW2UucGFnZVgsIGUucGFnZVldfTtcblx0XHR0aGlzLnVwZGF0ZUJhc2VkT25Nb3VzZVBvc2l0aW9uKCk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUJhc2VkT25Nb3VzZVBvc2l0aW9uKGZvcmNlRHJhdzogYm9vbGVhbiA9IGZhbHNlKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMubW91c2VQb3MgPT09IG51bGwpXG5cdFx0e1xuXHRcdFx0dGhpcy5oaWRlU2VnbWVudEhvdmVyKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsKHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSwgdGhpcy5zZWxlY3RlZEltZ0luZGV4LFxuXHRcdChyb3dBcnJheTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcikgPT4ge1xuXHRcdFx0Y29uc3Qgcm93SWR4ID0gdGhpcy5tb3VzZVBvcy5vZmZzZXRbMV0gKyBmaXJzdEluZGV4O1xuXHRcdFx0Y29uc3QgY29sSWR4ID0gdGhpcy5tb3VzZVBvcy5vZmZzZXRbMF07XG5cdFx0XHRjb25zdCBsYWJlbCA9IEltYWdlU3RhY2tEYXRhUmVxdWVzdC5nZXRMYWJlbFZhbHVlKHJvd0lkeCwgY29sSWR4LCByb3dBcnJheSk7XG5cdFx0XHRpZiAobGFiZWwgPT09IHRoaXMuY2VsbEhvdmVyZWQgJiYgIWZvcmNlRHJhdylcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2VsbEhvdmVyZWQgPSBsYWJlbDtcblx0XHRcdGlmIChsYWJlbCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLmRyYXdEZWZhdWx0Q2FudmFzKCk7XG5cdFx0XHRcdHRoaXMuZHJhd1Bpbm5lZENlbGxNYXJrZXJzKCk7XG5cdFx0XHRcdHRoaXMudG9vbHRpcC5IaWRlKCk7XG5cdFx0XHRcdGNvbnN0IGN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmcmFtZUhvdmVyQ2hhbmdlJywge1xuXHRcdFx0XHRcdGRldGFpbDpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRsb2NhdGlvbklkOiB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbklkKCksXG5cdFx0XHRcdFx0XHRmcmFtZUlkOiB0aGlzLmdldEN1cnJlbnRGcmFtZUlkKCksXG5cdFx0XHRcdFx0XHRjZWxsSWQ6IG51bGxcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNob3dTZWdtZW50SG92ZXIocm93QXJyYXksIGxhYmVsLCBmaXJzdEluZGV4LCBmb3JjZURyYXcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBvbkNhbnZhc0NsaWNrKGU6IE1vdXNlRXZlbnQpOiB2b2lkXG5cdHtcblx0XHRpZiAoIXRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0IHx8ICF0aGlzLmRlZmF1bHRDYW52YXNTdGF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC5nZXRMYWJlbCh0aGlzLmdldEN1cnJlbnRMb2NhdGlvbklkKCksIHRoaXMuc2VsZWN0ZWRJbWdJbmRleCxcblx0XHRcdChyb3dBcnJheTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcikgPT4ge1xuXHRcdFx0XHRjb25zdCByb3dJZHggPSBlLm9mZnNldFkgKyBmaXJzdEluZGV4O1xuXHRcdFx0XHRjb25zdCBjb2xJZHggPSBlLm9mZnNldFg7XG5cdFx0XHRcdGNvbnN0IGxhYmVsID0gSW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsVmFsdWUocm93SWR4LCBjb2xJZHgsIHJvd0FycmF5KTtcblx0XHRcdFx0bGV0IFtjZWxsLCBfaW5kZXhdID0gdGhpcy5nZXRDZWxsKGxhYmVsLCB0aGlzLmZ1bGxEYXRhKTtcblx0XHRcdFx0aWYgKGNlbGwpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCB0cmFjayA9IGNlbGwucGFyZW50O1xuXHRcdFx0XHRcdHRoaXMudG9nZ2xlUGluKHRyYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdH1cblxuXHRwdWJsaWMgdG9nZ2xlUGluKHRyYWNrOiBDdXJ2ZU5EKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MuaW5jbHVkZXModHJhY2spKVxuXHRcdHtcblx0XHRcdGNvbnN0IGluZGV4ID0gdGhpcy5tYW51YWxseVBpbm5lZFRyYWNrcy5pbmRleE9mKHRyYWNrKTtcblx0XHRcdHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MudW5zaGlmdCh0cmFjayk7XG5cdFx0fVxuXHRcdHRoaXMudXBkYXRlQ2FudmFzKCk7XG5cdFx0Y29uc3QgbWFudWFsUGluVG9nZ2xlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21hbnVhbFBpblRvZ2dsZScsIHtkZXRhaWw6IHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3N9KTtcblx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG1hbnVhbFBpblRvZ2dsZUV2ZW50KTtcblx0fVxuXG5cdHB1YmxpYyBoaWRlU2VnbWVudEhvdmVyKGhpZGVUb29sdGlwSW1tZWRpYXRlbHk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuXHRcdHRoaXMuZHJhd0RlZmF1bHRDYW52YXMoKTtcblx0XHR0aGlzLmRyYXdQaW5uZWRDZWxsTWFya2VycygpO1xuXHRcdGxldCBkZWxheU92ZXJyaWRlOiBudW1iZXI7XG5cdFx0aWYgKGhpZGVUb29sdGlwSW1tZWRpYXRlbHkpIHtcblx0XHRcdGRlbGF5T3ZlcnJpZGUgPSAwO1xuXHRcdH1cblx0XHR0aGlzLnRvb2x0aXAuSGlkZShkZWxheU92ZXJyaWRlKTtcblx0fVxuXG5cdHB1YmxpYyBzaG93U2VnbWVudEhvdmVyKHJvd0FycmF5OiBJbWFnZUxhYmVscywgc2VnbWVudElkOiBudW1iZXIsIGZpcnN0SW5kZXg6IG51bWJlciwgc2hvd1Rvb2x0aXBJbW1lZGlhdGVseTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG5cdFx0dGhpcy5fY2VsbEhvdmVyZWQgPSBzZWdtZW50SWQ7XG5cdFx0bGV0IFtjZWxsLCBpbmRleF0gPSB0aGlzLmdldENlbGwoc2VnbWVudElkLCB0aGlzLmZ1bGxEYXRhKTtcblxuXHRcdGxldCBjZWxsWCA9IDA7XG5cdFx0bGV0IGNlbGxZID0gMDtcblx0XHRsZXQgcGFnZVggPSAwO1xuXHRcdGxldCBwYWdlWSA9IDA7XG5cdFx0aWYgKGNlbGwpIHtcblx0XHRcdGxldCBjYW52YXNCb3VuZFJlY3QgPSB0aGlzLnNlbGVjdGVkSW1hZ2VDYW52YXMubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0Y2VsbFggPSAoY2VsbC5nZXQoJ1gnKSArIGNlbGwuZ2V0KCd4U2hpZnQnKSkgLyB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC5zY2FsZUZhY3Rvcjtcblx0XHRcdGNlbGxZID0gKGNlbGwuZ2V0KCdZJykgKyBjZWxsLmdldCgneVNoaWZ0JykpIC8gdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Quc2NhbGVGYWN0b3I7XG5cdFx0XHRwYWdlWCA9IGNhbnZhc0JvdW5kUmVjdC54ICsgY2VsbFg7XG5cdFx0XHRwYWdlWSA9IGNhbnZhc0JvdW5kUmVjdC55ICsgY2VsbFk7XG5cblx0XHRcdGNvbnN0IGN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmcmFtZUhvdmVyQ2hhbmdlJywge1xuXHRcdFx0XHRkZXRhaWw6XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2NhdGlvbklkOiB0aGlzLmdldEN1cnJlbnRMb2NhdGlvbklkKCksXG5cdFx0XHRcdFx0ZnJhbWVJZDogdGhpcy5nZXRDdXJyZW50RnJhbWVJZCgpLFxuXHRcdFx0XHRcdGNlbGxJZDogY2VsbC5wYXJlbnQuaWRcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2ZW50KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5tb3VzZVBvcykge1xuXHRcdFx0cGFnZVggPSB0aGlzLm1vdXNlUG9zLnBhZ2VbMF07XG5cdFx0XHRwYWdlWSA9IHRoaXMubW91c2VQb3MucGFnZVsxXTtcblx0XHR9XG5cblx0XHRsZXQgbXlJbWFnZURhdGEgPSB0aGlzLmNhbnZhc0NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGgsIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0KTtcblx0XHRteUltYWdlRGF0YS5kYXRhLnNldCh0aGlzLmRlZmF1bHRDYW52YXNTdGF0ZS5kYXRhKTtcblx0XHRmb3IgKGxldCByb3dJZHggPSBmaXJzdEluZGV4OyByb3dJZHggPCBmaXJzdEluZGV4ICsgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3QudGlsZUhlaWdodDsgcm93SWR4KyspIHtcblx0XHRcdGxldCByb3c6IFJvdyA9IHJvd0FycmF5LnJvd0xpc3Rbcm93SWR4XTtcblx0XHRcdGZvciAobGV0IGxhYmVsUnVuIG9mIHJvdy5yb3cpIHtcblx0XHRcdFx0aWYgKGxhYmVsUnVuLmxhYmVsID09PSB0aGlzLmNlbGxIb3ZlcmVkKSB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgY29sSWR4ID0gbGFiZWxSdW4uc3RhcnQ7IGNvbElkeCA8IGxhYmVsUnVuLnN0YXJ0ICsgbGFiZWxSdW4ubGVuZ3RoOyBjb2xJZHgrKykge1xuXHRcdFx0XHRcdFx0bGV0IGZsYXRJZHggPSAocm93SWR4IC0gZmlyc3RJbmRleCkgKiB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdC50aWxlV2lkdGggKyBjb2xJZHg7XG5cdFx0XHRcdFx0XHRmbGF0SWR4ICo9IDQ7XG5cdFx0XHRcdFx0XHRsZXQgW2NlbGwsIF9pbmRleF0gPSB0aGlzLmdldENlbGwobGFiZWxSdW4ubGFiZWwsIHRoaXMuZGF0YSk7XG5cdFx0XHRcdFx0XHRsZXQge2NvbG9yOiBjb2xvciwgc2hvdzogc2hvd30gPSB0aGlzLmdldENlbGxDb2xvcihjZWxsKTtcblx0XHRcdFx0XHRcdGxldCBbciwgZywgYl0gPSBjb2xvcjtcblx0XHRcdFx0XHRcdG15SW1hZ2VEYXRhLmRhdGFbZmxhdElkeF0gPSByO1xuXHRcdFx0XHRcdFx0bXlJbWFnZURhdGEuZGF0YVtmbGF0SWR4ICsgMV0gPSBnO1xuXHRcdFx0XHRcdFx0bXlJbWFnZURhdGEuZGF0YVtmbGF0SWR4ICsgMl0gPSBiO1xuXHRcdFx0XHRcdFx0bXlJbWFnZURhdGEuZGF0YVtmbGF0SWR4ICsgM10gPSAyMDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmNhbnZhc0NvbnRleHQucHV0SW1hZ2VEYXRhKG15SW1hZ2VEYXRhLCAwLCAwKTtcblx0XHR0aGlzLmRyYXdQaW5uZWRDZWxsTWFya2VycygpO1xuXHRcdHRoaXMuZHJhd0NlbGxDZW50ZXIoY2VsbCwgNSk7XG5cblx0XHRsZXQgdG9vbHRpcENvbnRlbnQ6IHN0cmluZyA9IHRoaXMuZ2V0VG9vbHRpcENvbnRlbnQoc2VnbWVudElkLCBjZWxsLCBpbmRleCk7XG5cdFx0bGV0IGRlbGF5T3ZlcnJpZGU6IG51bWJlcjtcblx0XHRpZiAoc2hvd1Rvb2x0aXBJbW1lZGlhdGVseSkge1xuXHRcdFx0ZGVsYXlPdmVycmlkZSA9IDA7XG5cdFx0fVxuXHRcdHRoaXMudG9vbHRpcC5TaG93KHRvb2x0aXBDb250ZW50LCBwYWdlWCwgcGFnZVksIGRlbGF5T3ZlcnJpZGUpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3Q2VsbENlbnRlcihjZWxsOiBQb2ludE5ELCByYWRpdXM6IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdGlmIChjZWxsKVxuXHRcdHtcblx0XHRcdGxldCBjZWxsWCA9IChjZWxsLmdldCgnWCcpICsgY2VsbC5nZXQoJ3hTaGlmdCcpKSAvIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LnNjYWxlRmFjdG9yO1xuXHRcdFx0bGV0IGNlbGxZID0gKGNlbGwuZ2V0KCdZJykgKyBjZWxsLmdldCgneVNoaWZ0JykpIC8gdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Quc2NhbGVGYWN0b3I7XG5cdFx0XHR0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHR0aGlzLmNhbnZhc0NvbnRleHQuYXJjKGNlbGxYLCBjZWxsWSwgcmFkaXVzLCAwLCAyICogTWF0aC5QSSk7XG5cdFx0XHR0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXHRcdFx0dGhpcy5jYW52YXNDb250ZXh0LnN0cm9rZSgpO1xuXHRcdFx0dGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICcjRkYwMEZGJztcblx0XHRcdHRoaXMuY2FudmFzQ29udGV4dC5maWxsKCk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGdldExhYmVsSW5kZXhGcm9tQmlnSW1nUGl4ZWxYWShmcmFtZUluZGV4OiBudW1iZXIsIHg6IG51bWJlciwgeTogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXSB7XG5cdFx0eCA9IE1hdGgucm91bmQoeCk7XG5cdFx0eSA9IE1hdGgucm91bmQoeSk7XG5cblx0XHRsZXQgY29sSWR4ID0geCAlIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGg7XG5cdFx0bGV0IHJvd0lkeCA9ICh5ICUgdGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVIZWlnaHQpICsgKGZyYW1lSW5kZXggJSB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZXNQZXJGaWxlKSAqIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0O1xuXG5cdFx0cmV0dXJuIFtyb3dJZHgsIGNvbElkeF07XG5cdH1cblxuXHRwdWJsaWMgZ2V0VGlsZUluZGV4RnJvbUJpZ0ltZ1BpeGVsWFkoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdGxldCBjb2xJbmRleCA9IE1hdGguZmxvb3IoeCAvIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlV2lkdGgpO1xuXHRcdGxldCByb3dJbmRleCA9IE1hdGguZmxvb3IoeSAvIHRoaXMuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0KTtcblx0XHRyZXR1cm4gcm93SW5kZXggKiB0aGlzLmltYWdlU3RhY2tEYXRhUmVxdWVzdD8ubnVtYmVyT2ZDb2x1bW5zICsgY29sSW5kZXg7XG5cdH1cblxuXHRwcml2YXRlIGdldFRvb2x0aXBDb250ZW50KGxhYmVsOiBudW1iZXIsIGNlbGw6IFBvaW50TkQgfCBudWxsLCBpbmRleDogbnVtYmVyIHwgbnVsbCk6IHN0cmluZyB7XG5cdFx0bGV0IGxhYmVsVmFsdWVQYWlyczogW3N0cmluZywgc3RyaW5nIHwgbnVsbF1bXSA9IFtdXG5cdFx0bGV0IGNlbGxJZCA9IGNlbGw/LnBhcmVudD8uaWQ7XG5cdFx0aWYgKGNlbGxJZClcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBrZXkgb2YgWydYJywgJ1knLCAnTWFzcyAocGcpJywnQXJlYScsICdNZWFuIEludGVuc2l0eSddKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgdmFsdWUgPSBjZWxsLmdldChrZXkpO1xuXHRcdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxhYmVsVmFsdWVQYWlycy5wdXNoKFtrZXksIHZhbHVlLnRvRml4ZWQoMSldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGFiZWxWYWx1ZVBhaXJzLnB1c2goWydSb3cnLCBpbmRleC50b1N0cmluZygpXSk7XG5cdFx0XHRsYWJlbFZhbHVlUGFpcnMucHVzaChbJ1NlZ21lbnQnLCBsYWJlbC50b1N0cmluZygpXSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRsYWJlbFZhbHVlUGFpcnMucHVzaChbJ1NlZ21lbnQnLCBsYWJlbC50b1N0cmluZygpXSk7XG5cdFx0XHRsYWJlbFZhbHVlUGFpcnMucHVzaChbJ05vIGNlbGwgbGlua2VkJywgbnVsbF0pXG5cdFx0fVxuXHRcdHJldHVybiBSaWNoVG9vbHRpcC5jcmVhdGVMYWJlbFZhbHVlTGlzdENvbnRlbnQobGFiZWxWYWx1ZVBhaXJzKTtcblx0fVxuXG5cdHB1YmxpYyBnZXRDZWxsKGxhYmVsOiBudW1iZXIsIGRhdGFTb3VyY2U6IEN1cnZlTGlzdCk6IFtQb2ludE5ELCBudW1iZXJdIHwgW251bGwsIG51bGxdXG5cdHtcblx0XHRyZXR1cm4gZGF0YVNvdXJjZS5HZXRDZWxsRnJvbUxhYmVsKHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSwgdGhpcy5nZXRDdXJyZW50RnJhbWVJZCgpLCBsYWJlbCk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0Q2VsbENvbG9yKGNlbGw6IFBvaW50TkQgfCBudWxsKTogeyBjb2xvcjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBzaG93OiBib29sZWFuIH1cblx0e1xuXHRcdGxldCBjb2xvcjogW251bWJlciwgbnVtYmVyLCBudW1iZXJdID0gWzAsIDAsIDBdO1xuXHRcdGxldCBzaG93OiBib29sZWFuO1xuXHRcdGlmICghY2VsbClcblx0XHR7XG5cdFx0XHQvLyBudXRlZC9kYXJrZW5lZCBmcm9tIFNwcmluZ0dyZWVuXG5cdFx0XHRjb2xvciA9IFsxMTksIDE0MCwgNzddO1xuXHRcdFx0c2hvdyA9ICh0aGlzLmxlZ2VuZFRvZ2dsZUZpbHRlcmVkT3V0Lm5vZGUoKWFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWRcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2VsbC5pbkJydXNoKVxuXHRcdHtcblx0XHRcdC8vIEZpcmVCcmlja1xuXHRcdFx0Y29sb3IgPSBbMTc4LCAzNCwgMzRdO1xuXHRcdFx0c2hvdyA9ICh0aGlzLmxlZ2VuZFRvZ2dsZVNlbGVjdGVkLm5vZGUoKWFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQ7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHQvLyBTdGVlbEJsdWVcblx0XHRcdGNvbG9yID0gWzcwLCAxMzAsIDE4MF07XG5cdFx0XHRzaG93ID0gKHRoaXMubGVnZW5kVG9nZ2xlTm90U2VsZWN0ZWQubm9kZSgpYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZDtcblx0XHR9XG5cdFx0cmV0dXJuIHtjb2xvcjogY29sb3IsIHNob3c6IHNob3d9O1xuXHR9XG5cblx0cHVibGljIGNoYW5nZVNlbGVjdGVkSW1hZ2UobmV3SW5kZXg6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMuX3NlbGVjdGVkSW1nSW5kZXggPSBuZXdJbmRleDtcblx0XHR0aGlzLmRyYXdVcGRhdGUoKTtcblx0fVxuXG5cdHByaXZhdGUgc2V0SW1hZ2VJbmxpbmVTdHlsZShpbmRleDogbnVtYmVyLCBpbmNsdWRlRmFsbGJhY2sgPSB0cnVlKTogdm9pZCB7XG5cdFx0dGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LmdldEltYWdlKHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uSWQoKSwgaW5kZXgsXG5cdFx0XHQodG9wLCBsZWZ0LCBfYmxvYiwgaW1hZ2VVcmwpID0+IHtcblx0XHRcdFx0bGV0IHN0eWxlU3RyaW5nOiBzdHJpbmcgPVxuXHRcdFx0XHRcdGBcblx0XHRcdFx0XHRiYWNrZ3JvdW5kLXBvc2l0aW9uLXg6ICR7LWxlZnR9cHg7XG5cdFx0XHRcdFx0YmFja2dyb3VuZC1wb3NpdGlvbi15OiAkey10b3B9cHg7XG5cdFx0XHRcdFx0d2lkdGg6ICR7dGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVXaWR0aH1weDtcblx0XHRcdFx0XHRoZWlnaHQ6ICR7dGhpcy5pbWFnZVN0YWNrRGF0YVJlcXVlc3Q/LnRpbGVIZWlnaHR9cHg7XG5cdFx0XHRcdFx0YDtcblx0XHRcdFx0aWYgKGltYWdlVXJsKSB7XG5cdFx0XHRcdFx0c3R5bGVTdHJpbmcgKz0gYGJhY2tncm91bmQtaW1hZ2U6IHVybCgke2ltYWdlVXJsfSk7YDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpbmNsdWRlRmFsbGJhY2spIHtcblx0XHRcdFx0XHRzdHlsZVN0cmluZyArPSAnYmFja2dyb3VuZC1jb2xvcjogI2ViZWJlYjsnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2VsZWN0ZWRJbWFnZUNvbnRhaW5lci5hdHRyKFwic3R5bGVcIiwgc3R5bGVTdHJpbmcpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUJhY2tncm91bmRQb3NpdGlvbihpbmRleDogbnVtYmVyKSB7XG5cdFx0dGhpcy5zZXRJbWFnZUlubGluZVN0eWxlKGluZGV4KTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRwdWJsaWMgT25SZXNpemUobmV3TWF4SGVpZ2h0OiBudW1iZXIsIGltYWdlVHJhY2tNYXhIZWlnaHQ6IG51bWJlciwgbmV3V2lkdGg6IG51bWJlcik6IHZvaWQge1xuXHRcdHRoaXMuX21heEhlaWdodCA9IG5ld01heEhlaWdodDtcblx0XHR0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYG1heC1oZWlnaHQ6ICR7dGhpcy5tYXhIZWlnaHR9cHg7YCk7XG5cdFx0dGhpcy5pbWFnZVRyYWNrV2lkZ2V0Lk9uUmVzaXplKG5ld1dpZHRoLCBpbWFnZVRyYWNrTWF4SGVpZ2h0KTtcblx0fVxuXG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHt0b09yZGluYWx9IGZyb20gJ251bWJlci10by13b3Jkcyc7XG5pbXBvcnQgeyBIdG1sU2VsZWN0aW9uLCBTdmdTZWxlY3Rpb24sIE1hcmdpbiwgTkRpbSwgQnV0dG9uUHJvcHMgfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVHlwZXMnO1xuaW1wb3J0IHsgSW1hZ2VTdGFja1dpZGdldCB9IGZyb20gJy4vSW1hZ2VTdGFja1dpZGdldCc7XG5pbXBvcnQgeyBDdXJ2ZU5EIH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTkQnO1xuaW1wb3J0IHsgUG9pbnRORCB9IGZyb20gJy4uL0RhdGFNb2RlbC9Qb2ludE5EJztcbmltcG9ydCB7IGNvbmRpdGlvbkV4ZW1wbGFyLCBSZWN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRGV2bGliTWF0aCB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJNYXRoJztcbmltcG9ydCB7IERldmxpYkFsZ28gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliQWxnbyc7XG5pbXBvcnQgeyBJbWFnZUxhYmVscywgSW1hZ2VTdGFja0RhdGFSZXF1ZXN0LCBSb3cgfSBmcm9tICcuLi9EYXRhTW9kZWwvSW1hZ2VTdGFja0RhdGFSZXF1ZXN0JztcbmltcG9ydCB7IERldmxpYlRTVXRpbCB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUU1V0aWwnO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5pbXBvcnQgeyBIaXN0b2dyYW1XaWRnZXQgfSBmcm9tICcuL0hpc3RvZ3JhbVdpZGdldCc7XG5pbXBvcnQgeyBPcHRpb25TZWxlY3QgfSBmcm9tICcuL09wdGlvblNlbGVjdCc7XG5pbXBvcnQgeyBHcm91cEJ5V2lkZ2V0IH0gZnJvbSAnLi9Hcm91cEJ5V2lkZ2V0JztcblxuZXhwb3J0IGNsYXNzIEltYWdlVHJhY2tXaWRnZXRcbntcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXI6IEhUTUxFbGVtZW50LCBwYXJlbnQ6IEltYWdlU3RhY2tXaWRnZXQsIHNhbXBsaW5nU3RyYXRPcHRpb25zOiB7XCJzdHJhdFwiOiAobnVtYmVyW10gfCBudW1iZXIpLCBcImxhYmVsXCI6IHN0cmluZ31bXSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5fcGFyZW50V2lkZ2V0ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbFBhZCA9IDI0O1xuICAgICAgICB0aGlzLl9ob3Jpem9udGFsUGFkID0gODtcbiAgICAgICAgdGhpcy5fdHJhY2tUb1Bsb3RQYWRkaW5nID0gNDg7XG4gICAgICAgIHRoaXMuX2V4ZW1wbGFyTWluV2lkdGggPSA4MDtcbiAgICAgICAgdGhpcy5fbWluSGVpZ2h0Rm9yRmF2b3JpdGVzID0gMTIwICsgMiAqIHRoaXMudmVydGljYWxQYWQ7XG4gICAgICAgIHRoaXMuX2ZyYW1lTGFiZWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2VsbExhYmVsUG9zaXRpb25zID0gW107XG4gICAgICAgIHRoaXMuX2V4ZW1wbGFyWUtleSA9ICdNYXNzX25vcm0nO1xuICAgICAgICB0aGlzLl9zYW1wbGluZ1N0cmF0T3B0aW9ucyA9IHNhbXBsaW5nU3RyYXRPcHRpb25zO1xuXHRcdHRoaXMuX3Ntb290aEN1cnZlcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RyYWdnaW5nUGluID0gZmFsc2U7XG4gICAgICAgIC8vIGhhcmRjb2RlZCBmcm9tIGNzc1xuICAgICAgICB0aGlzLl9jZWxsVGltZWxpbmVNYXJnaW4gPSB7XG4gICAgICAgICAgICB0b3A6IDM2LFxuICAgICAgICAgICAgcmlnaHQ6IDQsXG4gICAgICAgICAgICBib3R0b206IDQsXG4gICAgICAgICAgICBsZWZ0OiAxMjRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXRlc3RTY3JvbGwgPSBbMCwwXTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQ2hhbmdlVGlja2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zb3VyY2VEZXN0Q2VsbCA9IFtdO1xuICAgICAgICB0aGlzLl9oaXN0b2dyYW1TY2FsZVlMaXN0ID0gW107XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29udGFpbmVyIDogSFRNTEVsZW1lbnQ7XG4gICAgcHVibGljIGdldCBjb250YWluZXIoKSA6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9wYXJlbnRXaWRnZXQgOiBJbWFnZVN0YWNrV2lkZ2V0O1xuICAgIHB1YmxpYyBnZXQgcGFyZW50V2lkZ2V0KCkgOiBJbWFnZVN0YWNrV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudFdpZGdldDtcbiAgICB9ICAgIFxuICAgIFxuICAgIHByaXZhdGUgX2lubmVyQ29udGFpbmVyIDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGlubmVyQ29udGFpbmVyKCkgOiBIdG1sU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2lubmVyQ29udGFpbmVyVyA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGlubmVyQ29udGFpbmVyVygpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyQ29udGFpbmVyVztcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfaW5uZXJDb250YWluZXJIIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgaW5uZXJDb250YWluZXJIKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXJDb250YWluZXJIO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RpdGxlQ29udGFpbmVyIDogSHRtbFNlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IHRpdGxlQ29udGFpbmVyKCkgOiBIdG1sU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpdGxlQ29udGFpbmVyO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zYW1wbGluZ1N0cmF0ZWd5U2VsZWN0IDogT3B0aW9uU2VsZWN0O1xuICAgIHB1YmxpYyBnZXQgc2FtcGxpbmdTdHJhdGVneVNlbGVjdCgpIDogT3B0aW9uU2VsZWN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsaW5nU3RyYXRlZ3lTZWxlY3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2FtcGxpbmdTdHJhdE9wdGlvbnMgOiB7XCJzdHJhdFwiOiAobnVtYmVyW10gfCBudW1iZXIpLCBcImxhYmVsXCI6IHN0cmluZ31bXTtcbiAgICBwdWJsaWMgZ2V0IHNhbXBsaW5nU3RyYXRPcHRpb25zKCkgOiAoe1wic3RyYXRcIjogKG51bWJlcltdIHwgbnVtYmVyKSwgXCJsYWJlbFwiOiBzdHJpbmd9W10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NhbXBsaW5nU3RyYXRPcHRpb25zO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2N1cnJlbnRTYW1wbGluZ1N0YXRlZ3kgOiB7XCJzdHJhdFwiOiAobnVtYmVyW10gfCBudW1iZXIpLCBcImxhYmVsXCI6IHN0cmluZ307XG4gICAgcHVibGljIGdldCBjdXJyZW50U2FtcGxpbmdTdGF0ZWd5KCkgOiB7XCJzdHJhdFwiOiAobnVtYmVyW10gfCBudW1iZXIpLCBcImxhYmVsXCI6IHN0cmluZ30ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFNhbXBsaW5nU3RhdGVneTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYW51YWxTYW1wbGVWYWx1ZXMgOiBudW1iZXJbXTtcbiAgICBwdWJsaWMgZ2V0IG1hbnVhbFNhbXBsZVZhbHVlcygpIDogbnVtYmVyW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFudWFsU2FtcGxlVmFsdWVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgbWFudWFsU2FtcGxlVmFsdWVzKHY6IG51bWJlcltdKSB7XG4gICAgICAgIHRoaXMuX21hbnVhbFNhbXBsZVZhbHVlcyA9IHY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc3ZnQ29udGFpbmVyIDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgc3ZnQ29udGFpbmVyKCkgOiBTdmdTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3ZnQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NlbGxMYWJlbEdyb3VwIDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgY2VsbExhYmVsR3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZWxsTGFiZWxHcm91cDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9sYWJlbExpbmVQYWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBsYWJlbExpbmVQYWQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbExpbmVQYWQ7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX3NjZW50ZWRXaWRnZXRHcm91cCA6IFN2Z1NlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IHNjZW50ZWRXaWRnZXRHcm91cCgpIDogU3ZnU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjZW50ZWRXaWRnZXRHcm91cDtcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfZXhlbXBsYXJQaW5Hcm91cCA6IFN2Z1NlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGV4ZW1wbGFyUGluR3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVtcGxhclBpbkdyb3VwO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9hZGRQaW5SZWN0R3JvdXAgOiBTdmdTZWxlY3Rpb247XG4gICAgcHVibGljIGdldCBhZGRQaW5SZWN0R3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRQaW5SZWN0R3JvdXA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbWFudWFsRXhlbXBsYXJQaW5Hcm91cCA6IFN2Z1NlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IG1hbnVhbEV4ZW1wbGFyUGluR3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYW51YWxFeGVtcGxhclBpbkdyb3VwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2ZyYW1lTGFiZWxHcm91cCA6IFN2Z1NlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lTGFiZWxHcm91cCgpIDogU3ZnU2VsZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lTGFiZWxHcm91cDtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfZXhlbXBsYXJDdXJ2ZXNHcm91cCA6IFN2Z1NlbGVjdGlvbjtcbiAgICBwdWJsaWMgZ2V0IGV4ZW1wbGFyQ3VydmVzR3JvdXAoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVtcGxhckN1cnZlc0dyb3VwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3NoYW1lUmVjdGFuZ2xlIDogU3ZnU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgc2hhbWVSZWN0YW5nbGUoKSA6IFN2Z1NlbGVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFtZVJlY3RhbmdsZTtcbiAgICB9ICAgIFxuXG5cdHByaXZhdGUgX3NlbGVjdGVkSW1hZ2VDYW52YXMgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHNlbGVjdGVkSW1hZ2VDYW52YXMoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZEltYWdlQ2FudmFzO1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FudmFzQ29udGV4dCA6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcblx0cHVibGljIGdldCBjYW52YXNDb250ZXh0KCkgOiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXNDb250ZXh0O1xuICAgIH1cbiAgICBcblx0cHJpdmF0ZSBfZGVmYXVsdENhbnZhc1N0YXRlOiBJbWFnZURhdGE7XG5cdHB1YmxpYyBnZXQgZGVmYXVsdENhbnZhc1N0YXRlKCk6IEltYWdlRGF0YSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlZmF1bHRDYW52YXNTdGF0ZTtcblx0fVxuXG4gICAgcHJpdmF0ZSBfdHJhY2tMaXN0IDogY29uZGl0aW9uRXhlbXBsYXI8Q3VydmVORD5bXTtcbiAgICBwdWJsaWMgZ2V0IHRyYWNrTGlzdCgpIDogY29uZGl0aW9uRXhlbXBsYXI8Q3VydmVORD5bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja0xpc3Q7XG4gICAgfVxuICAgICAgICBcbiAgICBwcml2YXRlIF9tYW51YWxseVBpbm5lZFRyYWNrcyA6IEN1cnZlTkRbXTtcbiAgICBwdWJsaWMgZ2V0IG1hbnVhbGx5UGlubmVkVHJhY2tzKCkgOiBDdXJ2ZU5EW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFudWFsbHlQaW5uZWRUcmFja3M7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbWluSGVpZ2h0Rm9yRmF2b3JpdGVzIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgbWluSGVpZ2h0Rm9yRmF2b3JpdGVzKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluSGVpZ2h0Rm9yRmF2b3JpdGVzO1xuICAgIH0gICAgXG4gICAgXG4gICAgcHJpdmF0ZSBfdmVydGljYWxQYWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCB2ZXJ0aWNhbFBhZCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRpY2FsUGFkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hvcml6b250YWxQYWQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBob3Jpem9udGFsUGFkKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbFBhZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF90cmFja1RvUGxvdFBhZGRpbmcgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCB0cmFja1RvUGxvdFBhZGRpbmcoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja1RvUGxvdFBhZGRpbmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnJhbWVMYWJlbFBvc2l0aW9ucyA6IFtzdHJpbmcsIG51bWJlcl1bXTtcbiAgICBwdWJsaWMgZ2V0IGZyYW1lTGFiZWxQb3NpdGlvbnMoKSA6IFtzdHJpbmcsIG51bWJlcl1bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUxhYmVsUG9zaXRpb25zO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NlbGxMYWJlbFBvc2l0aW9ucyA6IFtzdHJpbmcsIG51bWJlcl1bXTtcbiAgICBwdWJsaWMgZ2V0IGNlbGxMYWJlbFBvc2l0aW9ucygpIDogW3N0cmluZywgbnVtYmVyXVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbGxMYWJlbFBvc2l0aW9ucztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jb25kaXRpb25MYWJlbFBvc2l0aW9ucyA6IFtzdHJpbmcsIFtudW1iZXIsIG51bWJlcl1dW107XG4gICAgcHVibGljIGdldCBjb25kaXRpb25MYWJlbFBvc2l0aW9ucygpIDogW3N0cmluZywgW251bWJlciwgbnVtYmVyXV1bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25kaXRpb25MYWJlbFBvc2l0aW9ucztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9oaXN0b2dyYW1TY2FsZVggOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG4gICAgcHVibGljIGdldCBoaXN0b2dyYW1TY2FsZVgoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaXN0b2dyYW1TY2FsZVg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaGlzdG9ncmFtU2NhbGVZTGlzdCA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPltdO1xuICAgIHB1YmxpYyBnZXQgaGlzdG9ncmFtU2NhbGVZTGlzdCgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlzdG9ncmFtU2NhbGVZTGlzdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9ub3JtYWxpemVkSGlzdG9ncmFtU2NhbGVZIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuICAgIHB1YmxpYyBnZXQgbm9ybWFsaXplZEhpc3RvZ3JhbVNjYWxlWSgpIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVk7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2NlbGxUaW1lbGluZU1hcmdpbiA6IE1hcmdpbjtcbiAgICBwdWJsaWMgZ2V0IGNlbGxUaW1lbGluZU1hcmdpbigpIDogTWFyZ2luIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NlbGxUaW1lbGluZU1hcmdpbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zY3JvbGxDaGFuZ2VUaWNraW5nIDogYm9vbGVhbjtcbiAgICBwdWJsaWMgZ2V0IHNjcm9sbENoYW5nZVRpY2tpbmcoKSA6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsQ2hhbmdlVGlja2luZztcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfbGF0ZXN0U2Nyb2xsIDogW251bWJlciwgbnVtYmVyXTtcbiAgICBwdWJsaWMgZ2V0IGxhdGVzdFNjcm9sbCgpIDogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RTY3JvbGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbGF0ZXN0TW91c2VDYW52YXNPZmZzZXQgOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIHB1YmxpYyBnZXQgbGF0ZXN0TW91c2VDYW52YXNPZmZzZXQoKSA6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF0ZXN0TW91c2VDYW52YXNPZmZzZXQ7XG4gICAgfSAgICBcblxuICAgIHByaXZhdGUgX3NvdXJjZURlc3RDZWxsIDogW1JlY3QsIFtudW1iZXIsIG51bWJlcl0sIFBvaW50TkRdW107XG4gICAgcHVibGljIGdldCBzb3VyY2VEZXN0Q2VsbCgpIDogW1JlY3QsIFtudW1iZXIsIG51bWJlcl0sIFBvaW50TkRdW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlRGVzdENlbGw7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2V4ZW1wbGFyU2NhbGVYIDogZDMuU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuICAgIHB1YmxpYyBnZXQgZXhlbXBsYXJTY2FsZVgoKSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVtcGxhclNjYWxlWDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9leGVtcGxhclNjYWxlWSA6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPjtcbiAgICBwdWJsaWMgZ2V0IGV4ZW1wbGFyU2NhbGVZKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhlbXBsYXJTY2FsZVk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZXhlbXBsYXJNaW5XaWR0aCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGV4ZW1wbGFyTWluV2lkdGgoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVtcGxhck1pbldpZHRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2V4ZW1wbGFyWUtleSA6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IGV4ZW1wbGFyWUtleSgpIDogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4ZW1wbGFyWUtleTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zbW9vdGhDdXJ2ZXMgOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IHNtb290aEN1cnZlcygpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3Ntb290aEN1cnZlcztcblx0fVxuXG4gICAgcHJpdmF0ZSBfZHJhZ2dpbmdQaW4gOiBib29sZWFuO1xuICAgIHB1YmxpYyBnZXQgZHJhZ2dpbmdQaW4oKSA6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmdQaW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZHJhZ2dpbmdQaW5FbGVtZW50IDogU1ZHUGF0aEVsZW1lbnQ7XG4gICAgcHVibGljIGdldCBkcmFnZ2luZ1BpbkVsZW1lbnQoKSA6IFNWR1BhdGhFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdnaW5nUGluRWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9uZWVkbGVTZWxlY3Rpb24gOiBkMy5TZWxlY3Rpb248U1ZHTGluZUVsZW1lbnQsIGFueSwgRWxlbWVudCwgYW55PjtcbiAgICBwdWJsaWMgZ2V0IG5lZWRsZVNlbGVjdGlvbigpIDogZDMuU2VsZWN0aW9uPFNWR0xpbmVFbGVtZW50LCBhbnksIEVsZW1lbnQsIGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVlZGxlU2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RleHRTZWxlY3Rpb24gOiBkMy5TZWxlY3Rpb248U1ZHVGV4dEVsZW1lbnQsIGFueSwgRWxlbWVudCwgYW55PjtcbiAgICBwdWJsaWMgZ2V0IHRleHRTZWxlY3Rpb24oKSA6IGQzLlNlbGVjdGlvbjxTVkdUZXh0RWxlbWVudCwgYW55LCBFbGVtZW50LCBhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRTZWxlY3Rpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5pdGlhbERyYWdDb29yZHMgOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIHB1YmxpYyBnZXQgaW5pdGlhbERyYWdDb29yZHMoKSA6IFtudW1iZXIsIG51bWJlcl0ge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbERyYWdDb29yZHM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdG90YWxEcmFnT2Zmc2V0IDogW251bWJlciwgbnVtYmVyXTtcbiAgICBwdWJsaWMgZ2V0IHRvdGFsRHJhZ09mZnNldCgpIDogW251bWJlciwgbnVtYmVyXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3RhbERyYWdPZmZzZXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5pdGlhbFBpblZhbHVlIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgaW5pdGlhbFBpblZhbHVlKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5pdGlhbFBpblZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2FuY2hvclBpblZhbHVlIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgYW5jaG9yUGluVmFsdWUoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JQaW5WYWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9waW5Nb3ZlZCA6IGJvb2xlYW47XG4gICAgcHVibGljIGdldCBwaW5Nb3ZlZCgpIDogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waW5Nb3ZlZDtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfZHJhZ0dyb3VwSW5kZXggOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBkcmFnR3JvdXBJbmRleCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdHcm91cEluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0aXRsZUJhckRpdiA9IGNvbnRhaW5lclNlbGVjdC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgndHJhY2tNb2RlVGl0bGVDb250YWluZXInLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ21lZGl1bVRleHQnLCB0cnVlKTtcblxuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuX3RpdGxlQ29udGFpbmVyPSB0aXRsZUJhckRpdi5hcHBlbmQoJ3NwYW4nKTtcblxuICAgICAgICBjb25zdCBvcHRpb25TZWxlY3RDb250YWluZXIgPSB0aXRsZUJhckRpdi5hcHBlbmQoJ3NwYW4nKVxuICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ2V4ZW1wbGFyU2FtcGxpbmdTdHJhdFNlbGVjdGlvbicpXG5cbiAgICAgICAgdGhpcy5fc2FtcGxpbmdTdHJhdGVneVNlbGVjdCA9IG5ldyBPcHRpb25TZWxlY3QoJ2V4ZW1wbGFyU2FtcGxpbmdTdHJhdFNlbGVjdGlvbicsICdTYW1wbGVkIGF0Jyk7XG4gICAgICAgIGxldCBidXR0b25Qcm9wTGlzdDogQnV0dG9uUHJvcHNbXSA9IFtdO1xuICAgICAgICB0aGlzLl9jdXJyZW50U2FtcGxpbmdTdGF0ZWd5ID0gdGhpcy5zYW1wbGluZ1N0cmF0T3B0aW9uc1swXTsgLy8gZGVmYXVsdCB0byBmaXJzdFxuICAgICAgICB0aGlzLl9tYW51YWxTYW1wbGVWYWx1ZXMgPSBbXTsgLy8gdG9kbyByZW1vdmVcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uIG9mIHRoaXMuc2FtcGxpbmdTdHJhdE9wdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBvcHRpb25OYW1lOiBzdHJpbmc7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmxhYmVsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSBvcHRpb24ubGFiZWw7XG4gICAgICAgICAgICB9XG5cdFx0XHRlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbi5zdHJhdCkpXG5cdFx0XHR7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbkNvcHk6IG51bWJlcltdIHwgc3RyaW5nW10gPSBvcHRpb24uc3RyYXQubWFwKHggPT4geCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbi5zdHJhdC5sZW5ndGggPCA4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uQ29weSA9IG9wdGlvbkNvcHkubWFwKHggPT4gXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnTWluJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0gMC41KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdNZWRpYW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdNYXgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9PcmRpbmFsKDEwMCAqIHgpICsgJyBwZXJjZW50aWxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgPSBvcHRpb25Db3B5LmpvaW4oJywgJyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG4gICAgICAgICAgICAgICAgb3B0aW9uTmFtZSA9IGAke29wdGlvbi5zdHJhdH0gcmFuZG9tIHRyYWNrYDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnN0cmF0ID4gMSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbk5hbWUgKz0gJ3MnO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cblx0XHRcdGxldCBidXR0b25Qcm9wOiBCdXR0b25Qcm9wcyA9IHtcblx0XHRcdFx0ZGlzcGxheU5hbWU6IG9wdGlvbk5hbWUsXG5cdFx0XHRcdGNhbGxiYWNrOiAoKSA9PiBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTYW1wbGluZ1N0YXRlZ3kgPSBvcHRpb247XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzYW1wbGluZ1N0cmF0ZWd5Q2hhbmdlJywge2RldGFpbDogb3B0aW9ufSkpO1xuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cblx0XHRcdGJ1dHRvblByb3BMaXN0LnB1c2goYnV0dG9uUHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYW1wbGluZ1N0cmF0ZWd5U2VsZWN0Lm9uRGF0YUNoYW5nZShidXR0b25Qcm9wTGlzdCk7XG5cbiAgICAgICAgdGhpcy5fc3ZnQ29udGFpbmVyID0gY29udGFpbmVyU2VsZWN0LmFwcGVuZCgnc3ZnJyk7XG4gICAgICAgIHRoaXMuX2NlbGxMYWJlbEdyb3VwID0gdGhpcy5zdmdDb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3B9KWApO1xuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuX2xhYmVsTGluZVBhZCA9IDE2O1xuXG4gICAgICAgIHRoaXMuX3NjZW50ZWRXaWRnZXRHcm91cCA9IHRoaXMuc3ZnQ29udGFpbmVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKDAsICR7dGhpcy5jZWxsVGltZWxpbmVNYXJnaW4udG9wfSlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLl9leGVtcGxhclBpbkdyb3VwID0gdGhpcy5zdmdDb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3B9KWApOyAgXG4gICAgICAgICAgICBcbiAgICAgICAgdGhpcy5fYWRkUGluUmVjdEdyb3VwID0gdGhpcy5zdmdDb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3B9KWApO1xuXG4gICAgICAgIHRoaXMuX21hbnVhbEV4ZW1wbGFyUGluR3JvdXAgPSB0aGlzLnN2Z0NvbnRhaW5lci5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHRyYW5zbGF0ZSgwLCAke3RoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLnRvcH0pYCk7ICBcbiAgICAgICAgICAgIFxuICAgICAgICBjb25zdCBvZmZzZXRUb0V4ZW1wbGFyQ3VydmVzID0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5fZXhlbXBsYXJDdXJ2ZXNHcm91cCA9IHRoaXMuc3ZnQ29udGFpbmVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKCR7b2Zmc2V0VG9FeGVtcGxhckN1cnZlc30sICR7dGhpcy5jZWxsVGltZWxpbmVNYXJnaW4udG9wfSlgKTtcblxuICAgICAgICB0aGlzLl9zaGFtZVJlY3RhbmdsZSA9IHRoaXMuc3ZnQ29udGFpbmVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxMDAwMClcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3ApXG4gICAgICAgICAgICAuYXR0cignZmlsbCcsICd3aGl0ZScpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgMCk7XG5cbiAgICAgICAgdGhpcy5fZnJhbWVMYWJlbEdyb3VwID0gdGhpcy5zdmdDb250YWluZXIuYXBwZW5kKCdnJylcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi5sZWZ0fSwgMClgKTtcblxuICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lciA9IGNvbnRhaW5lclNlbGVjdC5hcHBlbmQoJ2RpdicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnY2VsbFRpbWVsaW5lSW5uZXJDb250YWluZXInLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ292ZXJmbG93LXNjcm9sbCcsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuaW5uZXJDb250YWluZXIubm9kZSgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIChlOiBXaGVlbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2VsbFRpbWVsaW5lU2Nyb2xsKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zZWxlY3RlZEltYWdlQ2FudmFzID0gdGhpcy5pbm5lckNvbnRhaW5lci5hcHBlbmQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjYW52YXNFbGVtZW50OiBIVE1MQ2FudmFzRWxlbWVudCA9IHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5ub2RlKCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICAgIGNhbnZhc0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGU6IE1vdXNlRXZlbnQpID0+IHRoaXMub25DYW52YXNNb3VzZU1vdmUoZSkgKTtcbiAgICAgICAgY2FudmFzRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlOiBNb3VzZUV2ZW50KSA9PiB0aGlzLm9uQ2FudmFzQ2xpY2soZSkpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW1hZ2VDYW52YXMub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB0aGlzLm9uQ2FudmFzTW91c2VMZWF2ZSgpICk7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmcmFtZUhvdmVyQ2hhbmdlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZnJhbWVJZCA9IGUuZGV0YWlsLmZyYW1lSWQ7XG4gICAgICAgICAgICBjb25zdCBjZWxsSWQgPSBlLmRldGFpbC5jZWxsSWQ7XG4gICAgICAgICAgICBjb25zdCByb3dJbmRleCA9IGUuZGV0YWlsLnJvd0luZGV4O1xuICAgICAgICAgICAgaWYgKGZyYW1lSWQgIT09IG51bGwgJiYgY2VsbElkICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBmcmFtZUluZGV4OiBudW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJ2ZTogQ3VydmVORCA9IHRoaXMucGFyZW50V2lkZ2V0LmZ1bGxEYXRhLmN1cnZlTG9va3VwLmdldChjZWxsSWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRJbmRleCA9IGN1cnZlLnBvaW50TGlzdC5maW5kSW5kZXgocG9pbnQgPT4gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpID09PSBmcmFtZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgTCA9IGN1cnZlLnBvaW50TGlzdC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IHBvaW50SW5kZXggLyBMO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gcGVyY2VudCAqICh0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYW1lSW5kZXhSb3VuZGVkID0gTWF0aC5yb3VuZChmcmFtZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlYWxQZXJjZW50ID0gZnJhbWVJbmRleFJvdW5kZWQgLyAodGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50IC0gMSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXBzaWxvbiA9IDEgLyBMO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocGVyY2VudCAtIHJlYWxQZXJjZW50KSA8IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSBmcmFtZUluZGV4Um91bmRlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gZnJhbWVJZCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFiZWxzT25Nb3VzZU1vdmUoY2VsbElkLCBmcmFtZUluZGV4LCByb3dJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYWJlbHNPbk1vdXNlTW92ZSgnJywgLTEsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYXZlcmFnZUN1cnZlS2V5Q2hhbmdlJywgKGU6IEN1c3RvbUV2ZW50KSA9PiBcblx0XHR7XG5cdFx0XHR0aGlzLl9leGVtcGxhcllLZXkgPSBlLmRldGFpbC55S2V5O1xuICAgICAgICAgICAgdGhpcy5kcmF3RXhlbXBsYXJHcm93dGhDdXJ2ZXMoKTtcblx0XHR9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzbW9vdGhDdXJ2ZUNoYW5nZScsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0dGhpcy5fc21vb3RoQ3VydmVzID0gZS5kZXRhaWw7XG4gICAgICAgICAgICB0aGlzLmRyYXdFeGVtcGxhckdyb3d0aEN1cnZlcygpO1xuXHRcdH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21hbnVhbFBpblRvZ2dsZScsIChlOiBDdXN0b21FdmVudCkgPT4gXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0V4ZW1wbGFyR3Jvd3RoQ3VydmVzKCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYub25EcmFnKGUubW92ZW1lbnRYLCBlLm1vdmVtZW50WSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZi5vbkRyYWdFbmQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9jRnJhbWVDbGlja2VkJywgKGU6IEN1c3RvbUV2ZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gZS5kZXRhaWwuZnJhbWVJZDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudEZyYW1lSW5kaWNhdG9yKGZyYW1lSWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZHJhdyh0cmFja3M6IGNvbmRpdGlvbkV4ZW1wbGFyPEN1cnZlTkQ+W10sIG1hbnVhbGx5UGlubmVkVHJhY2tzOiBDdXJ2ZU5EW10pOiBQcm9taXNlPHZvaWQ+XG4gICAge1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2tzID09PSB0aGlzLnRyYWNrTGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERldmxpYlRTVXRpbC5sYXVuY2hTcGlubmVyKCk7XG4gICAgICAgIHRoaXMuX3RyYWNrTGlzdCA9IHRyYWNrcztcbiAgICAgICAgdGhpcy5fbWFudWFsbHlQaW5uZWRUcmFja3MgPSBtYW51YWxseVBpbm5lZFRyYWNrcztcbiAgICAgICAgdGhpcy51cGRhdGVUaXRsZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLmRyYXdUcmFja0xpc3QoKTtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKCk7XG4gICAgICAgIHRoaXMuZHJhd0FsbFBpbnModHJhY2tzKTtcbiAgICAgICAgdGhpcy5kcmF3RXhlbXBsYXJHcm93dGhDdXJ2ZXMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRpdGxlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkV4ZW1wbGFyTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50aXRsZUNvbnRhaW5lci50ZXh0KCdFeGVtcGxhcnMgb2YgJyArIHRoaXMucGFyZW50V2lkZ2V0LmV4ZW1wbGFyQXR0cmlidXRlICsgJyAtICcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy50aXRsZUNvbnRhaW5lci50ZXh0KCdGcmFtZSBFeHRyYWN0aW9uIE1vZGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgT25CcnVzaENoYW5nZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRyYXdPdXRsaW5lcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgZHJhd1RyYWNrTGlzdCgpOiBQcm9taXNlPHZvaWQ+XG4gICAge1xuICAgICAgICBjb25zdCBqdXN0RGF0YSA9IHRoaXMudHJhY2tMaXN0Lm1hcChkID0+IGQuZGF0YSk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkVHJhY2tzID0gWy4uLnRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MsIC4uLmp1c3REYXRhXTtcbiAgICAgICAgdGhpcy5fc291cmNlRGVzdENlbGwgPSBbXTtcbiAgICAgICAgbGV0IGxpc3RPZkJvdW5kaW5nQm94TGlzdHMgPSBhd2FpdCB0aGlzLmdldEJvdW5kaW5nQm94TGlzdHMoY29tYmluZWRUcmFja3MpO1xuICAgICAgICBsZXQgbWF4SGVpZ2h0TGlzdDogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgbGV0IG1heFdpZHRoOiBudW1iZXIgPSBkMy5tYXgobGlzdE9mQm91bmRpbmdCb3hMaXN0cywgXG4gICAgICAgICAgICAocmVjdExpc3Q6IFJlY3RbXSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDMubWF4KHJlY3RMaXN0LCByID0+IEltYWdlVHJhY2tXaWRnZXQucmVjdFdpZHRoKHIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgcmVjdExpc3Qgb2YgbGlzdE9mQm91bmRpbmdCb3hMaXN0cylcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IHRoaXNIZWlnaHQgPSBkMy5tYXgocmVjdExpc3QsIHIgPT4gSW1hZ2VUcmFja1dpZGdldC5yZWN0SGVpZ2h0KHIpKTtcbiAgICAgICAgICAgIG1heEhlaWdodExpc3QucHVzaCh0aGlzSGVpZ2h0KTsgXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbWluRnJhbWVJZCA9IGQzLm1pbihjb21iaW5lZFRyYWNrcywgXG4gICAgICAgICAgICAodHJhY2s6IEN1cnZlTkQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLm1pbih0cmFjay5wb2ludExpc3QsIHBvaW50ID0+IHBvaW50LmdldCgnRnJhbWUgSUQnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbWF4RnJhbWVJZCA9IGQzLm1heChjb21iaW5lZFRyYWNrcywgXG4gICAgICAgICAgICAodHJhY2s6IEN1cnZlTkQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQzLm1heCh0cmFjay5wb2ludExpc3QsIHBvaW50ID0+IHBvaW50LmdldCgnRnJhbWUgSUQnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBsZXQgbnVtRnJhbWVzOiBudW1iZXI7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG51bUZyYW1lcyA9IHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG51bUZyYW1lcyA9IG1heEZyYW1lSWQgLSBtaW5GcmFtZUlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhHcm91cENvbnRlbnRIZWlnaHQgPSB0aGlzLmdldE1heEdyb3VwSGVpZ2h0KG1heEhlaWdodExpc3QpO1xuICAgICAgICBjb25zdCBudW1FeGVtcGxhcnMgPSB0aGlzLnBhcmVudFdpZGdldC5udW1FeGVtcGxhcnM7XG5cbiAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBudW1GcmFtZXMgKiBtYXhXaWR0aCArIHRoaXMuaG9yaXpvbnRhbFBhZCAqIChudW1GcmFtZXMgKyAxKTtcbiAgICAgICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGhpcy52ZXJ0aWNhbFBhZCAqIChjb21iaW5lZFRyYWNrcy5sZW5ndGggKyAxKTtcbiAgICAgICAgY29uc3QgYmV0d2Vlbkdyb3VwUGFkID0gMTY7XG4gICAgICAgIGNvbnN0IGhlaWdodE9mTWFudWFsbHlQaW5uZWQgPSBkMy5zdW0obWF4SGVpZ2h0TGlzdC5zbGljZSgwLCB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzLmxlbmd0aCkpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5FeGVtcGxhck1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG51bUdyb3VwcyA9ICh0aGlzLnRyYWNrTGlzdC5sZW5ndGggLyBudW1FeGVtcGxhcnMpO1xuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gbWF4R3JvdXBDb250ZW50SGVpZ2h0ICogbnVtR3JvdXBzO1xuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gYmV0d2Vlbkdyb3VwUGFkICogbnVtR3JvdXBzO1xuICAgICAgICAgICAgdG90YWxIZWlnaHQgKz0gaGVpZ2h0T2ZNYW51YWxseVBpbm5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IGQzLnN1bShtYXhIZWlnaHRMaXN0KTtcblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhc1xuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY2FudmFzV2lkdGgpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgdG90YWxIZWlnaHQpO1xuXG4gICAgICAgIGxldCB2ZXJ0aWNhbE9mZnNldDogbnVtYmVyID0gdGhpcy52ZXJ0aWNhbFBhZDtcbiAgICAgICAgdGhpcy5fY2VsbExhYmVsUG9zaXRpb25zID0gW107XG5cbiAgICAgICAgbGV0IGRyYXdUcmFja1Byb21pc2VzID0gW107XG4gICAgICAgIGxldCB2ZXJ0aWNhbE9mZnNldExpc3QgPSBbXTtcbiAgICAgICAgY29uc3QgcGluT2Zmc2V0ID0gdGhpcy5tYW51YWxseVBpbm5lZFRyYWNrcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tYmluZWRUcmFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU3RhcnJlZCA9IGkgPCBwaW5PZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkSWR4ID0gaSAtIHBpbk9mZnNldDtcbiAgICAgICAgICAgIGxldCB0cmFjayA9IGNvbWJpbmVkVHJhY2tzW2ldO1xuICAgICAgICAgICAgbGV0IGJvdW5kaW5nQm94TGlzdCA9IGxpc3RPZkJvdW5kaW5nQm94TGlzdHNbaV07XG4gICAgICAgICAgICBsZXQgdHJhY2tIZWlnaHQgPSBtYXhIZWlnaHRMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlICYmIGkgPT09IHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MubGVuZ3RoICYmIHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9IE1hdGgubWF4KHZlcnRpY2FsT2Zmc2V0LCB0aGlzLm1pbkhlaWdodEZvckZhdm9yaXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldExpc3QucHVzaCh2ZXJ0aWNhbE9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBjYXRlZ29yeUluZGV4ID0gTWF0aC5mbG9vcihzYW1wbGVkSWR4IC8gbnVtRXhlbXBsYXJzKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5kcmF3VHJhY2sodHJhY2ssIGJvdW5kaW5nQm94TGlzdCwgbWF4V2lkdGgsIHRyYWNrSGVpZ2h0LCBtaW5GcmFtZUlkLCB2ZXJ0aWNhbE9mZnNldCwgY2F0ZWdvcnlJbmRleCwgaXNTdGFycmVkKTtcbiAgICAgICAgICAgIGRyYXdUcmFja1Byb21pc2VzLnB1c2goZG9uZSk7XG4gICAgICAgICAgICB0aGlzLmNlbGxMYWJlbFBvc2l0aW9ucy5wdXNoKFt0cmFjay5pZCwgdmVydGljYWxPZmZzZXQgKyB0cmFja0hlaWdodCAvIDJdKTtcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ICs9IHRyYWNrSGVpZ2h0ICsgdGhpcy52ZXJ0aWNhbFBhZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkV4ZW1wbGFyTW9kZSAmJiAhaXNTdGFycmVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBncm91cFN0YXJ0SWR4ID0gKHNhbXBsZWRJZHggLSAoc2FtcGxlZElkeCAlIG51bUV4ZW1wbGFycykpICsgcGluT2Zmc2V0OyAvLyBJIGhhdmUgcmVncmV0cyBjb21iaW5pbmcgdGhlc2UgbGlzdHMuXG4gICAgICAgICAgICAgICAgbGV0IGRpZmZCZXR3ZWVuTWF4ID0gbWF4R3JvdXBDb250ZW50SGVpZ2h0IC0gZDMuc3VtKG1heEhlaWdodExpc3Quc2xpY2UoZ3JvdXBTdGFydElkeCwgZ3JvdXBTdGFydElkeCArIG51bUV4ZW1wbGFycykpO1xuICAgICAgICAgICAgICAgIGlmIChpICUgbnVtRXhlbXBsYXJzIDwgbnVtRXhlbXBsYXJzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4dHJhUGFkZGluZyA9IGRpZmZCZXR3ZWVuTWF4IC8gKG51bUV4ZW1wbGFycyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCArPSBleHRyYVBhZGRpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ICs9IGJldHdlZW5Hcm91cFBhZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkV4ZW1wbGFyTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY29uZGl0aW9uTGFiZWxQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbk5hbWVzID0gdGhpcy5nZXRDb25kaXRpb25OYW1lcygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWNrTGlzdC5sZW5ndGg7IGkgKz0gbnVtRXhlbXBsYXJzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGkgKyBwaW5PZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGkgLyBudW1FeGVtcGxhcnM7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBjb25kaXRpb25OYW1lc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSB2ZXJ0aWNhbE9mZnNldExpc3RbaWR4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEJvdCA9IGlkeCArIG51bUV4ZW1wbGFycyAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgYm90ID0gdmVydGljYWxPZmZzZXRMaXN0W2luZGV4Qm90XSArIG1heEhlaWdodExpc3RbaW5kZXhCb3RdO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uTGFiZWxQb3NpdGlvbnMucHVzaChbbmFtZSwgW3RvcCwgYm90XV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhbWVMYWJlbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZyYW1lczsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgZnJhbWVJZDogc3RyaW5nID0gKGkgKyBtaW5GcmFtZUlkKS50b1N0cmluZygpO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuaG9yaXpvbnRhbFBhZFxuICAgICAgICAgICAgb2Zmc2V0ICs9IGkgKiAobWF4V2lkdGggKyB0aGlzLmhvcml6b250YWxQYWQpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG1heFdpZHRoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lTGFiZWxQb3NpdGlvbnMucHVzaChbZnJhbWVJZCwgb2Zmc2V0XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSSBkb24ndCBrbm93IHdoeSBndWxwIGlzbid0IHJlY29nbml6aW5nIGFsbFNldHRsZWQuIFRoZSB2ZXJzaW9uIHNob3VsZFxuICAgICAgICAvLyBiZSBjb3JyZWN0LiBCdXQgSSdtIHRpcmVkIG9mIHNlZWluZyB0aGUgZXJyb3IuXG4gICAgICAgIGF3YWl0IChQcm9taXNlIGFzIGFueSkuYWxsU2V0dGxlZChkcmF3VHJhY2tQcm9taXNlcyk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRDYW52YXNTdGF0ZSA9IHRoaXMuY2FudmFzQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzV2lkdGgsIHRvdGFsSGVpZ2h0KTtcbiAgICAgICAgYXdhaXQgdGhpcy5kcmF3T3V0bGluZXMoZmFsc2UpO1xuICAgICAgICBEZXZsaWJUU1V0aWwuc3RvcFNwaW5uZXIoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1heEdyb3VwSGVpZ2h0KG1heEhlaWdodExpc3Q6IG51bWJlcltdKTogbnVtYmVyXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBvbmx5IHVzZWZ1bCBmb3IgZXhlbXBsYXIgbW9kZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1heEdyb3VwSGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MubGVuZ3RoOyBpIDwgbWF4SGVpZ2h0TGlzdC5sZW5ndGg7IGkgKz0gdGhpcy5wYXJlbnRXaWRnZXQubnVtRXhlbXBsYXJzKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBDb250ZW50SGVpZ2h0ID0gZDMuc3VtKG1heEhlaWdodExpc3Quc2xpY2UoaSwgaSArIHRoaXMucGFyZW50V2lkZ2V0Lm51bUV4ZW1wbGFycykpO1xuICAgICAgICAgICAgbWF4R3JvdXBIZWlnaHQgPSBNYXRoLm1heChtYXhHcm91cEhlaWdodCwgZ3JvdXBDb250ZW50SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4R3JvdXBIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb25kaXRpb25OYW1lcygpOiBzdHJpbmdbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50V2lkZ2V0LmZhY2V0TGlzdC5tYXAoZmFjZXQgPT4gZmFjZXQubmFtZS5qb2luKCdfX18nKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRCb3VuZGluZ0JveExpc3RzKHRyYWNrTGlzdDogQ3VydmVORFtdKTogUHJvbWlzZTxSZWN0W11bXT5cbiAgICB7XG4gICAgICAgIGxldCBsaXN0T2ZMaXN0czogUmVjdFtdW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdHJhY2sgb2YgdHJhY2tMaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdGhpc0xpc3Q6IFJlY3RbXSA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbih0cmFjay5sZW5ndGgsIHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludDogUG9pbnRORCA9IHRoaXMuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUodHJhY2ssIGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGF3YWl0IHRoaXMuZ2V0Q2VsbEJvdW5kaW5nQm94KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0xpc3QucHVzaChib3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRyYWNrLnBvaW50TGlzdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gYXdhaXQgdGhpcy5nZXRDZWxsQm91bmRpbmdCb3gocG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzTGlzdC5wdXNoKGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0T2ZMaXN0cy5wdXNoKHRoaXNMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdE9mTGlzdHM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFBvaW50SW5Db25kZW5zZWRNb2RlKHRyYWNrOiBDdXJ2ZU5ELCBpbmRleDogbnVtYmVyKTogUG9pbnRORFxuICAgIHtcbiAgICAgICAgaWYgKHRyYWNrLnBvaW50TGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjay5wb2ludExpc3RbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4Q291bnQgPSBNYXRoLm1pbih0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQsIHRyYWNrLnBvaW50TGlzdC5sZW5ndGgpO1xuICAgICAgICBsZXQgcGVyY2VudCA9IGluZGV4IC8gKG1heENvdW50IC0gMSk7XG4gICAgICAgIGxldCB0cmFja0luZGV4ID0gTWF0aC5taW4oTWF0aC5mbG9vcihwZXJjZW50ICogdHJhY2sucG9pbnRMaXN0Lmxlbmd0aCksIHRyYWNrLnBvaW50TGlzdC5sZW5ndGgtMSk7XG4gICAgICAgIHJldHVybiB0cmFjay5wb2ludExpc3RbdHJhY2tJbmRleF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBkcmF3VHJhY2soXG4gICAgICAgIHRyYWNrRGF0YTogQ3VydmVORCxcbiAgICAgICAgYm91bmRpbmdCb3hMaXN0OiBSZWN0W10sXG4gICAgICAgIG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyLFxuICAgICAgICBtaW5GcmFtZTogbnVtYmVyLFxuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogbnVtYmVyLFxuICAgICAgICBjYXRlZ29yeUluZGV4OiBudW1iZXIsXG4gICAgICAgIGlzU3RhcnJlZDogYm9vbGVhbik6IFByb21pc2U8dm9pZD5cbiAgICB7XG4gICAgICAgIC8vIGRyYXcgdHJhY2sgYmFja2dyb3VuZFxuICAgICAgICB0aGlzLmRyYXdUcmFja0JhY2tncm91bmRBbmRUaW1lUmFuZ2UodHJhY2tEYXRhLCBtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtaW5GcmFtZSwgdmVydGljYWxPZmZzZXQsIGNhdGVnb3J5SW5kZXgsIGlzU3RhcnJlZCk7XG5cbiAgICAgICAgbGV0IGFzeW5jRnVuY3Rpb25MaXN0ID0gW107XG4gICAgICAgIGxldCBibG9iUmVxdWVzdHM6IFByb21pc2U8W251bWJlciwgbnVtYmVyLCBCbG9iLCBzdHJpbmddPltdID0gW107XG4gICAgICAgIGxldCBvZmZzZXRBcnJheTogW251bWJlciwgbnVtYmVyXVtdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm91bmRpbmdCb3hMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgYml0IHBhaW5mdWwuIFRoZSBiaWdnZXN0IGFkZGl0aW9uIHRvIHRoZSBjb21wbGV4aXR5XG4gICAgICAgICAgICAvLyBpcyBhY2NvdW50aW5nIGZvciBlZGdlIGNhc2VzIGluIHRoZSB0aWxlIG9mIHRoZSB0aWxlZCBpbWFnZS5cbiAgICAgICAgICAgIC8vIGlmIGl0IGdldHMgdG8gYW4gZWRnZSBvbmx5IG9ubHkgY29waWVzIHdoYXQgaXQgY2FuLCB0aGVuIGNlbnRlcnMgaW5cbiAgICAgICAgICAgIC8vIGEgcmVjdCBvZiB0aGUgc2FtZSBzaXplIGFzIG90aGVycyBpbiB0aGUgY2VsbC5cbiAgICAgICAgICAgIGxldCBwb2ludDogUG9pbnRORDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSB0aGlzLmdldFBvaW50SW5Db25kZW5zZWRNb2RlKHRyYWNrRGF0YSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSB0cmFja0RhdGEucG9pbnRMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnJhbWVJZCA9IHBvaW50LmdldCgnRnJhbWUgSUQnKTtcblxuICAgICAgICAgICAgY29uc3QgZnJhbWVJbmRleCA9IGZyYW1lSWQgLSAxO1xuXG4gICAgICAgICAgICBsZXQgYmxvYlJlcXVlc3QgPSB0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0SW1hZ2VQcm9taXNlKHBvaW50LmdldCgnTG9jYXRpb24gSUQnKSwgZnJhbWVJbmRleCk7XG5cbiAgICAgICAgICAgIGJsb2JSZXF1ZXN0cy5wdXNoKGJsb2JSZXF1ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmxvYlJlcXVlc3RzKTtcbiAgICAgICAgbGV0IHNvdXJjZURlc3RDZWxsID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHdvcmtlckRhdGE6IFtCbG9iLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgd2ViV29ya2VyID0gbmV3IFdvcmtlcignL3N0YXRpYy9zY3JpcHQvZGlzdC9JbWFnZVdvcmtlci5qcycpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0cy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBbdGlsZVRvcCwgdGlsZUxlZnQsIGJsb2IsIF91cmxdID0gcmVzdWx0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJib3ggPSBib3VuZGluZ0JveExpc3Rbal07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzWCwgc1ldID0gYmJveFswXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gSW1hZ2VUcmFja1dpZGdldC5yZWN0V2lkdGgoYmJveCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBJbWFnZVRyYWNrV2lkZ2V0LnJlY3RIZWlnaHQoYmJveCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhWCA9IE1hdGgucm91bmQoKG1heFdpZHRoIC0gd2lkdGgpIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhWSA9IE1hdGgucm91bmQoKG1heEhlaWdodCAtIGhlaWdodCkgLyAyKTtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnQ6IFBvaW50TkQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gdGhpcy5nZXRQb2ludEluQ29uZGVuc2VkTW9kZSh0cmFja0RhdGEsIGopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSB0cmFja0RhdGEucG9pbnRMaXN0W2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lSWQgPSBwb2ludC5nZXQoJ0ZyYW1lIElEJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0SW5kZXg6IG51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSB0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdGlvbjogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uID0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbiA9IGogLyAocmVzdWx0cy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSBmcmFjdGlvbiAqICh0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleCBoZXJlIGlzIGEgZmxvYXQgLSBnb3RjaGEhXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRJbmRleCA9IGZyYW1lSWQgLSBtaW5GcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbGVCb3QgPSB0aWxlVG9wICsgdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0Py50aWxlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aWxlUmlnaHQgPSB0aWxlTGVmdCArIHRoaXMucGFyZW50V2lkZ2V0LmltYWdlU3RhY2tEYXRhUmVxdWVzdD8udGlsZVdpZHRoO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weVRvcCA9IERldmxpYk1hdGguY2xhbXAoc1kgLSBleHRyYVksIFt0aWxlVG9wLCB0aWxlQm90XSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlMZWZ0ID0gRGV2bGliTWF0aC5jbGFtcChzWCAtIGV4dHJhWCwgW3RpbGVMZWZ0LCB0aWxlUmlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlXaWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCB0aWxlUmlnaHQgLSBjb3B5TGVmdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlIZWlnaHQgPSBNYXRoLm1pbihtYXhIZWlnaHQsIHRpbGVCb3QgLSBjb3B5VG9wKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKHRoaXMuaG9yaXpvbnRhbFBhZCArIG9mZnNldEluZGV4ICogKG1heFdpZHRoICsgdGhpcy5ob3Jpem9udGFsUGFkKSArIChtYXhXaWR0aCAtIGNvcHlXaWR0aCkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQodmVydGljYWxPZmZzZXQgKyAobWF4SGVpZ2h0IC0gY29weUhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdE9mZnNldDogW251bWJlciwgbnVtYmVyXSA9IFtvZmZzZXRYLCBvZmZzZXRZXTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QXJyYXkucHVzaChkZXN0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNvdXJjZVJlY3Q6IFJlY3QgPSBbW2NvcHlMZWZ0LCBjb3B5VG9wXSwgW2NvcHlMZWZ0ICsgY29weVdpZHRoLCBjb3B5VG9wICsgY29weUhlaWdodF1dO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURlc3RDZWxsLnB1c2goW3NvdXJjZVJlY3QsIGRlc3RPZmZzZXQsIHBvaW50XSk7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZURlc3RDZWxsLnB1c2goW3NvdXJjZVJlY3QsIGRlc3RPZmZzZXQsIHBvaW50XSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlckRhdGEucHVzaChbYmxvYiwgY29weUxlZnQsIGNvcHlUb3AsIGNvcHlXaWR0aCwgY29weUhlaWdodF0pO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdlYldvcmtlci5wb3N0TWVzc2FnZSh3b3JrZXJEYXRhKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2ViV29ya2VyLm9ubWVzc2FnZSA9IChldmVudCkgPT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiaXRNYXBMaXN0OiB7c3RhdHVzOiBzdHJpbmcsIHZhbHVlOkltYWdlQml0bWFwfVtdID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRNYXBMaXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdCaXRtYXAgPSBiaXRNYXBMaXN0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50OiBQb2ludE5EO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUodHJhY2tEYXRhLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHRyYWNrRGF0YS5wb2ludExpc3RbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZyYW1lOiBib29sZWFuID0gZnJhbWVJZCA9PT0gdGhpcy5wYXJlbnRXaWRnZXQuZ2V0Q3VycmVudEZyYW1lSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXRJbmRleDogbnVtYmVyID0gZnJhbWVJZCAtIG1pbkZyYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdE1hcExpc3QubGVuZ3RoID09PSB0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdGlvbjogbnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0TWFwTGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uID0gMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb24gPSBpIC8gKGJpdE1hcExpc3QubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSBmcmFjdGlvbiAqICh0aGlzLnBhcmVudFdpZGdldC5jb25kZW5zZWRNb2RlQ291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXggaGVyZSBpcyBhIGZsb2F0IC0gZ290Y2hhIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRJbmRleCA9IGZyYW1lSWQgLSBtaW5GcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lWCA9IHRoaXMuaG9yaXpvbnRhbFBhZCArIG9mZnNldEluZGV4ICogKG1heFdpZHRoICsgdGhpcy5ob3Jpem9udGFsUGFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lWSA9IHZlcnRpY2FsT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW29mZnNldFgsIG9mZnNldFldID0gb2Zmc2V0QXJyYXlbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KGZyYW1lWCwgZnJhbWVZLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgJiYgIXRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9ICdNZWRpdW1TZWFHcmVlbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmxpbmVXaWR0aCA9IDg7IFxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlID0gJ2dyZXknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSAxOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltZ0JpdG1hcC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5wYXJlbnRXaWRnZXQuaW52ZXJ0SW1hZ2VUb2dnbGUubm9kZSgpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsdGVyID0gJ2ludmVydCgxKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoaW1nQml0bWFwLnZhbHVlLCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsdGVyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB3ZWJXb3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3VHJhY2tCYWNrZ3JvdW5kQW5kVGltZVJhbmdlKFxuICAgICAgICB0cmFja0RhdGE6IEN1cnZlTkQsXG4gICAgICAgIG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyLFxuICAgICAgICBtaW5GcmFtZTogbnVtYmVyLFxuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogbnVtYmVyLFxuICAgICAgICBjYXRlZ29yeUluZGV4OiBudW1iZXIsXG4gICAgICAgIGlzU3RhcnJlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGRyYXcgdHJhY2sgYmFja2dyb3VuZFxuICAgICAgICBsZXQgb2Zmc2V0SW5kZXg6IG51bWJlcjtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgb2Zmc2V0SW5kZXggPSB0cmFja0RhdGEucG9pbnRMaXN0WzBdLmdldCgnRnJhbWUgSUQnKSAtIG1pbkZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbkRlc3RYID0gdGhpcy5ob3Jpem9udGFsUGFkICsgb2Zmc2V0SW5kZXggKiAobWF4V2lkdGggKyB0aGlzLmhvcml6b250YWxQYWQpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBvZmZzZXRJbmRleCA9IHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRyYWNrRGF0YS5wb2ludExpc3QubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIG9mZnNldEluZGV4ID0gdHJhY2tEYXRhLnBvaW50TGlzdFtsYXN0SW5kZXhdLmdldCgnRnJhbWUgSUQnKSAtIG1pbkZyYW1lICsgMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhEZXN0WCA9IG9mZnNldEluZGV4ICogKG1heFdpZHRoICsgdGhpcy5ob3Jpem9udGFsUGFkKTtcbiAgICAgICAgY29uc3QgbWluRGVzdFkgPSB2ZXJ0aWNhbE9mZnNldDtcblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IG1hcmdpblggPSA0O1xuICAgICAgICBjb25zdCBtYXJnaW5ZID0gNDtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlY3QoXG4gICAgICAgICAgICBtaW5EZXN0WCAtIG1hcmdpblgsXG4gICAgICAgICAgICBtaW5EZXN0WSAtIG1hcmdpblksXG4gICAgICAgICAgICBtYXhEZXN0WCAtIG1pbkRlc3RYICsgMSArIDIgKiBtYXJnaW5YLFxuICAgICAgICAgICAgbWF4SGVpZ2h0ICsgMiAqIG1hcmdpblkpO1xuICAgICAgICBsZXQgYmFja2dyb3VuZENvbG9yOiBzdHJpbmc7XG4gICAgICAgIGlmIChpc1N0YXJyZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9ICdyZ2IoMTgwLDE4MCwxODApJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvciA9ICdyZ2IoMjQwLDI0MCwyNDApJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGwoKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZUhlaWdodCA9IDY7XG4gICAgICAgIGNvbnN0IHRpbWVSYW5nZVZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxPZmZzZXQgLSBtYXJnaW5ZIC0gdGltZVJhbmdlSGVpZ2h0O1xuICAgICAgICB0aGlzLmRyYXdUaW1lUmFuZ2UodHJhY2tEYXRhLCBbbWluRGVzdFgsIG1heERlc3RYXSwgdGltZVJhbmdlSGVpZ2h0LCB0aW1lUmFuZ2VWZXJ0aWNhbE9mZnNldCwgY2F0ZWdvcnlJbmRleCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3VGltZVJhbmdlKFxuICAgICAgICB0cmFja0RhdGE6IEN1cnZlTkQsXG4gICAgICAgIGV4dGVudFg6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICAgIGhlaWdodDogbnVtYmVyLFxuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogbnVtYmVyLFxuICAgICAgICBjYXRlZ29yeUluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50V2lkZ2V0LmluQ29uZGVuc2VkTW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXhUaW1lUmFuZ2UgPSB0aGlzLnBhcmVudFdpZGdldC5mdWxsRGF0YS5nZXRNaW5NYXgoJ0ZyYW1lIElEJyk7XG4gICAgICAgIGxldCBzY2FsZVggPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKG1heFRpbWVSYW5nZSlcbiAgICAgICAgICAgIC5yYW5nZShleHRlbnRYKVxuXG4gICAgICAgIGxldCB0aW1lUmFuZ2U6IFtudW1iZXIsIG51bWJlcl0gPSBkMy5leHRlbnQodHJhY2tEYXRhLnBvaW50TGlzdCwgcG9pbnQgPT4gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpKTtcbiAgICAgICAgbGV0IHRpbWVSYW5nZVB4ID0gdGltZVJhbmdlLm1hcCh0ID0+IHNjYWxlWCh0KSk7XG5cbiAgICAgICAgLy8gVG90YWwgcG9zc2libGUgdGltZVxuICAgICAgICBjb25zdCBzbWFsbEhlaWdodCA9IDAuNSAqIGhlaWdodDtcbiAgICAgICAgY29uc3QgaGVpZ2h0RGlmZiA9IGhlaWdodCAtIHNtYWxsSGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KFxuICAgICAgICAgICAgZXh0ZW50WFswXSxcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ICsgKGhlaWdodERpZmYgLyAyKSxcbiAgICAgICAgICAgIGV4dGVudFhbMV0gLSBleHRlbnRYWzBdICsgMSxcbiAgICAgICAgICAgIHNtYWxsSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICdncmV5JztcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGwoKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhpcyB0aW1lXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlY3QoXG4gICAgICAgICAgICB0aW1lUmFuZ2VQeFswXSxcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0LFxuICAgICAgICAgICAgdGltZVJhbmdlUHhbMV0gLSB0aW1lUmFuZ2VQeFswXSArIDEsXG4gICAgICAgICAgICBoZWlnaHQpO1xuXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uSWQgPSB0cmFja0RhdGEucG9pbnRMaXN0WzBdLmdldCgnTG9jYXRpb24gSUQnKTtcbiAgICAgICAgY29uc3QgbGFiZWxMaXN0ID0gdGhpcy5wYXJlbnRXaWRnZXQuZnVsbERhdGEuaW52ZXJzZUxvY2F0aW9uTWFwLmdldChsb2NhdGlvbklkKTtcbiAgICAgICAgY29uc3QgY29sb3IgPSBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGxhYmVsTGlzdCwgdGhpcy5wYXJlbnRXaWRnZXQuY29sb3JMb29rdXApO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5maWxsKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgc3RhdGljIHJlY3RXaWR0aChyZWN0OiBSZWN0KTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gcmVjdFsxXVswXSAtIHJlY3RbMF1bMF0gKyAxO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIHN0YXRpYyByZWN0SGVpZ2h0KHJlY3Q6IFJlY3QpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiByZWN0WzFdWzFdIC0gcmVjdFswXVsxXSArIDE7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRDZWxsQm91bmRpbmdCb3gocG9pbnQ6IFBvaW50TkQpOiBQcm9taXNlPFJlY3Q+XG4gICAge1xuICAgICAgICBjb25zdCBsb2NJZCA9IHBvaW50LmdldCgnTG9jYXRpb24gSUQnKTtcbiAgICAgICAgY29uc3QgZnJhbWVJZCA9IHBvaW50LmdldCgnRnJhbWUgSUQnKTtcbiAgICAgICAgY29uc3QgZnJhbWVJbmRleCA9IGZyYW1lSWQgLSAxOyAvLyBNYXRMYWIuLiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNlZ21lbnRJZCA9IHBvaW50LmdldCgnc2VnbWVudExhYmVsJyk7XG4gICAgICAgIGNvbnN0IG51bVBpeGVsc0luVGlsZSA9IHRoaXMucGFyZW50V2lkZ2V0Lm51bVBpeGVsc0luVGlsZTtcbiAgICAgICAgLy8gY29uc3QgZmlyc3RJbmRleCA9IGZyYW1lSW5kZXggKiBudW1QaXhlbHNJblRpbGU7XG4gICAgICAgIGxldCBleHRlbnQ6IFJlY3QgPSBbW0luZmluaXR5LCBJbmZpbml0eV0sIFstSW5maW5pdHksIC1JbmZpbml0eV1dXG4gICAgICAgIGxldCBbcm93QXJyYXksIGZpcnN0SW5kZXhdID0gYXdhaXQgdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsUHJvbWlzZShsb2NJZCwgZnJhbWVJbmRleCk7XG4gICAgICAgIGZvciAobGV0IHJvd0lkeCA9IGZpcnN0SW5kZXg7IHJvd0lkeCA8IGZpcnN0SW5kZXggKyB0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QudGlsZUhlaWdodDsgcm93SWR4KyspXG4gICAgICAgIHtcblx0XHRcdGxldCByb3c6IFJvdyA9IHJvd0FycmF5LnJvd0xpc3Rbcm93SWR4XTtcblx0XHRcdGZvciAobGV0IGxhYmVsUnVuIG9mIHJvdy5yb3cpXG5cdFx0XHR7XG4gICAgICAgICAgICAgICAgbGV0IFt0b3AsIGxlZnRdID0gdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldFRpbGVUb3BMZWZ0KGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxldCBiaWdJbWdYTWluID0gbGVmdCArIGxhYmVsUnVuLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGxldCBiaWdJbWdYTWF4ID0gbGVmdCArIGxhYmVsUnVuLnN0YXJ0ICsgbGFiZWxSdW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBiaWdJbWdZID0gdG9wICsgKHJvd0lkeCAlIHRoaXMucGFyZW50V2lkZ2V0LmltYWdlU3RhY2tEYXRhUmVxdWVzdC50aWxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIGlmIChsYWJlbFJ1bi5sYWJlbCA9PT0gc2VnbWVudElkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFtbbWluWCwgbWluWV0sIFttYXhYLCBtYXhZXV0gPSBleHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBiaWdJbWdYTWluKTtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGJpZ0ltZ1kpO1xuICAgICAgICAgICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgYmlnSW1nWE1heCk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBiaWdJbWdZKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW50ID0gW1ttaW5YLCBtaW5ZXSwgW21heFgsIG1heFldXTtcbiAgICAgICAgICAgICAgICB9XG5cdFx0XHR9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBleHRlbnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNlbGxUaW1lbGluZVNjcm9sbChldmVudDogRXZlbnQpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgZWwgPSB0aGlzLmlubmVyQ29udGFpbmVyLm5vZGUoKTtcbiAgICAgICAgdGhpcy5fbGF0ZXN0U2Nyb2xsID0gW2VsLnNjcm9sbExlZnQsIGVsLnNjcm9sbFRvcF07XG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxDaGFuZ2VUaWNraW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGFiZWxzKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbENoYW5nZVRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsQ2hhbmdlVGlja2luZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2FudmFzQ2xpY2soZTogTW91c2VFdmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHhQb3MgPSBlLm9mZnNldFg7XG4gICAgICAgIGxldCB5UG9zID0gZS5vZmZzZXRZO1xuICAgICAgICBjb25zdCBbY2VsbElkLCBjZWxsSWRJbmRleF0gPSBJbWFnZVRyYWNrV2lkZ2V0LmdldENsb3Nlc3RMYWJlbCh0aGlzLmNlbGxMYWJlbFBvc2l0aW9ucywgeVBvcyk7XG4gICAgICAgIGxldCBjdXJ2ZTogQ3VydmVORCA9IHRoaXMucGFyZW50V2lkZ2V0LmZ1bGxEYXRhLmN1cnZlTG9va3VwLmdldChjZWxsSWQpO1xuXG4gICAgICAgIGxldCBmcmFtZUlkOiBudW1iZXJcbiAgICAgICAgY29uc3QgW2ZyYW1lTGFiZWwsIGZyYW1lTGFiZWxJbmRleF0gID0gSW1hZ2VUcmFja1dpZGdldC5nZXRDbG9zZXN0TGFiZWwodGhpcy5mcmFtZUxhYmVsUG9zaXRpb25zLCB4UG9zKTtcbiAgICAgICAgbGV0IGZyYW1lSW5kZXggPSArZnJhbWVMYWJlbCAtIDE7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjdXJ2ZS5wb2ludExpc3QubGVuZ3RoIDwgdGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSB4UG9zIC8gTnVtYmVyKHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5hdHRyKCd3aWR0aCcpKTtcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gTWF0aC5mbG9vcihwZXJjZW50ICogY3VydmUucG9pbnRMaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IE1hdGgubWluKGZyYW1lSW5kZXgsIGN1cnZlLnBvaW50TGlzdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUoY3VydmUsIGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgZnJhbWVJZCA9IHBvaW50LmdldCgnRnJhbWUgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZyYW1lSWQgPSBmcmFtZUluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmaXJzdFBvaW50ID0gY3VydmUucG9pbnRMaXN0WzBdO1xuICAgICAgICBjb25zdCB0cmFja0xvY2F0aW9uID0gZmlyc3RQb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnbG9jRnJhbWVDbGlja2VkJywgeyBkZXRhaWw6XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxvY2F0aW9uSWQ6IHRyYWNrTG9jYXRpb24sXG4gICAgICAgICAgICBmcmFtZUlkOiBmcmFtZUlkXG4gICAgICAgIH19KTtcblx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2FudmFzTW91c2VNb3ZlKGU6IE1vdXNlRXZlbnQpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50V2lkZ2V0LmltYWdlU3RhY2tEYXRhUmVxdWVzdClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB4UG9zID0gZS5vZmZzZXRYO1xuICAgICAgICBsZXQgeVBvcyA9IGUub2Zmc2V0WTtcbiAgICAgICAgY29uc3QgW2NlbGxJZCwgY2VsbElkSW5kZXhdID0gSW1hZ2VUcmFja1dpZGdldC5nZXRDbG9zZXN0TGFiZWwodGhpcy5jZWxsTGFiZWxQb3NpdGlvbnMsIHlQb3MpO1xuICAgICAgICBsZXQgY3VydmU6IEN1cnZlTkQgPSB0aGlzLnBhcmVudFdpZGdldC5mdWxsRGF0YS5jdXJ2ZUxvb2t1cC5nZXQoY2VsbElkKTtcblxuICAgICAgICBsZXQgZnJhbWVJZDogbnVtYmVyXG4gICAgICAgIGNvbnN0IFtmcmFtZUxhYmVsLCBmcmFtZUxhYmVsSW5kZXhdICA9IEltYWdlVHJhY2tXaWRnZXQuZ2V0Q2xvc2VzdExhYmVsKHRoaXMuZnJhbWVMYWJlbFBvc2l0aW9ucywgeFBvcyk7XG4gICAgICAgIGxldCBmcmFtZUluZGV4ID0gK2ZyYW1lTGFiZWwgLSAxO1xuXG4gICAgICAgIGlmICh0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjdXJ2ZS5wb2ludExpc3QubGVuZ3RoIDwgdGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSB4UG9zIC8gTnVtYmVyKHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5hdHRyKCd3aWR0aCcpKTtcbiAgICAgICAgICAgICAgICBmcmFtZUluZGV4ID0gTWF0aC5mbG9vcihwZXJjZW50ICogY3VydmUucG9pbnRMaXN0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZnJhbWVJbmRleCA9IE1hdGgubWluKGZyYW1lSW5kZXgsIGN1cnZlLnBvaW50TGlzdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMuZ2V0UG9pbnRJbkNvbmRlbnNlZE1vZGUoY3VydmUsIGZyYW1lSW5kZXgpO1xuICAgICAgICAgICAgZnJhbWVJZCA9IHBvaW50LmdldCgnRnJhbWUgSUQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZyYW1lSWQgPSBmcmFtZUluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFyZW50V2lkZ2V0LnNlbGVjdGVkSW1nSW5kZXg7XG4gICAgICAgIGNvbnN0IGRpc3BsYXllZEZyYW1lSWQgPSB0aGlzLnBhcmVudFdpZGdldC5nZXRDdXJyZW50RnJhbWVJZCgpO1xuICAgICAgICBsZXQgZmlyc3RQb2ludCA9IGN1cnZlLnBvaW50TGlzdFswXTtcbiAgICAgICAgY29uc3QgdHJhY2tMb2NhdGlvbiA9IGZpcnN0UG9pbnQuZ2V0KCdMb2NhdGlvbiBJRCcpO1xuICAgICAgICBjb25zdCBjdXJyZW50TG9jYXRpb24gPSB0aGlzLnBhcmVudFdpZGdldC5nZXRDdXJyZW50TG9jYXRpb25JZCgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRyYWNrTG9jYXRpb24gPT0gY3VycmVudExvY2F0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgZGlzcGxheWVkUG9pbnQgPSBjdXJ2ZS5wb2ludExpc3QuZmluZChwb2ludCA9PiBwb2ludC5nZXQoJ0ZyYW1lIElEJykgPT09IGRpc3BsYXllZEZyYW1lSWQpO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXllZFBvaW50KVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuaW1hZ2VTdGFja0RhdGFSZXF1ZXN0LmdldExhYmVsKGRpc3BsYXllZFBvaW50LmdldCgnTG9jYXRpb24gSUQnKSwgZGlzcGxheWVkUG9pbnQuZ2V0KCdGcmFtZSBJRCcpIC0gMSxcbiAgICAgICAgICAgICAgICAocm93QXJyYXk6IEltYWdlTGFiZWxzLCBmaXJzdEluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFdpZGdldC5zaG93U2VnbWVudEhvdmVyKHJvd0FycmF5LCBkaXNwbGF5ZWRQb2ludC5nZXQoJ3NlZ21lbnRMYWJlbCcpLCBmaXJzdEluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFdpZGdldC5oaWRlU2VnbWVudEhvdmVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuaGlkZVNlZ21lbnRIb3Zlcih0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlTGFiZWxzT25Nb3VzZU1vdmUoY2VsbElkLCBmcmFtZUluZGV4LCBjZWxsSWRJbmRleCk7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZnJhbWVIb3ZlckNoYW5nZScsIHsgZGV0YWlsOlxuICAgICAgICB7XG4gICAgICAgICAgICBsb2NhdGlvbklkOiB0cmFja0xvY2F0aW9uLFxuICAgICAgICAgICAgZnJhbWVJZDogZnJhbWVJZCxcbiAgICAgICAgICAgIGNlbGxJZDogY2VsbElkLFxuICAgICAgICAgICAgcm93SW5kZXg6IGNlbGxJZEluZGV4LFxuICAgICAgICB9fSk7XG5cdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNhbnZhc01vdXNlTGVhdmUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQuaGlkZVNlZ21lbnRIb3Zlcih0cnVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYWJlbHNPbk1vdXNlTW92ZSgnJywgLTEsIC0xKTtcbiAgICAgICAgY29uc3QgbG9jSWQgPSB0aGlzLnBhcmVudFdpZGdldC5nZXRDdXJyZW50TG9jYXRpb25JZCgpO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2ZyYW1lSG92ZXJDaGFuZ2UnLCB7IGRldGFpbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbklkOiBsb2NJZCxcbiAgICAgICAgICAgICAgICBmcmFtZUlkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNlbGxJZDogbnVsbFxuICAgICAgICAgICAgfX0pO1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0Q2xvc2VzdExhYmVsKGxhYmVsUG9zaXRpb25zOiBbc3RyaW5nLCBudW1iZXJdW10sIHBvczogbnVtYmVyKTogW3N0cmluZywgbnVtYmVyXVxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBhcmVGdW5jdGlvbiA9IERldmxpYkFsZ28uY29tcGFyZVByb3BlcnR5PFtzdHJpbmcsIG51bWJlcl0+KHBvcywgbGFiZWxQb3MgPT4gIGxhYmVsUG9zWzFdKTtcbiAgICAgICAgbGV0IGluZGljZXMgPSBEZXZsaWJBbGdvLkJpbmFyeVNlYXJjaEluZGV4KGxhYmVsUG9zaXRpb25zLCBjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICBpZiAodHlwZW9mIGluZGljZXMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIFsnLTEnLCAtMV07IC8vIHRvZG9cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWxJbmRleDogbnVtYmVyO1xuICAgICAgICBpZiAodHlwZW9mIGluZGljZXMgPT09ICdudW1iZXInKVxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbEluZGV4ID0gaW5kaWNlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBbaW5kZXhMb3csIGluZGV4SGlnaF0gPSBpbmRpY2VzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleExvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWxJbmRleCA9IGluZGV4SGlnaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbmRleEhpZ2ggPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsSW5kZXggPSBpbmRleExvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFsgX2xhYmVsTG93LCBsYWJlbFBvc0xvd10gPSBsYWJlbFBvc2l0aW9uc1tpbmRleExvd107XG4gICAgICAgICAgICAgICAgY29uc3QgWyBfbGFiZWxIZWlnaCwgbGFiZWxQb3NIaWdoXSA9IGxhYmVsUG9zaXRpb25zW2luZGV4SGlnaF07XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdFRvTG93ID0gcG9zIC0gbGFiZWxQb3NMb3c7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdFRvSGlnaCA9IGxhYmVsUG9zSGlnaCAtIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoZGlzdFRvTG93IDwgZGlzdFRvSGlnaClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsSW5kZXggPSBpbmRleExvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxJbmRleCA9IGluZGV4SGlnaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtsYWJlbFBvc2l0aW9uc1tsYWJlbEluZGV4XVswXSwgbGFiZWxJbmRleF07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBkcmF3T3V0bGluZXMoZHJhd0RlZmF1bHRDYW52YXMgPSB0cnVlKTogUHJvbWlzZTx2b2lkPlxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRDYW52YXNTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkcmF3RGVmYXVsdENhbnZhcylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnB1dEltYWdlRGF0YSh0aGlzLmRlZmF1bHRDYW52YXNTdGF0ZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodGhpcy5wYXJlbnRXaWRnZXQuc2hvd091dGxpbmVUb2dnbGUubm9kZSgpIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGRvIGl0IVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtzb3VyY2VSZWN0LCBbZFgsIGRZXSwgcG9pbnRdIG9mIHRoaXMuc291cmNlRGVzdENlbGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IEltYWdlVHJhY2tXaWRnZXQucmVjdFdpZHRoKHNvdXJjZVJlY3QpO1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IEltYWdlVHJhY2tXaWRnZXQucmVjdEhlaWdodChzb3VyY2VSZWN0KTtcbiAgICAgICAgICAgIGxldCBbW3NMZWZ0LCBzVG9wXSwgW3NSaWdodCwgc0JvdF1dID0gc291cmNlUmVjdDtcbiAgICAgICAgICAgIGxldCBvdXRsaW5lVGlsZURhdGEgPSB0aGlzLmNhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKGRYLCBkWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBsZXQgbGFiZWxUb01hdGNoID0gcG9pbnQuZ2V0KCdzZWdtZW50TGFiZWwnKTtcbiAgICAgICAgICAgIGxldCBmcmFtZUluZGV4ID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpIC0gMTtcbiAgICAgICAgICAgIGxldCBySWR4ID0gMDtcbiAgICAgICAgICAgIGxldCBbbGFiZWxBcnJheSwgZmlyc3RJbmRleF0gPSBhd2FpdCB0aGlzLnBhcmVudFdpZGdldC5pbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0TGFiZWxQcm9taXNlKHBvaW50LmdldCgnTG9jYXRpb24gSUQnKSwgZnJhbWVJbmRleCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gc1RvcDsgeSA8PSBzQm90OyB5KyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IHNMZWZ0OyB4IDw9IHNSaWdodDsgeCsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IFtyb3dJZHgsIGNvbElkeF0gPSB0aGlzLnBhcmVudFdpZGdldC5nZXRMYWJlbEluZGV4RnJvbUJpZ0ltZ1BpeGVsWFkoZnJhbWVJbmRleCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGFiZWwgPSBJbWFnZVN0YWNrRGF0YVJlcXVlc3QuZ2V0TGFiZWxWYWx1ZShyb3dJZHgsIGNvbElkeCwgbGFiZWxBcnJheSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsID09IGxhYmVsVG9NYXRjaClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50V2lkZ2V0LmlzQm9yZGVyKGxhYmVsLCByb3dJZHgsIGNvbElkeCwgbGFiZWxBcnJheSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIHVzZSBkYXRhLCBub3QgZnVsbCBkYXRhIHRvIGdldCB0aGUgcmlnaHQgY29sb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NlbGwsIF9pbmRleF0gPSB0aGlzLnBhcmVudFdpZGdldC5kYXRhLkdldENlbGxGcm9tTGFiZWwocG9pbnQuZ2V0KCdMb2NhdGlvbiBJRCcpLCBwb2ludC5nZXQoJ0ZyYW1lIElEJyksIGxhYmVsVG9NYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHtjb2xvcjogY29sb3IsIHNob3c6IHNob3d9ID0gdGhpcy5wYXJlbnRXaWRnZXQuZ2V0Q2VsbENvbG9yKGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFtyLCBnLCBiXSA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRsaW5lVGlsZURhdGEuZGF0YVtySWR4XSA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVUaWxlRGF0YS5kYXRhW3JJZHggKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVUaWxlRGF0YS5kYXRhW3JJZHggKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmVUaWxlRGF0YS5kYXRhW3JJZHggKyAzXSA9IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcklkeCArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEob3V0bGluZVRpbGVEYXRhLCBkWCwgZFkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3TGFiZWxzKG9uU2Nyb2xsID0gZmFsc2UpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjZWxsIGxhYmVsc1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBEZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnNjZW50ZWRXaWRnZXRHcm91cC5ub2RlKCkpO1xuICAgICAgICAgICAgRGV2bGliVFNVdGlsLmhpZGUodGhpcy5leGVtcGxhclBpbkdyb3VwLm5vZGUoKSk7XG4gICAgICAgICAgICBEZXZsaWJUU1V0aWwuaGlkZSh0aGlzLm1hbnVhbEV4ZW1wbGFyUGluR3JvdXAubm9kZSgpKTtcbiAgICAgICAgICAgIERldmxpYlRTVXRpbC5oaWRlKHRoaXMuYWRkUGluUmVjdEdyb3VwLm5vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBEZXZsaWJUU1V0aWwuc2hvdyh0aGlzLnNjZW50ZWRXaWRnZXRHcm91cC5ub2RlKCkpO1xuICAgICAgICAgICAgRGV2bGliVFNVdGlsLnNob3codGhpcy5leGVtcGxhclBpbkdyb3VwLm5vZGUoKSk7XG4gICAgICAgICAgICBEZXZsaWJUU1V0aWwuc2hvdyh0aGlzLm1hbnVhbEV4ZW1wbGFyUGluR3JvdXAubm9kZSgpKTtcbiAgICAgICAgICAgIERldmxpYlRTVXRpbC5zaG93KHRoaXMuYWRkUGluUmVjdEdyb3VwLm5vZGUoKSk7XG4gICAgICAgICAgICBsZXQgeEFuY2hvciA9IHRoaXMuZHJhd0NvbmRpdGlvbkxhYmVscygpO1xuICAgICAgICAgICAgaWYgKG9uU2Nyb2xsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hpZnRTY2VudGVkV2lkZ2V0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NjZW50ZWRXaWRnZXRzKHhBbmNob3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0FkZFBpblJlY3RzKHhBbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhd0NlbGxMYWJlbHMoKTsgLy8gdG9kbyBtYWtlIHRoaXMgZnVuY3Rpb24gY29uZGl0aW9uYWwgdG8gYWx3YXlzIHNob3cgcGlubmVkIHdpdGggc3RhciBhbmQgb25seSBzaG93IG90aGVycyBkZXBlbmRpbmcgb24gaWYgaXQncyBpbiBleGVtcGxhciBtb2RlLlxuXG5cbiAgICAgICAgLy8gZnJhbWUgbGFiZWxzXG4gICAgICAgIGxldCBwYWQgPSA2O1xuICAgICAgICBjb25zdCB5QW5jaG9yID0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4udG9wIC0gcGFkO1xuICAgICAgICBsZXQgbGFiZWxzSW5WaWV3ID0gdGhpcy5mcmFtZUxhYmVsUG9zaXRpb25zLmZpbHRlcigobGFiZWxQb3M6IFtzdHJpbmcsIG51bWJlcl0pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHBvczogbnVtYmVyID0gbGFiZWxQb3NbMV0gLSB0aGlzLmxhdGVzdFNjcm9sbFswXTtcbiAgICAgICAgICAgIHJldHVybiAwIDw9IHBvcyAmJiBwb3MgPD0gdGhpcy5pbm5lckNvbnRhaW5lclc7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbHNJblZpZXcgPSBsYWJlbHNJblZpZXcubWFwKChsYWJlbFBvczogW3N0cmluZywgbnVtYmVyXSkgPT4gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gK2xhYmVsUG9zWzBdIC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IGluZGV4IC8gKHRoaXMucGFyZW50V2lkZ2V0LmNvbmRlbnNlZE1vZGVDb3VudCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGVyY2VudC50b0ZpeGVkKDIpLCBsYWJlbFBvc1sxXV07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZSAgPSB0aGlzLnBhcmVudFdpZGdldC5nZXRDdXJyZW50RnJhbWVJZCgpO1xuICAgICAgICB0aGlzLmZyYW1lTGFiZWxHcm91cC5zZWxlY3RBbGwoJ3RleHQnKVxuICAgICAgICAgICAgLmRhdGEobGFiZWxzSW5WaWV3KVxuICAgICAgICAgICAgLmpvaW4oJ3RleHQnKVxuICAgICAgICAgICAgLnRleHQoZCA9PiBkWzBdKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCBkID0+IGRbMV0gLSB0aGlzLmxhdGVzdFNjcm9sbFswXSlcbiAgICAgICAgICAgIC5hdHRyKCd5JywgeUFuY2hvcilcbiAgICAgICAgICAgIC5jbGFzc2VkKCdjdXJyZW50RnJhbWUnLCBkID0+ICtkWzBdID09PSBjdXJyZW50RnJhbWUgJiYgIXRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2NlbGxBeGlzTGFiZWwnLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JpZ2h0JywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3Q2VsbExhYmVscygpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBwYWQgPSAxMDtcbiAgICAgICAgY29uc3Qgc3RhckJ1dHRvblNpemUgPSAzMjtcbiAgICAgICAgY29uc3Qgc3RhckV4dHJhT2Zmc2V0ID0gMjtcbiAgICAgICAgY29uc3QgeEFuY2hvciA9IHRoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLmxlZnQgLSBwYWQ7XG4gICAgICAgIGxldCBsYWJlbHNXaXRoSW5kZXg6IFtudW1iZXIsIFtzdHJpbmcsIG51bWJlcl1dW10gPSB0aGlzLmNlbGxMYWJlbFBvc2l0aW9ucy5tYXAoKHgsIGkpID0+IFtpLCB4XSk7XG4gICAgICAgIGxldCBsYWJlbHNJblZpZXcgPSBsYWJlbHNXaXRoSW5kZXguZmlsdGVyKChsYWJlbFBvczogW251bWJlciwgW3N0cmluZywgbnVtYmVyXV0sIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzLmxlbmd0aCAmJiB0aGlzLnBhcmVudFdpZGdldC5pbkV4ZW1wbGFyTW9kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3M6IG51bWJlciA9IGxhYmVsUG9zWzFdWzFdIC0gdGhpcy5sYXRlc3RTY3JvbGxbMV07XG4gICAgICAgICAgICByZXR1cm4gMCA8PSBwb3MgJiYgcG9zIDw9IHRoaXMuaW5uZXJDb250YWluZXJIO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jZWxsTGFiZWxHcm91cC5zZWxlY3RBbGwoJ3RleHQudHJhY2tMYWJlbCcpXG4gICAgICAgICAgICAuZGF0YShsYWJlbHNJblZpZXcpXG4gICAgICAgICAgICAuam9pbigndGV4dCcpXG4gICAgICAgICAgICAuY2xhc3NlZCgndHJhY2tMYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAudGV4dChkID0+IGRbMV1bMF0pXG4gICAgICAgICAgICAuYXR0cigneCcsIGQgPT4gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGRbMF0gPCB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4QW5jaG9yIC0gc3RhckJ1dHRvblNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB4QW5jaG9yXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmF0dHIoJ3knLCBkID0+IGRbMV1bMV0gLSB0aGlzLmxhdGVzdFNjcm9sbFsxXSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAnJylcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgZCA9PiBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZFswXSA8IHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzW2RbMF1dO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NJZCA9IHRyYWNrLnBvaW50TGlzdFswXS5nZXQoJ0xvY2F0aW9uIElEJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsTGlzdCA9IHRoaXMucGFyZW50V2lkZ2V0LmZ1bGxEYXRhLmludmVyc2VMb2NhdGlvbk1hcC5nZXQobG9jSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGxhYmVsTGlzdCwgdGhpcy5wYXJlbnRXaWRnZXQuY29sb3JMb29rdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JsYWNrJztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2xhc3NlZCgnY2VsbEF4aXNMYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbGVmdCcsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgncm90YXRlZCcsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBtYW51YWxseVBpbm5lZEluVmlldyA9IGxhYmVsc1dpdGhJbmRleC5maWx0ZXIoKGxhYmVsUG9zOiBbbnVtYmVyLCBbc3RyaW5nLCBudW1iZXJdXSwgaW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5tYW51YWxseVBpbm5lZFRyYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zOiBudW1iZXIgPSBsYWJlbFBvc1sxXVsxXSAtIHRoaXMubGF0ZXN0U2Nyb2xsWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiAwIDw9IHBvcyAmJiBwb3MgPD0gdGhpcy5pbm5lckNvbnRhaW5lckg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY2VsbExhYmVsR3JvdXAuc2VsZWN0QWxsKCdmb3JlaWduT2JqZWN0JylcbiAgICAgICAgICAgIC5kYXRhKG1hbnVhbGx5UGlubmVkSW5WaWV3KVxuICAgICAgICAuam9pbignZm9yZWlnbk9iamVjdCcpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4T2Zmc2V0ID0geEFuY2hvciAtIHN0YXJCdXR0b25TaXplO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlPZmZzZXQgPSBkWzFdWzFdIC0gdGhpcy5sYXRlc3RTY3JvbGxbMV0gLSAoc3RhckJ1dHRvblNpemUgLyAyKSAtIHN0YXJFeHRyYU9mZnNldDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3hPZmZzZXR9LCAke3lPZmZzZXR9KWBcbiAgICAgICAgICAgIH0pXG5cdFx0XHQuYXR0cignd2lkdGgnLCBzdGFyQnV0dG9uU2l6ZSlcblx0XHRcdC5hdHRyKCdoZWlnaHQnLCBzdGFyQnV0dG9uU2l6ZSlcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoJ2RpdicpXG4gICAgICAgICAgICAuZGF0YShkID0+IFtkXSlcbiAgICAgICAgLmpvaW4oJ3hodG1sOmRpdicpXG4gICAgICAgICAgICAuc2VsZWN0QWxsKCdidXR0b24nKVxuICAgICAgICAgICAgLmRhdGEoZCA9PiBbZF0pXG4gICAgICAgIC5qb2luKCdidXR0b24nKVxuICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgZCA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkWzBdIDwgdGhpcy5tYW51YWxseVBpbm5lZFRyYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3NbZFswXV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY0lkID0gdHJhY2sucG9pbnRMaXN0WzBdLmdldCgnTG9jYXRpb24gSUQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxMaXN0ID0gdGhpcy5wYXJlbnRXaWRnZXQuZnVsbERhdGEuaW52ZXJzZUxvY2F0aW9uTWFwLmdldChsb2NJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBjb2xvcjogJHtHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGxhYmVsTGlzdCwgdGhpcy5wYXJlbnRXaWRnZXQuY29sb3JMb29rdXApfTtgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuYXR0cigndGl0bGUnLCAnQ2xpY2sgdG8gcmVtb3ZlIHRoaXMgZmF2b3JpdGUuJylcbiAgICAgICAgICAgIC5odG1sKCc8aSBjbGFzcz1cImZhcyBmYS1zdGFyXCI+PC9pPicpXG4gICAgICAgICAgICAuY2xhc3NlZCgnYmFzaWNJY29uQnV0dG9uJywgdHJ1ZSlcbiAgICAgICAgICAgIC5vbignY2xpY2snLCBkID0+IFxuICAgICAgICAgICAge1xuICAgICAgICBcdFx0Y29uc3QgdHJhY2sgPSB0aGlzLnBhcmVudFdpZGdldC5mdWxsRGF0YS5jdXJ2ZUxvb2t1cC5nZXQoZFsxXVswXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRXaWRnZXQudG9nZ2xlUGluKHRyYWNrKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRXaWRnZXQuaW5FeGVtcGxhck1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2VsbExhYmVsR3JvdXAuc2VsZWN0QWxsKCdsaW5lJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmNlbGxMYWJlbEdyb3VwLnNlbGVjdEFsbCgndGV4dC5jb25kaXRpb25MYWJlbCcpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3Q29uZGl0aW9uTGFiZWxzKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgY29uc3QgeEFuY2hvciA9IHRoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLmxlZnQgLSB0aGlzLmxhYmVsTGluZVBhZDtcbiAgICAgICAgY29uc3QgeEFuY2hvckxpbmUgPSB4QW5jaG9yIC0gNDtcbiAgICAgICAgdGhpcy5jZWxsTGFiZWxHcm91cC5zZWxlY3RBbGwoJ3RleHQuY29uZGl0aW9uTGFiZWwnKVxuICAgICAgICAgICAgLmRhdGEodGhpcy5jb25kaXRpb25MYWJlbFBvc2l0aW9ucylcbiAgICAgICAgICAgIC5qb2luKCd0ZXh0JylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdjb25kaXRpb25MYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAudGV4dChkID0+IGRbMF0ucmVwbGFjZSgnX19fJywgJyAnKSlcbiAgICAgICAgICAgIC5hdHRyKCd4JywgeEFuY2hvcilcbiAgICAgICAgICAgIC5hdHRyKCd5JywgZCA9PiAoZFsxXVswXSArIGRbMV1bMV0pIC8gMiAtIHRoaXMubGF0ZXN0U2Nyb2xsWzFdKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHJvdGF0ZSgtOTAsICR7eEFuY2hvcn0sICR7KGRbMV1bMF0gKyBkWzFdWzFdKSAvIDIgLSB0aGlzLmxhdGVzdFNjcm9sbFsxXX0pYClcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgKGQsaSkgPT4gR3JvdXBCeVdpZGdldC5nZXRDb2xvcihkWzBdLnNwbGl0KCdfX18nKSwgdGhpcy5wYXJlbnRXaWRnZXQuY29sb3JMb29rdXApKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2NlbGxBeGlzTGFiZWwnLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3JvdGF0ZWQnLCB0cnVlKTtcblxuICAgICAgICB0aGlzLmNlbGxMYWJlbEdyb3VwLnNlbGVjdEFsbCgnbGluZScpXG4gICAgICAgICAgICAuZGF0YSh0aGlzLmNvbmRpdGlvbkxhYmVsUG9zaXRpb25zKVxuICAgICAgICAgICAgLmpvaW4oJ2xpbmUnKVxuICAgICAgICAgICAgLmF0dHIoJ3gxJywgeEFuY2hvckxpbmUpXG4gICAgICAgICAgICAuYXR0cigneDInLCB4QW5jaG9yTGluZSlcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIGQgPT4gTWF0aC5tYXgoMCwgZFsxXVswXSAtIHRoaXMubGF0ZXN0U2Nyb2xsWzFdKSlcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIGQgPT4gTWF0aC5tYXgoMCwgZFsxXVsxXSAtIHRoaXMubGF0ZXN0U2Nyb2xsWzFdKSlcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAoZCxpKSA9PiBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGRbMF0uc3BsaXQoJ19fXycpLCB0aGlzLnBhcmVudFdpZGdldC5jb2xvckxvb2t1cCkpXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgJzJweCcpO1xuXG4gICAgICAgIHJldHVybiB4QW5jaG9yTGluZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNoaWZ0U2NlbnRlZFdpZGdldHMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zY2VudGVkV2lkZ2V0R3JvdXBcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3AgLSB0aGlzLmxhdGVzdFNjcm9sbFsxXX0pYCk7ICAgIFxuXG4gICAgICAgIHRoaXMuZXhlbXBsYXJQaW5Hcm91cFxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHRyYW5zbGF0ZSgwLCAke3RoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLnRvcCAtIHRoaXMubGF0ZXN0U2Nyb2xsWzFdfSlgKTsgICAgXG4gICAgICAgIFxuICAgICAgICB0aGlzLm1hbnVhbEV4ZW1wbGFyUGluR3JvdXBcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3AgLSB0aGlzLmxhdGVzdFNjcm9sbFsxXX0pYCk7ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuYWRkUGluUmVjdEdyb3VwXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKDAsICR7dGhpcy5jZWxsVGltZWxpbmVNYXJnaW4udG9wIC0gdGhpcy5sYXRlc3RTY3JvbGxbMV19KWApOyBcblxuICAgICAgICB0aGlzLnVwZGF0ZUV4ZW1wbGFyQ3VydmVzT2Zmc2V0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3QWRkUGluUmVjdHMoYXhpc0FuY2hvcjogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkUGluUmVjdEdyb3VwLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAuZGF0YSh0aGlzLmNvbmRpdGlvbkxhYmVsUG9zaXRpb25zKVxuICAgICAgICAgICAgLmpvaW4oJ3JlY3QnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4gYHRyYW5zbGF0ZSgwLCAke2RbMV1bMF19KWApXG4gICAgICAgICAgICAuYXR0cignd2lkdGgnLCB0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi5sZWZ0IC0gdGhpcy5sYWJlbExpbmVQYWQpXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZCA9PiBkWzFdWzFdIC0gZFsxXVswXSlcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAnMHB4JylcbiAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3RvbWF0bycpXG4gICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIDAuMClcbiAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsICdjdXJzb3I6IGNyb3NzaGFpcjsnKVxuICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtfeFBvcywgeVBvc10gPSBkMy5tb3VzZSh0aGlzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZWxmLm5vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVkuaW52ZXJ0KHlQb3MpO1xuICAgICAgICAgICAgICAgIHNlbGYubWFudWFsU2FtcGxlVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzYW1wbGluZ1N0cmF0ZWd5Q2hhbmdlJywge2RldGFpbDogc2VsZi5jdXJyZW50U2FtcGxpbmdTdGF0ZWd5fSkpO1xuICAgICAgICAgICAgfSlcbiAgICB9XG5cbiAgICBwcml2YXRlIGRyYXdTY2VudGVkV2lkZ2V0cyhheGlzQW5jaG9yOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgYmluQXJyYXk6IGQzLkJpbjxORGltLCBudW1iZXI+W11bXSA9IFtdO1xuICAgICAgICBjb25zdCBudW1CaW5zID0gNDg7XG4gICAgICAgIHRoaXMuX2hpc3RvZ3JhbVNjYWxlWUxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcmVudFdpZGdldC5mYWNldExpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcblxuICAgICAgICAgICAgbGV0IGRhdGE6IEN1cnZlTGlzdCA9IHRoaXMucGFyZW50V2lkZ2V0LmZhY2V0TGlzdFtpXS5kYXRhO1xuXG4gICAgICAgICAgICBsZXQgYmlucyA9IEhpc3RvZ3JhbVdpZGdldC5jYWxjdWxhdGVCaW5zKFxuICAgICAgICAgICAgICAgIGRhdGEuY3VydmVDb2xsZWN0aW9uLkFycmF5LmZpbHRlcihkID0+ICFpc05hTihkLmdldCh0aGlzLnBhcmVudFdpZGdldC5leGVtcGxhckF0dHJpYnV0ZSkpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFdpZGdldC5leGVtcGxhckF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICBkYXRhLmN1cnZlQ29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICBudW1CaW5zLFxuICAgICAgICAgICAgICAgIHRydWUpO1xuICAgICAgICAgICAgYmluQXJyYXkucHVzaChiaW5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtaW5CaW5Cb3VuZGFyeSA9IGQzLm1pbihiaW5BcnJheSwgYmlucyA9PiBiaW5zWzBdLngwKTtcbiAgICAgICAgbGV0IG1heEJpbkJvdW5kYXJ5ID0gZDMubWF4KGJpbkFycmF5LCBiaW5zID0+IGJpbnNbYmlucy5sZW5ndGggLSAxXS54MSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluQXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbkV4dGVudCA9IHRoaXMuY29uZGl0aW9uTGFiZWxQb3NpdGlvbnNbaV1bMV07XG4gICAgICAgICAgICBsZXQgc2NhbGVZID0gZDMuc2NhbGVMaW5lYXIoKVxuICAgICAgICAgICAgICAgIC5kb21haW4oW21pbkJpbkJvdW5kYXJ5LCBtYXhCaW5Cb3VuZGFyeV0pXG4gICAgICAgICAgICAgICAgLnJhbmdlKHBvc2l0aW9uRXh0ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1TY2FsZVlMaXN0LnB1c2goc2NhbGVZKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXJzdEV4dGVudCA9IHRoaXMuY29uZGl0aW9uTGFiZWxQb3NpdGlvbnNbMF1bMV07XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVkgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFttaW5CaW5Cb3VuZGFyeSwgbWF4QmluQm91bmRhcnldKVxuICAgICAgICAgICAgLnJhbmdlKFswLCBmaXJzdEV4dGVudFsxXSAtIGZpcnN0RXh0ZW50WzBdXSk7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IDQ7XG5cdFx0bGV0IGJpZ2dlc3RCaW5QZXJjZW50YWdlID0gZDMubWF4KGJpbkFycmF5LCBiaW4gPT4gZDMubWF4KGJpbiwgZCA9PiBkLmxlbmd0aCkgLyBkMy5zdW0oYmluLCBkID0+IGQubGVuZ3RoKSk7XG4gICAgICAgIGNvbnN0IG1heFdpZHRoID0gNTI7XG4gICAgICAgIHRoaXMuX2hpc3RvZ3JhbVNjYWxlWCA9IGQzLnNjYWxlTGluZWFyKClcbiAgICAgICAgICAgIC5kb21haW4oWzAsIGJpZ2dlc3RCaW5QZXJjZW50YWdlXSlcbiAgICAgICAgICAgIC5yYW5nZShbYXhpc0FuY2hvciAtIHBhZGRpbmcsIGF4aXNBbmNob3IgLSBtYXhXaWR0aF0pO1xuXG4gICAgICAgIHRoaXMuc2NlbnRlZFdpZGdldEdyb3VwLnNlbGVjdEFsbCgncGF0aCcpXG4gICAgICAgICAgICAuZGF0YSh0aGlzLmNvbmRpdGlvbkxhYmVsUG9zaXRpb25zKVxuICAgICAgICAgICAgLmpvaW4oJ3BhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCAoZCwgaSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgYmlucyA9IGJpbkFycmF5W2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhpc3RvZ3JhbVNreWxpbmVQYXRoKGJpbnMsIHRoaXMuaGlzdG9ncmFtU2NhbGVYLCB0aGlzLmhpc3RvZ3JhbVNjYWxlWUxpc3RbaV0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdrZGVQYXRoJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRIaXN0b2dyYW1Ta3lsaW5lUGF0aChiaW5zOiBkMy5CaW48TkRpbSwgbnVtYmVyPltdLCBzY2FsZVg6IGQzLlNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPiwgc2NhbGVZOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4pOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBwYXRoUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXTtcblx0XHRjb25zdCB0b3RhbENvdW50ID0gZDMuc3VtKGJpbnMsIGJpbiA9PiBiaW4ubGVuZ3RoKTtcblx0XHRmb3IgKGxldCBiaW4gb2YgYmlucylcblx0XHR7XG5cdFx0XHRsZXQgeTE6IG51bWJlciA9IHNjYWxlWShiaW4ueDApO1xuICAgICAgICAgICAgbGV0IHggPSBzY2FsZVgoYmluLmxlbmd0aCAvIHRvdGFsQ291bnQpO1xuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFt4LCB5MV0pO1xuXHRcdFx0aWYgKGJpbi5sZW5ndGggPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBzcGxpdFBvaW50OiBbbnVtYmVyLCBudW1iZXJdID0gW251bGwsIG51bGxdO1xuXHRcdFx0XHRwYXRoUG9pbnRzLnB1c2goc3BsaXRQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgeTI6IG51bWJlciA9IHNjYWxlWShiaW4ueDEpO1xuXHRcdFx0cGF0aFBvaW50cy5wdXNoKFt4LCB5Ml0pO1xuXHRcdH1cbiAgICAgICAgbGV0IG1pbll2YWwgPSBiaW5zWzBdLngwO1xuICAgICAgICBsZXQgbWF4WXZhbCA9IGJpbnNbYmlucy5sZW5ndGggLSAxXS54MTtcblx0XHRcblx0XHRwYXRoUG9pbnRzLnVuc2hpZnQoW3NjYWxlWC5yYW5nZSgpWzBdLCBzY2FsZVkobWluWXZhbCldKTtcblx0XHRwYXRoUG9pbnRzLnB1c2goW3NjYWxlWC5yYW5nZSgpWzBdLCBzY2FsZVkobWF4WXZhbCldKTtcblxuXHRcdGxldCBsaW5lRnVuYyA9IGQzLmxpbmUoKVxuXHRcdFx0LngoZCA9PiBkWzBdKVxuXHRcdFx0LnkoZCA9PiBkWzFdKVxuXHRcdFx0LmRlZmluZWQoZCA9PiBkWzBdICE9PSBudWxsKTtcblxuXHRcdHJldHVybiBsaW5lRnVuYyhwYXRoUG9pbnRzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyUGlucygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4ZW1wbGFyUGluR3JvdXAuaHRtbChudWxsKTtcbiAgICAgICAgdGhpcy5tYW51YWxFeGVtcGxhclBpbkdyb3VwLmh0bWwobnVsbCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3QWxsUGlucyhjdXJ2ZUxpc3Q6IGNvbmRpdGlvbkV4ZW1wbGFyPEN1cnZlTkQ+W10pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmNsZWFyUGlucygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnZlTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnlJbmRleCA9IE1hdGguZmxvb3IoaSAvIHRoaXMucGFyZW50V2lkZ2V0Lm51bUV4ZW1wbGFycyk7XG4gICAgICAgICAgICB0aGlzLmRyYXdQaW4oY3VydmVMaXN0W2ldLCBjYXRlZ29yeUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd1Bpbih0cmFja0RhdGE6IGNvbmRpdGlvbkV4ZW1wbGFyPEN1cnZlTkQ+LCBjYXRlZ29yeUluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgZXhlbXBsYXJWYWx1ZSA9IHRyYWNrRGF0YS5kYXRhLmdldCh0aGlzLnBhcmVudFdpZGdldC5leGVtcGxhckF0dHJpYnV0ZSk7XG4gICAgICAgIGxldCB5UG9zID0gdGhpcy5oaXN0b2dyYW1TY2FsZVlMaXN0W2NhdGVnb3J5SW5kZXhdKGV4ZW1wbGFyVmFsdWUpO1xuICAgICAgICBsZXQgW3hQb3NQaW4sIHhQb3NIZWFkXSA9IHRoaXMuaGlzdG9ncmFtU2NhbGVYLnJhbmdlKCk7XG4gICAgICAgIGNvbnN0IG1hbnVhbDogYm9vbGVhbiA9IHRyYWNrRGF0YS50eXBlID09PSAnbWFudWFsJ1xuICAgICAgICBpZiAobWFudWFsKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBuZWVkbGVFbGVtZW50ID0gdGhpcy5tYW51YWxFeGVtcGxhclBpbkdyb3VwLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeFBvc0hlYWQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeFBvc1BpbilcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5UG9zKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHlQb3MpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3BpbkxpbmUnLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKHRyYWNrRGF0YS5kYXRhLmlkLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgbXlQdXNoUGluRGVzaWduID0gXCJNMTcuMiwwLjNjLTIsMC40LTIuNywxLTMsMS41Yy0wLjcsMS4xLDAsMi42LTAuOCwzYy0wLjEsMC0wLjEsMC0wLjIsMGMtMSwwLTEuNCwwLTQsMGMtMi45LDAtNCwwLTUsMGMtMC43LDAtMC44LTEtMS0xLjVDMi45LDIuNiwzLDIuMywyLjcsMkMxLjgsMS40LDAuMywxLjgsMC4zLDEuOHMwLTAuOCwwLDYuNWMwLDcuMiwwLDYuNSwwLDYuNXMxLjUsMC40LDIuNC0wLjJDMywxNC4zLDIuOSwxNCwzLjMsMTMuM2MwLjItMC42LDAuMy0xLjUsMS0xLjVjMSwwLDIuMSwwLDUsMGMyLjYsMCwzLDAsNCwwczAuMSwxLjgsMSwzYzAuNywwLjksMi4xLDEuMywzLDEuNWMwLTIuNywwLTUuMywwLThTMTcuMiwzLDE3LjIsMC4zelwiO1xuICAgICAgICAgICAgY29uc3QgaWNvbldpZHRoID0gMTc7XG4gICAgICAgICAgICBjb25zdCBpY29uSGVpZ2h0ID0gMTY7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zWCA9IHhQb3NIZWFkIC0gaWNvbldpZHRoO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNZID0geVBvcyAtIGljb25IZWlnaHQgLyAyO1xuICAgICAgICAgICAgdGhpcy5tYW51YWxFeGVtcGxhclBpbkdyb3VwLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3BpbkhlYWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dHJhbnNYfSwgJHt0cmFuc1l9KWApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBteVB1c2hQaW5EZXNpZ24pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkRyYWdTdGFydCh0aGlzLCB0cmFuc1gsIHRyYW5zWSwgbmVlZGxlRWxlbWVudCwgdGV4dFNlbGVjdCwgZXhlbXBsYXJWYWx1ZSwgdHJhY2tEYXRhLmFuY2hvclZhbCwgY2F0ZWdvcnlJbmRleCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCh0cmFja0RhdGEuZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHRleHRQYWQgPSA0O1xuICAgICAgICAgICAgY29uc3QgdGV4dFNlbGVjdCA9IHRoaXMuZXhlbXBsYXJQaW5Hcm91cC5hcHBlbmQoJ3RleHQnKSAvLyBwdXQgaW4gc2VtYW50aWNhbGx5IGluY29ycmVjdCBncm91cCB0byBhdm9pZCBtb3VzZW92ZXIgcHJvYmxlbXMgYW5kIGJlY2F1c2UgSSdtIHRpcmVkLlxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgdGV4dFBhZClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIHlQb3MpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdwaW5MYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3RpbnlUZXh0JywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbm9TZWxlY3QnLCB0cnVlKVxuICAgICAgICAgICAgICAgIC50ZXh0KHRoaXMuZm9ybWF0UGluTGFiZWwoZXhlbXBsYXJWYWx1ZSkpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQodHJhY2tEYXRhLmRhdGEuaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5leGVtcGxhclBpbkdyb3VwLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgeFBvc0hlYWQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeFBvc1BpbilcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5UG9zKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHlQb3MpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3BpbkxpbmUnLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKHRyYWNrRGF0YS5kYXRhLmlkLCB0cnVlKTtcblxuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gM1xuICAgICAgICAgICAgdGhpcy5leGVtcGxhclBpbkdyb3VwLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgICAgICAgICAuYXR0cignY3gnLCB4UG9zSGVhZCAtIHJhZGl1cylcbiAgICAgICAgICAgICAgICAuYXR0cignY3knLCB5UG9zKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdyJywgcmFkaXVzKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdwaW5IZWFkJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCh0cmFja0RhdGEuZGF0YS5pZCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGZvcm1hdFBpbkxhYmVsKHZhbHVlOiBudW1iZXIpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBhYnNWYWwgPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICAgIGlmIChhYnNWYWwgPiA5OS41KSBcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFic1ZhbCA+IDkuNSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoMik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkRyYWdTdGFydChcbiAgICAgICAgcGluRWxlbWVudDogU1ZHUGF0aEVsZW1lbnQsXG4gICAgICAgIHRyYW5zWDogbnVtYmVyLCB0cmFuc1k6IG51bWJlcixcbiAgICAgICAgbmVlZGxlU2VsZWN0OiBkMy5TZWxlY3Rpb248U1ZHTGluZUVsZW1lbnQsIGFueSwgRWxlbWVudCwgYW55PixcbiAgICAgICAgdGV4dFNlbGVjdDogZDMuU2VsZWN0aW9uPFNWR1RleHRFbGVtZW50LCBhbnksIEVsZW1lbnQsIGFueT4sXG4gICAgICAgIGluaXRpYWxWYWx1ZTogbnVtYmVyLCBhbmNob3JWYWx1ZTogbnVtYmVyLFxuICAgICAgICBncm91cEluZGV4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBjb29yZHMgPSBkMy5tb3VzZShwaW5FbGVtZW50KTtcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmdQaW4gPSB0cnVlO1xuICAgICAgICB0aGlzLl9kcmFnZ2luZ1BpbkVsZW1lbnQgPSBwaW5FbGVtZW50O1xuICAgICAgICB0aGlzLl9pbml0aWFsRHJhZ0Nvb3JkcyA9IFt0cmFuc1gsIHRyYW5zWV07XG4gICAgICAgIHRoaXMuX25lZWRsZVNlbGVjdGlvbiA9IG5lZWRsZVNlbGVjdDtcbiAgICAgICAgdGhpcy5fdGV4dFNlbGVjdGlvbiA9IHRleHRTZWxlY3Q7XG4gICAgICAgIHRoaXMuX3RvdGFsRHJhZ09mZnNldCA9IFswLCAwXTtcbiAgICAgICAgdGhpcy5faW5pdGlhbFBpblZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB0aGlzLl9hbmNob3JQaW5WYWx1ZSA9IGFuY2hvclZhbHVlO1xuICAgICAgICB0aGlzLl9kcmFnR3JvdXBJbmRleCA9IGdyb3VwSW5kZXg7XG4gICAgICAgIHRoaXMuX3Bpbk1vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgdW5waW5PZmZzZXQgPSAxMjtcbiAgICAgICAgZDMuc2VsZWN0KHBpbkVsZW1lbnQpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RyYW5zWCAtIHVucGluT2Zmc2V0fSwgJHt0cmFuc1l9KWApXG4gICAgICAgICAgICAuY2xhc3NlZCgnZ3JhYmJlZCcsIHRydWUpO1xuXG4gICAgICAgIG5lZWRsZVNlbGVjdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7LXVucGluT2Zmc2V0fSwgMClgKTtcbiAgICAgICAgdGV4dFNlbGVjdC50ZXh0KCdYJyk7XG5cbiAgICAgICAgdGhpcy5hZGRQaW5SZWN0R3JvdXAuc2VsZWN0QWxsKCdyZWN0JykuY2xhc3NlZCgnZ3JhYmJlZCcsIHRydWUpO1xuICAgICAgICB0aGlzLm5lZWRsZVNlbGVjdGlvbi5jbGFzc2VkKCdncmFiYmVkJywgdHJ1ZSk7XG4gICAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gJ2dyYWJiaW5nJztcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRHJhZ0VuZCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmdQaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kcmFnZ2luZ1BpbiA9IGZhbHNlO1xuXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzLmRyYWdnaW5nUGluRWxlbWVudCkuY2xhc3NlZCgnZ3JhYmJlZCcsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hZGRQaW5SZWN0R3JvdXAuc2VsZWN0QWxsKCdyZWN0JykuY2xhc3NlZCgnZ3JhYmJlZCcsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5uZWVkbGVTZWxlY3Rpb24uY2xhc3NlZCgnZ3JhYmJlZCcsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYW51YWxTYW1wbGVWYWx1ZXMuaW5kZXhPZih0aGlzLmFuY2hvclBpblZhbHVlKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGluTW92ZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW51YWxTYW1wbGVWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnVhbFNhbXBsZVZhbHVlc1tpbmRleF0gPSB0aGlzLmdldEN1cnJlbnREcmFnZ2VkVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzYW1wbGluZ1N0cmF0ZWd5Q2hhbmdlJywge2RldGFpbDogdGhpcy5jdXJyZW50U2FtcGxpbmdTdGF0ZWd5fSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgb25EcmFnKG1vdmVYOiBudW1iZXIsIG1vdmVZOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmdQaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG90YWxEcmFnT2Zmc2V0WzFdICs9IG1vdmVZO1xuICAgICAgICBjb25zdCByZW1vdmVQaXhlbFJvb20gPSAyOyAgICAgICAgICAgIFxuICAgICAgICB0aGlzLl9waW5Nb3ZlZCA9IE1hdGguYWJzKHRoaXMudG90YWxEcmFnT2Zmc2V0WzFdKSA+IHJlbW92ZVBpeGVsUm9vbTtcbiAgICAgICAgY29uc3QgdmFsdWVPZmZzZXRQaXhlbHMgPSB0aGlzLm5vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVkodGhpcy5hbmNob3JQaW5WYWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4dGVudDogW251bWJlciwgbnVtYmVyXSA9IHRoaXMubm9ybWFsaXplZEhpc3RvZ3JhbVNjYWxlWS5yYW5nZSgpLm1hcCh5ID0+IHkgLSB2YWx1ZU9mZnNldFBpeGVscykgYXMgW251bWJlciwgbnVtYmVyXTtcbiAgICAgICAgbGV0IHlPZmZzZXQgPSBEZXZsaWJNYXRoLmNsYW1wKHRoaXMudG90YWxEcmFnT2Zmc2V0WzFdLCBleHRlbnQpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdW5waW5PZmZzZXQgPSB0aGlzLnBpbk1vdmVkID8gNCA6IDEyO1xuICAgICAgICBkMy5zZWxlY3QodGhpcy5kcmFnZ2luZ1BpbkVsZW1lbnQpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMuaW5pdGlhbERyYWdDb29yZHNbMF0gKyB0aGlzLnRvdGFsRHJhZ09mZnNldFswXSAtIHVucGluT2Zmc2V0fSwgJHt0aGlzLmluaXRpYWxEcmFnQ29vcmRzWzFdICsgeU9mZnNldH0pYCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5lZWRsZVNlbGVjdGlvblxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHstdW5waW5PZmZzZXR9LCAke3lPZmZzZXR9KWApO1xuICAgICAgICBcbiAgICAgICAgdGhpcy50ZXh0U2VsZWN0aW9uXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke3lPZmZzZXR9KWApXG4gICAgICAgICAgICAudGV4dCh0aGlzLnBpbk1vdmVkID8gdGhpcy5mb3JtYXRQaW5MYWJlbCh0aGlzLmdldEN1cnJlbnREcmFnZ2VkVmFsdWUoKSkgOiAnWCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q3VycmVudERyYWdnZWRWYWx1ZSgpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGNvbnN0IHBpeGVsRGlmZmVyZW5jZSA9IHRoaXMudG90YWxEcmFnT2Zmc2V0WzFdO1xuICAgICAgICBjb25zdCB2YWx1ZURpZmZlcmVuY2UgPSB0aGlzLm5vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVkuaW52ZXJ0KHBpeGVsRGlmZmVyZW5jZSkgLSB0aGlzLm5vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVkuaW52ZXJ0KDApO1xuICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGhpcy5pbml0aWFsUGluVmFsdWUgKyB2YWx1ZURpZmZlcmVuY2U7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IERldmxpYk1hdGguY2xhbXAoY3VycmVudFZhbHVlLCB0aGlzLm5vcm1hbGl6ZWRIaXN0b2dyYW1TY2FsZVkuZG9tYWluKCkgYXMgW251bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGRyYXdFeGVtcGxhckdyb3d0aEN1cnZlcygpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyB0b2RvIG1ha2UgdGhpcyB3b3JrIGZvciBleGVtcGxhciBtb2RlIHdoZW4gdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZVxuICAgICAgICBpZiAoIXRoaXMucGFyZW50V2lkZ2V0LmluRXhlbXBsYXJNb2RlIHx8ICF0aGlzLnBhcmVudFdpZGdldC5pbkNvbmRlbnNlZE1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIERldmxpYlRTVXRpbC5oaWRlKHRoaXMuZXhlbXBsYXJDdXJ2ZXNHcm91cC5ub2RlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIERldmxpYlRTVXRpbC5zaG93KHRoaXMuZXhlbXBsYXJDdXJ2ZXNHcm91cC5ub2RlKCkpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRXhlbXBsYXJDdXJ2ZXNPZmZzZXQoKTtcblxuICAgICAgICBsZXQgZ3JvdXBMaXN0U2VsZWN0aW9uID0gdGhpcy5leGVtcGxhckN1cnZlc0dyb3VwLnNlbGVjdEFsbCgnLmV4ZW1wbGFyLnBsb3RHcm91cGVyJylcbiAgICAgICAgICAgIC5kYXRhKHRoaXMuY29uZGl0aW9uTGFiZWxQb3NpdGlvbnMpXG4gICAgICAgICAgICAuam9pbignZycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnZXhlbXBsYXInLCB0cnVlKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ3Bsb3RHcm91cGVyJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoMCwgJHtkWzFdWzBdfSlgKTtcblxuICAgICAgICBjb25zdCByaWdodFBhZGRpbmcgPSA0O1xuXG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuaW5uZXJDb250YWluZXIubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAtIE51bWJlcih0aGlzLnNlbGVjdGVkSW1hZ2VDYW52YXMuYXR0cignd2lkdGgnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gdGhpcy50cmFja1RvUGxvdFBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gcmlnaHRQYWRkaW5nO1xuXG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMuZXhlbXBsYXJNaW5XaWR0aCk7IC8vIG1pbi13aWR0aDogODBcbiAgICAgICAgd2lkdGggPSBNYXRoLm1pbih3aWR0aCwgMjQwKTsgLy8gbWF4LXdpZHRoOiAyNDBcblxuICAgICAgICBjb25zdCBmcmFtZUV4dGVudCA9IHRoaXMucGFyZW50V2lkZ2V0LmZ1bGxEYXRhLmdldE1pbk1heCgnRnJhbWUgSUQnKTtcbiAgICAgICAgdGhpcy5fZXhlbXBsYXJTY2FsZVggPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKGZyYW1lRXh0ZW50KVxuICAgICAgICAgICAgLnJhbmdlKFswLCB3aWR0aF0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeUtleSA9IHRoaXMuZXhlbXBsYXJZS2V5O1xuICAgICAgICBjb25zdCBhbGxEYXRhID0gWy4uLnRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MsIC4uLnRoaXMudHJhY2tMaXN0Lm1hcChleGVtcGxhciA9PiBleGVtcGxhci5kYXRhKV07XG4gICAgICAgIGxldCB5TWluID0gZDMubWluKGFsbERhdGEsIGN1cnZlID0+IGQzLm1pbihjdXJ2ZS5wb2ludExpc3QsIHBvaW50ID0+IHBvaW50LmdldCh5S2V5KSkpO1xuICAgICAgICBsZXQgeU1heCA9IGQzLm1heChhbGxEYXRhLCBjdXJ2ZSA9PiBkMy5tYXgoY3VydmUucG9pbnRMaXN0LCBwb2ludCA9PiBwb2ludC5nZXQoeUtleSkpKTtcblxuICAgICAgICBmb3IgKGxldCBmYWNldCBvZiB0aGlzLnBhcmVudFdpZGdldC5mYWNldExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBhdmVyYWdlR3Jvd3RoQ3VydmU6IFtudW1iZXIsIG51bWJlcl1bXSA9IGZhY2V0LmRhdGEuZ2V0QXZlcmFnZUN1cnZlKHlLZXksIGZhbHNlLCB0aGlzLnNtb290aEN1cnZlcyk7XG4gICAgICAgICAgICBsZXQgW3RoaXNNaW4sIHRoaXNNYXhdID0gZDMuZXh0ZW50KGF2ZXJhZ2VHcm93dGhDdXJ2ZSwgZCA9PiBkWzFdKTtcbiAgICAgICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCB0aGlzTWluKTtcbiAgICAgICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCB0aGlzTWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0UG9zaXRpb24gPSB0aGlzLmNvbmRpdGlvbkxhYmVsUG9zaXRpb25zWzBdWzFdO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gZmlyc3RQb3NpdGlvblsxXSAtIGZpcnN0UG9zaXRpb25bMF0gKyAxO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIDEyMCk7IC8vIG1heC1oZWlnaHQgMTIwXG5cbiAgICAgICAgdGhpcy5fZXhlbXBsYXJTY2FsZVkgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgICAgICAgICAuZG9tYWluKFt5TWluLCB5TWF4XSlcbiAgICAgICAgICAgIC5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGZhdm9yaXRlQ3VydmVzOiBmYXZvcml0ZUN1cnZlcyxcbiAgICAgICAgICAgIGV4ZW1wbGFyQ3VydmVzOiBleGVtcGxhckdyb3d0aEN1cnZlcyxcbiAgICAgICAgICAgIGF2ZXJhZ2VDdXJ2ZXM6IGF2ZXJhZ2VHcm93dGhMaW5lc1xuICAgICAgICAgfSA9IHRoaXMuZ2VuZXJhdGVFeGVtcGxhckdyb3d0aEN1cnZlcygpO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHRoaXMucGFyZW50V2lkZ2V0LmdldEN1cnJlbnRGcmFtZUlkKCk7XG4gICAgICAgIGdyb3VwTGlzdFNlbGVjdGlvbi5zZWxlY3RBbGwoJy5jdXJyZW50RnJhbWVMaW5lJylcbiAgICAgICAgICAgIC5kYXRhKChkLGkpID0+IFtpXSlcbiAgICAgICAgICAgIC5qb2luKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIHRoaXMuZXhlbXBsYXJTY2FsZVgoY3VycmVudEZyYW1lKSlcbiAgICAgICAgICAgIC5hdHRyKCd4MicsIHRoaXMuZXhlbXBsYXJTY2FsZVgoY3VycmVudEZyYW1lKSlcbiAgICAgICAgICAgIC5hdHRyKCd5MScsIHRoaXMuZXhlbXBsYXJTY2FsZVkucmFuZ2UoKVswXSlcbiAgICAgICAgICAgIC5hdHRyKCd5MicsIHRoaXMuZXhlbXBsYXJTY2FsZVkucmFuZ2UoKVsxXSlcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2N1cnJlbnRGcmFtZUxpbmUnLCB0cnVlKTtcblxuICAgICAgICBncm91cExpc3RTZWxlY3Rpb24uc2VsZWN0QWxsKCcuYXZlcmFnZUN1cnZlJylcbiAgICAgICAgICAgIC5kYXRhKChkLGkpID0+IFtbYXZlcmFnZUdyb3d0aExpbmVzW2ldLCBkWzBdXSBdKVxuICAgICAgICAgICAgLmpvaW4oJ3BhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkID0+IGRbMF0pXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZCA9PiBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGRbMV0uc3BsaXQoJ19fXycpLCB0aGlzLnBhcmVudFdpZGdldC5jb2xvckxvb2t1cCkpXG4gICAgICAgICAgICAuY2xhc3NlZCgnYXZlcmFnZUN1cnZlJywgdHJ1ZSk7XG5cbiAgICAgICAgZ3JvdXBMaXN0U2VsZWN0aW9uLnNlbGVjdEFsbCgnLmV4ZW1wbGFyQ3VydmUnKVxuICAgICAgICAgICAgLmRhdGEoKGQsaSkgPT4gZXhlbXBsYXJHcm93dGhDdXJ2ZXNbaV0ubWFwKHggPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRoU3RyaW5nOiB4LFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZFswXSxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRleDogaVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLmpvaW4oJ3BhdGgnKVxuICAgICAgICAgICAgLmF0dHIoJ2QnLCBkID0+IGQucGF0aFN0cmluZylcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBkID0+IEdyb3VwQnlXaWRnZXQuZ2V0Q29sb3IoZC5sYWJlbC5zcGxpdCgnX19fJyksIHRoaXMucGFyZW50V2lkZ2V0LmNvbG9yTG9va3VwKSlcbiAgICAgICAgICAgIC5hdHRyKCdkYXRhLWNlbGxJZCcsIChkLCBpKSA9PiB0aGlzLnRyYWNrTGlzdFtpICsgdGhpcy5wYXJlbnRXaWRnZXQubnVtRXhlbXBsYXJzICogZC5ncm91cEluZGV4XS5kYXRhLmlkKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2V4ZW1wbGFyQ3VydmUnLCB0cnVlKTtcblxuICAgICAgICBsZXQgc2NhbGVMaXN0OiBbZDMuQXhpczxudW1iZXIgfCB7IHZhbHVlT2YoKTogbnVtYmVyOyB9PiwgbnVtYmVyXVtdID1cbiAgICAgICAgW1xuICAgICAgICAgICAgW2QzLmF4aXNCb3R0b20odGhpcy5leGVtcGxhclNjYWxlWCkudGlja3MoNSksIGhlaWdodF0sXG4gICAgICAgICAgICBbZDMuYXhpc0xlZnQodGhpcy5leGVtcGxhclNjYWxlWSksIDBdXG4gICAgICAgIF07XG5cbiAgICAgICAgZ3JvdXBMaXN0U2VsZWN0aW9uLnNlbGVjdEFsbCgnLmV4ZW1wbGFyUGxvdEF4aXMnKVxuICAgICAgICAgICAgLmRhdGEoKGQsIGkpID0+IHNjYWxlTGlzdC5tYXAoeCA9PiBbeCwgaV0pKVxuICAgICAgICAgICAgLmpvaW4oJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2V4ZW1wbGFyUGxvdEF4aXMnLCB0cnVlKVxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIChkKSA9PiBgdHJhbnNsYXRlKDAsICR7ZFswXVsxXX0pYClcbiAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXhpc0Z1bmM6IGQzLkF4aXM8bnVtYmVyIHwge3ZhbHVlT2YoKTogbnVtYmVyO30+O1xuICAgICAgICAgICAgICAgIGF4aXNGdW5jID0gZFswXVswXTtcbiAgICAgICAgICAgICAgICBheGlzRnVuYyhkMy5zZWxlY3QodGhpcykgYXMgYW55KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZHJhd0Zhdm9yaXRlR3Jvd3RoQ3VydmVzKGZhdm9yaXRlQ3VydmVzLCBzY2FsZUxpc3QpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZHJhd0Zhdm9yaXRlR3Jvd3RoQ3VydmVzKGZhdm9yaXRlQ3VydmVzOiBzdHJpbmdbXSwgc2NhbGVMaXN0OiBbZDMuQXhpczxudW1iZXIgfCB7IHZhbHVlT2YoKTogbnVtYmVyOyB9PiwgbnVtYmVyXVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMubWFudWFsbHlQaW5uZWRUcmFja3MubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmV4ZW1wbGFyQ3VydmVzR3JvdXAuc2VsZWN0QWxsKCcuZmF2b3JpdGUucGxvdEdyb3VwZXInKS5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cFNlbGVjdGlvbiA9IHRoaXMuZXhlbXBsYXJDdXJ2ZXNHcm91cC5zZWxlY3RBbGwoJy5mYXZvcml0ZS5wbG90R3JvdXBlcicpXG4gICAgICAgICAgICAuZGF0YShbNDJdKVxuICAgICAgICAgICAgLmpvaW4oJ2cnKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2Zhdm9yaXRlJywgdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKCdwbG90R3JvdXBlcicsIHRydWUpXG4gICAgICAgICAgICAuY2xhc3NlZCgnbm9EaXNwJywgZmFsc2UpXG4gICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZCA9PiBgdHJhbnNsYXRlKDAsICR7dGhpcy52ZXJ0aWNhbFBhZH0pYCk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lID0gdGhpcy5wYXJlbnRXaWRnZXQuZ2V0Q3VycmVudEZyYW1lSWQoKTtcbiAgICAgICAgZ3JvdXBTZWxlY3Rpb24uc2VsZWN0QWxsKCcuY3VycmVudEZyYW1lTGluZScpXG4gICAgICAgICAgICAuZGF0YSgoZCxpKSA9PiBbaV0pXG4gICAgICAgICAgICAuam9pbignbGluZScpXG4gICAgICAgICAgICAuYXR0cigneDEnLCB0aGlzLmV4ZW1wbGFyU2NhbGVYKGN1cnJlbnRGcmFtZSkpXG4gICAgICAgICAgICAuYXR0cigneDInLCB0aGlzLmV4ZW1wbGFyU2NhbGVYKGN1cnJlbnRGcmFtZSkpXG4gICAgICAgICAgICAuYXR0cigneTEnLCB0aGlzLmV4ZW1wbGFyU2NhbGVZLnJhbmdlKClbMF0pXG4gICAgICAgICAgICAuYXR0cigneTInLCB0aGlzLmV4ZW1wbGFyU2NhbGVZLnJhbmdlKClbMV0pXG4gICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdjdXJyZW50RnJhbWVMaW5lJywgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBncm91cFNlbGVjdGlvbi5zZWxlY3RBbGwoJy5leGVtcGxhckN1cnZlJylcbiAgICAgICAgICAgIC5kYXRhKGQgPT4gZmF2b3JpdGVDdXJ2ZXMpXG4gICAgICAgICAgICAuam9pbigncGF0aCcpXG4gICAgICAgICAgICAuYXR0cignZCcsIGQgPT4gZClcbiAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCAoZCwgaSkgPT4gXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSB0cmFjay5wb2ludExpc3RbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jSWQgPSBmaXJzdFBvaW50LmdldCgnTG9jYXRpb24gSUQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbExpc3QgPSB0aGlzLnBhcmVudFdpZGdldC5mdWxsRGF0YS5pbnZlcnNlTG9jYXRpb25NYXAuZ2V0KGxvY0lkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IEdyb3VwQnlXaWRnZXQuZ2V0Q29sb3IobGFiZWxMaXN0LCB0aGlzLnBhcmVudFdpZGdldC5jb2xvckxvb2t1cCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hdHRyKCdkYXRhLWNlbGxJZCcsIChkLCBpKSA9PiB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzW2ldLmlkKVxuICAgICAgICAgICAgLmNsYXNzZWQoJ2V4ZW1wbGFyQ3VydmUnLCB0cnVlKTtcblxuICAgICAgICBncm91cFNlbGVjdGlvbi5zZWxlY3RBbGwoJy5leGVtcGxhclBsb3RBeGlzJylcbiAgICAgICAgICAgIC5kYXRhKChkLCBpKSA9PiBzY2FsZUxpc3QubWFwKHggPT4gW3gsIGldKSlcbiAgICAgICAgICAgIC5qb2luKCdnJylcbiAgICAgICAgICAgIC5jbGFzc2VkKCdleGVtcGxhclBsb3RBeGlzJywgdHJ1ZSlcbiAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCkgPT4gYHRyYW5zbGF0ZSgwLCAke2RbMF1bMV19KWApXG4gICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF4aXNGdW5jOiBkMy5BeGlzPG51bWJlciB8IHt2YWx1ZU9mKCk6IG51bWJlcjt9PjtcbiAgICAgICAgICAgICAgICBheGlzRnVuYyA9IGRbMF1bMF07XG4gICAgICAgICAgICAgICAgYXhpc0Z1bmMoZDMuc2VsZWN0KHRoaXMpIGFzIGFueSk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgdXBkYXRlQ3VycmVudEZyYW1lSW5kaWNhdG9yKGZyYW1lSWQ6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5leGVtcGxhclNjYWxlWClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdyb3VwTGlzdFNlbGVjdGlvbiA9IHRoaXMuZXhlbXBsYXJDdXJ2ZXNHcm91cC5zZWxlY3RBbGwoJy5wbG90R3JvdXBlcicpXG5cbiAgICAgICAgZ3JvdXBMaXN0U2VsZWN0aW9uLnNlbGVjdEFsbCgnLmN1cnJlbnRGcmFtZUxpbmUnKVxuICAgICAgICAgICAgLmRhdGEoWzQyXSlcbiAgICAgICAgICAgIC5qb2luKCdsaW5lJylcbiAgICAgICAgICAgIC5hdHRyKCd4MScsIHRoaXMuZXhlbXBsYXJTY2FsZVgoZnJhbWVJZCkpXG4gICAgICAgICAgICAuYXR0cigneDInLCB0aGlzLmV4ZW1wbGFyU2NhbGVYKGZyYW1lSWQpKVxuICAgICAgICAgICAgLmF0dHIoJ3kxJywgdGhpcy5leGVtcGxhclNjYWxlWS5yYW5nZSgpWzBdKVxuICAgICAgICAgICAgLmF0dHIoJ3kyJywgdGhpcy5leGVtcGxhclNjYWxlWS5yYW5nZSgpWzFdKVxuICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG4gICAgICAgICAgICAuY2xhc3NlZCgnY3VycmVudEZyYW1lTGluZScsIHRydWUpO1xuXG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVFeGVtcGxhckN1cnZlc09mZnNldCgpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBjb250ZW50T2Zmc2V0ID0gTnVtYmVyKHRoaXMuc2VsZWN0ZWRJbWFnZUNhbnZhcy5hdHRyKCd3aWR0aCcpKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VG9FeGVtcGxhckN1cnZlcyA9IHRoaXMuY2VsbFRpbWVsaW5lTWFyZ2luLmxlZnQgKyBjb250ZW50T2Zmc2V0ICsgdGhpcy50cmFja1RvUGxvdFBhZGRpbmc7XG4gICAgICAgIHRoaXMuZXhlbXBsYXJDdXJ2ZXNHcm91cC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoJHtvZmZzZXRUb0V4ZW1wbGFyQ3VydmVzfSwgJHt0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi50b3AgLSB0aGlzLmxhdGVzdFNjcm9sbFsxXX0pYCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUV4ZW1wbGFyR3Jvd3RoQ3VydmVzKCk6IHtmYXZvcml0ZUN1cnZlczogc3RyaW5nW10sIGV4ZW1wbGFyQ3VydmVzOiBzdHJpbmdbXVtdLCBhdmVyYWdlQ3VydmVzOiBzdHJpbmdbXX1cbiAgICB7XG4gICAgICAgIGNvbnN0IHhLZXkgPSAnRnJhbWUgSUQnO1xuICAgICAgICBjb25zdCB5S2V5ID0gdGhpcy5leGVtcGxhcllLZXk7XG4gICAgICAgIGxldCBsaW5lID0gZDMubGluZTxbbnVtYmVyLCBudW1iZXJdPigpXG4gICAgICAgICAgICAueChkID0+IHRoaXMuZXhlbXBsYXJTY2FsZVgoZFswXSkpXG4gICAgICAgICAgICAueShkID0+IHRoaXMuZXhlbXBsYXJTY2FsZVkoZFsxXSkpO1xuXG4gICAgICAgIC8vIHRvZG8gLSBtYXliZSBub3JtYWxpemUgdGhpcyB0byBhIFtudW1iZXIsIG51bWJlcl1bXSBzbyBmaWx0ZXJpbmcgaXMgZWFzaWVyLlxuICAgICAgICBcbiAgICAgICAgbGV0IGZhdm9yaXRlQ3VydmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCB0cmFjayBvZiB0aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcG9pbnRMaXN0ID0gdGhpcy5leHRyYWN0MkRBcnJheSh0cmFjay5wb2ludExpc3QsIHhLZXksIHlLZXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc21vb3RoQ3VydmVzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBvaW50TGlzdCA9IEN1cnZlTGlzdC5tZWRpYW5GaWx0ZXIocG9pbnRMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXRoU3RyaW5nID0gbGluZShwb2ludExpc3QpO1xuICAgICAgICAgICAgZmF2b3JpdGVDdXJ2ZXMucHVzaChwYXRoU3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBleGVtcGxhckN1cnZlczogc3RyaW5nW11bXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhY2tMaXN0Lmxlbmd0aDsgaSArPSB0aGlzLnBhcmVudFdpZGdldC5udW1FeGVtcGxhcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBwYXRoTGlzdDogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHBhdGggb2YgdGhpcy50cmFja0xpc3Quc2xpY2UoaSwgaSArIHRoaXMucGFyZW50V2lkZ2V0Lm51bUV4ZW1wbGFycykpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50TGlzdCA9IHRoaXMuZXh0cmFjdDJEQXJyYXkocGF0aC5kYXRhLnBvaW50TGlzdCwgeEtleSwgeUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc21vb3RoQ3VydmVzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRMaXN0ID0gQ3VydmVMaXN0Lm1lZGlhbkZpbHRlcihwb2ludExpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGF0aFN0cmluZyA9IGxpbmUocG9pbnRMaXN0KTtcbiAgICAgICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhlbXBsYXJDdXJ2ZXMucHVzaChwYXRoTGlzdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhdmVyYWdlIGdyb3d0aCBjYWxjdWxhdGlvblxuXG5cdFx0bGV0IFttaW5GcmFtZSwgbWF4RnJhbWVdID0gdGhpcy5wYXJlbnRXaWRnZXQuZnVsbERhdGEuZ2V0TWluTWF4KCdGcmFtZSBJRCcpO1xuICAgICAgICBsZXQgbGluZUF2ZyA9IGQzLmxpbmU8W251bWJlciwgbnVtYmVyXT4oKVxuICAgICAgICAgICAgLngoZCA9PiB0aGlzLmV4ZW1wbGFyU2NhbGVYKGRbMF0pKVxuICAgICAgICAgICAgLnkoZCA9PiB0aGlzLmV4ZW1wbGFyU2NhbGVZKGRbMV0pKTtcblxuICAgICAgICBsZXQgYXZlcmFnZUdyb3d0aExpbmVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmYWNldCBvZiB0aGlzLnBhcmVudFdpZGdldC5mYWNldExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBhdmVyYWdlR3Jvd3RoQ3VydmUgPSBmYWNldC5kYXRhLmdldEF2ZXJhZ2VDdXJ2ZSh5S2V5LCBmYWxzZSwgdGhpcy5zbW9vdGhDdXJ2ZXMpO1xuICAgICAgICAgICAgbGV0IGF2ZXJhZ2VHcm93dGhDdXJ2ZVN0cmluZyA9IGxpbmVBdmcoYXZlcmFnZUdyb3d0aEN1cnZlKTtcbiAgICAgICAgICAgIGF2ZXJhZ2VHcm93dGhMaW5lcy5wdXNoKGF2ZXJhZ2VHcm93dGhDdXJ2ZVN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmF2b3JpdGVDdXJ2ZXM6IGZhdm9yaXRlQ3VydmVzLFxuICAgICAgICAgICAgZXhlbXBsYXJDdXJ2ZXM6IGV4ZW1wbGFyQ3VydmVzLFxuICAgICAgICAgICAgYXZlcmFnZUN1cnZlczogYXZlcmFnZUdyb3d0aExpbmVzXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3QyREFycmF5KHBvaW50TGlzdDogUG9pbnRORFtdLCB4S2V5OiBzdHJpbmcsIHlLZXk6IHN0cmluZyk6IFtudW1iZXIsIG51bWJlcl1bXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHBvaW50TGlzdC5tYXAocG9pbnQgPT4gW3BvaW50LmdldCh4S2V5KSwgcG9pbnQuZ2V0KHlLZXkpXSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVMYWJlbHNPbk1vdXNlTW92ZShjZWxsSWQ6IHN0cmluZywgZnJhbWVJbmRleDogbnVtYmVyLCByb3dJbmRleDogbnVtYmVyKTogdm9pZFxuICAgIHtcblxuICAgICAgICBsZXQgc3ZnU2VsZWN0aW9uID0gdGhpcy5jZWxsTGFiZWxHcm91cC5zZWxlY3RBbGwoJ3RleHQnKSBhcyBTdmdTZWxlY3Rpb247XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnRXaWRnZXQuaW5FeGVtcGxhck1vZGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBmb3VuZE1hdGNoID0gdGhpcy5ob3Zlck5vZGVXaXRoVGV4dChzdmdTZWxlY3Rpb24ubm9kZXMoKSwgY2VsbElkKTtcbiAgICAgICAgICAgIHN2Z1NlbGVjdGlvbiA9IHRoaXMuZnJhbWVMYWJlbEdyb3VwLnNlbGVjdEFsbCgndGV4dCcpIGFzIFN2Z1NlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICghZm91bmRNYXRjaClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyTm9kZVdpdGhUZXh0KHN2Z1NlbGVjdGlvbi5ub2RlcygpLCAnJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmV4ZW1wbGFyQ3VydmVzR3JvdXAuc2VsZWN0QWxsKCcuZXhlbXBsYXJDdXJ2ZScpLmNsYXNzZWQoJ3NlbGVjdGVkJywgZmFsc2UpXG4gICAgICAgICAgICB0aGlzLmV4ZW1wbGFyUGluR3JvdXAuc2VsZWN0QWxsKCcqJykuY2xhc3NlZCgnc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLm1hbnVhbEV4ZW1wbGFyUGluR3JvdXAuc2VsZWN0QWxsKCcqJykuY2xhc3NlZCgnc2VsZWN0ZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHJvd0luZGV4KSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJvd0luZGV4IDwgdGhpcy5tYW51YWxseVBpbm5lZFRyYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRNYXRjaCA9IHRoaXMuaG92ZXJOb2RlV2l0aFRleHQoc3ZnU2VsZWN0aW9uLm5vZGVzKCksIGNlbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgIHN2Z1NlbGVjdGlvbiA9IHRoaXMuZnJhbWVMYWJlbEdyb3VwLnNlbGVjdEFsbCgndGV4dCcpIGFzIFN2Z1NlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZE1hdGNoKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdmVyTm9kZVdpdGhUZXh0KHN2Z1NlbGVjdGlvbi5ub2RlcygpLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2VsbElkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IFsuLi50aGlzLm1hbnVhbGx5UGlubmVkVHJhY2tzLCAuLi50aGlzLnRyYWNrTGlzdC5tYXAoZXhlbXBsYXIgPT4gZXhlbXBsYXIuZGF0YSldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZW1wbGFyQ3VydmVzR3JvdXAuc2VsZWN0QWxsKCcuZXhlbXBsYXJDdXJ2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24oZCwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID09IHJvd0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhpc0NlbGxJZCA9IGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdkYXRhLWNlbGxJZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ2VsbElkID09PSBjZWxsSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlbXBsYXJQaW5Hcm91cC5zZWxlY3RBbGwoJyonKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24oZCwgaSkgXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKGNlbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFudWFsRXhlbXBsYXJQaW5Hcm91cC5zZWxlY3RBbGwoJyonKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24oZCwgaSkgXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKGNlbGxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgICAgICAgICAgbGV0IHNlYXJjaFRleHQ6IHN0cmluZztcbiAgICAgICAgICAgICAgICBpZiAocm93SW5kZXggPCAwKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoVGV4dCA9ICcnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjYXRlZ29yeUluZGV4ID0gTWF0aC5mbG9vcihyb3dJbmRleCAvIHRoaXMucGFyZW50V2lkZ2V0Lm51bUV4ZW1wbGFycyk7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFRleHQgPSB0aGlzLmNvbmRpdGlvbkxhYmVsUG9zaXRpb25zW2NhdGVnb3J5SW5kZXhdWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyTm9kZVdpdGhUZXh0KHN2Z1NlbGVjdGlvbi5ub2RlcygpLCBzZWFyY2hUZXh0KTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHN2Z1NlbGVjdGlvbiA9IHRoaXMuZnJhbWVMYWJlbEdyb3VwLnNlbGVjdEFsbCgndGV4dCcpIGFzIFN2Z1NlbGVjdGlvbjtcbiAgICAgICAgbGV0IGZyYW1lVGV4dDogc3RyaW5nO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRXaWRnZXQuaW5Db25kZW5zZWRNb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgcGVyY2VudCA9IGZyYW1lSW5kZXggLyAodGhpcy5wYXJlbnRXaWRnZXQuY29uZGVuc2VkTW9kZUNvdW50IC0gMSk7XG4gICAgICAgICAgICBmcmFtZVRleHQgPSBwZXJjZW50LnRvRml4ZWQoMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBmcmFtZVRleHQgPSAoZnJhbWVJbmRleCArIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3Zlck5vZGVXaXRoVGV4dChzdmdTZWxlY3Rpb24ubm9kZXMoKSwgZnJhbWVUZXh0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhvdmVyTm9kZVdpdGhUZXh0KHN2Z0VsZW1lbnRMaXN0OiBTVkdFbGVtZW50W10sIHRleHQ6IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBmb3VudE1hdGNoID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IG5vZGUgIG9mIHN2Z0VsZW1lbnRMaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgbm9kZUVsID0gKG5vZGUgYXMgU1ZHRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobm9kZUVsLnRleHRDb250ZW50ID09PSB0ZXh0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGVFbC5jbGFzc0xpc3QuYWRkKCdob3ZlcmVkJyk7XG4gICAgICAgICAgICAgICAgZm91bnRNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbm9kZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ2hvdmVyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bnRNYXRjaDtcbiAgICB9XG5cbiAgICBwdWJsaWMgT25SZXNpemUod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBoZWlnaHQgLT0gMzA7IC8vIGhhY2t5LCBidXQgc2VlIC5jZWxsVGltZWxpbmVJbm5lckNvbnRhaW5lci50b3AgZm9yIGV4cGxhbmF0aW9uXG4gICAgICAgIHRoaXMuc3ZnQ29udGFpbmVyXG4gICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxuICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgd2lkdGgpO1xuXG4gICAgICAgIHRoaXMuc2hhbWVSZWN0YW5nbGUuYXR0cignd2lkdGgnLCB3aWR0aCk7XG5cbiAgICAgICAgY29uc3QgaW5uZXJXID0gd2lkdGggLSB0aGlzLmNlbGxUaW1lbGluZU1hcmdpbi5sZWZ0IC0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4ucmlnaHQ7XG4gICAgICAgIHRoaXMuX2lubmVyQ29udGFpbmVyVyA9IGlubmVyVztcbiAgICAgICAgY29uc3QgaW5uZXJIID0gaGVpZ2h0IC0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4udG9wIC0gdGhpcy5jZWxsVGltZWxpbmVNYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLl9pbm5lckNvbnRhaW5lckggPSBpbm5lckg7XG4gICAgICAgIHRoaXMuaW5uZXJDb250YWluZXJcbiAgICAgICAgICAgIC5hdHRyKCdzdHlsZScsXG4gICAgICAgICAgICBgbWF4LXdpZHRoOiAke2lubmVyV31weDtcbiAgICAgICAgICAgIG1heC1oZWlnaHQ6ICR7aW5uZXJIfXB4O1xuICAgICAgICAgICAgd2lkdGg6ICR7aW5uZXJXfXB4O1xuICAgICAgICAgICAgaGVpZ2h0OiAke2lubmVySH1weDtgKVxuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQge0h0bWxTZWxlY3Rpb259IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcyc7XG5pbXBvcnQge0RldmxpYlRTVXRpbH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlRTVXRpbCc7XG5pbXBvcnQge0Jhc2VXaWRnZXR9IGZyb20gJy4vQmFzZVdpZGdldCc7XG5pbXBvcnQge1BvaW50Q29sbGVjdGlvbn0gZnJvbSAnLi4vRGF0YU1vZGVsL1BvaW50Q29sbGVjdGlvbic7XG5pbXBvcnQge0N1cnZlTGlzdH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5pbXBvcnQge0xheW91dEZyYW1ld29ya30gZnJvbSAnLi4vTGF5b3V0RnJhbWV3b3JrJztcbmltcG9ydCB7SGlzdG9ncmFtV2lkZ2V0fSBmcm9tICcuL0hpc3RvZ3JhbVdpZGdldCc7XG5pbXBvcnQge1NjYXR0ZXJQbG90V2lkZ2V0fSBmcm9tICcuL1NjYXR0ZXJQbG90V2lkZ2V0JztcbmltcG9ydCB7RnJhbWUsIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLCBEaXJlY3Rpb24sIE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCwgRGF0YXNldFNwZWN9IGZyb20gJy4uL3R5cGVzJztcblxuaW50ZXJmYWNlIGJvb2xXaXRoSW5kZXgge1xuXHR2YWx1ZTogYm9vbGVhbixcblx0aW5kZXg6IFtudW1iZXIsIG51bWJlcl0sXG59XG5cblxuZXhwb3J0IGNsYXNzIE1ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldCBleHRlbmRzIEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz4ge1xuXHRcblxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEVsZW1lbnQsXG5cdFx0bWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsOiBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwsXG5cdFx0aXNDbG9uZTogYm9vbGVhbiA9IGZhbHNlKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCBmYWxzZSwgbWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsKTtcblx0XHR0aGlzLl9pc0Nsb25lID0gaXNDbG9uZTtcblx0fVxuXG4gICAgcHJvdGVjdGVkIENsb25lKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiBCYXNlV2lkZ2V0PEN1cnZlTGlzdCwgRGF0YXNldFNwZWM+XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IE1ldHJpY0Rpc3RyaWJ1dGlvbldpZGdldChjb250YWluZXIsIHRoaXMubWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsLCB0cnVlKTtcbiAgICB9XG5cblx0cHJpdmF0ZSBfaXNDbG9uZSA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaXNDbG9uZSgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzQ2xvbmU7XG5cdH1cblxuXHRwcml2YXRlIF93cmFwcGVyQ29udGFpbmVyIDogSFRNTERpdkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgd3JhcHBlckNvbnRhaW5lcigpIDogSFRNTERpdkVsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl93cmFwcGVyQ29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfbGF5b3V0RnJhbWV3b3JrIDogTGF5b3V0RnJhbWV3b3JrO1xuXHRwdWJsaWMgZ2V0IGxheW91dEZyYW1ld29yaygpIDogTGF5b3V0RnJhbWV3b3JrIHtcblx0XHRyZXR1cm4gdGhpcy5fbGF5b3V0RnJhbWV3b3JrO1xuXHR9XG5cblx0cHJpdmF0ZSBfc3ViQ29tcG9uZW50TG9va3VwIDogTWFwPEhUTUxFbGVtZW50LCBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcz47XG5cdHB1YmxpYyBnZXQgc3ViQ29tcG9uZW50TG9va3VwKCkgOiBNYXA8SFRNTEVsZW1lbnQsIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YkNvbXBvbmVudExvb2t1cDtcblx0fVxuXG5cdHByaXZhdGUgX3RpdGxlQ29udGFpbmVyU2VsZWN0aW9uIDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCB0aXRsZUNvbnRhaW5lclNlbGVjdGlvbigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3RpdGxlQ29udGFpbmVyU2VsZWN0aW9uO1xuXHR9XG5cblx0cHJpdmF0ZSBfYmFzaXNTZWxlY3RDb250YWluZXJTZWxlY3Rpb24gOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGJhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uKCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fYmFzaXNTZWxlY3RDb250YWluZXJTZWxlY3Rpb247XG5cdH1cblxuXHRwcml2YXRlIF9zY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvbiA6IEh0bWxTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24oKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvbjtcblx0fVxuXG5cdHByaXZhdGUgX3lBeGlzTWF0cml4U2VsZWN0IDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCB5QXhpc01hdHJpeFNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lBeGlzTWF0cml4U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeEF4aXNNYXRyaXhTZWxlY3QgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHhBeGlzTWF0cml4U2VsZWN0KCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5feEF4aXNNYXRyaXhTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uIDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBkaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uKCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbjtcblx0fVxuXG5cdHByaXZhdGUgX3NjYXR0ZXJQbG90Q29udGFpbmVyU2VsZWN0aW9uIDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBzY2F0dGVyUGxvdENvbnRhaW5lclNlbGVjdGlvbigpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYXR0ZXJQbG90Q29udGFpbmVyU2VsZWN0aW9uO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29sbGFwc2VCdXR0b25TZWxlY3QgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGNvbGxhcHNlQnV0dG9uU2VsZWN0KCkgOiBIdG1sU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sbGFwc2VCdXR0b25TZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9leHBhbmRCdXR0b25TZWxlY3QgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGV4cGFuZEJ1dHRvblNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZEJ1dHRvblNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX2F0dHJpYnV0ZVRvSW5kZXggOiBNYXA8c3RyaW5nLCBudW1iZXI+O1xuXHRwdWJsaWMgZ2V0IGF0dHJpYnV0ZVRvSW5kZXgoKSA6IE1hcDxzdHJpbmcsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9hdHRyaWJ1dGVUb0luZGV4O1xuXHR9XG5cblx0cHJpdmF0ZSBfYmFzaXNTZWxlY3Rpb25Cb29sZWFucyA6IGJvb2xlYW5bXTtcblx0cHVibGljIGdldCBiYXNpc1NlbGVjdGlvbkJvb2xlYW5zKCkgOiBib29sZWFuW10ge1xuXHRcdHJldHVybiB0aGlzLl9iYXNpc1NlbGVjdGlvbkJvb2xlYW5zO1xuXHR9XG5cblx0cHJpdmF0ZSBfc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucyA6IGJvb2xXaXRoSW5kZXhbXVtdO1xuXHRwdWJsaWMgZ2V0IHNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMoKSA6IGJvb2xXaXRoSW5kZXhbXVtdIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucztcblx0fVxuXG5cdHByaXZhdGUgX2hpc3RvZ3JhbVdpZGdldHMgOiBIaXN0b2dyYW1XaWRnZXRbXTtcblx0cHVibGljIGdldCBoaXN0b2dyYW1XaWRnZXRzKCkgOiBIaXN0b2dyYW1XaWRnZXRbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hpc3RvZ3JhbVdpZGdldHM7XG5cdH1cblxuXHRwcml2YXRlIF9zY2F0dGVyUGxvdFdpZGdldHMgOiBTY2F0dGVyUGxvdFdpZGdldFtdO1xuXHRwdWJsaWMgZ2V0IHNjYXR0ZXJQbG90V2lkZ2V0cygpIDogU2NhdHRlclBsb3RXaWRnZXRbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjYXR0ZXJQbG90V2lkZ2V0cztcblx0fVxuXG5cdHByaXZhdGUgX3BvaW50Q29sbGVjdGlvbiA6IFBvaW50Q29sbGVjdGlvbjtcblx0cHVibGljIGdldCBwb2ludENvbGxlY3Rpb24oKSA6IFBvaW50Q29sbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50Q29sbGVjdGlvbjtcblx0fVxuXG5cdHByaXZhdGUgX21ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCA6IE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbDtcblx0cHVibGljIGdldCBtZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwoKSA6IE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCB7XG5cdFx0cmV0dXJuIHRoaXMuX21ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfaW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24gOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGluY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b247XG5cdH1cblxuXHRwcml2YXRlIF9zaG93aW5nU2VsZWN0aW9uTWF0cml4IDogYm9vbGVhbjtcblx0cHVibGljIGdldCBzaG93aW5nU2VsZWN0aW9uTWF0cml4KCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fc2hvd2luZ1NlbGVjdGlvbk1hdHJpeDtcblx0fVxuXG5cdHByb3RlY3RlZCBpbml0UHJvcHMocHJvcHM/OiBhbnlbXSk6IHZvaWRcblx0e1xuXHRcdHN1cGVyLmluaXRQcm9wcygpO1xuXHRcdHRoaXMuX21ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbCA9IHByb3BzWzBdO1xuXHRcdHRoaXMuX3Nob3dpbmdTZWxlY3Rpb25NYXRyaXggPSBmYWxzZTtcblx0fVxuXG5cdHByb3RlY3RlZCBpbml0KCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3dyYXBwZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdHRoaXMud3JhcHBlckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJhbWVcIiwgXCJkaXItcm93XCIsIFwid3JhcHBlckNvbnRhaW5lclwiKTtcblx0XHR0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXJDb250YWluZXIpO1xuXG5cdFx0dGhpcy5fbGF5b3V0RnJhbWV3b3JrID0gbmV3IExheW91dEZyYW1ld29yayh0aGlzLndyYXBwZXJDb250YWluZXIsIGZhbHNlKTtcblx0XHRsZXQgbGF5b3V0OiBGcmFtZTxNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcz4gPSB7XG5cdFx0XHRkaXJlY3Rpb246IERpcmVjdGlvbi5yb3csXG5cdFx0XHR3cmFwOiB0cnVlLFxuXHRcdFx0b3ZlcmZsb3dTY3JvbGw6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRpcmVjdGlvbjogRGlyZWN0aW9uLmNvbHVtbixcblx0XHRcdFx0XHRpbnNpZGU6IE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLlRpdGxlLFxuXHRcdFx0XHRcdG1pblNpemU6ICcxMDAlJyxcblx0XHRcdFx0XHRmcmFjdGlvbjogMFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBEaXJlY3Rpb24uY29sdW1uLFxuXHRcdFx0XHRcdG1pblNpemU6ICc4MHB4Jyxcblx0XHRcdFx0XHRtYXhTaXplOiAnODBweCcsXG5cdFx0XHRcdFx0aW5zaWRlOiBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5CYXNpc1NlbGVjdFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZGlyZWN0aW9uOiBEaXJlY3Rpb24uY29sdW1uLFxuXHRcdFx0XHRcdGluc2lkZTogTWV0cmljRGlzdHJpYnV0aW9uU3ViQ29tcG9uZW50VHlwZXMuU2NhdHRlcnBsb3RTZWxlY3Rcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRpcmVjdGlvbjogRGlyZWN0aW9uLmNvbHVtbixcblx0XHRcdFx0XHRpbnNpZGU6IE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLkRpc3RyaWJ1dGlvblBsb3Rcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRpcmVjdGlvbjogRGlyZWN0aW9uLmNvbHVtbixcblx0XHRcdFx0XHRpbnNpZGU6IE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLlNjYXR0ZXJwbG90XG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9O1xuXHRcdHRoaXMuX3N1YkNvbXBvbmVudExvb2t1cCA9IHRoaXMubGF5b3V0RnJhbWV3b3JrLkluaXRpYWxpemVMYXlvdXQ8TWV0cmljRGlzdHJpYnV0aW9uU3ViQ29tcG9uZW50VHlwZXM+KGxheW91dClcblx0XHR0aGlzLmluaXRTdWJDb21wb25lbnRzKCk7XG5cdH1cblxuXHRwcml2YXRlIGluaXRTdWJDb21wb25lbnRzKCk6IHZvaWRcblx0e1xuXHRcdGZvciAobGV0IFtjb250YWluZXIsIHN1YkNvbXBvbmVudF0gb2YgdGhpcy5zdWJDb21wb25lbnRMb29rdXApXG5cdFx0e1xuXHRcdFx0c3dpdGNoIChzdWJDb21wb25lbnQpIHtcblx0XHRcdFx0Y2FzZSBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5UaXRsZTpcblx0XHRcdFx0XHR0aGlzLl90aXRsZUNvbnRhaW5lclNlbGVjdGlvbiA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChjb250YWluZXIsIFwidGl0bGVDb250YWluZXJcIik7XG5cdFx0XHRcdFx0bGV0IHRpdGxlOiBzdHJpbmc7XG5cdFx0XHRcdFx0aWYgKHRoaXMubWV0cmljRGlzdHJpYnV0aW9uQ29sbGVjdGlvbkxldmVsID09IE1ldHJpY0Rpc3RyaWJ1dGlvbkNvbGxlY3Rpb25MZXZlbC5DdXJ2ZSlcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aXRsZSA9ICdUcmFjay1MZXZlbCBBdHRyaWJ1dGVzJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRpdGxlID0gJ0NlbGwtTGV2ZWwgQXR0cmlidXRlcyc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudGl0bGVDb250YWluZXJTZWxlY3Rpb25cblx0XHRcdFx0XHRcdC5hcHBlbmQoJ2RpdicpXG5cdFx0XHRcdFx0XHQuYXR0cignc3R5bGUnLCAnd2lkdGg6IDMycHgnKTsgLy8gc3BhY2VyIGRpdlxuXHRcdFx0XHRcdHRoaXMudGl0bGVDb250YWluZXJTZWxlY3Rpb25cblx0XHRcdFx0XHRcdC5hcHBlbmQoJ3NwYW4nKVxuXHRcdFx0XHRcdFx0LnRleHQodGl0bGUpXG5cdFx0XHRcdFx0XHQuY2xhc3NlZCgnYXR0cmlidXRlVGl0bGUnLCB0cnVlKVxuXHRcdFx0XHRcdFx0LmNsYXNzZWQoJ21lZGl1bVRleHQnLCB0cnVlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBNZXRyaWNEaXN0cmlidXRpb25TdWJDb21wb25lbnRUeXBlcy5CYXNpc1NlbGVjdDpcblx0XHRcdFx0XHR0aGlzLl9iYXNpc1NlbGVjdENvbnRhaW5lclNlbGVjdGlvbiA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChjb250YWluZXIsIFwidG9nZ2xlQnV0dG9uQ29udGFpbmVyXCIpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLlNjYXR0ZXJwbG90U2VsZWN0OlxuXHRcdFx0XHRcdGxldCB3cmFwcGVyID0gZDMuc2VsZWN0KGNvbnRhaW5lcikuYXBwZW5kKCdkaXYnKVxuXHRcdFx0XHRcdFx0LmNsYXNzZWQoXCJtYXRyaXhXcmFwcGVyQ29udGFpbmVyXCIsIHRydWUpXG5cdFx0XHRcdFx0XHQuYXR0cihcImlkXCIsIFwibWF0cml4V3JhcHBlckNvbnRhaW5lclwiKTtcblxuXHRcdFx0XHRcdHRoaXMuX3lBeGlzTWF0cml4U2VsZWN0ID0gdGhpcy5pbml0U3ViQ29tcG9uZW50KHdyYXBwZXIubm9kZSgpLCBcInlBeGlzTWF0cml4Q29udGFpbmVyXCIpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGV0IHJpZ2h0V3JhcHBlciA9IHdyYXBwZXIuYXBwZW5kKCdkaXYnKVxuXHRcdFx0XHRcdFx0LmNsYXNzZWQoXCJtYXRyaXhSaWdodFdyYXBwZXJDb250YWluZXJcIiwgdHJ1ZSk7XG5cblx0XHRcdFx0XHR0aGlzLl9zY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvbiA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChyaWdodFdyYXBwZXIubm9kZSgpLCBcIm1hdHJpeENvbnRhaW5lclwiKTtcblx0XHRcdFx0XHR0aGlzLl94QXhpc01hdHJpeFNlbGVjdCA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChyaWdodFdyYXBwZXIubm9kZSgpLCBcInhBeGlzTWF0cml4Q29udGFpbmVyXCIpO1xuXHRcdFx0XHRcdGxldCBjb2xsYXBzZUV4cGFuZExpc3Q6IEhUTUxFbGVtZW50W10gPSBbXG5cdFx0XHRcdFx0XHR0aGlzLmJhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5wYXJlbnRFbGVtZW50LFxuXHRcdFx0XHRcdFx0d3JhcHBlci5ub2RlKCkucGFyZW50RWxlbWVudFxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0dGhpcy5oaWRlRWxlbWVudHMoY29sbGFwc2VFeHBhbmRMaXN0KTsgLy8gY29sbGFwc2VkIGJ5IGRlZmF1bHRcblx0XHRcdFx0XHR0aGlzLmluaXRFeHBhbmRDb2xsYXBzZUJ1dHRvbihjb2xsYXBzZUV4cGFuZExpc3QpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzLkRpc3RyaWJ1dGlvblBsb3Q6XG5cdFx0XHRcdFx0dGhpcy5fZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbiA9IHRoaXMuaW5pdFN1YkNvbXBvbmVudChjb250YWluZXIsIFwiZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclwiKTtcblx0XHRcdFx0XHR0aGlzLmRpc3RyaWJ1dGlvblBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1pbldpZHRoID0gJzMwMHB4JzsgLy8gdGhpcyBpcyBoYXJkY29kZWQgYmFzZWQgb24gbWF4IHdpZHRoIG9mIGhpc3RvZ3JhbVxuXHRcdFx0XHRcdHRoaXMuZGlzdHJpYnV0aW9uUGxvdENvbnRhaW5lclNlbGVjdGlvbi5ub2RlKCkuc3R5bGUubWF4V2lkdGggPSAnMzAwcHgnOyAvLyB0aGlzIGlzIGhhcmRjb2RlZCBiYXNlZCBvbiBtYXggd2lkdGggb2YgaGlzdG9ncmFtXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgTWV0cmljRGlzdHJpYnV0aW9uU3ViQ29tcG9uZW50VHlwZXMuU2NhdHRlcnBsb3Q6XG5cdFx0XHRcdFx0dGhpcy5fc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24gPSB0aGlzLmluaXRTdWJDb21wb25lbnQoY29udGFpbmVyLCBcInNjYXR0ZXJQbG90T3V0ZXJDb250YWluZXJcIik7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5fc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1pbldpZHRoID0gJzMwMHB4JzsgLy8gdGhpcyBpcyBoYXJkY29kZWQgYmFzZWQgb24gbWF4IHdpZHRoIG9mIHNjYXR0ZXJwbG90XG5cdFx0XHRcdFx0dGhpcy5fc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1heFdpZHRoID0gJzMwMHB4JzsgLy8gdGhpcyBpcyBoYXJkY29kZWQgYmFzZWQgb24gbWF4IHdpZHRoIG9mIHNjYXR0ZXJwbG90XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMucmVzaXplU3ViQ29tcG9uZW50cygpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0U3ViQ29tcG9uZW50KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGNsYXNzTmFtZTogc3RyaW5nKTogSHRtbFNlbGVjdGlvblxuXHR7XG5cdFx0cmV0dXJuIGQzLnNlbGVjdChjb250YWluZXIpXHRcdFx0XG5cdFx0XHQuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHQuY2xhc3NlZChjbGFzc05hbWUsIHRydWUpXG5cdFx0XHQvLyAuY2xhc3NlZChcIm92ZXJmbG93LXNjcm9sbFwiLCB0cnVlKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBjbGFzc05hbWUpO1xuXHR9XG5cblx0cHJpdmF0ZSBoaWRlRWxlbWVudHModG9IaWRlOiBIVE1MRWxlbWVudFtdKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgZWxlbWVudCBvZiB0b0hpZGUpXG5cdFx0e1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibm9EaXNwXCIpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaW5pdEV4cGFuZENvbGxhcHNlQnV0dG9uKHRvU2hvdzogSFRNTEVsZW1lbnRbXSk6IHZvaWRcblx0e1xuXHRcdHRoaXMuX2V4cGFuZEJ1dHRvblNlbGVjdCA9IHRoaXMudGl0bGVDb250YWluZXJTZWxlY3Rpb24uYXBwZW5kKCdidXR0b24nKVxuXHRcdFx0Ly8gLmxvd2VyKClcblx0XHRcdC5jbGFzc2VkKCdiYXNpY0ljb25CdXR0b24nLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ3RhYicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSlcblx0XHRcdC5hdHRyKCdpZCcsICdNZXRyaWNEaXN0cmlidXRpb25XaWRnZXQtZXhwYW5kQnV0dG9uJylcblx0XHRcdC5hdHRyKFwidGl0bGVcIiwgXCJPcGVuIGRpc3RyaWJ1dGlvbiBzZWxlY3Rpb24gd2lkZ2V0LlwiKVxuXHRcdFx0Lm9uKCdjbGljaycsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLnNob3dpbmdTZWxlY3Rpb25NYXRyaXgpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGxldCBlbGVtZW50IG9mIHRvU2hvdylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ25vRGlzcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmV4cGFuZEJ1dHRvblNlbGVjdC5jbGFzc2VkKCdzZWxlY3RlZCcsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGxldCBlbGVtZW50IG9mIHRvU2hvdylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ25vRGlzcCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmV4cGFuZEJ1dHRvblNlbGVjdC5jbGFzc2VkKCdzZWxlY3RlZCcsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX3Nob3dpbmdTZWxlY3Rpb25NYXRyaXggPSAhdGhpcy5zaG93aW5nU2VsZWN0aW9uTWF0cml4O1xuXHRcdFx0fSk7XG5cdFx0bGV0IGljb24gPSBEZXZsaWJUU1V0aWwuZ2V0Rm9udEF3ZXNvbWVJY29uKCdjb2cnKTtcblx0XHR0aGlzLmV4cGFuZEJ1dHRvblNlbGVjdC5ub2RlKCkuYXBwZW5kQ2hpbGQoaWNvbik7XG5cdH1cblxuXHRwdWJsaWMgT25EYXRhQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdHN3aXRjaCAodGhpcy5tZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwpXG5cdFx0e1xuXHRcdFx0Y2FzZSBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwuUG9pbnQ6XG5cdFx0XHRcdHRoaXMuX3BvaW50Q29sbGVjdGlvbiA9IHRoaXMuZGF0YSBhcyBQb2ludENvbGxlY3Rpb247XG5cdFx0XHRcdHRoaXMuX2luY2x1ZGVFeGVtcGxhclRyYWNrQnV0dG9uID0gZmFsc2U7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwuQ3VydmU6XG5cdFx0XHRcdHRoaXMuX3BvaW50Q29sbGVjdGlvbiA9IHRoaXMuZGF0YS5jdXJ2ZUNvbGxlY3Rpb24gYXMgUG9pbnRDb2xsZWN0aW9uO1xuXHRcdFx0XHR0aGlzLl9pbmNsdWRlRXhlbXBsYXJUcmFja0J1dHRvbiA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5fcG9pbnRDb2xsZWN0aW9uID0gbnVsbDtcblx0XHRcdFx0dGhpcy5faW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24gPSBmYWxzZTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwgbm90IHNldC4nKVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHR0aGlzLl9hdHRyaWJ1dGVUb0luZGV4ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblx0XHRmb3IgKGxldCBbaW5kZXgsIGF0dHJdIG9mIHRoaXMucG9pbnRDb2xsZWN0aW9uLmF0dHJpYnV0ZUxpc3QuZW50cmllcygpKVxuXHRcdHtcblx0XHRcdHRoaXMuYXR0cmlidXRlVG9JbmRleC5zZXQoYXR0ciwgaW5kZXgpO1xuXHRcdH1cblxuXHRcdHRoaXMudXBkYXRlVUlEYXRhKCk7XG5cdFx0dGhpcy5kcmF3QmFzaXNTZWxlY3QoKTtcblx0XHR0aGlzLmRyYXdTY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvbigpO1xuXHRcdHRoaXMuZHJhd01hdHJpeEF4aXMoKTtcblx0XHR0aGlzLmV4cGFuZEJ1dHRvblNlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG5cdFx0dGhpcy5kcmF3SGlzdG9ncmFtcygpO1xuXHRcdHRoaXMuZHJhd1NjYXR0ZXJQbG90cyh0aGlzLmdldFNjYXR0ZXJPcHRpb25zTWF0cml4KCkpO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgaGlzdCBvZiB0aGlzLmhpc3RvZ3JhbVdpZGdldHMpXG5cdFx0e1xuXHRcdFx0aGlzdC5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgc2NhdHRlciBvZiB0aGlzLnNjYXR0ZXJQbG90V2lkZ2V0cylcblx0XHR7XG5cdFx0XHRzY2F0dGVyLk9uQnJ1c2hDaGFuZ2UoKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVVJRGF0YSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9iYXNpc1NlbGVjdGlvbkJvb2xlYW5zID0gW107XG5cdFx0Ly8gVG9kbyAtIGl0IHdvdWxkIGJlIG5pY2UgaWYgdGhpcyB3YXMgY29uZmlndXJhYmxlLlxuXHRcdGNvbnN0IGRlZmF1bHRJbmNsdWRlZCA9IG5ldyBTZXQoWydNYXNzIChwZyknLCAnVGltZSAoaCknLCAnTWFzc19ub3JtJywgJ1RyYWNrIExlbmd0aCcsICdBdmcuIE1hc3MgKHBnKScsICdHcm93dGggUmF0ZScsICdFeHBvbmVudGlhbCBHcm93dGggQ29uc3RhbnQnXSk7XG5cblx0XHRjb25zdCBtYXhEZWZhdWx0TWF0cml4U2l6ZSA9IDE1XG5cdFx0dGhpcy5fc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucyA9IFtdO1xuXHRcdGZvciAobGV0IFtyb3dJbmRleCwgYXR0cjFdIG9mIHRoaXMucG9pbnRDb2xsZWN0aW9uLmF0dHJpYnV0ZUxpc3QuZW50cmllcygpKVxuXHRcdHtcblx0XHRcdHRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFucy5wdXNoKHJvd0luZGV4IDwgbWF4RGVmYXVsdE1hdHJpeFNpemUgJiYgZGVmYXVsdEluY2x1ZGVkLmhhcyhhdHRyMSkpO1xuXHRcdFx0bGV0IHJvdzogYm9vbFdpdGhJbmRleFtdID0gW107XG5cdFx0XHRmb3IgKGxldCBbY29sSW5kZXgsIGF0dHIyXSBvZiB0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0LmVudHJpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0cm93LnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBhdHRyMSA9PT0gYXR0cjIsXG5cdFx0XHRcdFx0aW5kZXg6IFtyb3dJbmRleCwgY29sSW5kZXhdXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMucHVzaChyb3cpO1xuXHRcdH1cblx0XHR0aGlzLmRyYXdCYXNpc1NlbGVjdCgpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3QmFzaXNTZWxlY3QoKTogdm9pZFxuXHR7XG5cdFx0bGV0IHRoaXNXaWRnZXQgPSB0aGlzO1xuXHRcdGxldCBmbGF0RGF0YSA9IHRoaXMuZ2V0U2NhdHRlck9wdGlvbnNNYXRyaXgoKTtcblx0XHR0aGlzLmJhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uXG5cdFx0XHQuc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHQuZGF0YSh0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0KVxuXHRcdFx0LmpvaW4oXCJidXR0b25cIilcblx0XHRcdC50ZXh0KGQgPT4gZClcblx0XHRcdC5hdHRyKCd0aXRsZScsIGQgPT4gZClcblx0XHRcdC5jbGFzc2VkKFwidG9nZ2xlQnV0dG9uXCIsIHRydWUpXG5cdFx0XHQuY2xhc3NlZChcIm9uXCIsIChkLCBpKSA9PiB0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbaV0pXG5cdFx0XHQuYXR0cihcImlkXCIsIGQgPT4gXCJNZXRyaWNEaXN0cmlidXRpb25XaWRnZXQtdmFyU2VsZWN0LVwiICsgZClcblx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbihkLCBpKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYnV0dG9uU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRsZXQgdHVybk9uID0gIXRoaXNXaWRnZXQuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tpXTtcblx0XHRcdFx0YnV0dG9uU2VsZWN0LmNsYXNzZWQoXCJvblwiLCB0dXJuT24pO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbaV0gPSB0dXJuT247XG5cdFx0XHRcdHRoaXNXaWRnZXQuZHJhd1NjYXR0ZXJQbG90U2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uKCk7XG5cdFx0XHRcdHRoaXNXaWRnZXQuZHJhd01hdHJpeEF4aXMoKTtcblx0XHRcdFx0dGhpc1dpZGdldC51cGRhdGVIaXN0b2dyYW1zKCk7XG5cdFx0XHRcdHRoaXNXaWRnZXQudXBkYXRlU2NhdHRlclBsb3RzKGZsYXREYXRhKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3TWF0cml4QXhpcygpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBidXR0b25XaWR0aCA9IDgwO1xuXHRcdGNvbnN0IGJ1dHRvbkhlaWdodCA9IDE4O1xuXHRcdGxldCBvcHRpb25zID0gdGhpcy5nZXRDdXJyZW50T3B0aW9ucygpO1xuXHRcdHRoaXMueUF4aXNNYXRyaXhTZWxlY3Quc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHQuZGF0YShvcHRpb25zKVxuXHRcdCAgLmpvaW4oXCJidXR0b25cIilcblx0XHRcdC5jbGFzc2VkKCdheGlzQnV0dG9uJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCd5JywgdHJ1ZSlcblx0XHRcdC5hdHRyKFwic3R5bGVcIiwgKGQsIGkpID0+IGBcblx0XHRcdFx0d2lkdGg6ICR7YnV0dG9uV2lkdGh9cHg7XG5cdFx0XHRcdGhlaWdodDogJHtidXR0b25IZWlnaHR9cHg7YClcblx0XHRcdC50ZXh0KGQgPT4gZClcblx0XHRcdC5hdHRyKCd0aXRsZScsIGQgPT4gZClcblx0XHRcdC5vbihcImNsaWNrXCIsIChkKSA9PiB7XG5cdFx0XHRcdGxldCByb3dJbmRleCA9IHRoaXMuYXR0cmlidXRlVG9JbmRleC5nZXQoZCk7XG5cdFx0XHRcdGxldCByb3c6IGJvb2xXaXRoSW5kZXhbXSA9IHRoaXMuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFuc1tyb3dJbmRleF07XG5cdFx0XHRcdGxldCBhbGxUcnVlID0gdHJ1ZTtcblx0XHRcdFx0Zm9yIChsZXQgY2VsbCBvZiByb3cpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAodGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2NlbGwuaW5kZXhbMV1dKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmICghY2VsbC52YWx1ZSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0YWxsVHJ1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2VsbC52YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhbGxUcnVlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Zm9yIChsZXQgY2VsbCBvZiByb3cpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tjZWxsLmluZGV4WzFdXSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y2VsbC52YWx1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuYWZ0ZXJNdWx0aXBsZU1hdHJpeENoYW5nZXMoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKGQpXG5cdFx0XHR7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwiaG92ZXJlZFwiLCB0cnVlKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKGQpXG5cdFx0XHR7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwiaG92ZXJlZFwiLCBmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdC8vIGFkZCB0cmlhbmdsZSBxdWljayBzZWxlY3RzXG5cdFx0Y29uc3QgdHJpYW5nbGVCdXR0b25TdmcgPSB0aGlzLnlBeGlzTWF0cml4U2VsZWN0LnNlbGVjdEFsbCgnc3ZnJylcblx0XHRcdC5kYXRhKFs0Ml0pXG5cdFx0XHQuam9pbignc3ZnJylcblx0XHRcdC5hdHRyKCd3aWR0aCcsIGJ1dHRvbldpZHRoKVxuXHRcdFx0LmF0dHIoJ2hlaWdodCcsIGJ1dHRvbldpZHRoKVxuXHRcdFx0LmNsYXNzZWQoJ3RyaWFuZ2xlUXVpY2tTZWxlY3QnLCB0cnVlKVxuXHRcdFx0LnJhaXNlKCk7XG5cblxuXHRcdGNvbnN0IHRyaWFuZ2xlUGFkID0gNDtcblx0XHRjb25zdCB0cmlhbmdsZVNjYWxlID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0LmRvbWFpbihbMCwgMV0pXG5cdFx0XHQucmFuZ2UoW3RyaWFuZ2xlUGFkLCBidXR0b25XaWR0aCAtIHRyaWFuZ2xlUGFkXSlcblxuXHRcdGNvbnN0IGdhcCA9IDAuMDU7XG5cdFx0Y29uc3QgdXBwZXJUcmlhbmdsZVBvaW50czogW251bWJlciwgbnVtYmVyXVtdID0gW1tnYXAsIDBdLCBbMSwgMF0sIFsxLCAxIC0gZ2FwXSwgW2dhcCwgMF1dO1xuXHRcdGNvbnN0IGxvd2VyVHJpYW5nbGVQb2ludHM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtbMCwgZ2FwXSwgWzEgLSBnYXAsIDFdLCBbMCwgMV0sIFswLCBnYXBdXTtcblxuXHRcdGNvbnN0IGxpbmUgPSBkMy5saW5lPFtudW1iZXIsIG51bWJlcl0+KClcblx0XHRcdC54KGQgPT4gdHJpYW5nbGVTY2FsZShkWzBdKSlcblx0XHRcdC55KGQgPT4gdHJpYW5nbGVTY2FsZShkWzFdKSk7XG5cblx0XHR0cmlhbmdsZUJ1dHRvblN2Zy5zZWxlY3RBbGwoJ3BhdGgnKVxuXHRcdFx0LmRhdGEoW3VwcGVyVHJpYW5nbGVQb2ludHMsIGxvd2VyVHJpYW5nbGVQb2ludHNdKVxuXHRcdFx0LmpvaW4oJ3BhdGgnKVxuXHRcdFx0LmF0dHIoJ2QnLCBkID0+IGxpbmUoZCkpXG5cdFx0XHQuY2xhc3NlZCgndHJpYW5nbGVCdXR0b24nLCB0cnVlKVxuXHRcdFx0Lm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZCkgXG5cdFx0XHR7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKGQpIFxuXHRcdFx0e1xuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdjbGljaycsIChkLCBpKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0aWYgKGkgPT0gMClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMudG9nZ2xlVXBwZXJUcmlhbmdsZSgpO1xuXHRcdFx0XHRcdHRoaXMuYWZ0ZXJNdWx0aXBsZU1hdHJpeENoYW5nZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnRvZ2dsZUxvd2VyVHJpYW5nbGUoKTtcblx0XHRcdFx0XHR0aGlzLmFmdGVyTXVsdGlwbGVNYXRyaXhDaGFuZ2VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0Y29uc3QgaGFsZldpZHRoID0gYnV0dG9uV2lkdGggLyAyOyBcblx0XHRjb25zdCByb3RhdGUgPSAtOTA7XG5cdFx0Y29uc3QgdGhldGEgPSBNYXRoLlBJICogcm90YXRlIC8gMTgwO1xuXHRcdGNvbnN0IHhPZmZzZXQgPSAtMC41ICogKGJ1dHRvbldpZHRoICsgYnV0dG9uV2lkdGggKiBNYXRoLmNvcygtdGhldGEpICsgYnV0dG9uSGVpZ2h0ICogTWF0aC5zaW4oLXRoZXRhKSk7XG5cdFx0Y29uc3QgeU9mZnNldCA9IDAuNSAqIChidXR0b25XaWR0aCAqIE1hdGguc2luKC10aGV0YSkgKyBidXR0b25IZWlnaHQgKiBNYXRoLmNvcygtdGhldGEpIC0gYnV0dG9uSGVpZ2h0KTtcblxuXHRcdGxldCB0aGV0YTIgPSA5MCArIHJvdGF0ZTtcblx0XHR0aGV0YTIgPSBNYXRoLlBJICogdGhldGEyIC8gMTgwO1xuXHRcdGNvbnN0IGhvcml6b250YWxQYWRkaW5nID0gMjtcblx0XHRsZXQgc3RlcFNpemUgPSBob3Jpem9udGFsUGFkZGluZyArIGJ1dHRvbkhlaWdodCAvIE1hdGguY29zKHRoZXRhMik7XG5cblxuXHRcdHRoaXMueEF4aXNNYXRyaXhTZWxlY3Quc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHQuZGF0YShvcHRpb25zKVxuXHRcdCAgLmpvaW4oXCJidXR0b25cIilcblx0XHRcdC5jbGFzc2VkKCdheGlzQnV0dG9uJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCd4JywgdHJ1ZSlcblx0XHRcdC5hdHRyKFwic3R5bGVcIiwgKGQsIGkpID0+IGBcblx0XHRcdFx0d2lkdGg6ICR7YnV0dG9uV2lkdGh9cHg7XG5cdFx0XHRcdGhlaWdodDogJHtidXR0b25IZWlnaHR9cHg7XG5cdFx0XHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlKCAke3N0ZXBTaXplICogKGkgKyAxKSArIHhPZmZzZXR9cHgsICR7eU9mZnNldH1weCkgcm90YXRlKCR7cm90YXRlfWRlZyk7YClcblx0XHRcdC50ZXh0KGQgPT4gZClcblx0XHRcdC5hdHRyKCd0aXRsZScsIGQgPT4gZClcblx0XHRcdC5vbihcImNsaWNrXCIsIChkKSA9PiB7XG5cdFx0XHRcdGxldCBjb2xJbmRleCA9IHRoaXMuYXR0cmlidXRlVG9JbmRleC5nZXQoZCk7XG5cdFx0XHRcdGxldCBhbGxUcnVlID0gdHJ1ZTtcblx0XHRcdFx0Zm9yIChsZXQgcm93IG9mIHRoaXMuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFucylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAobGV0IGNlbGwgb2Ygcm93KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxldCBjZWxsUm93SW5kZXggPSBjZWxsLmluZGV4WzBdO1xuXHRcdFx0XHRcdFx0bGV0IGNlbGxDb2xJbmRleCA9IGNlbGwuaW5kZXhbMV07XG5cblx0XHRcdFx0XHRcdGlmIChjb2xJbmRleCA9PT0gY2VsbENvbEluZGV4ICYmIHRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tjZWxsUm93SW5kZXhdKVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRpZiAoIWNlbGwudmFsdWUpXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRhbGxUcnVlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y2VsbC52YWx1ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFsbFRydWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGxldCByb3cgb2YgdGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGNlbGwgb2Ygcm93KVxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRsZXQgY2VsbFJvd0luZGV4ID0gY2VsbC5pbmRleFswXTtcblx0XHRcdFx0XHRcdFx0bGV0IGNlbGxDb2xJbmRleCA9IGNlbGwuaW5kZXhbMV07XG5cblx0XHRcdFx0XHRcdFx0aWYgKGNvbEluZGV4ID09PSBjZWxsQ29sSW5kZXggJiYgdGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2NlbGxSb3dJbmRleF0pXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRjZWxsLnZhbHVlID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuYWZ0ZXJNdWx0aXBsZU1hdHJpeENoYW5nZXMoKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKGQpXG5cdFx0XHR7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwiaG92ZXJlZFwiLCB0cnVlKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uKGQpXG5cdFx0XHR7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwiaG92ZXJlZFwiLCBmYWxzZSk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgdG9nZ2xlVXBwZXJUcmlhbmdsZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnRvZ2dsZVRyaWFuZ2xlKHRydWUpO1xuXHR9XG5cblx0cHJpdmF0ZSB0b2dnbGVMb3dlclRyaWFuZ2xlKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMudG9nZ2xlVHJpYW5nbGUoZmFsc2UpO1xuXHR9XG5cblx0cHJpdmF0ZSB0b2dnbGVUcmlhbmdsZSh1cHBlcjogYm9vbGVhbik6IHZvaWRcblx0e1xuXG5cdFx0bGV0IGFsbFRydWUgPSB0cnVlO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdGlmICghdGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2ldKVxuXHRcdFx0e1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGxldCByb3c6IGJvb2xXaXRoSW5kZXhbXSA9IHRoaXMuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFuc1tpXTtcblx0XHRcdGxldCBsb3c6IG51bWJlcjtcblx0XHRcdGxldCBoaWdoOiBudW1iZXI7XG5cdFx0XHRpZiAodXBwZXIpXG5cdFx0XHR7XG5cdFx0XHRcdGxvdyA9IGkgKyAxO1xuXHRcdFx0XHRoaWdoID0gcm93Lmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0bG93ID0gMDtcblx0XHRcdFx0aGlnaCA9IGk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBqID0gbG93OyBqIDwgaGlnaDsgaisrKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIXRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tqXSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghcm93W2pdLnZhbHVlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YWxsVHJ1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWFsbFRydWUpXG5cdFx0XHR7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IG5ld1ZhbHVlID0gIWFsbFRydWU7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMubGVuZ3RoOyBpKyspXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbaV0pXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0bGV0IHJvdzogYm9vbFdpdGhJbmRleFtdID0gdGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zW2ldO1xuXHRcdFx0bGV0IGxvdzogbnVtYmVyO1xuXHRcdFx0bGV0IGhpZ2g6IG51bWJlcjtcblx0XHRcdGlmICh1cHBlcilcblx0XHRcdHtcblx0XHRcdFx0bG93ID0gaSArIDE7XG5cdFx0XHRcdGhpZ2ggPSByb3cubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRsb3cgPSAwO1xuXHRcdFx0XHRoaWdoID0gaTtcblx0XHRcdH1cblx0XHRcdGZvciAobGV0IGogPSBsb3c7IGogPCBoaWdoOyBqKyspXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbal0pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyb3dbal0udmFsdWUgPSBuZXdWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgZ2V0Q3VycmVudE9wdGlvbnMoKTogc3RyaW5nW11cblx0e1xuXHRcdHJldHVybiB0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0LmZpbHRlcigoZCwgaSkgPT4gdGhpcy5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2ldKTtcblx0fVxuXG5cdHByaXZhdGUgYWZ0ZXJNdWx0aXBsZU1hdHJpeENoYW5nZXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy51cGRhdGVNYXRyaXhDZWxsU2VsZWN0aW9ucygpO1xuXHRcdGxldCBmbGF0RGF0YSA9IHRoaXMuZ2V0U2NhdHRlck9wdGlvbnNNYXRyaXgoKVxuXHRcdHRoaXMudXBkYXRlSGlzdG9ncmFtcygpO1xuXHRcdHRoaXMudXBkYXRlU2NhdHRlclBsb3RzKGZsYXREYXRhKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlTWF0cml4Q2VsbFNlbGVjdGlvbnMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5zY2F0dGVyUGxvdFNlbGVjdENvbnRhaW5lclNlbGVjdGlvblxuXHRcdFx0LnNlbGVjdEFsbChcImRpdlwiKVxuXHRcdFx0LmRhdGEodGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zKVxuXHRcdCAgLmpvaW4oXCJkaXZcIilcblx0XHRcdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdC5kYXRhKGQgPT4gZClcblx0XHQgIC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0ICBcdC5jbGFzc2VkKFwib25cIiwgZD0+IGQudmFsdWUpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3U2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24oKTogdm9pZFxuXHR7XG5cdFx0bGV0IHRoaXNXaWRnZXQgPSB0aGlzO1xuXHRcdGxldCBmbGF0RGF0YSA9IHRoaXMuZ2V0U2NhdHRlck9wdGlvbnNNYXRyaXgoKTtcblx0XHR0aGlzLnNjYXR0ZXJQbG90U2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uXG5cdFx0XHQuc2VsZWN0QWxsKFwiZGl2XCIpXG5cdFx0XHQuZGF0YSh0aGlzLnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnMpXG5cdFx0ICAuam9pbihcImRpdlwiKVxuXHRcdFx0LmNsYXNzZWQoXCJyb3dDb250YWluZXJcIiwgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKFwibm9EaXNwXCIsIChkLCBpKSA9PiAhdGhpc1dpZGdldC5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2ldIClcblx0XHRcdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdC5kYXRhKGQgPT4gZClcblx0XHQgIC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0ICBcdC5jbGFzc2VkKFwic3F1YXJlQnV0dG9uXCIsIHRydWUpXG5cdFx0ICBcdC5jbGFzc2VkKFwib25cIiwgZD0+IGQudmFsdWUpXG5cdFx0ICBcdC5jbGFzc2VkKFwibm9EaXNwXCIsIChkLCBpKSA9PiAhdGhpc1dpZGdldC5iYXNpc1NlbGVjdGlvbkJvb2xlYW5zW2ldKVxuXHRcdFx0LmF0dHIoXCJpZFwiLCBkID0+IFwiTWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0LXNjYXR0ZXJTZWxlY3QtXCIgKyBkLmluZGV4WzBdICsgXCItXCIgKyBkLmluZGV4WzFdKVxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCwgaSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IGJ1dHRvblNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzKTtcblx0XHRcdFx0bGV0IHR1cm5PbiA9ICFkLnZhbHVlO1xuXHRcdFx0XHRidXR0b25TZWxlY3QuY2xhc3NlZChcIm9uXCIsIHR1cm5Pbik7XG5cdFx0XHRcdHRoaXNXaWRnZXQuc2NhdHRlcnBsb3RTZWxlY3Rpb25Cb29sZWFuc1tkLmluZGV4WzBdXVtpXS52YWx1ZSA9IHR1cm5Pbjtcblx0XHRcdFx0aWYgKGkgPT09IGQuaW5kZXhbMF0pXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzV2lkZ2V0LnVwZGF0ZUhpc3RvZ3JhbXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzV2lkZ2V0LnVwZGF0ZVNjYXR0ZXJQbG90cyhmbGF0RGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQub24oXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uIChkKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgW3Jvd0lkeCwgY29sSWR4XSA9IGQuaW5kZXg7XG5cdFx0XHRcdGxldCBidXR0b25TZWxlY3QgPSBkMy5zZWxlY3QodGhpcyk7XG5cdFx0XHRcdGJ1dHRvblNlbGVjdC5jbGFzc2VkKFwiaG92ZXJlZFwiLCB0cnVlKTtcblx0XHRcdFx0bGV0IG9wdGlvbnMgPSB0aGlzV2lkZ2V0LmdldEN1cnJlbnRPcHRpb25zKCk7XG5cdFx0XHRcdGxldCByb3dOYW1lID0gdGhpc1dpZGdldC5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdFtyb3dJZHhdO1xuXHRcdFx0XHRsZXQgY29sTmFtZSA9IHRoaXNXaWRnZXQucG9pbnRDb2xsZWN0aW9uLmF0dHJpYnV0ZUxpc3RbY29sSWR4XTtcblx0XHRcdFx0dGhpc1dpZGdldC55QXhpc01hdHJpeFNlbGVjdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdFx0XHQuZGF0YShvcHRpb25zKVxuXHRcdFx0XHRcdC5jbGFzc2VkKFwiaG92ZXJlZFwiLCBkID0+IGQgPT09IHJvd05hbWUpO1xuXG5cdFx0XHRcdHRoaXNXaWRnZXQueEF4aXNNYXRyaXhTZWxlY3Quc2VsZWN0QWxsKFwiYnV0dG9uXCIpXG5cdFx0XHRcdFx0LmRhdGEob3B0aW9ucylcblx0XHRcdFx0XHQuY2xhc3NlZChcImhvdmVyZWRcIiwgZCA9PiBkID09PSBjb2xOYW1lKTtcblx0XHRcdH0pXG5cdFx0XHQub24oXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uIChkKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYnV0dG9uU2VsZWN0ID0gZDMuc2VsZWN0KHRoaXMpO1xuXHRcdFx0XHRidXR0b25TZWxlY3QuY2xhc3NlZChcImhvdmVyZWRcIiwgZmFsc2UpO1xuXG5cdFx0XHRcdGxldCBvcHRpb25zID0gdGhpc1dpZGdldC5nZXRDdXJyZW50T3B0aW9ucygpO1xuXHRcdFx0XHR0aGlzV2lkZ2V0LnlBeGlzTWF0cml4U2VsZWN0LnNlbGVjdEFsbChcImJ1dHRvblwiKVxuXHRcdFx0XHRcdC5kYXRhKG9wdGlvbnMpXG5cdFx0XHRcdFx0LmNsYXNzZWQoXCJob3ZlcmVkXCIsIGZhbHNlKTtcblxuXHRcdFx0XHR0aGlzV2lkZ2V0LnhBeGlzTWF0cml4U2VsZWN0LnNlbGVjdEFsbChcImJ1dHRvblwiKVxuXHRcdFx0XHRcdC5kYXRhKG9wdGlvbnMpXG5cdFx0XHRcdFx0LmNsYXNzZWQoXCJob3ZlcmVkXCIsIGZhbHNlKTtcblx0XHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3SGlzdG9ncmFtcygpOiB2b2lkXG5cdHtcblx0XHRsZXQgdGhpc1dpZGdldCA9IHRoaXM7XG5cdFx0dGhpcy5faGlzdG9ncmFtV2lkZ2V0cyA9IFtdO1xuXG5cdFx0bGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLmRpc3RyaWJ1dGlvblBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnBhcmVudEVsZW1lbnQ7XG5cdFx0cGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibm9EaXNwXCIpO1xuXG5cblx0XHR0aGlzLmRpc3RyaWJ1dGlvblBsb3RDb250YWluZXJTZWxlY3Rpb24uaHRtbChudWxsKVxuXHRcdFx0LmNsYXNzZWQoXCJub0Rpc3BcIiwgZmFsc2UpXG5cdFx0XHQuc2VsZWN0QWxsKFwiZGl2XCIpXG5cdFx0XHQuZGF0YSh0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0KVxuXHRcdCAgLmpvaW4oXCJkaXZcIilcblx0XHRcdC5jbGFzc2VkKFwiaGlzdG9ncmFtQ29udGFpbmVyXCIsIHRydWUpXG5cdFx0XHQuYXR0cihcImlkXCIsIGQgPT4gXCJNZXRyaWNEaXN0cmlidXRpb25XaWRnZXQtaGlzdG9ncmFtQ29udGFpbmVyLVwiICsgZClcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBjb250YWluZXIgPSB0aGlzIGFzIEhUTUxEaXZFbGVtZW50O1xuXHRcdFx0XHRjb25zdCBjYW5CcnVzaCA9IHRydWU7XG5cdFx0XHRcdGxldCBuZXdXaWRnZXQgPSBuZXcgSGlzdG9ncmFtV2lkZ2V0KGNvbnRhaW5lciwgZCwgY2FuQnJ1c2gsIHRoaXNXaWRnZXQuaW5jbHVkZUV4ZW1wbGFyVHJhY2tCdXR0b24pO1xuXHRcdFx0XHR0aGlzV2lkZ2V0Lmhpc3RvZ3JhbVdpZGdldHMucHVzaChuZXdXaWRnZXQpO1xuXHRcdFx0fSk7XG5cdFx0dGhpcy51cGRhdGVIaXN0b2dyYW1zKCk7XG5cdH1cblxuXHRcblx0cHJpdmF0ZSB1cGRhdGVIaXN0b2dyYW1zKCk6IHZvaWRcblx0e1xuXHRcdGxldCB0aGlzV2lkZ2V0ID0gdGhpcztcblx0XHRsZXQgYWxsSGlkZGVuID0gdHJ1ZTtcblx0XHR0aGlzLmRpc3RyaWJ1dGlvblBsb3RDb250YWluZXJTZWxlY3Rpb25cblx0XHRcdC5zZWxlY3RBbGwoXCIuaGlzdG9ncmFtQ29udGFpbmVyXCIpXG5cdFx0XHQuZGF0YSh0aGlzLnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0KVxuXHRcdFx0LmNsYXNzZWQoXCJub0Rpc3BcIiwgKGQsIGkpID0+IFxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgc2hvdWxkSGlkZSA9IHRoaXMuc2hvdWxkSGlkZShpKTtcblx0XHRcdFx0aWYgKCFzaG91bGRIaWRlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YWxsSGlkZGVuID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNob3VsZEhpZGU7XG5cdFx0XHR9KVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IGNvbnRhaW5lciA9IHRoaXMgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdFx0XHRcdGxldCBoaXN0b2dyYW1XaWRnZXQgPSB0aGlzV2lkZ2V0Lmhpc3RvZ3JhbVdpZGdldHNbaV07XG5cdFx0XHRcdGlmICghdGhpc1dpZGdldC5zaG91bGRIaWRlKGkpICYmICFoaXN0b2dyYW1XaWRnZXQuZGF0YSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGhpc3RvZ3JhbVdpZGdldC5TZXREYXRhKHRoaXNXaWRnZXQucG9pbnRDb2xsZWN0aW9uKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdGxldCBwYXJlbnRFbGVtZW50ID0gdGhpcy5kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5wYXJlbnRFbGVtZW50O1xuXHRcdGlmIChhbGxIaWRkZW4pXG5cdFx0e1xuXHRcdFx0cGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibm9EaXNwXCIpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0cGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibm9EaXNwXCIpO1xuXHRcdH1cblx0fVxuXG5cblxuXHRwcml2YXRlIGdldFNjYXR0ZXJPcHRpb25zTWF0cml4KCk6IGJvb2xXaXRoSW5kZXhbXVxuXHR7XG5cdFx0bGV0IGZsYXREYXRhID0gdGhpcy5zY2F0dGVycGxvdFNlbGVjdGlvbkJvb2xlYW5zLmZsYXQoKTtcblx0XHRmbGF0RGF0YSA9IGZsYXREYXRhLmZpbHRlcihkID0+IGQuaW5kZXhbMF0gIT09IGQuaW5kZXhbMV0pO1xuXHRcdHJldHVybiBmbGF0RGF0YTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd1NjYXR0ZXJQbG90cyhmbGF0RGF0YTogYm9vbFdpdGhJbmRleFtdKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fc2NhdHRlclBsb3RXaWRnZXRzID0gW107XG5cdFx0bGV0IHRoaXNXaWRnZXQgPSB0aGlzO1xuXG5cdFx0bGV0IHBhcmVudEVsZW1lbnQgPSB0aGlzLnNjYXR0ZXJQbG90Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5wYXJlbnRFbGVtZW50O1xuXHRcdHBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm5vRGlzcFwiKTtcblxuXHRcdHRoaXMuc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24uaHRtbChudWxsKVxuXHRcdFx0LnNlbGVjdEFsbChcImRpdlwiKVxuXHRcdFx0LmRhdGEoZmxhdERhdGEpXG5cdFx0XHQuam9pbihcImRpdlwiKVxuXHRcdFx0LmNsYXNzZWQoXCJzY2F0dGVyUGxvdENvbnRhaW5lclwiLCB0cnVlKVxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZClcblx0XHRcdHtcblx0XHRcdFx0bGV0IGNvbnRhaW5lciA9IHRoaXMgYXMgSFRNTERpdkVsZW1lbnQ7XG5cdFx0XHRcdGxldCB4S2V5ID0gdGhpc1dpZGdldC5wb2ludENvbGxlY3Rpb24uYXR0cmlidXRlTGlzdFtkLmluZGV4WzFdXTtcblx0XHRcdFx0bGV0IHlLZXkgPSB0aGlzV2lkZ2V0LnBvaW50Q29sbGVjdGlvbi5hdHRyaWJ1dGVMaXN0W2QuaW5kZXhbMF1dO1xuXHRcdFx0XHRsZXQgbmV3V2lkZ2V0ID0gbmV3IFNjYXR0ZXJQbG90V2lkZ2V0KGNvbnRhaW5lciwgeEtleSwgeUtleSk7XG5cdFx0XHRcdHRoaXNXaWRnZXQuc2NhdHRlclBsb3RXaWRnZXRzLnB1c2gobmV3V2lkZ2V0KTtcblx0XHRcdH0pO1xuXHRcdHRoaXMudXBkYXRlU2NhdHRlclBsb3RzKGZsYXREYXRhKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlU2NhdHRlclBsb3RzKGZsYXREYXRhOiBib29sV2l0aEluZGV4W10pOiB2b2lkXG5cdHtcblx0XHRsZXQgdGhpc1dpZGdldCA9IHRoaXM7XG5cblx0XHRsZXQgYWxsSGlkZGVuID0gdHJ1ZTtcblxuXHRcdHRoaXMuc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb25cblx0XHRcdC5zZWxlY3RBbGwoXCIuc2NhdHRlclBsb3RDb250YWluZXJcIilcblx0XHRcdC5kYXRhKGZsYXREYXRhKVxuXHRcdFx0LmNsYXNzZWQoXCJub0Rpc3BcIiwgKGQpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGxldCBzaG91bGRIaWRlID0gdGhpcy5zaG91bGRIaWRlKGQpO1xuXHRcdFx0XHRpZiAoIXNob3VsZEhpZGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhbGxIaWRkZW4gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2hvdWxkSGlkZTtcblx0XHRcdH0pXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgc2NhdHRlcldpZGdldCA9IHRoaXNXaWRnZXQuc2NhdHRlclBsb3RXaWRnZXRzW2ldO1xuXHRcdFx0XHRpZiAoIXRoaXNXaWRnZXQuc2hvdWxkSGlkZShkKSAmJiAhc2NhdHRlcldpZGdldC5kYXRhKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0c2NhdHRlcldpZGdldC5TZXREYXRhKHRoaXNXaWRnZXQucG9pbnRDb2xsZWN0aW9uKVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRsZXQgcGFyZW50RWxlbWVudCA9IHRoaXMuc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnBhcmVudEVsZW1lbnQ7XG5cdFx0aWYgKGFsbEhpZGRlbilcblx0XHR7XG5cdFx0XHRwYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJub0Rpc3BcIik7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRwYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJub0Rpc3BcIik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBzaG91bGRIaWRlKGQ6IGJvb2xXaXRoSW5kZXggfCBudW1iZXIpOiBib29sZWFuXG5cdHtcblx0XHRpZiAodHlwZW9mIGQgPT09IFwibnVtYmVyXCIpXG5cdFx0e1xuXHRcdFx0aWYgKCF0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbZF0pXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICF0aGlzLnNjYXR0ZXJwbG90U2VsZWN0aW9uQm9vbGVhbnNbZF1bZF0udmFsdWU7XG5cblx0XHR9XG5cdFx0aWYgKCF0aGlzLmJhc2lzU2VsZWN0aW9uQm9vbGVhbnNbZC5pbmRleFswXV0gfHwgIXRoaXMuYmFzaXNTZWxlY3Rpb25Cb29sZWFuc1tkLmluZGV4WzFdXSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuICFkLnZhbHVlO1xuXHR9XG5cblx0cHJvdGVjdGVkIE9uUmVzaXplKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMucmVzaXplU3ViQ29tcG9uZW50cygpO1xuXHR9XG5cblx0cHJpdmF0ZSByZXNpemVTdWJDb21wb25lbnRzKCk6IHZvaWRcblx0e1xuXHRcdC8vIHRoaXMubGF5b3V0RnJhbWV3b3JrLmNvbnRhaW5lci5jaGlsXG5cdFx0Ly8gdGhpcy5iYXNpc1NlbGVjdENvbnRhaW5lclNlbGVjdGlvbi5ub2RlKCkuc3R5bGUubWF4SGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCJcblx0XHQvLyB0aGlzLmJhc2lzU2VsZWN0Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIlxuXHRcdC8vIHRoaXMuc2NhdHRlclBsb3RTZWxlY3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1heEhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiXG5cdFx0Ly8gdGhpcy5kaXN0cmlidXRpb25QbG90Q29udGFpbmVyU2VsZWN0aW9uLm5vZGUoKS5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIlxuXHRcdHRoaXMuc2NhdHRlclBsb3RDb250YWluZXJTZWxlY3Rpb24ubm9kZSgpLnN0eWxlLm1heEhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiXG5cdH1cblxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IEJ1dHRvblByb3BzLCBIdG1sU2VsZWN0aW9uIH0gZnJvbSAnLi4vZGV2bGliL0RldkxpYlR5cGVzJztcblxuZW51bSBPcHRpb25Nb2RlIHtcblx0QnV0dG9uTGlzdCxcblx0RHJvcGRvd25cbn1cblxuZXhwb3J0IGNsYXNzIE9wdGlvblNlbGVjdCB7XG5cdFxuXHRjb25zdHJ1Y3RvcihodG1sQ29udGFpbmVySWQ6IHN0cmluZywgbGFiZWw/OiBzdHJpbmcsIGRlZmF1bHRTZWxlY3Rpb25JbmRleD86IG51bWJlcilcblx0e1xuXHRcdHRoaXMuX2NvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdChcIiNcIiArIGh0bWxDb250YWluZXJJZCk7XG5cdFx0dGhpcy5fbGFiZWwgPSBsYWJlbDtcblx0XHR0aGlzLl91bmlxdWVJZCA9ICdPcHRpb25TZWxlY3REcm9wZG93bl8nICsgT3B0aW9uU2VsZWN0Ll9pbnN0YW5jZUNvdW50Kys7XG5cdFx0dGhpcy5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gbnVsbDtcblx0XHRpZiAodHlwZW9mIGRlZmF1bHRTZWxlY3Rpb25JbmRleCAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gZGVmYXVsdFNlbGVjdGlvbkluZGV4O1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgX2RhdGEgOiBCdXR0b25Qcm9wc1tdO1xuXHRwdWJsaWMgZ2V0IGRhdGEoKSA6IEJ1dHRvblByb3BzW10ge1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29udGFpbmVyU2VsZWN0IDogSHRtbFNlbGVjdGlvbjtcblx0cHVibGljIGdldCBjb250YWluZXJTZWxlY3QoKSA6IEh0bWxTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXJTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9sYWJlbCA6IHN0cmluZztcblx0cHVibGljIGdldCBsYWJlbCgpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5fbGFiZWw7XG5cdH1cblxuXHRwcml2YXRlIF9tb2RlIDogT3B0aW9uTW9kZTtcblx0cHVibGljIGdldCBtb2RlKCkgOiBPcHRpb25Nb2RlIHtcblx0XHRyZXR1cm4gdGhpcy5fbW9kZTtcblx0fVxuXG5cdHByaXZhdGUgX3VuaXF1ZUlkIDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHVuaXF1ZUlkKCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl91bmlxdWVJZDtcblx0fVxuXG5cdFxuXHRwcml2YXRlIF9jdXJyZW50U2VsZWN0aW9uSW5kZXggOiBudW1iZXIgfCBudWxsO1xuXHRwdWJsaWMgZ2V0IGN1cnJlbnRTZWxlY3Rpb25JbmRleCgpIDogbnVtYmVyIHwgbnVsbCB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRTZWxlY3Rpb25JbmRleDtcblx0fVxuXHRcblx0cHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlQ291bnQ6IG51bWJlciA9IDA7XG5cblx0cHJpdmF0ZSBjbGVhclNlbGVjdGVkQnV0dG9uKCk6IHZvaWRcblx0e1xuXHRcdHRoaXMuY29udGFpbmVyU2VsZWN0LnNlbGVjdEFsbChcIi5vblwiKVxuXHRcdFx0LmNsYXNzZWQoXCJvblwiLCBmYWxzZSk7XG5cdH1cblxuXHRwdWJsaWMgb25EYXRhQ2hhbmdlKGRhdGE6IEJ1dHRvblByb3BzW10sIGRlZmF1bHRTZWxlY3Rpb24/OiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0XHRjb25zb2xlLmxvZyhkYXRhKTtcblx0XHR0aGlzLmNvbnRhaW5lclNlbGVjdC5odG1sKG51bGwpO1xuXG5cdFx0aWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDEpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMubGFiZWwpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY29udGFpbmVyU2VsZWN0XG5cdFx0XHRcdFx0LmFwcGVuZCgnc3BhbicpXG5cdFx0XHRcdFx0LmNsYXNzZWQoJ29wdGlvblNlbGVjdExhYmVsJywgdHJ1ZSlcblx0XHRcdFx0XHQudGV4dCh0aGlzLmxhYmVsKTtcblx0XHRcdH1cblx0XG5cblx0XHRcdHRoaXMuY29udGFpbmVyU2VsZWN0XG5cdFx0XHRcdC5hcHBlbmQoXCJzcGFuXCIpXG5cdFx0XHRcdC5jbGFzc2VkKFwidmFsdWVIZWFkZXJcIiwgdHJ1ZSlcblx0XHRcdFx0LnRleHQodGhpcy5kYXRhWzBdLmRpc3BsYXlOYW1lKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnVwZGF0ZUJ1dHRvbnMoZGVmYXVsdFNlbGVjdGlvbik7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUJ1dHRvbnMoZGVmYXVsdFNlbGVjdGlvbj86IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdGlmICh0eXBlb2YgZGVmYXVsdFNlbGVjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gZGVmYXVsdFNlbGVjdGlvbjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kYXRhLmxlbmd0aCA8IDQpXG5cdFx0e1xuXHRcdFx0dGhpcy5kcmF3UXVpY2tTZWxlY3RCdXR0b25zKHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4KTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuZHJhd0Ryb3BEb3duQnV0dG9ucyh0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBkcmF3UXVpY2tTZWxlY3RCdXR0b25zKGRlZmF1bHRTZWxlY3Rpb24/OiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tb2RlID0gT3B0aW9uTW9kZS5CdXR0b25MaXN0O1xuXHRcdGxldCB0aGlzT3B0aW9uU2VsZWN0OiBPcHRpb25TZWxlY3QgPSB0aGlzO1xuXHRcdHRoaXMuY29udGFpbmVyU2VsZWN0Lmh0bWwobnVsbCk7XG5cblx0XHRpZiAodGhpcy5sYWJlbClcblx0XHR7XG5cdFx0XHR0aGlzLmNvbnRhaW5lclNlbGVjdFxuXHRcdFx0XHQuYXBwZW5kKCdzcGFuJylcblx0XHRcdFx0LmNsYXNzZWQoJ29wdGlvblNlbGVjdExhYmVsJywgdHJ1ZSlcblx0XHRcdFx0LnRleHQodGhpcy5sYWJlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb250YWluZXJTZWxlY3Rcblx0XHRcdC5zZWxlY3RBbGwoXCJidXR0b25cIilcblx0XHRcdC5kYXRhKHRoaXMuZGF0YSlcblx0XHRcdC5qb2luKFwiYnV0dG9uXCIpXG5cdFx0XHQudGV4dChkID0+IGQuZGlzcGxheU5hbWUpXG5cdFx0XHQuY2xhc3NlZChcInRvZ2dsZUJ1dHRvblwiLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoXCJvblwiLCAoZCwgaSkgPT4gZGVmYXVsdFNlbGVjdGlvbiA9PT0gaSlcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGJ1dHRvblByb3BzOiBCdXR0b25Qcm9wcywgaW5kZXg6IG51bWJlcilcblx0XHRcdHtcblx0XHRcdFx0aWYgKCh0aGlzIGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoXCJvblwiKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzT3B0aW9uU2VsZWN0Ll9jdXJyZW50U2VsZWN0aW9uSW5kZXggPSBpbmRleDtcblx0XHRcdFx0dGhpc09wdGlvblNlbGVjdC5jbGVhclNlbGVjdGVkQnV0dG9uKCk7XG5cdFx0XHRcdGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKFwib25cIiwgdHJ1ZSk7XG5cdFx0XHRcdGJ1dHRvblByb3BzLmNhbGxiYWNrKCk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0Ryb3BEb3duQnV0dG9ucyhkZWZhdWx0U2VsZWN0aW9uPzogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fbW9kZSA9IE9wdGlvbk1vZGUuRHJvcGRvd247XG5cdFx0bGV0IHRoaXNPcHRpb25TZWxlY3Q6IE9wdGlvblNlbGVjdCA9IHRoaXM7XG5cdFx0dGhpcy5jb250YWluZXJTZWxlY3QuaHRtbChudWxsKTtcblxuXHRcdGlmICh0aGlzLmxhYmVsKVxuXHRcdHtcblx0XHRcdHRoaXMuY29udGFpbmVyU2VsZWN0LmFwcGVuZCgnbGFiZWwnKVxuXHRcdFx0XHQudGV4dCh0aGlzLmxhYmVsKVxuXHRcdFx0XHQuY2xhc3NlZCgnb3B0aW9uU2VsZWN0TGFiZWwnLCB0cnVlKVxuXHRcdFx0XHQuYXR0cignZm9yJywgdGhpcy51bmlxdWVJZCk7XG5cdFx0fVxuXHRcdFxuXHRcdHRoaXMuY29udGFpbmVyU2VsZWN0XG5cdFx0XHQuYXBwZW5kKCdzZWxlY3QnKVxuXHRcdFx0LmF0dHIoJ2lkJywgdGhpcy51bmlxdWVJZCkgXG5cdFx0XHQuY2xhc3NlZCgnb3B0aW9uU2VsZWN0U2VsZWN0JywgdHJ1ZSlcblx0XHRcdC5vbignY2hhbmdlJywgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0bGV0IG9wdGlvblNlbGVjdCA9IHRoaXMuY29udGFpbmVyU2VsZWN0LnNlbGVjdCgnIycgKyB0aGlzLnVuaXF1ZUlkKVxuXHRcdFx0XHRsZXQgbmV3SW5kZXg6IG51bWJlciA9ICtvcHRpb25TZWxlY3QucHJvcGVydHkoJ3ZhbHVlJyk7XG5cdFx0XHRcdHRoaXMuZGF0YVtuZXdJbmRleF0uY2FsbGJhY2soKTtcblx0XHRcdFx0dGhpc09wdGlvblNlbGVjdC5fY3VycmVudFNlbGVjdGlvbkluZGV4ID0gbmV3SW5kZXg7XG5cdFx0XHR9KVxuXHRcdFx0LnNlbGVjdEFsbCgnb3B0aW9uJylcblx0XHRcdC5kYXRhKHRoaXMuZGF0YSlcblx0XHRcdC5qb2luKCdvcHRpb24nKVxuXHRcdFx0LmF0dHIoJ3ZhbHVlJywgKGQsIGkpID0+IGkpXG5cdFx0XHQucHJvcGVydHkoJ3NlbGVjdGVkJywgKGQsIGkpID0+IGRlZmF1bHRTZWxlY3Rpb24gPT09IGkpXG5cdFx0XHQudGV4dChkID0+IGQuZGlzcGxheU5hbWUpO1xuXHR9XG5cdFxuXHRwdWJsaWMgYWRkQnV0dG9uKGJ1dHRvblByb3BzOiBCdXR0b25Qcm9wcywgc2VsZWN0SW5kZXg/OiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmRhdGEucHVzaChidXR0b25Qcm9wcyk7XG5cdFx0dGhpcy51cGRhdGVCdXR0b25zKHNlbGVjdEluZGV4KTtcblx0fVxuXG5cdHB1YmxpYyByZW1vdmVCdXR0b24oZGlzcGxheU5hbWU6IHN0cmluZywgY2FsbERlZmF1bHRDYWxsYmFjayA9IHRydWUpOiB2b2lkXG5cdHtcblx0XHRpZiAoIXRoaXMuZGF0YSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCByZW1vdmVJbmRleCA9IHRoaXMuZGF0YS5maW5kSW5kZXgoKGJ1dHRvbjogQnV0dG9uUHJvcHMpID0+IGJ1dHRvbi5kaXNwbGF5TmFtZSA9PT0gZGlzcGxheU5hbWUpO1xuXHRcdGlmIChyZW1vdmVJbmRleCA9PT0gLTEpXG5cdFx0e1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLmRhdGEuc3BsaWNlKHJlbW92ZUluZGV4KTtcblx0XHRsZXQgc2VsZWN0aW9uSW5kZXg6IG51bWJlcjtcblx0XHRpZiAoY2FsbERlZmF1bHRDYWxsYmFjayAmJiB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleCA9PT0gcmVtb3ZlSW5kZXgpXG5cdFx0e1xuXHRcdFx0c2VsZWN0aW9uSW5kZXggPSAwO1xuXHRcdFx0dGhpcy5kYXRhWzBdLmNhbGxiYWNrKCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRzZWxlY3Rpb25JbmRleCA9IHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4O1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUJ1dHRvbnMoc2VsZWN0aW9uSW5kZXgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHB1YmxpYyByZXBsYWNlQnV0dG9uKG9sZEJ1dHRvbk5hbWU6IHN0cmluZywgbmV3QnV0dG9uUHJvcHM6IEJ1dHRvblByb3BzKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5yZW1vdmVCdXR0b24ob2xkQnV0dG9uTmFtZSwgZmFsc2UpO1xuXHRcdHRoaXMuYWRkQnV0dG9uKG5ld0J1dHRvblByb3BzLCB0aGlzLmN1cnJlbnRTZWxlY3Rpb25JbmRleCk7XG5cdFx0aWYgKHRoaXMuY3VycmVudFNlbGVjdGlvbkluZGV4ID09PSB0aGlzLmRhdGEubGVuZ3RoIC0gMSlcblx0XHR7XG5cdFx0XHR0aGlzLmRhdGFbdGhpcy5jdXJyZW50U2VsZWN0aW9uSW5kZXhdLmNhbGxiYWNrKCk7XG5cdFx0fVxuXHR9XG5cdFxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7QmFzZVdpZGdldH0gZnJvbSAnLi9CYXNlV2lkZ2V0JztcbmltcG9ydCB7Q3VydmVMaXN0fSBmcm9tICcuLi9EYXRhTW9kZWwvQ3VydmVMaXN0JztcbmltcG9ydCB7UG9pbnRORH0gZnJvbSAnLi4vRGF0YU1vZGVsL1BvaW50TkQnO1xuaW1wb3J0IHtTdmdTZWxlY3Rpb24sIEh0bWxTZWxlY3Rpb24sIEJ1dHRvblByb3BzfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnO1xuaW1wb3J0IHsgdmFsdWVGaWx0ZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBPcHRpb25TZWxlY3QgfSBmcm9tICcuL09wdGlvblNlbGVjdCc7XG5pbXBvcnQgeyBEYXRhc2V0U3BlYywgRmFjZXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBEZXZsaWJUU1V0aWwgfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVFNVdGlsJztcbmltcG9ydCB7IERhdGFFdmVudHMgfSBmcm9tICcuLi9EYXRhTW9kZWwvRGF0YUV2ZW50cyc7XG5pbXBvcnQgeyBHcm91cEJ5V2lkZ2V0IH0gZnJvbSAnLi9Hcm91cEJ5V2lkZ2V0JztcblxuaW50ZXJmYWNlIHF1aWNrUGlja09wdGlvbiB7XG5cdHhLZXk6IHN0cmluZyxcblx0eUtleTogc3RyaW5nLFxuXHRhdmVyYWdlZDogYm9vbGVhbixcblx0c3F1YXJlQXNwZWN0UmF0aW86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFBsb3QyZFBhdGhzV2lkZ2V0IGV4dGVuZHMgQmFzZVdpZGdldDxDdXJ2ZUxpc3QsIERhdGFzZXRTcGVjPiB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihjb250YWluZXI6IEVsZW1lbnQsXG5cdFx0cXVpY2tQaWNrT3B0aW9uczogcXVpY2tQaWNrT3B0aW9uW10sXG5cdFx0aW5pdGlhbFF1aWNrUGlja09wdGlvbkluZGV4OiBudW1iZXIgPSAwLFxuXHRcdHNxdWFyZUFzcGVjdFJhdGlvOiBib29sZWFuID0gdHJ1ZSxcblx0XHRjYW5CcnVzaDogYm9vbGVhbiA9IHRydWUsXG5cdFx0aXNDbG9uZTogYm9vbGVhbiA9IGZhbHNlKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCB0cnVlLCBxdWlja1BpY2tPcHRpb25zLCBpbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXgsIGNhbkJydXNoKTtcblx0XHR0aGlzLl9zcXVhcmVBc3BlY3RSYXRpbyA9IHNxdWFyZUFzcGVjdFJhdGlvO1xuXHRcdHRoaXMuYWRkTGFiZWwoKTtcblx0XHR0aGlzLl9mYWNldExpc3QgPSBbXTtcblx0XHR0aGlzLl9jb2xvckxvb2t1cCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cdFx0dGhpcy5faXNDbG9uZSA9IGlzQ2xvbmU7XG5cdFx0aWYgKGlzQ2xvbmUpXG5cdFx0e1xuXHRcdFx0dGhpcy5faW5BdmVyYWdlTW9kZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5faW5GYWNldE1vZGUgPSBmYWxzZTtcblx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMuYXZlcmFnZUxlZ2VuZFNlbGVjdC5ub2RlKCkpO1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy5zZWxlY3RDb25kaXRpb25CdXR0b24pO1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy5jb21wYXJlQ29uZGl0aW9uQnV0dG9uKTtcblx0XHR9XG5cdFx0dGhpcy5zd2FwU3ZnVmlzaWJpbGl0eSgpO1xuXHRcdGlmICh0aGlzLmluQXZlcmFnZU1vZGUpXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUodGhpcy5mYWNldEJ1dHRvbik7XG5cdFx0fVxuXHR9XG5cdFxuXHRwcm90ZWN0ZWQgQ2xvbmUoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz5cbiAgICB7XG5cdFx0Y29uc3QgY2FuQnJ1c2ggPSBmYWxzZTtcblx0XHRyZXR1cm4gbmV3IFBsb3QyZFBhdGhzV2lkZ2V0KFxuXHRcdFx0Y29udGFpbmVyLFxuXHRcdFx0dGhpcy5xdWlja1BpY2tPcHRpb25zLFxuXHRcdFx0dGhpcy5xdWlja1BpY2tPcHRpb25TZWxlY3QuY3VycmVudFNlbGVjdGlvbkluZGV4LFxuXHRcdFx0dGhpcy5zcXVhcmVBc3BlY3RSYXRpbyxcblx0XHRcdGNhbkJydXNoLFxuXHRcdFx0dHJ1ZSk7XG5cdH1cblxuXHRwcml2YXRlIF9pc0Nsb25lIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpc0Nsb25lKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faXNDbG9uZTtcblx0fVxuXG5cdHByb3RlY3RlZCBpbml0UHJvcHMocHJvcHM/OiBhbnlbXSk6IHZvaWRcblx0e1xuXHRcdHN1cGVyLmluaXRQcm9wcygpO1xuXHRcdHRoaXMuX3F1aWNrUGlja09wdGlvbnMgPSBwcm9wc1swXTtcblx0XHR0aGlzLl9pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXggPSBwcm9wc1sxXTtcblx0XHRsZXQgaW5pdGlhbE9wdGlvbiA9IHRoaXMucXVpY2tQaWNrT3B0aW9uc1t0aGlzLmluaXRpYWxRdWlja1BpY2tPcHRpb25JbmRleF07XG5cdFx0dGhpcy5fY2FuQnJ1c2ggPSBwcm9wc1syXTtcblx0XHR0aGlzLl94S2V5ID0gaW5pdGlhbE9wdGlvbi54S2V5O1xuXHRcdHRoaXMuX3lLZXkgPSBpbml0aWFsT3B0aW9uLnlLZXk7XG5cdFx0dGhpcy5faW5BdmVyYWdlTW9kZSA9IGluaXRpYWxPcHRpb24uYXZlcmFnZWQ7XG5cdFx0dGhpcy5faW5GYWNldE1vZGUgPSB0cnVlO1xuXHRcdHRoaXMuX3RlbXBDb25kaXRpb25GaWx0ZXJTdGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBib29sZWFuPj4oKTtcblx0XHR0aGlzLl9zbW9vdGhDdXJ2ZXMgPSB0cnVlO1xuXHR9XG5cblx0cHJpdmF0ZSBfdGl0bGVCYXJDb250YWluZXIgOiBIdG1sU2VsZWN0aW9uO1xuICAgIHB1YmxpYyBnZXQgdGl0bGVCYXJDb250YWluZXIoKSA6IEh0bWxTZWxlY3Rpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGVCYXJDb250YWluZXI7XG4gICAgfVxuXG5cdHByaXZhdGUgX3N2Z1NlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBzdmdTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3N2Z1NlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3N2Z0ZhY2V0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHN2Z0ZhY2V0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9zdmdGYWNldFNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX21haW5Hcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBtYWluR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX21haW5Hcm91cFNlbGVjdDtcblx0fVxuXHRcblx0cHJpdmF0ZSBfbWFpbkdyb3VwRmFjZXRTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgbWFpbkdyb3VwRmFjZXRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX21haW5Hcm91cEZhY2V0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeUF4aXNGYWNldFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB5QXhpc0ZhY2V0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl95QXhpc0ZhY2V0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeEF4aXNGYWNldFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4QXhpc0ZhY2V0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94QXhpc0ZhY2V0U2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfYXZlcmFnZUxlZ2VuZFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBhdmVyYWdlTGVnZW5kU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9hdmVyYWdlTGVnZW5kU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfZmFjZXRMZWdlbmRTZWxlY3QgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgZmFjZXRMZWdlbmRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZhY2V0TGVnZW5kU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FudmFzQ29udGFpbmVyIDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGNhbnZhc0NvbnRhaW5lcigpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzQ29udGFpbmVyO1xuXHR9XHRcblxuXHRwcml2YXRlIF9jYW52YXNFbGVtZW50IDogSFRNTENhbnZhc0VsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY2FudmFzRWxlbWVudCgpIDogSFRNTENhbnZhc0VsZW1lbnQge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXNFbGVtZW50O1xuXHR9XG5cblx0cHJpdmF0ZSBfYXZlcmFnZUN1cnZlTGFiZWxDb250YWluZXIgOiBTdmdTZWxlY3Rpb247XG5cdHB1YmxpYyBnZXQgYXZlcmFnZUN1cnZlTGFiZWxDb250YWluZXIoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2F2ZXJhZ2VDdXJ2ZUxhYmVsQ29udGFpbmVyO1xuXHR9XG5cblx0cHJpdmF0ZSBfY3VycmVudEZyYW1lSW5kaWNhdG9yIDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGN1cnJlbnRGcmFtZUluZGljYXRvcigpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudEZyYW1lSW5kaWNhdG9yO1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FuQnJ1c2ggOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGNhbkJydXNoKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FuQnJ1c2g7XG5cdH1cblxuXHRwcml2YXRlIF9icnVzaEdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IGJydXNoR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF94QXhpc0dyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHhBeGlzR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3hBeGlzR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF94TGFiZWxUZXh0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHhMYWJlbFRleHRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3hMYWJlbFRleHRTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF95QXhpc0dyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHlBeGlzR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lBeGlzR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF95TGFiZWxUZXh0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHlMYWJlbFRleHRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lMYWJlbFRleHRTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9xdWlja1BpY2tDb250YWluZXJTZWxlY3QgOiBIdG1sU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHF1aWNrUGlja0NvbnRhaW5lclNlbGVjdCgpIDogSHRtbFNlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3F1aWNrUGlja0NvbnRhaW5lclNlbGVjdDtcblx0fVxuXHRwdWJsaWMgc2V0IHF1aWNrUGlja0NvbnRhaW5lclNlbGVjdCh2IDogSHRtbFNlbGVjdGlvbikge1xuXHRcdHRoaXMuX3F1aWNrUGlja0NvbnRhaW5lclNlbGVjdCA9IHY7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVggOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVYKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVg7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVZKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVk7XG5cdH1cblxuXHRwcml2YXRlIF94S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHhLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3hLZXk7XG5cdH1cblxuXHRwcml2YXRlIF95S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHlLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3lLZXk7XG5cdH1cblxuXHRwcml2YXRlIF9xdWlja1BpY2tPcHRpb25zIDogcXVpY2tQaWNrT3B0aW9uW107XG5cdHB1YmxpYyBnZXQgcXVpY2tQaWNrT3B0aW9ucygpIDogcXVpY2tQaWNrT3B0aW9uW10ge1xuXHRcdHJldHVybiB0aGlzLl9xdWlja1BpY2tPcHRpb25zO1xuXHR9XHRcblxuXHRwcml2YXRlIF9pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgaW5pdGlhbFF1aWNrUGlja09wdGlvbkluZGV4KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9pbml0aWFsUXVpY2tQaWNrT3B0aW9uSW5kZXg7XG5cdH1cblx0XG5cdHByaXZhdGUgX3F1aWNrUGlja09wdGlvblNlbGVjdCA6IE9wdGlvblNlbGVjdDtcblx0cHVibGljIGdldCBxdWlja1BpY2tPcHRpb25TZWxlY3QoKSA6IE9wdGlvblNlbGVjdCB7XG5cdFx0cmV0dXJuIHRoaXMuX3F1aWNrUGlja09wdGlvblNlbGVjdDtcblx0fVxuXG5cdHByaXZhdGUgX3NxdWFyZUFzcGVjdFJhdGlvIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBzcXVhcmVBc3BlY3RSYXRpbygpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3NxdWFyZUFzcGVjdFJhdGlvO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2ggOiBkMy5CcnVzaEJlaGF2aW9yPGFueT47XG5cdHB1YmxpYyBnZXQgYnJ1c2goKSA6IGQzLkJydXNoQmVoYXZpb3I8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2JydXNoO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9sYXN0WFZhbHVlQnJ1c2hCb3VuZCA6IFtudW1iZXIsIG51bWJlcl07XG5cdHB1YmxpYyBnZXQgbGFzdFhWYWx1ZUJydXNoQm91bmQoKSA6IFtudW1iZXIsIG51bWJlcl0ge1xuXHRcdHJldHVybiB0aGlzLl9sYXN0WFZhbHVlQnJ1c2hCb3VuZDtcblx0fVxuXG5cdHByaXZhdGUgX2xhc3RZVmFsdWVCcnVzaEJvdW5kIDogW251bWJlciwgbnVtYmVyXTtcblx0cHVibGljIGdldCBsYXN0WVZhbHVlQnJ1c2hCb3VuZCgpIDogW251bWJlciwgbnVtYmVyXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhc3RZVmFsdWVCcnVzaEJvdW5kO1xuXHR9XG5cdFxuXHRwcml2YXRlIF9pbkF2ZXJhZ2VNb2RlIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpbkF2ZXJhZ2VNb2RlKCkgOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faW5BdmVyYWdlTW9kZTtcblx0fVxuXG5cdHByaXZhdGUgX2luRmFjZXRNb2RlIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpbkZhY2V0TW9kZSgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luRmFjZXRNb2RlO1xuXHR9XG5cblx0cHJpdmF0ZSBfc21vb3RoQ3VydmVzIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBzbW9vdGhDdXJ2ZXMoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9zbW9vdGhDdXJ2ZXM7XG5cdH1cblxuXHRwcml2YXRlIF9mYWNldExpc3QgOiBGYWNldFtdO1xuXHRwdWJsaWMgZ2V0IGZhY2V0TGlzdCgpIDogRmFjZXRbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZhY2V0TGlzdDtcblx0fVxuXG5cdHByaXZhdGUgX2NvbG9yTG9va3VwIDogTWFwPHN0cmluZywgc3RyaW5nPjtcblx0cHVibGljIGdldCBjb2xvckxvb2t1cCgpIDogTWFwPHN0cmluZywgc3RyaW5nPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yTG9va3VwO1xuXHR9XHRcblxuXHRwcml2YXRlIF9mb3JjZVNpbXVsYXRpb24gOiBkMy5TaW11bGF0aW9uPGFueSwgdW5kZWZpbmVkPiA7XG5cdHB1YmxpYyBnZXQgZm9yY2VTaW11bGF0aW9uKCkgOiBkMy5TaW11bGF0aW9uPGFueSwgdW5kZWZpbmVkPiAge1xuXHRcdHJldHVybiB0aGlzLl9mb3JjZVNpbXVsYXRpb247XG5cdH1cblxuXHRwcml2YXRlIF90ZW1wQ29uZGl0aW9uRmlsdGVyU3RhdGUgOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBib29sZWFuPj47XG5cdHB1YmxpYyBnZXQgdGVtcENvbmRpdGlvbkZpbHRlclN0YXRlKCkgOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBib29sZWFuPj4ge1xuXHRcdHJldHVybiB0aGlzLl90ZW1wQ29uZGl0aW9uRmlsdGVyU3RhdGU7XG5cdH1cblxuXHRwcml2YXRlIF9taW5pQ2VsbFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBtaW5pQ2VsbFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluaUNlbGxTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9zZWxlY3RDb25kaXRpb25CdXR0b24gOiBIVE1MQnV0dG9uRWxlbWVudDtcblx0cHVibGljIGdldCBzZWxlY3RDb25kaXRpb25CdXR0b24oKSA6IEhUTUxCdXR0b25FbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0Q29uZGl0aW9uQnV0dG9uO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29tcGFyZUNvbmRpdGlvbkJ1dHRvbiA6IEhUTUxCdXR0b25FbGVtZW50O1xuXHRwdWJsaWMgZ2V0IGNvbXBhcmVDb25kaXRpb25CdXR0b24oKSA6IEhUTUxCdXR0b25FbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY29tcGFyZUNvbmRpdGlvbkJ1dHRvbjtcblx0fVx0XG5cblx0cHJvdGVjdGVkIHNldE1hcmdpbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tYXJnaW4gPSB7XG5cdFx0XHR0b3A6IDU0LFxuXHRcdFx0cmlnaHQ6IDEyMCxcblx0XHRcdGJvdHRvbTogNjIsXG5cdFx0XHRsZWZ0OiA2NFxuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCBpbml0KCk6IHZvaWRcblx0e1xuXHRcdGNvbnN0IGNvbnRhaW5lclNlbGVjdCA9IGQzLnNlbGVjdCh0aGlzLmNvbnRhaW5lcik7XG5cblx0XHR0aGlzLl90aXRsZUJhckNvbnRhaW5lciA9IGNvbnRhaW5lclNlbGVjdC5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgndGl0bGVCYXJDb250YWluZXInLCB0cnVlKTtcblxuXHRcdHRoaXMuX3N2Z1NlbGVjdCA9IGNvbnRhaW5lclNlbGVjdC5hcHBlbmQoXCJzdmdcIik7XG5cdFx0dGhpcy5fbWFpbkdyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApO1xuXG5cdFx0dGhpcy5fc3ZnRmFjZXRTZWxlY3QgPSBjb250YWluZXJTZWxlY3QuYXBwZW5kKCdzdmcnKTtcblx0XHR0aGlzLl9tYWluR3JvdXBGYWNldFNlbGVjdCA9IHRoaXMuc3ZnRmFjZXRTZWxlY3QuYXBwZW5kKCdnJylcblx0XHR0aGlzLl95QXhpc0ZhY2V0U2VsZWN0ID0gdGhpcy5zdmdGYWNldFNlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdHRoaXMuX3hBeGlzRmFjZXRTZWxlY3QgPSB0aGlzLnN2Z0ZhY2V0U2VsZWN0LmFwcGVuZCgnZycpXG5cblx0XHQvLyB0aGlzLnN3YXBTdmdWaXNpYmlsaXR5KCk7XG5cblx0XHR0aGlzLl9jYW52YXNDb250YWluZXIgPSB0aGlzLm1haW5Hcm91cFNlbGVjdFxuXHRcdFx0LmFwcGVuZCgnZm9yZWlnbk9iamVjdCcpXG5cdFx0XHRcdC5hdHRyKCd3aWR0aCcsIHRoaXMudml6V2lkdGgpXG5cdFx0XHRcdC5hdHRyKCdoZWlnaHQnLCB0aGlzLnZpekhlaWdodCk7XG5cblx0XHR0aGlzLl9jYW52YXNFbGVtZW50ID0gdGhpcy5jYW52YXNDb250YWluZXIuYXBwZW5kKCd4aHRtbDpjYW52YXMnKVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQpXG5cdFx0XHQubm9kZSgpIGFzIEhUTUxDYW52YXNFbGVtZW50O1xuXG5cdFx0aWYgKHRoaXMuY2FuQnJ1c2gpXG5cdFx0e1xuXHRcdFx0dGhpcy5fYnJ1c2hHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZChcImdcIilcblx0XHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApXG5cdFx0XHRcdC5jbGFzc2VkKCdicnVzaENvbnRhaW5lcicsIHRydWUpXG5cdFx0XHRcdC5jbGFzc2VkKCdub0Rpc3AnLCB0aGlzLmluQXZlcmFnZU1vZGUpO1xuXG5cdFx0XHR0aGlzLmluaXRCcnVzaCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3ZnU2VsZWN0LmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aCk7XG5cdFx0dGhpcy5zdmdTZWxlY3QuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuXG5cdFx0dGhpcy5zdmdGYWNldFNlbGVjdC5hdHRyKCd3aWR0aCcsIHRoaXMud2lkdGgpO1xuXHRcdHRoaXMuc3ZnRmFjZXRTZWxlY3QuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuXG5cdFx0dGhpcy5feEF4aXNHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgnZycpXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0fSlgKVxuXHRcdFx0LmNsYXNzZWQoXCJsYWJlbENvbG9yXCIsIHRydWUpO1xuXG5cdFx0dGhpcy5feUF4aXNHcm91cFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgnZycpXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYClcblx0XHRcdC5jbGFzc2VkKFwibGFiZWxDb2xvclwiLCB0cnVlKTtcblxuXHRcdHRoaXMuX2N1cnJlbnRGcmFtZUluZGljYXRvciA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgnZycpXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYCk7XG5cdFxuXHRcdHRoaXMuX2F2ZXJhZ2VDdXJ2ZUxhYmVsQ29udGFpbmVyID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCdnJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdH0sICR7dGhpcy5tYXJnaW4udG9wfSlgKTtcblxuXHRcdHRoaXMuX2F2ZXJhZ2VMZWdlbmRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0LzJ9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0ICsgNDR9KWApO1xuXHRcdFxuXHRcdHRoaXMuX2ZhY2V0TGVnZW5kU2VsZWN0ID0gdGhpcy5zdmdGYWNldFNlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0LzJ9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0ICsgNDR9KWApO1xuXHRcdFxuXHRcdHRoaXMuZHJhd0xlZ2VuZCgpO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ3JvdXBCeUNoYW5nZWQnLCBhc3luYyAoZTogQ3VzdG9tRXZlbnQpID0+XG5cdFx0e1xuXHRcdFx0bGV0IHBvcHVwQ29udGFpbmVyID0gZDMuc2VsZWN0KCcjbGFyZ2VQb3B1cENvbnRhaW5lck91dGVyJyk7XG5cdFx0XHRpZiAoIXBvcHVwQ29udGFpbmVyLmVtcHR5KCkgJiYgIXBvcHVwQ29udGFpbmVyLmNsYXNzZWQoJ25vRGlzcCcpKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQgdGhpcy5fZmFjZXRMaXN0ID0gZS5kZXRhaWwuZmxhdEZhY2V0TGlzdDtcblx0XHRcdCB0aGlzLl9jb2xvckxvb2t1cCA9IGUuZGV0YWlsLmNvbG9yTG9va3VwO1xuXHRcdFx0IGlmICh0aGlzLmluQXZlcmFnZU1vZGUpXG5cdFx0XHQge1xuXHRcdFx0XHQgdGhpcy5PbkRhdGFDaGFuZ2UoKTtcblx0XHRcdCB9XG5cdFx0fSk7XG5cblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzbW9vdGhDdXJ2ZUNoYW5nZScsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0dGhpcy5fc21vb3RoQ3VydmVzID0gZS5kZXRhaWw7XG5cdFx0XHRpZiAodGhpcy5pbkF2ZXJhZ2VNb2RlKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLk9uRGF0YUNoYW5nZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9jRnJhbWVDbGlja2VkJywgKGU6IEN1c3RvbUV2ZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gZS5kZXRhaWwuZnJhbWVJZDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudEZyYW1lSW5kaWNhdG9yKGZyYW1lSWQpO1xuICAgICAgICB9KTtcblxuXHRcdHRoaXMuX3NlbGVjdENvbmRpdGlvbkJ1dHRvbiA9IERldmxpYlRTVXRpbC5nZXRJY29uQnV0dG9uKCd0aCcsICgpID0+XG5cdFx0e1xuXHRcdFx0dGhpcy5faW5GYWNldE1vZGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5zZWxlY3RDb25kaXRpb25CdXR0b24uY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcblx0XHRcdHRoaXMuY29tcGFyZUNvbmRpdGlvbkJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuXHRcdFx0dGhpcy5kcmF3RmFjZXRDb250ZW50KClcblx0XHR9LFxuXHRcdCdGYWNldCcpO1xuXHRcdHRoaXMuc2VsZWN0Q29uZGl0aW9uQnV0dG9uLnRpdGxlID0gJ0ZpbHRlciBkYXRhIG9uIGV4cGVyaW1lbnRhbCBjb25kaXRpb25zJztcblx0XHR0aGlzLnNlbGVjdENvbmRpdGlvbkJ1dHRvbi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG5cdFx0dGhpcy5zZWxlY3RDb25kaXRpb25CdXR0b24uY2xhc3NMaXN0LmFkZCgndGFiJyk7XG5cdFx0dGhpcy50aXRsZUJhckNvbnRhaW5lci5ub2RlKCkuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RDb25kaXRpb25CdXR0b24pO1xuXG5cdFx0dGhpcy5fY29tcGFyZUNvbmRpdGlvbkJ1dHRvbiA9IERldmxpYlRTVXRpbC5nZXRJY29uQnV0dG9uKCdjaGFydC1saW5lJywgKCkgPT5cblx0XHR7XG5cdFx0XHR0aGlzLl9pbkZhY2V0TW9kZSA9IGZhbHNlO1xuXHRcdFx0dGhpcy5zZWxlY3RDb25kaXRpb25CdXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcblx0XHRcdHRoaXMuY29tcGFyZUNvbmRpdGlvbkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuXHRcdFx0dGhpcy5kcmF3RmFjZXRDb250ZW50KClcblx0XHR9LFxuXHRcdCdDb21wYXJlJyk7XG5cdFx0dGhpcy5jb21wYXJlQ29uZGl0aW9uQnV0dG9uLnRpdGxlID0gJ0NvbXBhcmUgYXZlcmFnZSBjdXJ2ZXMgYWNyb3NzIGV4cGVyaW1lbnRhbCBjb25kaXRpb25zJztcblx0XHR0aGlzLmNvbXBhcmVDb25kaXRpb25CdXR0b24uc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuXHRcdHRoaXMuY29tcGFyZUNvbmRpdGlvbkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd0YWInKTtcblx0XHR0aGlzLnRpdGxlQmFyQ29udGFpbmVyLm5vZGUoKS5hcHBlbmRDaGlsZCh0aGlzLmNvbXBhcmVDb25kaXRpb25CdXR0b24pO1xuXHRcdHRoaXMudGl0bGVCYXJDb250YWluZXIuYXBwZW5kKCdkaXYnKS5hdHRyKCdzdHlsZScsICdmbGV4LWdyb3c6IDE7Jyk7XG5cblx0XHRpZiAodGhpcy5pbkZhY2V0TW9kZSlcblx0XHR7XG5cdFx0XHR0aGlzLnNlbGVjdENvbmRpdGlvbkJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5jb21wYXJlQ29uZGl0aW9uQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0UXVpY2tQaWNrT3B0aW9ucygpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0UXVpY2tQaWNrT3B0aW9ucygpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBjb250YWluZXJJZCA9IHRoaXMuQ29tcG9uZW50SWQgKyAnLXF1aWNrUGlja0NvbnRhaW5lcic7XG5cdFx0dGhpcy5fcXVpY2tQaWNrQ29udGFpbmVyU2VsZWN0ID0gdGhpcy50aXRsZUJhckNvbnRhaW5lci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgncXVpY2tQaWNrQ29udGFpbmVyJywgdHJ1ZSlcblx0XHRcdC5hdHRyKCdpZCcsIGNvbnRhaW5lcklkKTtcblxuXHRcdHRoaXMuX3F1aWNrUGlja09wdGlvblNlbGVjdCA9IG5ldyBPcHRpb25TZWxlY3QoY29udGFpbmVySWQsIFwiQXhlc1wiKTtcblx0XHRsZXQgYnV0dG9uUHJvcExpc3Q6IEJ1dHRvblByb3BzW10gPSBbXTtcblx0XHRmb3IgKGxldCBxdWlja1BpY2tPcHRpb24gb2YgdGhpcy5xdWlja1BpY2tPcHRpb25zKVxuXHRcdHtcblx0XHRcdGxldCBvcHRpb25OYW1lOiBzdHJpbmc7XG5cdFx0XHRpZiAocXVpY2tQaWNrT3B0aW9uLmF2ZXJhZ2VkKVxuXHRcdFx0e1xuXHRcdFx0XHRvcHRpb25OYW1lID0gJ0F2ZXJhZ2VkOiAnICsgcXVpY2tQaWNrT3B0aW9uLnlLZXkgKyAnIG92ZXIgJyArIHF1aWNrUGlja09wdGlvbi54S2V5O1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRvcHRpb25OYW1lID0gcXVpY2tQaWNrT3B0aW9uLnlLZXkgKyBcIiB2LiBcIiArIHF1aWNrUGlja09wdGlvbi54S2V5O1xuXHRcdFx0fVxuXHRcdFx0bGV0IGJ1dHRvblByb3A6IEJ1dHRvblByb3BzID0ge1xuXHRcdFx0XHRkaXNwbGF5TmFtZTogb3B0aW9uTmFtZSxcblx0XHRcdFx0Y2FsbGJhY2s6ICgpID0+IHRoaXMuY2hhbmdlQXhlcyhxdWlja1BpY2tPcHRpb24ueEtleSwgcXVpY2tQaWNrT3B0aW9uLnlLZXksIHF1aWNrUGlja09wdGlvbi5hdmVyYWdlZCwgcXVpY2tQaWNrT3B0aW9uLnNxdWFyZUFzcGVjdFJhdGlvKVxuXHRcdFx0fVxuXHRcdFx0YnV0dG9uUHJvcExpc3QucHVzaChidXR0b25Qcm9wKTtcblx0XHR9XG5cdFx0dGhpcy5xdWlja1BpY2tPcHRpb25TZWxlY3Qub25EYXRhQ2hhbmdlKGJ1dHRvblByb3BMaXN0LCB0aGlzLmluaXRpYWxRdWlja1BpY2tPcHRpb25JbmRleCk7XG5cdH1cblxuXHRwcml2YXRlIGluaXRCcnVzaCgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9icnVzaCA9IGQzLmJydXNoKClcblx0XHQuZXh0ZW50KFtbMCwgMF0sIFt0aGlzLnZpeldpZHRoLCB0aGlzLnZpekhlaWdodF1dKVxuXHRcdC5vbihcImVuZFwiLCAoKSA9PiB7IHRoaXMuYnJ1c2hIYW5kbGVyKCkgfSk7XG5cblx0XHR0aGlzLmJydXNoR3JvdXBTZWxlY3QuY2FsbCh0aGlzLmJydXNoKTtcblx0fVxuXG5cdHByaXZhdGUgYWRkTGFiZWwoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5feExhYmVsVGV4dFNlbGVjdCA9IHRoaXMuc3ZnU2VsZWN0LmFwcGVuZCgndGV4dCcpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdub0Rpc3AnLCB0cnVlKTtcblxuXHRcdHRoaXMuX3lMYWJlbFRleHRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmNsYXNzZWQoJ2F4aXNMYWJlbCcsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnbGFiZWxDb2xvcicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnbm9EaXNwJywgdHJ1ZSk7XG5cblx0XHR0aGlzLnBvc2l0aW9uTGFiZWxzKCk7XG5cdH1cblxuXHRwcml2YXRlIHBvc2l0aW9uTGFiZWxzKCk6IHZvaWRcblx0e1xuXHRcdC8vIFgtQXhpc1xuXHRcdGxldCBidWZmZXJGb3JBeGlzID0gMzI7XG5cdFx0dGhpcy54TGFiZWxUZXh0U2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnQgKyB0aGlzLnZpeldpZHRoIC8gMn0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgKyBidWZmZXJGb3JBeGlzfSlgKTtcblxuXHRcdGJ1ZmZlckZvckF4aXMgPSA0MDtcblx0XHQvLyBZLUF4aXNcblx0XHRsZXQgdHJhbnNYID0gdGhpcy5tYXJnaW4ubGVmdCAtIGJ1ZmZlckZvckF4aXM7XG5cdFx0bGV0IHRyYW5zWSA9IHRoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0IC8gMjtcblx0XHRsZXQgdHJhbnNmb3JtVGV4dDogc3RyaW5nO1xuXHRcdHRyYW5zZm9ybVRleHQgPSBgcm90YXRlKC05MCkgdHJhbnNsYXRlKCR7LXRyYW5zWX0sICR7dHJhbnNYfSlgO1xuXHRcdHRoaXMueUxhYmVsVGV4dFNlbGVjdC5hdHRyKCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1UZXh0KTtcblx0fVxuXG5cblx0cHVibGljIE9uRGF0YUNoYW5nZSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnVwZGF0ZVNjYWxlcygpO1xuXHRcdHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLmNsZWFyKCk7XG5cdFx0dGhpcy5yZXNldFRlbXBDb25kaXRpb25GaWx0ZXIoKTtcblx0XHR0aGlzLnVwZGF0ZVBhdGhzKCk7XG5cdFx0dGhpcy5kcmF3QXhpcygpO1xuICAgICAgICB0aGlzLnNob3dMYWJlbCgpO1xuXHR9XG5cblx0cHJpdmF0ZSBjaGFuZ2VBeGVzKHhLZXk6IHN0cmluZywgeUtleTogc3RyaW5nLCBpbkF2ZXJhZ2VNb2RlOiBib29sZWFuLCBzcXVhcmVBc3BlY3RSYXRpbzogYm9vbGVhbik6IHZvaWRcblx0e1xuXHRcdHRoaXMuX3hLZXkgPSB4S2V5O1xuXHRcdHRoaXMuX3lLZXkgPSB5S2V5O1xuXHRcdGlmICh0aGlzLl9pbkF2ZXJhZ2VNb2RlICE9PSBpbkF2ZXJhZ2VNb2RlKVxuXHRcdHtcblx0XHRcdHRoaXMuX2luQXZlcmFnZU1vZGUgPSBpbkF2ZXJhZ2VNb2RlO1xuXHRcdFx0aWYgKGluQXZlcmFnZU1vZGUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubWFyZ2luLnJpZ2h0ID0gMTIwO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLmZhY2V0QnV0dG9uKTtcblx0XHRcdFx0RGV2bGliVFNVdGlsLnNob3codGhpcy5hdmVyYWdlTGVnZW5kU2VsZWN0Lm5vZGUoKSk7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMuZmFjZXRMZWdlbmRTZWxlY3Qubm9kZSgpKTtcblxuXHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyh0aGlzLmNvbXBhcmVDb25kaXRpb25CdXR0b24pO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuc2hvdyh0aGlzLnNlbGVjdENvbmRpdGlvbkJ1dHRvbik7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubWFyZ2luLnJpZ2h0ID0gODtcblx0XHRcdFx0aWYgKHRoaXMuaW5GYWNldE1vZGUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLl9pbkZhY2V0TW9kZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuc3dhcFN2Z1Zpc2liaWxpdHkoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KHRoaXMuZmFjZXRCdXR0b24pO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLnNlbGVjdENvbmRpdGlvbkJ1dHRvbik7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMuY29tcGFyZUNvbmRpdGlvbkJ1dHRvbik7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMuYXZlcmFnZUxlZ2VuZFNlbGVjdC5ub2RlKCkpO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLmZhY2V0TGVnZW5kU2VsZWN0Lm5vZGUoKSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldFdpZHRoSGVpZ2h0KCk7XG5cdFx0XHR0aGlzLk9uUmVzaXplKCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNhbkJydXNoKVxuXHRcdHtcblx0XHRcdGxldCBicnVzaEVsZW1lbnQgPSB0aGlzLmJydXNoR3JvdXBTZWxlY3Qubm9kZSgpO1xuXHRcdFx0aWYgKHRoaXMuaW5BdmVyYWdlTW9kZSlcblx0XHRcdHtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUoYnJ1c2hFbGVtZW50KTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0RGV2bGliVFNVdGlsLnNob3coYnJ1c2hFbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fc3F1YXJlQXNwZWN0UmF0aW8gPSBzcXVhcmVBc3BlY3RSYXRpbztcblx0XHR0aGlzLnJlbW92ZUJydXNoKCk7XG5cdFx0dGhpcy5PbkRhdGFDaGFuZ2UoKTtcblx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnYXZlcmFnZUN1cnZlS2V5Q2hhbmdlJywge1xuXHRcdFx0ZGV0YWlsOiB7XG5cdFx0XHRcdHlLZXk6IHlLZXlcblx0XHRcdH1cblx0XHR9KSk7XG5cdH1cblx0XG5cdHByaXZhdGUgcmVtb3ZlQnJ1c2goKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5icnVzaEdyb3VwU2VsZWN0LmNhbGwodGhpcy5icnVzaC5tb3ZlLCBudWxsKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlU2NhbGVzKCk6IHZvaWRcblx0e1xuXHRcdGxldCBtaW5YIDogbnVtYmVyLCBtYXhYIDogbnVtYmVyLCBtaW5ZIDogbnVtYmVyLCBtYXhZIDogbnVtYmVyO1xuXHRcdGlmICh0aGlzLmluQXZlcmFnZU1vZGUpXG5cdFx0e1xuXHRcdFx0bWluWSA9IGQzLm1pbih0aGlzLmZhY2V0TGlzdCwgZmFjZXQgPT4gZDMubWluKChmYWNldC5kYXRhIGFzIEN1cnZlTGlzdCkuZ2V0QXZlcmFnZUN1cnZlKHRoaXMueUtleSwgZmFsc2UsIHRoaXMuc21vb3RoQ3VydmVzKSwgZCA9PiBkWzFdKSk7XG5cdFx0XHRtYXhZID0gZDMubWF4KHRoaXMuZmFjZXRMaXN0LCBmYWNldCA9PiBkMy5tYXgoKGZhY2V0LmRhdGEgYXMgQ3VydmVMaXN0KS5nZXRBdmVyYWdlQ3VydmUodGhpcy55S2V5LCBmYWxzZSwgdGhpcy5zbW9vdGhDdXJ2ZXMpLCBkID0+IGRbMV0pKTtcblxuXHRcdFx0aWYgKHRoaXMuZGF0YS5icnVzaEFwcGxpZWQpXG5cdFx0XHR7XG5cdFx0XHRcdG1pblkgPSBkMy5taW4oW21pblksIGQzLm1pbih0aGlzLmZhY2V0TGlzdCwgZmFjZXQgPT4gZDMubWluKChmYWNldC5kYXRhIGFzIEN1cnZlTGlzdCkuZ2V0QXZlcmFnZUN1cnZlKHRoaXMueUtleSwgdHJ1ZSwgdGhpcy5zbW9vdGhDdXJ2ZXMpLCBkID0+IGRbMV0pKV0pO1xuXHRcdFx0XHRtYXhZID0gZDMubWF4KFttYXhZLCBkMy5tYXgodGhpcy5mYWNldExpc3QsIGZhY2V0ID0+IGQzLm1heCgoZmFjZXQuZGF0YSBhcyBDdXJ2ZUxpc3QpLmdldEF2ZXJhZ2VDdXJ2ZSh0aGlzLnlLZXksIHRydWUsIHRoaXMuc21vb3RoQ3VydmVzKSwgZCA9PiBkWzFdKSldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGxldCBkYXRhOiBDdXJ2ZUxpc3Q7XG5cdFx0XHRpZiAodGhpcy5pc0Nsb25lKVxuXHRcdFx0e1xuXHRcdFx0XHRkYXRhID0gdGhpcy5mdWxsRGF0YTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0ZGF0YSA9IHRoaXMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0W21pblksIG1heFldID0gZGF0YS5taW5NYXhNYXAuZ2V0KHRoaXMueUtleSk7XG5cdFx0fVxuXHRcdFttaW5YLCBtYXhYXSA9IHRoaXMuZGF0YS5taW5NYXhNYXAuZ2V0KHRoaXMueEtleSk7XG5cdFx0aWYgKHRoaXMuc3F1YXJlQXNwZWN0UmF0aW8pXG5cdFx0e1xuXHRcdFx0dGhpcy5tYWtlU3F1YXJlQXNwZWN0UmF0aW9TY2FsZXMobWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLm1ha2VTdHJldGNoZWRBc3BlY3RSYXRpb1NjYWxlcyhtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIG1ha2VTcXVhcmVBc3BlY3RSYXRpb1NjYWxlcyhtaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXIpOiB2b2lkXG5cdHtcblx0XHQvLyB0aGlzIGNvZGUga2VlcHMgdGhlIGRhdGEgYXNwZWN0IHJhdGlvIHNxdWFyZSBhbmQga2VlcHMgaXQgY2VudGVyZWQgYW5kIGFzIGxhcmdlXG5cdFx0Ly8gYXMgcG9zc2libGUgaW4gaXQncyBjb250YWluZXJcblx0XHRsZXQgY29udGFpbmVyUmF0aW8gPSB0aGlzLnZpekhlaWdodCAvIHRoaXMudml6V2lkdGg7XG5cdFx0bGV0IGRhdGFSYXRpbyA9IChtYXhZIC0gbWluWSkgLyAobWF4WCAtIG1pblgpO1xuXHRcdGlmIChjb250YWluZXJSYXRpbyA+IGRhdGFSYXRpbylcblx0XHR7XG5cdFx0XHR0aGlzLl9zY2FsZVggPSBkMy5zY2FsZUxpbmVhcigpXG5cdFx0XHRcdC5kb21haW4oW21pblgsIG1heFhdKVxuXHRcdFx0XHQucmFuZ2UoWzAsIHRoaXMudml6V2lkdGhdKTtcblxuXHRcdFx0bGV0IFtzY2FsZWRNaW5ZLCBzY2FsZWRNYXhZXSA9IFt0aGlzLnNjYWxlWChtaW5ZKSwgdGhpcy5zY2FsZVgobWF4WSldOyBcblx0XHRcdGxldCBkYXRhTGVuZ3RoID0gc2NhbGVkTWF4WSAtIHNjYWxlZE1pblk7XG5cdFx0XHRsZXQgb2Zmc2V0ID0gKHRoaXMudml6SGVpZ2h0IC0gZGF0YUxlbmd0aCkgLyAyLjAgLSBzY2FsZWRNaW5ZO1xuXG5cdFx0XHR0aGlzLl9zY2FsZVkgPSBkMy5zY2FsZUxpbmVhcigpXG5cdFx0XHRcdC5kb21haW4oW21pblksIG1heFldKVxuXHRcdFx0XHQucmFuZ2UoW3NjYWxlZE1heFkgKyBvZmZzZXQsIHNjYWxlZE1pblkgKyBvZmZzZXRdKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuX3NjYWxlWSA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdFx0LmRvbWFpbihbbWluWSwgbWF4WV0pXG5cdFx0XHRcdC5yYW5nZShbdGhpcy52aXpIZWlnaHQsIDBdKTtcblxuXG5cdFx0XHRsZXQgW3NjYWxlZE1pblgsIHNjYWxlZE1heFhdID0gW3RoaXMuc2NhbGVZKG1pblgpLCB0aGlzLnNjYWxlWShtYXhYKV07IFxuXHRcdFx0bGV0IGRhdGFMZW5ndGggPSBzY2FsZWRNYXhYIC0gc2NhbGVkTWluWDtcblx0XHRcdGxldCBvZmZzZXQgPSAodGhpcy52aXpXaWR0aCAtIGRhdGFMZW5ndGgpIC8gMi4wIC0gc2NhbGVkTWluWDtcblxuXHRcdFx0dGhpcy5fc2NhbGVYID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0XHQuZG9tYWluKFttaW5YLCBtYXhYXSlcblx0XHRcdFx0LnJhbmdlKFtzY2FsZWRNYXhYICsgb2Zmc2V0LCBzY2FsZWRNaW5YICsgb2Zmc2V0XSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBtYWtlU3RyZXRjaGVkQXNwZWN0UmF0aW9TY2FsZXMobWluWDogbnVtYmVyLCBtYXhYOiBudW1iZXIsIG1pblk6IG51bWJlciwgbWF4WTogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fc2NhbGVYID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0LmRvbWFpbihbbWluWCwgbWF4WF0pXG5cdFx0XHQucmFuZ2UoWzAsIHRoaXMudml6V2lkdGhdKTtcblxuXHRcdHRoaXMuX3NjYWxlWSA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4oW21pblksIG1heFldKVxuXHRcdFx0LnJhbmdlKFt0aGlzLnZpekhlaWdodCwgMF0pO1xuXHR9XG5cblx0cHJpdmF0ZSBzd2FwU3ZnVmlzaWJpbGl0eSgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLnN2Z1NlbGVjdC5jbGFzc2VkKCdub0Rpc3AnLCB0aGlzLmluRmFjZXRNb2RlKTtcblx0XHR0aGlzLnN2Z0ZhY2V0U2VsZWN0LmNsYXNzZWQoJ25vRGlzcCcsICF0aGlzLmluRmFjZXRNb2RlKTtcblx0XHRpZiAodGhpcy5pbkZhY2V0TW9kZSAmJiB0aGlzLmRhdGFTdXBlcnNldClcblx0XHR7XG5cdFx0XHR0aGlzLnJlc2V0VGVtcENvbmRpdGlvbkZpbHRlcigpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0bGV0IGFwcGx5QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmRpdGlvbkZpbHRlckFwcGx5QnV0dG9uJyk7XG5cdFx0XHRpZiAoYXBwbHlCdXR0b24pXG5cdFx0XHR7XG5cdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKGFwcGx5QnV0dG9uKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVBhdGhzKCk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmluQXZlcmFnZU1vZGUpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuaW5GYWNldE1vZGUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMudXBkYXRlRmFjZXRQYXRocygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLnVwZGF0ZUF2ZXJhZ2VQYXRocygpO1xuXHRcdFx0XHR0aGlzLmRyYXdBeGlzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLnVwZGF0ZUFsbFBhdGhzKClcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUFsbFBhdGhzKCk6IHZvaWRcblx0e1xuXHRcdGxldCBsaW5lID0gZDMubGluZTxQb2ludE5EPigpXG5cdFx0XHQueCgoZCwgaSkgPT4geyByZXR1cm4gdGhpcy5zY2FsZVgoZC5nZXQodGhpcy54S2V5KSkgfSlcblx0XHRcdC55KChkKSA9PiB7IHJldHVybiB0aGlzLnNjYWxlWShkLmdldCh0aGlzLnlLZXkpKSB9KVxuXHRcdFx0LmRlZmluZWQoZCA9PiBkLmluQnJ1c2gpO1xuXHRcdFxuXHRcdGNvbnN0IGNhbnZhc0NvbnRleHQgPSB0aGlzLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRjYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLDAsIHRoaXMudml6V2lkdGgsIHRoaXMudml6SGVpZ2h0KTtcblx0XHRjYW52YXNDb250ZXh0LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcblx0XHRjYW52YXNDb250ZXh0LmxpbmVXaWR0aCA9IDE7XG5cdFx0Y2FudmFzQ29udGV4dC5nbG9iYWxBbHBoYSA9IDAuMjU7XG5cdFx0Y2FudmFzQ29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cblx0XHRmb3IgKGxldCBjdXJ2ZSBvZiB0aGlzLmRhdGEuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKGxpbmUoY3VydmUucG9pbnRMaXN0KSk7XG5cdFx0XHRjYW52YXNDb250ZXh0LnN0cm9rZShwYXRoKTtcblx0XHR9XG5cdFx0dGhpcy5jbGVhckxhYmVscygpO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVBdmVyYWdlUGF0aHMoKTogdm9pZFxuXHR7XG4gICAgICAgIGxldCBsaW5lQXZnID0gZDMubGluZTxbbnVtYmVyLCBudW1iZXJdPigpXG4gICAgICAgICAgICAueChkID0+IHRoaXMuc2NhbGVYKGRbMF0pKVxuICAgICAgICAgICAgLnkoZCA9PiB0aGlzLnNjYWxlWShkWzFdKSk7XG5cdFx0XG5cdFx0Y29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGNhbnZhc0NvbnRleHQuY2xlYXJSZWN0KDAsMCwgdGhpcy52aXpXaWR0aCwgdGhpcy52aXpIZWlnaHQpO1xuXHRcdGNhbnZhc0NvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXHRcdFxuXHRcdGxldCBsYWJlbERhdGE6IFtzdHJpbmcsIFtudW1iZXIsIG51bWJlcl1dW10gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gdGhpcy5mYWNldExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKVxuXHRcdHtcblx0XHRcdGNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgPSAwLjg1O1xuXHRcdFx0Y2FudmFzQ29udGV4dC5saW5lV2lkdGggPSAyO1xuXG5cdFx0XHRsZXQgZmFjZXQgPSB0aGlzLmZhY2V0TGlzdFtpXTtcblx0XHRcdGNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGZhY2V0Lm5hbWUsIHRoaXMuY29sb3JMb29rdXApO1xuXHRcdFx0bGV0IGRhdGFQb2ludHMgPSBmYWNldC5kYXRhLmdldEF2ZXJhZ2VDdXJ2ZSh0aGlzLnlLZXksIGZhbHNlLCB0aGlzLnNtb290aEN1cnZlcyk7XG5cdFx0XHRpZiAoZGF0YVBvaW50cy5sZW5ndGggIT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmRhdGEuYnJ1c2hBcHBsaWVkKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2FudmFzQ29udGV4dC5zYXZlKClcblx0XHRcdFx0XHQvLyBjYW52YXNDb250ZXh0LnNldExpbmVEYXNoKFsyLCAzXSk7XG5cdFx0XHRcdFx0Y2FudmFzQ29udGV4dC5nbG9iYWxBbHBoYSAqPSAwLjg7XG5cdFx0XHRcdFx0Y2FudmFzQ29udGV4dC5saW5lV2lkdGggPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKGxpbmVBdmcoZGF0YVBvaW50cykpO1xuXHRcdFx0XHRjYW52YXNDb250ZXh0LnN0cm9rZShwYXRoKTtcblx0XHRcdH1cblx0XHRcdGxldCBsYXN0UG9pbnQ6IFtudW1iZXIsIG51bWJlcl0gPSBkYXRhUG9pbnRzW2RhdGFQb2ludHMubGVuZ3RoIC0gMV07XG5cdFx0XHRjYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcblxuXHRcdFx0aWYgKHRoaXMuZGF0YS5icnVzaEFwcGxpZWQpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCBmaWx0ZXJlZERhdGFQb2ludHMgPSBmYWNldC5kYXRhLmdldEF2ZXJhZ2VDdXJ2ZSh0aGlzLnlLZXksIHRydWUsIHRoaXMuc21vb3RoQ3VydmVzKTtcblx0XHRcdFx0aWYgKGZpbHRlcmVkRGF0YVBvaW50cy5sZW5ndGggIT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gbmV3IFBhdGgyRChsaW5lQXZnKGZpbHRlcmVkRGF0YVBvaW50cykpO1xuXHRcdFx0XHRcdGNhbnZhc0NvbnRleHQuc3Ryb2tlKHBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQb2ludCA9IGZpbHRlcmVkRGF0YVBvaW50c1tmaWx0ZXJlZERhdGFQb2ludHMubGVuZ3RoIC0gMV07XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mKGxhc3RQb2ludCkgPT09ICd1bmRlZmluZWQnKVxuXHRcdFx0e1xuXHRcdFx0XHRsYXN0UG9pbnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0bGFiZWxEYXRhLnVuc2hpZnQoW2ZhY2V0Lm5hbWUuam9pbignX19fJyksIGxhc3RQb2ludF0pO1xuXHRcdH1cblx0XHR0aGlzLmRyYXdMYWJlbHMobGFiZWxEYXRhKTtcblx0XHQvLyB0aGlzLnVwZGF0ZUN1cnJlbnRGcmFtZUluZGljYXRvcigpO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVDdXJyZW50RnJhbWVJbmRpY2F0b3IoZnJhbWVJZD86IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmluQXZlcmFnZU1vZGUgJiYgIXRoaXMuaW5GYWNldE1vZGUgJiYgdHlwZW9mKGZyYW1lSWQpICE9PSAndW5kZWZpbmVkJylcblx0XHR7XG5cdFx0XHR0aGlzLmN1cnJlbnRGcmFtZUluZGljYXRvci5zZWxlY3RBbGwoJ2xpbmUnKVxuXHRcdFx0XHQuZGF0YShbNDJdKVxuXHRcdFx0XHQuam9pbignbGluZScpXG5cdFx0XHRcdC5hdHRyKCd4MScsIHRoaXMuc2NhbGVYKGZyYW1lSWQpKVxuXHRcdFx0XHQuYXR0cigneDInLCB0aGlzLnNjYWxlWChmcmFtZUlkKSlcblx0XHRcdFx0LmF0dHIoJ3kxJywgdGhpcy5zY2FsZVkucmFuZ2UoKVswXSlcblx0XHRcdFx0LmF0dHIoJ3kyJywgdGhpcy5zY2FsZVkucmFuZ2UoKVsxXSlcblx0XHRcdFx0LmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG5cdFx0XHRcdC5jbGFzc2VkKCdjdXJyZW50RnJhbWVMaW5lJywgdHJ1ZSk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLmN1cnJlbnRGcmFtZUluZGljYXRvci5zZWxlY3RBbGwoJ2xpbmUnKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlRmFjZXRQYXRocygpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBtYXJnaW4gPSB7XG5cdFx0XHR0b3A6IDY0LFxuXHRcdFx0bGVmdDogMTIwLFxuXHRcdFx0cmlnaHQ6IDIwLFxuXHRcdFx0Ym90dG9tOiA0OFxuXHRcdH1cblxuXHRcdGNvbnN0IGRlZmF1bHRGYWNldHMgPSB0aGlzLmRhdGEuZGVmYXVsdEZhY2V0cztcblx0XHRjb25zdCBkZWZhdWx0RmFjZXRzRnVsbCA9IHRoaXMuZnVsbERhdGEuZGVmYXVsdEZhY2V0cztcblx0XHRjb25zdCBkZWZhdWx0QXhpc1RpY2tzID0gdGhpcy5mdWxsRGF0YS5kZWZhdWx0RmFjZXRBeGlzVGlja3M7XG5cdFx0Y29uc3Qgd0NvdW50ID0gZGVmYXVsdEF4aXNUaWNrcy54QXhpc1RpY2tzLmxlbmd0aDtcblx0XHRjb25zdCBsQ291bnQgPSBkZWZhdWx0QXhpc1RpY2tzLnlBeGlzVGlja3MubGVuZ3RoO1xuXG5cdFx0bGV0IG1pbmlXaWR0aCA9ICh0aGlzLndpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpIC8gd0NvdW50XG5cdFx0bGV0IG1pbmlIZWlnaHQgPSAodGhpcy5oZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkgLyBsQ291bnQ7XG5cblx0XHRsZXQgbWluaVNpemUgPSBNYXRoLm1pbihtaW5pV2lkdGgsIG1pbmlIZWlnaHQpO1xuXHRcdGNvbnN0IG1pbmlQYWRkaW5nID0gTWF0aC5yb3VuZCgwLjA4ICogbWluaVNpemUpO1xuXHRcdG1pbmlTaXplIC09IDIgKiBtaW5pUGFkZGluZztcblxuXHRcdGNvbnN0IHZpeldpZHRoID0gd0NvdW50ICogbWluaVNpemUgKyAod0NvdW50IC0gMSkgKiBtaW5pUGFkZGluZztcblx0XHRjb25zdCB2aXpIZWlnaHQgPSBsQ291bnQgKiBtaW5pU2l6ZSArIChsQ291bnQgLSAxKSAqIG1pbmlQYWRkaW5nO1xuXG5cdFx0dGhpcy5hZGRBcHBseUJ1dHRvbihkMy5zZWxlY3QodGhpcy5jb250YWluZXIgYXMgSFRNTEVsZW1lbnQpKTtcblxuXHRcdHRoaXMubWFpbkdyb3VwRmFjZXRTZWxlY3Rcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCAke21hcmdpbi50b3B9KWApXG5cblx0XHRsZXQgcm93U2VsZWN0ID0gdGhpcy5tYWluR3JvdXBGYWNldFNlbGVjdC5zZWxlY3RBbGwoJ2cucm93Jylcblx0XHRcdC5kYXRhKGRlZmF1bHRBeGlzVGlja3MueUF4aXNUaWNrcylcblx0XHRcdC5qb2luKCdnJylcblx0XHRcdC5jbGFzc2VkKCdyb3cnLCB0cnVlKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIChfLCBpKSA9PiBgdHJhbnNsYXRlKDAsICR7aSAqIChtaW5pU2l6ZSArIG1pbmlQYWRkaW5nKX0pYCk7XG5cblx0XHR0aGlzLl9taW5pQ2VsbFNlbGVjdCA9IHJvd1NlbGVjdC5zZWxlY3RBbGwoJ2cubWluaUNlbGwnKVxuXHRcdFx0LmRhdGEoZCA9PiBkZWZhdWx0QXhpc1RpY2tzLnhBeGlzVGlja3MubWFwKGxhYmVsID0+IFtkLCBsYWJlbF0pKVxuXHRcdFx0LmpvaW4oJ2cnKVxuXHRcdFx0LmNsYXNzZWQoJ21pbmlDZWxsJywgdHJ1ZSlcblx0XHRcdC5vbignY2xpY2snLCAoZCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuYWxsQ29uZGl0aW9uc1RydWUoKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc2V0QWxsQ29uZGl0aW9uc0ZhbHNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG9sZFZhbCA9IHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLmdldChkWzBdKT8uZ2V0KGRbMV0pO1xuXHRcdFx0XHR0aGlzLnRlbXBDb25kaXRpb25GaWx0ZXJTdGF0ZS5nZXQoZFswXSk/LnNldChkWzFdLCAhb2xkVmFsKTtcblx0XHRcdFx0dGhpcy51cGRhdGVDb25kaXRpb25GaWx0ZXJTZWxlY3Rpb24oKTtcblx0XHRcdH0pXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgKF8sIGkpID0+IGB0cmFuc2xhdGUoJHtpICogKG1pbmlTaXplICsgbWluaVBhZGRpbmcpfSwgMClgKSBhcyBTdmdTZWxlY3Rpb247XG5cdFx0XHRcblx0XHR0aGlzLnVwZGF0ZUNvbmRpdGlvbkZpbHRlclNlbGVjdGlvbigpXG5cdFx0XG5cdFx0bGV0IGZyYW1lRXh0ZW50ID0gdGhpcy5kYXRhLmdldE1pbk1heCgnRnJhbWUgSUQnKTtcblx0XHRjb25zdCBmcmFtZVBhZCA9IDE7XG5cdFx0Y29uc3Qgc2NhbGVYID0gZDMuc2NhbGVMaW5lYXIoKVxuXHRcdFx0LmRvbWFpbihmcmFtZUV4dGVudClcblx0XHRcdC5yYW5nZShbZnJhbWVQYWQsIG1pbmlTaXplIC0gZnJhbWVQYWRdKTtcblxuXHRcdGxldCBbbWluTWFzcywgbWF4TWFzc10gPSB0aGlzLmdldEV4dGVudE9mR3Jvd3RoQ3VydmVzKGRlZmF1bHRGYWNldHMpO1xuXHRcdGxldCBbbWluTWFzc0Z1bGwsIG1heE1hc3NGdWxsXSA9IHRoaXMuZ2V0RXh0ZW50T2ZHcm93dGhDdXJ2ZXMoZGVmYXVsdEZhY2V0c0Z1bGwsIHRydWUpO1xuXHRcdG1pbk1hc3MgPSBNYXRoLm1pbihtaW5NYXNzLCBtaW5NYXNzRnVsbCk7XG5cdFx0bWF4TWFzcyA9IE1hdGgubWF4KG1heE1hc3MsIG1heE1hc3NGdWxsKTtcblxuXHRcdGNvbnN0IHNjYWxlWSA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4oW21pbk1hc3MsIG1heE1hc3NdKVxuXHRcdFx0LnJhbmdlKFttaW5pU2l6ZSAtIGZyYW1lUGFkLCBmcmFtZVBhZF0pO1xuXG4gICAgICAgIGxldCBsaW5lQXZnID0gZDMubGluZTxbbnVtYmVyLCBudW1iZXJdPigpXG4gICAgICAgICAgICAueChkID0+IHNjYWxlWChkWzBdKSlcbiAgICAgICAgICAgIC55KGQgPT4gc2NhbGVZKGRbMV0pKTtcblx0XHRcdFx0XHRcblxuXHRcdHRoaXMubWluaUNlbGxTZWxlY3Quc2VsZWN0QWxsKCcubWluaUV4ZW1wbGFyQXJlYScpXG5cdFx0XHQuZGF0YShkID0+IFtkXSlcblx0XHRcdC5qb2luKCdwYXRoJylcblx0XHRcdC5jbGFzc2VkKCdtaW5pRXhlbXBsYXJBcmVhJywgdHJ1ZSlcblx0XHRcdC5hdHRyKCdkJywgZCA9PiBcblx0XHRcdHtcblx0XHRcdFx0bGV0IHBhdGhTdHJpbmcgPSB0aGlzLmdldEdyb3d0aExpbmUoZCwgZGVmYXVsdEZhY2V0cywgbGluZUF2ZywgZmFsc2UsIHRydWUsIG1pbk1hc3MpO1xuXHRcdFx0XHRpZiAocGF0aFN0cmluZylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBwYXRoU3RyaW5nXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0R3Jvd3RoTGluZShkLCBkZWZhdWx0RmFjZXRzRnVsbCwgbGluZUF2ZywgdHJ1ZSwgdHJ1ZSwgbWluTWFzcyk7XG5cdFx0XHR9KTtcblxuXHRcdHRoaXMubWluaUNlbGxTZWxlY3Quc2VsZWN0QWxsKCcubWluaUV4ZW1wbGFyQ3VydmUuYWxsRGF0YScpXG5cdFx0XHQuZGF0YShkID0+IFtkXSlcblx0XHRcdC5qb2luKCdwYXRoJylcblx0XHRcdC5jbGFzc2VkKCdtaW5pRXhlbXBsYXJDdXJ2ZScsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnYWxsRGF0YScsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnYWN0aXZlJywgIXRoaXMuZGF0YS5icnVzaEFwcGxpZWQpXG5cdFx0XHQuYXR0cignc3Ryb2tlJywgZCA9PiBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGQsIHRoaXMuY29sb3JMb29rdXApKVxuXHRcdFx0LmF0dHIoJ2QnLCBkID0+IFxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgcGF0aFN0cmluZyA9IHRoaXMuZ2V0R3Jvd3RoTGluZShkLCBkZWZhdWx0RmFjZXRzLCBsaW5lQXZnLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0XHRpZiAocGF0aFN0cmluZylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBwYXRoU3RyaW5nXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0R3Jvd3RoTGluZShkLCBkZWZhdWx0RmFjZXRzRnVsbCwgbGluZUF2ZywgdHJ1ZSwgZmFsc2UpO1xuXHRcdFx0fSk7XG5cblx0XHRpZiAodGhpcy5kYXRhLmJydXNoQXBwbGllZClcblx0XHR7XG5cdFx0XHR0aGlzLm1pbmlDZWxsU2VsZWN0LnNlbGVjdEFsbCgnLm1pbmlFeGVtcGxhckN1cnZlLnNlbGVjdGlvbicpXG5cdFx0XHRcdC5kYXRhKGQgPT4gW2RdKVxuXHRcdFx0XHQuam9pbigncGF0aCcpXG5cdFx0XHRcdC5jbGFzc2VkKCdtaW5pRXhlbXBsYXJDdXJ2ZScsIHRydWUpXG5cdFx0XHRcdC5jbGFzc2VkKCdzZWxlY3Rpb24nLCB0cnVlKVxuXHRcdFx0XHQuY2xhc3NlZCgnYWN0aXZlJywgdHJ1ZSlcblx0XHRcdFx0LmF0dHIoJ3N0cm9rZScsIGQgPT4gR3JvdXBCeVdpZGdldC5nZXRDb2xvcihkLCB0aGlzLmNvbG9yTG9va3VwKSlcblx0XHRcdFx0LmF0dHIoJ2QnLCBkID0+IFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0R3Jvd3RoTGluZShkLCBkZWZhdWx0RmFjZXRzLCBsaW5lQXZnLCB0cnVlLCBmYWxzZSk7XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5taW5pQ2VsbFNlbGVjdC5zZWxlY3RBbGwoJy5taW5pRXhlbXBsYXJDdXJ2ZS5zZWxlY3Rpb24nKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHR0aGlzLm1pbmlDZWxsU2VsZWN0LnNlbGVjdEFsbCgncmVjdCcpXG5cdFx0XHQuZGF0YShkID0+IFtkXSlcblx0XHRcdC5qb2luKCdyZWN0Jylcblx0XHRcdC5hdHRyKCd3aWR0aCcsIG1pbmlTaXplKVxuXHRcdFx0LmF0dHIoJ2hlaWdodCcsIG1pbmlTaXplKVxuXHRcdFx0LmNsYXNzZWQoJ21pbmlCb3gnLCB0cnVlKVxuXHRcdFx0Lm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24oZClcblx0XHRcdHtcdFxuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXJlZCcsIHRydWUpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKGQpIFxuXHRcdFx0e1xuXHRcdFx0XHRkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXJlZCcsIGZhbHNlKTtcblx0XHRcdH0pO1xuXG5cdFx0dGhpcy55QXhpc0ZhY2V0U2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwgJHttYXJnaW4udG9wfSlgKTtcblx0XHRcblx0XHRjb25zdCBtYXhMYWJlbFdpZHRoID0gNzA7XG5cdFx0Y29uc3QgbGFiZWxQYWRkaW5nID0gODtcblxuXHRcdGNvbnN0IG1haW5MYWJlbFNpemUgPSAyMDtcblxuXHRcdHRoaXMueUF4aXNGYWNldFNlbGVjdC5zZWxlY3RBbGwoJ3RleHQnKVxuXHRcdFx0LmRhdGEoW2RlZmF1bHRBeGlzVGlja3MuYXhpc0xhYmVsc1swXV0pXG5cdFx0ICAuam9pbigndGV4dCcpXG5cdFx0XHQuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcblx0XHRcdC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7LW1heExhYmVsV2lkdGggLSBsYWJlbFBhZGRpbmcgLSBtYWluTGFiZWxTaXplfSwgJHt2aXpIZWlnaHQvMn0pIHJvdGF0ZSgtOTApYClcblx0XHRcdC5jbGFzc2VkKCdtZWRpdW1UZXh0JywgdHJ1ZSlcblx0XHRcdC50ZXh0KGQgPT4gZClcblxuXHRcdHRoaXMueUF4aXNGYWNldFNlbGVjdC5zZWxlY3RBbGwoJ2ZvcmVpZ25PYmplY3QnKVxuXHRcdFx0LmRhdGEoZGVmYXVsdEF4aXNUaWNrcy55QXhpc1RpY2tzKVxuXHRcdCAgLmpvaW4oJ2ZvcmVpZ25PYmplY3QnKVxuXHRcdFx0LmF0dHIoJ3dpZHRoJywgbWF4TGFiZWxXaWR0aClcblx0XHRcdC5hdHRyKCdoZWlnaHQnLCBtaW5pU2l6ZSlcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCAoZCwgaSkgPT4gYHRyYW5zbGF0ZSgkey1tYXhMYWJlbFdpZHRoIC0gbGFiZWxQYWRkaW5nfSwgJHtpICogKG1pbmlTaXplICsgbWluaVBhZGRpbmcpfSlgKVxuXHRcdCAgXHQuc2VsZWN0QWxsKCdkaXYnKVxuXHRcdCBcdC5kYXRhKGQgPT4gW2RdKSBcblx0XHQgIC5qb2luKCd4aHRtbDpkaXYnKVxuXHRcdFx0LmF0dHIoJ3N0eWxlJywgYGhlaWdodDogJHttaW5pU2l6ZX1weDtgKVxuXHRcdFx0LmNsYXNzZWQoJ3knLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ2F4aXNCdXR0b25Db250YWluZXInLCB0cnVlKVxuXHRcdFx0LnNlbGVjdEFsbCgnYnV0dG9uJylcblx0XHRcdC5kYXRhKGQgPT4gW2RdKVxuXHRcdCAgLmpvaW4oJ2J1dHRvbicpXG5cdFx0XHQuY2xhc3NlZCgnYmFzaWNJY29uQnV0dG9uJywgdHJ1ZSlcblx0XHRcdC5hdHRyKCdzdHlsZScsIGBtYXgtd2lkdGg6ICR7bWF4TGFiZWxXaWR0aH1weDsgbWluLXdpZHRoOiAke21heExhYmVsV2lkdGh9cHg7YClcblx0XHRcdC5hdHRyKCd0aXRsZScsIGQgPT4gZClcblx0XHRcdC5vbignY2xpY2snLCAoZCkgPT4gXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmFsbENvbmRpdGlvbnNUcnVlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnNldEFsbENvbmRpdGlvbnNGYWxzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCByb3dNYXAgPSB0aGlzLnRlbXBDb25kaXRpb25GaWx0ZXJTdGF0ZS5nZXQoZCk7XG5cdFx0XHRcdGxldCBuZXdWYWx1ZTogYm9vbGVhbiA9ICFBcnJheSguLi5yb3dNYXAudmFsdWVzKCkpLmV2ZXJ5KHggPT4geClcblx0XHRcdFx0Zm9yIChsZXQga2V5IG9mIHJvd01hcC5rZXlzKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyb3dNYXAuc2V0KGtleSwgbmV3VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRlQ29uZGl0aW9uRmlsdGVyU2VsZWN0aW9uKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdtb3VzZWVudGVyJywgKGxhYmVsLCBpKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5taW5pQ2VsbFNlbGVjdFxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoJ3JlY3QnKVxuXHRcdFx0XHRcdC5kYXRhKGQgPT4gW2RdKVxuXHRcdFx0XHRcdC5jbGFzc2VkKCdob3ZlcmVkJywgZCA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxldCBbbDEsIF9sMl0gPSBkO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGwxID09PSBsYWJlbDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB0aGlzLm1pbmlDZWxsU2VsZWN0LnNlbGVjdEFsbCgncmVjdCcpLmNsYXNzZWQoJ2hvdmVyZWQnLCBmYWxzZSkpXG5cdFx0XHQudGV4dChkID0+IGQpO1xuXHRcdFxuXHRcdGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gMzY7XG5cblx0XHR0aGlzLnhBeGlzRmFjZXRTZWxlY3Rcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCAke21hcmdpbi50b3AgKyB2aXpIZWlnaHR9KWApO1xuXHRcdFxuXHRcdHRoaXMueEF4aXNGYWNldFNlbGVjdC5zZWxlY3RBbGwoJ3RleHQnKVxuXHRcdFx0LmRhdGEoW2RlZmF1bHRBeGlzVGlja3MuYXhpc0xhYmVsc1sxXV0pXG5cdFx0ICAuam9pbigndGV4dCcpXG5cdFx0XHQuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcblx0XHRcdC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdoYW5naW5nJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dml6V2lkdGggLyAyfSwgJHttYXhMYWJlbEhlaWdodCArIDIgKiBsYWJlbFBhZGRpbmd9KWApXG5cdFx0XHQuY2xhc3NlZCgnbWVkaXVtVGV4dCcsIHRydWUpXG5cdFx0XHQudGV4dChkID0+IGQpXG5cblx0XHR0aGlzLnhBeGlzRmFjZXRTZWxlY3Quc2VsZWN0QWxsKCdmb3JlaWduT2JqZWN0Jylcblx0XHRcdC5kYXRhKGRlZmF1bHRBeGlzVGlja3MueEF4aXNUaWNrcylcblx0XHQgIC5qb2luKCdmb3JlaWduT2JqZWN0Jylcblx0XHRcdC5hdHRyKCd3aWR0aCcsIG1pbmlTaXplKVxuXHRcdFx0LmF0dHIoJ2hlaWdodCcsIG1heExhYmVsSGVpZ2h0KVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIChkLCBpKSA9PiBgdHJhbnNsYXRlKCR7aSAqIChtaW5pU2l6ZSArIG1pbmlQYWRkaW5nKX0sICR7bGFiZWxQYWRkaW5nfSlgKVxuXHRcdFx0LnNlbGVjdEFsbCgnZGl2Jylcblx0XHRcdC5kYXRhKGQgPT4gW2RdKVxuXHRcdCAgLmpvaW4oJ3hodG1sOmRpdicpXG5cdFx0XHQuY2xhc3NlZCgneCcsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0J1dHRvbkNvbnRhaW5lcicsIHRydWUpXG5cdFx0XHQuc2VsZWN0QWxsKCdidXR0b24nKVxuXHRcdFx0LmRhdGEoZCA9PiBbZF0pXG5cdFx0ICAuam9pbignYnV0dG9uJylcblx0XHQgIFx0LmNsYXNzZWQoJ2Jhc2ljSWNvbkJ1dHRvbicsIHRydWUpXG5cdFx0XHQuYXR0cignc3R5bGUnLCBgbWF4LXdpZHRoOiAke21pbmlTaXplfXB4OyBtaW4td2lkdGg6ICR7bWluaVNpemV9cHg7IGhlaWdodDogJHttYXhMYWJlbEhlaWdodH1weGApXG5cdFx0ICBcdC5hdHRyKCd0aXRsZScsIGQgPT4gZClcblx0XHRcdC5vbignY2xpY2snLCAoZCkgPT4gXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmFsbENvbmRpdGlvbnNUcnVlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnNldEFsbENvbmRpdGlvbnNGYWxzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHJvd0xpc3Q6IE1hcDxzdHJpbmcsIGJvb2xlYW4+W10gPSBBcnJheSguLi50aGlzLnRlbXBDb25kaXRpb25GaWx0ZXJTdGF0ZS52YWx1ZXMoKSlcblx0XHRcdFx0Y29uc3QgY29sVmFsdWVzOiBib29sZWFuW10gPSByb3dMaXN0Lm1hcChtID0+IG0uZ2V0KGQpKVxuXHRcdFx0XHRjb25zdCBuZXdWYWx1ZTogYm9vbGVhbiA9ICFjb2xWYWx1ZXMuZXZlcnkoeCA9PiB4KVxuXHRcdFx0XHRmb3IgKGxldCBtYXAgb2Ygcm93TGlzdClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1hcC5zZXQoZCwgbmV3VmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRlQ29uZGl0aW9uRmlsdGVyU2VsZWN0aW9uKCk7XG5cdFx0XHR9KVxuXHRcdFx0Lm9uKCdtb3VzZWVudGVyJywgKGxhYmVsLCBpKSA9PiBcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5taW5pQ2VsbFNlbGVjdFxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoJ3JlY3QnKVxuXHRcdFx0XHRcdC5kYXRhKGQgPT4gW2RdKVxuXHRcdFx0XHRcdC5jbGFzc2VkKCdob3ZlcmVkJywgZCA9PlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxldCBbX2wxLCBsMl0gPSBkO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGwyID09PSBsYWJlbDtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pXG5cdFx0XHQub24oJ21vdXNlbGVhdmUnLCAoKSA9PiB0aGlzLm1pbmlDZWxsU2VsZWN0LnNlbGVjdEFsbCgncmVjdCcpLmNsYXNzZWQoJ2hvdmVyZWQnLCBmYWxzZSkpXG5cdFx0XHQudGV4dChkID0+IGQpO1xuXG5cdFx0Ly8gYWRkIGFsbCBidXR0b25cblx0XHR0aGlzLnlBeGlzRmFjZXRTZWxlY3QuYXBwZW5kKCdmb3JlaWduT2JqZWN0Jylcblx0XHRcdC5hdHRyKCd3aWR0aCcsIG1heExhYmVsV2lkdGgpXG5cdFx0XHQuYXR0cignaGVpZ2h0JywgbWF4TGFiZWxIZWlnaHQpXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgkey1tYXhMYWJlbFdpZHRoIC0gbGFiZWxQYWRkaW5nfSwgJHt2aXpIZWlnaHQgKyBsYWJlbFBhZGRpbmd9KWApXG5cdFx0ICAuYXBwZW5kKCd4aHRtbDpkaXYnKVxuXHRcdFx0LmNsYXNzZWQoJ3gnLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ2F4aXNCdXR0b25Db250YWluZXInLCB0cnVlKVxuXHRcdCAgLmFwcGVuZCgnYnV0dG9uJylcblx0XHQgIFx0LmNsYXNzZWQoJ2Jhc2ljSWNvbkJ1dHRvbicsIHRydWUpXG5cdFx0XHQuYXR0cignc3R5bGUnLCBgbWF4LXdpZHRoOiAke21heExhYmVsV2lkdGh9cHg7IG1pbi13aWR0aDogJHttYXhMYWJlbFdpZHRofXB4OyBoZWlnaHQ6ICR7bWF4TGFiZWxIZWlnaHR9cHhgKVxuXHRcdCAgXHQuYXR0cigndGl0bGUnLCAnU2VsZWN0IGFsbCBjb25kaXRpb25zJylcblx0XHRcdC50ZXh0KCdBbGwnKVxuXHRcdFx0Lm9uKCdjbGljaycsICgpID0+XG5cdFx0XHR7XG5cdFx0XHRcdGlmICh0aGlzLmFsbENvbmRpdGlvbnNUcnVlKCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLnNldEFsbENvbmRpdGlvbnNGYWxzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuc2V0QWxsQ29uZGl0aW9uc1RydWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0ZUNvbmRpdGlvbkZpbHRlclNlbGVjdGlvbigpO1xuXHRcdFx0fSlcblx0XHRcdC5vbignbW91c2VlbnRlcicsICgpID0+IHRoaXMubWluaUNlbGxTZWxlY3Quc2VsZWN0QWxsKCdyZWN0JykuY2xhc3NlZCgnaG92ZXJlZCcsIHRydWUpKVxuXHRcdFx0Lm9uKCdtb3VzZWxlYXZlJywgKCkgPT4gdGhpcy5taW5pQ2VsbFNlbGVjdC5zZWxlY3RBbGwoJ3JlY3QnKS5jbGFzc2VkKCdob3ZlcmVkJywgZmFsc2UpKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0R3Jvd3RoTGluZShcblx0XHRsYWJlbDogW3N0cmluZywgc3RyaW5nXSxcblx0XHRmYWNldHM6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIEN1cnZlTGlzdD4+LFxuXHRcdGxpbmVGdW5jOiBkMy5MaW5lPFtudW1iZXIsIG51bWJlcl0+LFxuXHRcdHNlbGVjdGlvbjogYm9vbGVhbixcblx0XHRtYWtlQXJlYVBhdGg6IGJvb2xlYW4sXG5cdFx0bWluWVZhbHVlPzogbnVtYmVyKTogc3RyaW5nXG5cdHtcblx0XHRsZXQgW2RydWdMYWJlbCwgY29uY0xhYmVsXSA9IGxhYmVsO1xuXHRcdGlmICghZmFjZXRzLmhhcyhkcnVnTGFiZWwpKVxuXHRcdHtcblx0XHRcdHJldHVybiAnJzsgLy8gZW1wdHkgd2hlbiBubyBkYXRhXG5cdFx0fVxuXHRcdGxldCByb3cgPSBmYWNldHMuZ2V0KGRydWdMYWJlbCk7XG5cdFx0aWYgKCFyb3cuaGFzKGNvbmNMYWJlbCkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRsZXQgZGF0YTogQ3VydmVMaXN0ID0gcm93LmdldChjb25jTGFiZWwpXG5cdFx0bGV0IGF2ZXJnZUdyb3d0aExpbmUgPSBbLi4uZGF0YS5nZXRBdmVyYWdlQ3VydmUodGhpcy55S2V5LCBzZWxlY3Rpb24sIHRoaXMuc21vb3RoQ3VydmVzKV07XG5cdFx0aWYgKGF2ZXJnZUdyb3d0aExpbmUubGVuZ3RoID09PSAwKVxuXHRcdHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cdFx0aWYgKG1ha2VBcmVhUGF0aClcblx0XHR7XG5cdFx0XHRsZXQgZmlyc3QgPSBhdmVyZ2VHcm93dGhMaW5lWzBdO1xuXHRcdFx0YXZlcmdlR3Jvd3RoTGluZS51bnNoaWZ0KFtmaXJzdFswXSwgbWluWVZhbHVlXSk7XG5cdFx0XHRcblx0XHRcdGxldCBsYXN0ID0gYXZlcmdlR3Jvd3RoTGluZVthdmVyZ2VHcm93dGhMaW5lLmxlbmd0aCAtIDFdO1xuXHRcdFx0YXZlcmdlR3Jvd3RoTGluZS5wdXNoKFtsYXN0WzBdLCBtaW5ZVmFsdWVdKTtcblx0XHRcdC8vIGF2ZXJnZUdyb3d0aExpbmUucHVzaChbZmlyc3RbMF0sIG1pbllWYWx1ZV0pO1xuXG5cdFx0fVxuXHRcdHJldHVybiBsaW5lRnVuYyhhdmVyZ2VHcm93dGhMaW5lKTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0RXh0ZW50T2ZHcm93dGhDdXJ2ZXMoZmFjZXRzOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBDdXJ2ZUxpc3Q+PiwgZmlsdGVyZWRPbmx5OiBib29sZWFuID0gZmFsc2UpOiBbbnVtYmVyLCBudW1iZXJdXG5cdHtcblx0XHRsZXQgbWluTWFzcyA9IEluZmluaXR5O1xuXHRcdGxldCBtYXhNYXNzID0gLUluZmluaXR5O1xuXHRcdGZvciAobGV0IG1hcCBvZiBmYWNldHMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgZGF0YSBvZiBtYXAudmFsdWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCB0aGlzTWluOiBudW1iZXJcblx0XHRcdFx0bGV0IHRoaXNNYXg6IG51bWJlcjtcblx0XHRcdFx0aWYgKGZpbHRlcmVkT25seSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXNNaW4gPSBJbmZpbml0eTtcblx0XHRcdFx0XHR0aGlzTWF4ID0gLUluZmluaXR5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IGFsbERhdGFQb2ludHMgPSBkYXRhLmdldEF2ZXJhZ2VDdXJ2ZSh0aGlzLnlLZXksIGZhbHNlLCB0aGlzLnNtb290aEN1cnZlcyk7XG5cdFx0XHRcdFx0dGhpc01pbiA9IGQzLm1pbihhbGxEYXRhUG9pbnRzLCBkID0+IGRbMV0pO1xuXHRcdFx0XHRcdHRoaXNNYXggPSBkMy5tYXgoYWxsRGF0YVBvaW50cywgZCA9PiBkWzFdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBkYXRhUG9pbnRzID0gZGF0YS5nZXRBdmVyYWdlQ3VydmUodGhpcy55S2V5LCB0cnVlLCB0aGlzLnNtb290aEN1cnZlcyk7XG5cdFx0XHRcdGNvbnN0IHNob3VsZENoZWNrRmlsdGVyZWQgPSAoZmlsdGVyZWRPbmx5IHx8IHRoaXMuZGF0YS5icnVzaEFwcGxpZWQpICYmIGRhdGFQb2ludHMubGVuZ3RoID4gMDtcblx0XHRcdFx0aWYgKHNob3VsZENoZWNrRmlsdGVyZWQpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzTWluID0gTWF0aC5taW4odGhpc01pbiwgZDMubWluKGRhdGFQb2ludHMsIGQgPT4gZFsxXSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG1pbk1hc3MgPSBNYXRoLm1pbih0aGlzTWluLCBtaW5NYXNzKTtcblxuXHRcdFx0XHRpZiAoc2hvdWxkQ2hlY2tGaWx0ZXJlZClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXNNYXggPSBNYXRoLm1heCh0aGlzTWF4LCBkMy5tYXgoZGF0YVBvaW50cywgZCA9PiBkWzFdKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4TWFzcyA9IE1hdGgubWF4KHRoaXNNYXgsIG1heE1hc3MpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gW21pbk1hc3MsIG1heE1hc3NdO1xuXHR9XG5cblx0cHJpdmF0ZSBhZGRBcHBseUJ1dHRvbihjb250YWluZXI6IEh0bWxTZWxlY3Rpb24pOiB2b2lkXG5cdHtcdFxuXHRcdGxldCBidXR0b25TZWxlY3QgPSBjb250YWluZXJcblx0XHRcdC5zZWxlY3RBbGwoJ2Rpdi5hcHBseUJ1dHRvbkNvbnRhaW5lcicpXG5cdFx0XHQuZGF0YShbNDJdKVxuXHRcdC5qb2luKCdkaXYnKVxuXHRcdFx0LmNsYXNzZWQoJ2FwcGx5QnV0dG9uQ29udGFpbmVyJywgdHJ1ZSlcblx0XHRcdC5zZWxlY3RBbGwoJ2J1dHRvbicpXG5cdFx0XHQuZGF0YShbNDJdKVxuXHRcdC5qb2luKCdidXR0b24nKVxuXHRcdFx0LmF0dHIoJ2lkJywgJ2NvbmRpdGlvbkZpbHRlckFwcGx5QnV0dG9uJylcblx0XHRcdC50ZXh0KCdBcHBseSBGaWx0ZXInKVxuXHRcdFx0LmNsYXNzZWQoJ2RldmxpYkJ1dHRvbicsIHRydWUpXG5cdFx0XHQuY2xhc3NlZCgnYmlnJywgdHJ1ZSlcblx0XHRcdC5vbignY2xpY2snLCAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmNvcHlUZW1wQ29uZGl0aW9uc1RvTW9kZWwoKTtcblx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmRpdGlvbkZpbHRlckFwcGx5QnV0dG9uJykpO1xuXHRcdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChEYXRhRXZlbnRzLmFwcGx5TmV3RmlsdGVyKSk7XG5cdFx0XHR9KTtcblx0XHREZXZsaWJUU1V0aWwuaGlkZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZGl0aW9uRmlsdGVyQXBwbHlCdXR0b24nKSk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUNvbmRpdGlvbkZpbHRlclNlbGVjdGlvbigpOiB2b2lkXG5cdHtcblx0XHR0aGlzLm1pbmlDZWxsU2VsZWN0LmNsYXNzZWQoJ2luRmlsdGVyJywgZCA9PiBcblx0XHR7XG5cdFx0XHRpZiAoIXRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLmhhcyhkWzBdKSlcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGxldFJvd0ZpbHRlcnMgPSB0aGlzLnRlbXBDb25kaXRpb25GaWx0ZXJTdGF0ZS5nZXQoZFswXSlcblx0XHRcdGlmICh0aGlzLnRlbXBDb25kaXRpb25GaWx0ZXJTdGF0ZS5oYXMoZFsxXSkpXG5cdFx0XHR7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBsZXRSb3dGaWx0ZXJzLmdldChkWzFdKTtcblx0XHR9KTtcblxuXHRcdGxldCBhcHBseUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25kaXRpb25GaWx0ZXJBcHBseUJ1dHRvbicpO1xuXHRcdGlmICh0aGlzLnRlbXBDb25kaXRpb25zRGlmZmVyZW50KCkpXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLnNob3coYXBwbHlCdXR0b24pO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLmhpZGUoYXBwbHlCdXR0b24pO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgcmVzZXRUZW1wQ29uZGl0aW9uRmlsdGVyKCk6IHZvaWRcblx0e1xuXHRcdGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmRhdGFTdXBlcnNldC5jb25kaXRpb25GaWx0ZXJTdGF0ZS5lbnRyaWVzKCkpXG5cdFx0e1xuXHRcdFx0dGhpcy50ZW1wQ29uZGl0aW9uRmlsdGVyU3RhdGUuc2V0KGtleSwgbmV3IE1hcCh2YWx1ZSkpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYWxsQ29uZGl0aW9uc1RydWUoKTogYm9vbGVhblxuXHR7XG5cdFx0Zm9yIChsZXQgbWFwIG9mIHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLnZhbHVlcygpKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IHZhbCBvZiBtYXAudmFsdWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghdmFsKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cHJpdmF0ZSBzZXRBbGxDb25kaXRpb25zRmFsc2UoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgbWFwIG9mIHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLnZhbHVlcygpKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IGtleSBvZiBtYXAua2V5cygpKVxuXHRcdFx0e1xuXHRcdFx0XHRtYXAuc2V0KGtleSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc2V0QWxsQ29uZGl0aW9uc1RydWUoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgbWFwIG9mIHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLnZhbHVlcygpKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IGtleSBvZiBtYXAua2V5cygpKVxuXHRcdFx0e1xuXHRcdFx0XHRtYXAuc2V0KGtleSwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSB0ZW1wQ29uZGl0aW9uc0RpZmZlcmVudCgpOiBib29sZWFuXG5cdHtcblx0XHRmb3IgKGxldCBrZXkxIG9mIHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLmtleXMoKSlcblx0XHR7XG5cdFx0XHRsZXQgaW5uZXJLZXlWYWxzID0gdGhpcy50ZW1wQ29uZGl0aW9uRmlsdGVyU3RhdGUuZ2V0KGtleTEpLmVudHJpZXMoKTtcblx0XHRcdGZvciAobGV0IFtrZXkyLCB2YWxdIG9mIGlubmVyS2V5VmFscylcblx0XHRcdHtcblx0XHRcdFx0aWYgKHZhbCAhPT0gdGhpcy5mdWxsRGF0YS5jb25kaXRpb25GaWx0ZXJTdGF0ZS5nZXQoa2V5MSk/LmdldChrZXkyKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHByaXZhdGUgY29weVRlbXBDb25kaXRpb25zVG9Nb2RlbCgpOiB2b2lkXG5cdHtcblx0XHRmb3IgKGxldCBrZXkxIG9mIHRoaXMudGVtcENvbmRpdGlvbkZpbHRlclN0YXRlLmtleXMoKSlcblx0XHR7XG5cdFx0XHRsZXQgaW5uZXJLZXlWYWxzID0gdGhpcy50ZW1wQ29uZGl0aW9uRmlsdGVyU3RhdGUuZ2V0KGtleTEpLmVudHJpZXMoKTtcblx0XHRcdGZvciAobGV0IFtrZXkyLCB2YWxdIG9mIGlubmVyS2V5VmFscylcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5mdWxsRGF0YS5jb25kaXRpb25GaWx0ZXJTdGF0ZS5nZXQoa2V5MSk/LnNldChrZXkyLCB2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0cHJvdGVjdGVkIGRyYXdGYWNldENvbnRlbnQoKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMuaW5BdmVyYWdlTW9kZSlcblx0XHR7XG5cdFx0XHR0aGlzLnN3YXBTdmdWaXNpYmlsaXR5KCk7XG5cdFx0XHR0aGlzLnVwZGF0ZVBhdGhzKCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRzdXBlci5kcmF3RmFjZXRDb250ZW50KCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBkcmF3TGFiZWxzKGxhYmVsRGF0YTogW3N0cmluZywgW251bWJlciwgbnVtYmVyXSB8IG51bGxdW10pOiB2b2lkXG5cdHtcblx0XHRjb25zdCBpbmRleGVkUG9pbnRzOiBbc3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdIHwgbnVsbCwgbnVtYmVyXVtdID0gbGFiZWxEYXRhLm1hcCgoZCxpKSA9PiBbZFswXSwgZFsxXSwgaV0pO1xuXHRcdGNvbnN0IHZhbGlkUG9pbnRzID0gaW5kZXhlZFBvaW50cy5maWx0ZXIoKHgsIGkpID0+IHhbMV0gIT09IG51bGwpO1xuXHRcdGNvbnN0IHBpeGVsU3BhY2VQb2ludHM6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVtdID0gdmFsaWRQb2ludHMubWFwKGQgPT4gW3RoaXMuc2NhbGVYKGRbMV1bMF0pLCB0aGlzLnNjYWxlWShkWzFdWzFdKSwgZFsyXV0pO1xuXHRcdHRoaXMuYXZlcmFnZUN1cnZlTGFiZWxDb250YWluZXIuc2VsZWN0QWxsKCdjaXJjbGUnKVxuXHRcdFx0LmRhdGEocGl4ZWxTcGFjZVBvaW50cylcblx0XHRcdC5qb2luKCdjaXJjbGUnKVxuXHRcdFx0LmF0dHIoJ2N4JywgZCA9PiBkWzBdKVxuXHRcdFx0LmF0dHIoJ2N5JywgZCA9PiBkWzFdKVxuXHRcdFx0LmF0dHIoJ3InLCAzKVxuXHRcdFx0LmF0dHIoJ2ZpbGwnLCBkID0+IEdyb3VwQnlXaWRnZXQuZ2V0Q29sb3IobGFiZWxEYXRhW2RbMl1dWzBdLnNwbGl0KCdfX18nKSwgdGhpcy5jb2xvckxvb2t1cCkpO1xuXG5cdFx0Y29uc3QgcmFkaXVzID0gZDMuc2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+KClcblx0XHRcdC5kb21haW4oWzUsNTBdKVxuXHRcdFx0LnJhbmdlKFs5LDJdKVxuXHRcdFx0LmNsYW1wKHRydWUpXG5cdFx0XHQobGFiZWxEYXRhLmxlbmd0aCk7XG5cblx0XHRjb25zdCBmb3JjZU5vZGVzOiBhbnlbXSA9IHBpeGVsU3BhY2VQb2ludHMubWFwKGQgPT4ge3JldHVybiB7eDogZFswXSwgeTogZFsxXSB9fSk7XG5cdFx0dGhpcy5fZm9yY2VTaW11bGF0aW9uID0gZDMuZm9yY2VTaW11bGF0aW9uKGZvcmNlTm9kZXMpXG5cdFx0XHQuZm9yY2UoJ2NvbnRyYWludFgnLCBhbHBoYSA9PiBcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmb3JjZU5vZGVzLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0IC8vIG1ha2UgeCBwb3NpdGlvbiBhIGhhcmQgY29uc3RyYWludFxuXHRcdFx0XHRcdGZvcmNlTm9kZXNbaV0ueCA9IHBpeGVsU3BhY2VQb2ludHNbaV1bMF07XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQuZm9yY2UoJ3JlcGVsJywgZDMuZm9yY2VDb2xsaWRlKCkucmFkaXVzKHJhZGl1cykpXG5cdFx0XHQuZm9yY2UoJ2F0dHJhY3RZJywgZDMuZm9yY2VZKCkueShkID0+IFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHBpeGVsU3BhY2VQb2ludHNbZC5pbmRleF1bMV07XG5cdFx0XHRcdH0pKVxuXHRcdFx0Lm9uKCd0aWNrJywgKCkgPT4gXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnNvbGUubG9nKCd0aWNrJylcblx0XHRcdH0pO1xuXHRcdHRoaXMuZm9yY2VTaW11bGF0aW9uLnN0b3AoKTtcblx0XHR0aGlzLmZvcmNlU2ltdWxhdGlvbi50aWNrKDEwMDApO1xuXG5cblx0XHRjb25zdCBmb250U2l6ZSA9IGQzLnNjYWxlTGluZWFyPG51bWJlciwgbnVtYmVyPigpXG5cdFx0XHQuZG9tYWluKFs1LDMwXSlcblx0XHRcdC5yYW5nZShbMTIsN10pXG5cdFx0XHQuY2xhbXAodHJ1ZSlcblx0XHRcdChsYWJlbERhdGEubGVuZ3RoKTtcblx0XHRcblx0XHRjb25zdCBob3Jpem9udGFsUGFkID0gMTI7XG5cdFx0dGhpcy5hdmVyYWdlQ3VydmVMYWJlbENvbnRhaW5lci5zZWxlY3RBbGwoJ3RleHQnKVxuXHRcdFx0LmRhdGEoZm9yY2VOb2Rlcylcblx0XHRcdC5qb2luKCd0ZXh0Jylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBkID0+IGB0cmFuc2xhdGUoJHtkLnggKyBob3Jpem9udGFsUGFkfSwgJHtkLnl9KWApXG5cdFx0XHQuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ2NlbnRyYWwnKVxuXHRcdFx0LnRleHQoKGQsaSkgPT4gbGFiZWxEYXRhW2ldWzBdLnJlcGxhY2UoJ19fXycsICcgJykpXG5cdFx0XHQuYXR0cignc3R5bGUnLCBgZm9udC1zaXplOiAke2ZvbnRTaXplfXB0O2ApXG5cdFx0XHQuYXR0cignc3Ryb2tlJywgKGQsIGkpID0+IEdyb3VwQnlXaWRnZXQuZ2V0Q29sb3IobGFiZWxEYXRhW3BpeGVsU3BhY2VQb2ludHNbaV1bMl1dWzBdLnNwbGl0KCdfX18nKSwgdGhpcy5jb2xvckxvb2t1cCkpXG5cdFx0XHQuYXR0cignZmlsbCcsIChkLCBpKSA9PiBHcm91cEJ5V2lkZ2V0LmdldENvbG9yKGxhYmVsRGF0YVtwaXhlbFNwYWNlUG9pbnRzW2ldWzJdXVswXS5zcGxpdCgnX19fJyksIHRoaXMuY29sb3JMb29rdXApKTtcblx0XHRcdFxuXHR9XG5cblx0cHJpdmF0ZSBjbGVhckxhYmVscygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmF2ZXJhZ2VDdXJ2ZUxhYmVsQ29udGFpbmVyLmh0bWwobnVsbCk7XG5cdH1cblxuXG5cdHByaXZhdGUgZHJhd0F4aXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy54QXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0fSlgKVxuXHRcdFx0LmNhbGwoZDMuYXhpc0JvdHRvbSh0aGlzLnNjYWxlWCkudGlja3MoNSkpO1xuXG5cdFx0dGhpcy55QXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYClcblx0XHRcdC5jYWxsKGQzLmF4aXNMZWZ0KHRoaXMuc2NhbGVZKS50aWNrcyg1KSk7XG5cdH1cblx0XG5cdHByaXZhdGUgZHJhd0xlZ2VuZCgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmRyYXdBdmVyYWdlTGVnZW5kKCk7XG5cdFx0dGhpcy5kcmF3RmFjZXRMZWdlbmQoKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0F2ZXJhZ2VMZWdlbmQoKTogdm9pZFxuXHR7XG5cdFx0Y29uc3QgbGluZVdpZHRoID0gMjQ7XG5cdFx0Y29uc3QgdGV4dE9mZnNldCA9IDQ7XG5cdFx0Y29uc3Qgc2VsZWN0ZWRUZXh0V2lkdGggPSA1NTsgLy8gYXBwcm94aW1hdGVcblx0XHRjb25zdCBiZXR3ZWVuUGFkID0gMjA7XG5cdFx0dGhpcy5hdmVyYWdlTGVnZW5kU2VsZWN0LmFwcGVuZCgnbGluZScpXG5cdFx0XHQuYXR0cigneDEnLCAwKVxuXHRcdFx0LmF0dHIoJ3gyJywgbGluZVdpZHRoKVxuXHRcdFx0LmF0dHIoJ3kxJywgMClcblx0XHRcdC5hdHRyKCd5MicsIDApXG5cdFx0XHQuYXR0cignc3Ryb2tlLXdpZHRoJywgMilcblx0XHRcdC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxuXHRcdFx0LmF0dHIoJ29wYWNpdHknLCAwLjg1KTtcblxuXHRcdHRoaXMuYXZlcmFnZUxlZ2VuZFNlbGVjdC5hcHBlbmQoJ2NpcmNsZScpXG5cdFx0XHQuYXR0cignY3gnLCBsaW5lV2lkdGgpXG5cdFx0XHQuYXR0cignY3knLCAwKVxuXHRcdFx0LmF0dHIoJ3InLCAzKVxuXHRcdFx0LmF0dHIoJ2ZpbGwnLCAnYmxhY2snKVxuXHRcdFx0LmF0dHIoJ29wYWNpdHknLCAwLjg1KTtcblxuXHRcdHRoaXMuYXZlcmFnZUxlZ2VuZFNlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsICdtaWRkbGUnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtsaW5lV2lkdGggKyB0ZXh0T2Zmc2V0fSwwKWApXG5cdFx0XHQuY2xhc3NlZCgnc21hbGxUZXh0JywgdHJ1ZSlcblx0XHRcdC50ZXh0KCdTZWxlY3RlZCcpO1xuXG5cdFx0dGhpcy5hdmVyYWdlTGVnZW5kU2VsZWN0LmFwcGVuZCgnbGluZScpXG5cdFx0XHQuYXR0cigneDEnLCB0ZXh0T2Zmc2V0ICsgc2VsZWN0ZWRUZXh0V2lkdGggKyBiZXR3ZWVuUGFkICsgbGluZVdpZHRoKVxuXHRcdFx0LmF0dHIoJ3gyJywgdGV4dE9mZnNldCArIHNlbGVjdGVkVGV4dFdpZHRoICsgYmV0d2VlblBhZCArIDIgKiBsaW5lV2lkdGgpXG5cdFx0XHQuYXR0cigneTEnLCAwKVxuXHRcdFx0LmF0dHIoJ3kyJywgMClcblx0XHRcdC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxuXHRcdFx0LmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG5cdFx0XHQuYXR0cignb3BhY2l0eScsIDAuOCk7XG5cblx0XHR0aGlzLmF2ZXJhZ2VMZWdlbmRTZWxlY3QuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7MiAqIGxpbmVXaWR0aCArIDIgKiB0ZXh0T2Zmc2V0ICsgc2VsZWN0ZWRUZXh0V2lkdGggKyBiZXR3ZWVuUGFkfSwwKWApXG5cdFx0XHQuY2xhc3NlZCgnc21hbGxUZXh0JywgdHJ1ZSlcblx0XHRcdC50ZXh0KCdBbGwnKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0ZhY2V0TGVnZW5kKCk6IHZvaWRcblx0e1xuXHRcdGNvbnN0IGxpbmVXaWR0aCA9IDI0O1xuXHRcdGNvbnN0IHRleHRPZmZzZXQgPSA0O1xuXHRcdGNvbnN0IHNlbGVjdGVkVGV4dFdpZHRoID0gNTU7IC8vIGFwcHJveGltYXRlXG5cdFx0Y29uc3QgYmV0d2VlblBhZCA9IDIwO1xuXHRcdHRoaXMuZmFjZXRMZWdlbmRTZWxlY3QuYXBwZW5kKCdsaW5lJylcblx0XHRcdC5hdHRyKCd4MScsIDApXG5cdFx0XHQuYXR0cigneDInLCBsaW5lV2lkdGgpXG5cdFx0XHQuYXR0cigneTEnLCAwKVxuXHRcdFx0LmF0dHIoJ3kyJywgMClcblx0XHRcdC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKVxuXHRcdFx0LmF0dHIoJ3N0cm9rZScsICdibGFjaycpXG5cblx0XHR0aGlzLmZhY2V0TGVnZW5kU2VsZWN0LmFwcGVuZCgndGV4dCcpXG5cdFx0XHQuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywgJ21pZGRsZScpXG5cdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2xpbmVXaWR0aCArIHRleHRPZmZzZXR9LDApYClcblx0XHRcdC5jbGFzc2VkKCdzbWFsbFRleHQnLCB0cnVlKVxuXHRcdFx0LnRleHQoJ1NlbGVjdGVkJyk7XG5cdFxuXHRcdHRoaXMuZmFjZXRMZWdlbmRTZWxlY3QuYXBwZW5kKCdyZWN0Jylcblx0XHRcdC5hdHRyKCd4JywgdGV4dE9mZnNldCArIHNlbGVjdGVkVGV4dFdpZHRoICsgYmV0d2VlblBhZCArIGxpbmVXaWR0aClcblx0XHRcdC5hdHRyKCd5JywgMClcblx0XHRcdC5hdHRyKCd3aWR0aCcsIGxpbmVXaWR0aClcblx0XHRcdC5hdHRyKCdoZWlnaHQnLCBsaW5lV2lkdGgvMilcblx0XHRcdC5hdHRyKCdzdHJva2UnLCAnbm9uZScpXG5cdFx0XHQuYXR0cignZmlsbCcsICdyZ2IoMjM2LCAyMzYsIDIzNiknKTtcblxuXHRcdHRoaXMuZmFjZXRMZWdlbmRTZWxlY3QuYXBwZW5kKCdsaW5lJylcblx0XHRcdC5hdHRyKCd4MScsIHRleHRPZmZzZXQgKyBzZWxlY3RlZFRleHRXaWR0aCArIGJldHdlZW5QYWQgKyBsaW5lV2lkdGgpXG5cdFx0XHQuYXR0cigneDInLCB0ZXh0T2Zmc2V0ICsgc2VsZWN0ZWRUZXh0V2lkdGggKyBiZXR3ZWVuUGFkICsgMiAqIGxpbmVXaWR0aClcblx0XHRcdC5hdHRyKCd5MScsIDApXG5cdFx0XHQuYXR0cigneTInLCAwKVxuXHRcdFx0LmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpXG5cdFx0XHQuYXR0cignc3Ryb2tlJywgJ2JsYWNrJylcblx0XHRcdC5hdHRyKCdvcGFjaXR5JywgMC42KTtcblxuXHRcdHRoaXMuZmFjZXRMZWdlbmRTZWxlY3QuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnbWlkZGxlJylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7MiAqIGxpbmVXaWR0aCArIDIgKiB0ZXh0T2Zmc2V0ICsgc2VsZWN0ZWRUZXh0V2lkdGggKyBiZXR3ZWVuUGFkfSwwKWApXG5cdFx0XHQuY2xhc3NlZCgnc21hbGxUZXh0JywgdHJ1ZSlcblx0XHRcdC50ZXh0KCdBbGwnKTtcblx0fVxuXG4gICAgcHJpdmF0ZSBzaG93TGFiZWwoKTogdm9pZFxuICAgIHtcblx0XHR0aGlzLnhMYWJlbFRleHRTZWxlY3Rcblx0XHRcdC50ZXh0KHRoaXMueEtleSlcblx0XHRcdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG5cblx0XHR0aGlzLnlMYWJlbFRleHRTZWxlY3Rcblx0XHRcdC50ZXh0KHRoaXMueUtleSlcblx0XHRcdC5jbGFzc2VkKCdub0Rpc3AnLCBmYWxzZSk7XG5cdFx0XG4gICAgfVxuXG5cdHByb3RlY3RlZCBPblJlc2l6ZSgpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5kYXRhKVxuXHRcdHtcblx0XHRcdHRoaXMuc3ZnU2VsZWN0LmF0dHIoJ3dpZHRoJywgdGhpcy53aWR0aCk7XG5cdFx0XHR0aGlzLnN2Z1NlbGVjdC5hdHRyKCdoZWlnaHQnLCB0aGlzLmhlaWdodCk7XG5cblx0XHRcdHRoaXMuc3ZnRmFjZXRTZWxlY3QuYXR0cignd2lkdGgnLCB0aGlzLndpZHRoKTtcblx0XHRcdHRoaXMuc3ZnRmFjZXRTZWxlY3QuYXR0cignaGVpZ2h0JywgdGhpcy5oZWlnaHQpO1xuXG5cdFx0XHR0aGlzLmF2ZXJhZ2VMZWdlbmRTZWxlY3QuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnQvMn0sICR7dGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgKyA0NH0pYCk7XG5cdFx0XHR0aGlzLmZhY2V0TGVnZW5kU2VsZWN0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0LzJ9LCAke3RoaXMubWFyZ2luLnRvcCArIHRoaXMudml6SGVpZ2h0ICsgNDR9KWApO1xuXHRcdFxuXG5cdFx0XHR0aGlzLmNhbnZhc0NvbnRhaW5lclxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQpO1xuXG5cdFx0XHRkMy5zZWxlY3QodGhpcy5jYW52YXNFbGVtZW50KVxuXHRcdFx0XHQuYXR0cignd2lkdGgnLCB0aGlzLnZpeldpZHRoKVxuXHRcdFx0XHQuYXR0cignaGVpZ2h0JywgdGhpcy52aXpIZWlnaHQpO1xuXHRcdFx0XHRcblx0XHRcdHRoaXMudXBkYXRlU2NhbGVzKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZVBhdGhzKCk7XG5cdFx0XHR0aGlzLnBvc2l0aW9uTGFiZWxzKCk7XG5cdFx0XHR0aGlzLmRyYXdBeGlzKCk7XG5cdFx0fVxuXHRcdHRoaXMucmVzaXplQnJ1c2goKTtcblx0fVxuXG5cdHByaXZhdGUgcmVzaXplQnJ1c2goKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5pbml0QnJ1c2goKTtcblx0XHRpZiAodGhpcy5sYXN0WVZhbHVlQnJ1c2hCb3VuZCA9PSBudWxsIHx8IHRoaXMubGFzdFhWYWx1ZUJydXNoQm91bmQgPT0gbnVsbClcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBsZWZ0ID0gdGhpcy5zY2FsZVgodGhpcy5sYXN0WFZhbHVlQnJ1c2hCb3VuZFswXSk7XG5cdFx0bGV0IHJpZ2h0ID0gdGhpcy5zY2FsZVgodGhpcy5sYXN0WFZhbHVlQnJ1c2hCb3VuZFsxXSk7XG5cdFx0bGV0IHRvcCA9IHRoaXMuc2NhbGVZKHRoaXMubGFzdFlWYWx1ZUJydXNoQm91bmRbMV0pO1xuXHRcdGxldCBib3R0b20gPSB0aGlzLnNjYWxlWSh0aGlzLmxhc3RZVmFsdWVCcnVzaEJvdW5kWzBdKTtcblx0XHR0aGlzLmJydXNoR3JvdXBTZWxlY3QuY2FsbCh0aGlzLmJydXNoLm1vdmUsIFtbbGVmdCwgdG9wXSwgW3JpZ2h0LCBib3R0b21dXSk7XG5cdH1cblxuXHRwcml2YXRlIGJydXNoSGFuZGxlcigpOiB2b2lkXG5cdHtcblx0XHRjb25zdCBzZWxlY3Rpb246IFtbbnVtYmVyLCBudW1iZXJdLCBbbnVtYmVyLCBudW1iZXJdXSB8IG51bGwgIHwgdW5kZWZpbmVkID0gZDMuZXZlbnQuc2VsZWN0aW9uO1xuXHRcdGlmICh0eXBlb2Ygc2VsZWN0aW9uID09PSBcInVuZGVmaW5lZFwiIHx8IHNlbGVjdGlvbiA9PT0gbnVsbClcblx0XHR7XG5cdFx0XHR0aGlzLmRhdGEucmVtb3ZlQ3VydmVCcnVzaCh0aGlzLkNvbXBvbmVudElkKTtcblx0XHRcdHRoaXMuX2xhc3RYVmFsdWVCcnVzaEJvdW5kID0gbnVsbDtcblx0XHRcdHRoaXMuX2xhc3RZVmFsdWVCcnVzaEJvdW5kID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgW1tsZWZ0LCB0b3BdLCBbcmlnaHQsIGJvdHRvbV1dID0gc2VsZWN0aW9uO1xuXG5cdFx0bGV0IG1pblggPSB0aGlzLnNjYWxlWC5pbnZlcnQobGVmdCk7XG5cdFx0bGV0IG1heFggPSB0aGlzLnNjYWxlWC5pbnZlcnQocmlnaHQpO1xuXHRcdHRoaXMuX2xhc3RYVmFsdWVCcnVzaEJvdW5kID0gW21pblgsIG1heFhdO1xuXHRcdGxldCB4VmFsdWVGaWx0ZXI6IHZhbHVlRmlsdGVyID0ge1xuXHRcdFx0a2V5OiB0aGlzLnhLZXksXG5cdFx0XHRib3VuZDogdGhpcy5sYXN0WFZhbHVlQnJ1c2hCb3VuZFxuXHRcdH1cblxuXHRcdGxldCBtaW5ZID0gdGhpcy5zY2FsZVkuaW52ZXJ0KGJvdHRvbSk7XG5cdFx0bGV0IG1heFkgPSB0aGlzLnNjYWxlWS5pbnZlcnQodG9wKTtcblx0XHR0aGlzLl9sYXN0WVZhbHVlQnJ1c2hCb3VuZCA9IFttaW5ZLCBtYXhZXTtcblx0XHRsZXQgeVZhbHVlRmlsdGVyOiB2YWx1ZUZpbHRlciA9IHtcblx0XHRcdGtleTogdGhpcy55S2V5LFxuXHRcdFx0Ym91bmQ6IHRoaXMubGFzdFlWYWx1ZUJydXNoQm91bmRcblx0XHR9XG5cdFx0dGhpcy5kYXRhLmFkZEN1cnZlQnJ1c2godGhpcy5Db21wb25lbnRJZCwgW3hWYWx1ZUZpbHRlciwgeVZhbHVlRmlsdGVyXSk7XG5cblx0fVxuXHRcblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgZmFjZXQgb2YgdGhpcy5mYWNldExpc3QpXG5cdFx0e1xuXHRcdFx0ZmFjZXQuZGF0YS5fYXZlcmFnZUZpbHRlcmVkQ3VydmVDYWNoZS5jbGVhcigpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5pbkF2ZXJhZ2VNb2RlKVxuXHRcdHtcblx0XHRcdHRoaXMudXBkYXRlU2NhbGVzKCk7XG5cdFx0fVxuXHRcdHRoaXMudXBkYXRlUGF0aHMoKTtcblx0fVxuXG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHsgRGV2bGliVFNVdGlsIH0gZnJvbSBcIi4uL2RldmxpYi9EZXZsaWJUU1V0aWxcIjtcblxuZXhwb3J0IGNsYXNzIFJpY2hUb29sdGlwXG57XG5cbiAgICBjb25zdHJ1Y3Rvcih3YWl0VG9TaG93OiBudW1iZXIgPSAzNTAsIHdhaXRUb0hpZGU6IG51bWJlciA9IDIwMClcbiAgICB7XG4gICAgICAgIHRoaXMuX3dhaXRUb1Nob3cgPSB3YWl0VG9TaG93O1xuICAgICAgICB0aGlzLl93YWl0VG9IaWRlID0gd2FpdFRvSGlkZTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIERldmxpYlRTVXRpbC5oaWRlKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3JpY2hUb29sdGlwJyk7XG4gICAgICAgIHRoaXMuX3Nob3dUaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5IaWRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGlkZVRpbWVyICYmIHRoaXMuaGlkZVRpbWVyUnVubmluZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVUaW1lci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zaG93VGltZXJSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faGlkZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgRGV2bGliVFNVdGlsLmhpZGUodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgIC8vIHNob3VsZG4ndCBuZWVkIHRoaXMsIGJ1dCBJIHdhcyBydW5uaW5nIGludG8gYSBwcm9ibGVtIHdoZXJlIHN0b3AgdGltZXIgd2FzIGdldHRpbmcgc3R1Y2sgaW4gYSBsb29wLlxuICAgICAgICAgICAgIC8vIHRoaXMgYXBwZWFycyB0byBmaXggaXQuXG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lci5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICB9XG5cbiAgICBcbiAgICBwcml2YXRlIF93YWl0VG9TaG93IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgd2FpdFRvU2hvdygpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRUb1Nob3c7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfd2FpdFRvSGlkZSA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHdhaXRUb0hpZGUoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWl0VG9IaWRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NvbnRhaW5lciA6IEhUTUxEaXZFbGVtZW50O1xuICAgIHB1YmxpYyBnZXQgY29udGFpbmVyKCkgOiBIVE1MRGl2RWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX3Nob3dUaW1lclJ1bm5pbmcgOiBib29sZWFuO1xuICAgIHB1YmxpYyBnZXQgc2hvd1RpbWVyUnVubmluZygpIDogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93VGltZXJSdW5uaW5nO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9zaG93VGltZXIgOiBkMy5UaW1lcjtcbiAgICBwdWJsaWMgZ2V0IHNob3dUaW1lcigpIDogZDMuVGltZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1RpbWVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2hpZGVUaW1lciA6IGQzLlRpbWVyO1xuICAgIHB1YmxpYyBnZXQgaGlkZVRpbWVyKCkgOiBkMy5UaW1lciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlVGltZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaGlkZVRpbWVyUnVubmluZyA6IGJvb2xlYW47XG4gICAgcHVibGljIGdldCBoaWRlVGltZXJSdW5uaW5nKCkgOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGVUaW1lclJ1bm5pbmc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaGlkZUNhbGxiYWNrIDogKGVsYXBzZWQ6IG51bWJlcikgPT4gdm9pZDtcbiAgICBwdWJsaWMgZ2V0IGhpZGVDYWxsYmFjaygpIDogKGVsYXBzZWQ6IG51bWJlcikgPT4gdm9pZCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlQ2FsbGJhY2s7XG4gICAgfVxuXG4gICAgcHVibGljIFNob3coaHRtbFN0cmluZzogc3RyaW5nLCBwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCB3YWl0T3ZlcnJpZGU/OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjb25zdCBjYWxsYmFja0Z1bmMgPSAoKSA9PiB0aGlzLmRyYXdUb29sdGlwKGh0bWxTdHJpbmcsIHBhZ2VYLCBwYWdlWSlcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWVyUnVubmluZylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zaG93VGltZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWxheTogbnVtYmVyXG4gICAgICAgIGlmICh0eXBlb2Ygd2FpdE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsYXkgPSB3YWl0T3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWxheSA9IHRoaXMud2FpdFRvU2hvdztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaG93VGltZXIgPSBkMy50aW1lb3V0KGNhbGxiYWNrRnVuYywgZGVsYXkpO1xuICAgICAgICB0aGlzLl9zaG93VGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaGlkZVRpbWVyUnVubmluZylcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5oaWRlVGltZXIuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkcmF3VG9vbHRpcChodG1sU3RyaW5nOiBzdHJpbmcsIHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9zaG93VGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWxTdHJpbmc7XG5cbiAgICAgICAgLy8gbmVlZCB0byBkaXNwbGF5IGFzIGhpZGRlbiB0byBnZXQgd2lkdGhcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICBEZXZsaWJUU1V0aWwuc2hvdyh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIGxldCBib3VuZFJlY3QgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IGNvbnRhaW5lclJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIFByaW9yaXR5IGZvciBwbGFjZW1lbnQgaXMgcmlnaHQsIGJlbG93LCBsZWZ0LCBhYm92ZVxuICAgICAgICBjb25zdCBvZmZzZXQgPSAyMDsgLy8gc3BhY2UgYmV0d2VlbiBsYWJlbCBhbmQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgZWRnZU1hcmdpbiA9IDEwOyAvLyB3aGl0ZXNwYWNlIHJlcXVpcmVkIGJldHdlZW4gbGFiZWwgYW5kIGVkZ2Ugb2YgZG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IHBhZCA9IG9mZnNldCAgKyBlZGdlTWFyZ2luO1xuICAgICAgICBsZXQgc3BhY2VSaWdodCA9IGNvbnRhaW5lclJlY3QucmlnaHQgLSBwYWdlWDtcbiAgICAgICAgbGV0IHNwYWNlQmVsb3cgPSBjb250YWluZXJSZWN0LmJvdHRvbSAtIHBhZ2VZO1xuICAgICAgICBsZXQgc3BhY2VMZWZ0ID0gY29udGFpbmVyUmVjdC53aWR0aCAtIHNwYWNlUmlnaHQ7XG4gICAgICAgIGxldCBzcGFjZUFib3ZlID0gY29udGFpbmVyUmVjdC5oZWlnaHQgLSBzcGFjZUJlbG93O1xuICAgICAgICBsZXQgdyA9IGJvdW5kUmVjdC53aWR0aDtcbiAgICAgICAgbGV0IGggPSBib3VuZFJlY3QuaGVpZ2h0O1xuICAgICAgICBsZXQgdzIgPSB3IC8gMi4wO1xuICAgICAgICBsZXQgaDIgPSBoIC8gMi4wO1xuICAgICAgICBsZXQgW3RvcCwgbGVmdF06IFtudW1iZXIsIG51bWJlcl0gPSBbMCwgMF07XG4gICAgICAgIGlmIChzcGFjZVJpZ2h0ID49IHcgKyBwYWQgJiYgc3BhY2VBYm92ZSA+PSBoMiArIGVkZ2VNYXJnaW4gJiYgc3BhY2VCZWxvdyA+PSBoMiArIGVkZ2VNYXJnaW4pXG4gICAgICAgIHtcbiAgICAgICAgICAgIFt0b3AsIGxlZnRdID0gdGhpcy5wb3NpdGlvblJpZ2h0KHBhZ2VYLCBwYWdlWSwgYm91bmRSZWN0LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNwYWNlQmVsb3cgPj0gaCArIHBhZCAmJiBzcGFjZVJpZ2h0ID49IGgyICsgZWRnZU1hcmdpbiAmJiBzcGFjZUxlZnQgPj0gaDIgKyBlZGdlTWFyZ2luKVxuICAgICAgICB7XG4gICAgICAgICAgICBbdG9wLCBsZWZ0XSA9IHRoaXMucG9zaXRpb25CZWxvdyhwYWdlWCwgcGFnZVksIGJvdW5kUmVjdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcGFjZUxlZnQgPj0gdyArIHBhZCAmJiBzcGFjZUFib3ZlID49IGgyICsgZWRnZU1hcmdpbiAmJiBzcGFjZUJlbG93ID49IGgyICsgZWRnZU1hcmdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgW3RvcCwgbGVmdF0gPSB0aGlzLnBvc2l0aW9uTGVmdChwYWdlWCwgcGFnZVksIGJvdW5kUmVjdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIFt0b3AsIGxlZnRdID0gdGhpcy5wb3NpdGlvbkFib3ZlKHBhZ2VYLCBwYWdlWSwgYm91bmRSZWN0LCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gVE9ETyBUaGlzIGNhbiBzdGlsbCBydW4gaW50byBwcm9ibGVtcyBpZiB0aGUgeCBhbmQgeSBhcmUgYXQgY29ybmVycywgYW5kIHRoaXMgcG9pbnQgZ2V0J3MgcmVhY2hlZC5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvblJpZ2h0KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIGJvdW5kUmVjdDogRE9NUmVjdCwgb2Zmc2V0OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdXG4gICAge1xuICAgICAgICBsZXQgdG9wID0gcGFnZVkgLSBib3VuZFJlY3QuaGVpZ2h0IC8gMi4wO1xuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIHByaXZhdGUgcG9zaXRpb25CZWxvdyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBib3VuZFJlY3Q6IERPTVJlY3QsIG9mZnNldDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXVxuICAgIHtcbiAgICAgICAgbGV0IHRvcCA9IHBhZ2VZICsgb2Zmc2V0O1xuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYIC0gYm91bmRSZWN0LndpZHRoIC8gMi4wO1xuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIHByaXZhdGUgcG9zaXRpb25MZWZ0KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIGJvdW5kUmVjdDogRE9NUmVjdCwgb2Zmc2V0OiBudW1iZXIpOiBbbnVtYmVyLCBudW1iZXJdXG4gICAge1xuICAgICAgICBsZXQgdG9wID0gcGFnZVkgLSBib3VuZFJlY3QuaGVpZ2h0IC8gMi4wO1xuICAgICAgICBsZXQgbGVmdCA9IHBhZ2VYIC0gb2Zmc2V0IC0gYm91bmRSZWN0LndpZHRoO1xuICAgICAgICByZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIHByaXZhdGUgcG9zaXRpb25BYm92ZShwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBib3VuZFJlY3Q6IERPTVJlY3QsIG9mZnNldDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXVxuICAgIHtcbiAgICAgICAgbGV0IHRvcCA9IHBhZ2VZIC0gb2Zmc2V0IC0gYm91bmRSZWN0LmhlaWdodDtcbiAgICAgICAgbGV0IGxlZnQgPSBwYWdlWCAtIGJvdW5kUmVjdC53aWR0aCAvIDIuMDtcbiAgICAgICAgcmV0dXJuIFt0b3AsIGxlZnRdO1xuICAgIH1cblxuICAgIHB1YmxpYyBIaWRlKHdhaXRPdmVycmlkZT86IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnNob3dUaW1lclJ1bm5pbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd1RpbWVyLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3dUaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhpZGVUaW1lciAmJiB0aGlzLmhpZGVUaW1lclJ1bm5pbmcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGRlbGF5OiBudW1iZXI7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdhaXRPdmVycmlkZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSB3YWl0T3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSB0aGlzLndhaXRUb0hpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oaWRlVGltZXIgPSBkMy50aW1lb3V0KHRoaXMuaGlkZUNhbGxiYWNrLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlkZVRpbWVyUnVubmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVMYWJlbFZhbHVlTGlzdENvbnRlbnQobGFiZWxWYWx1ZUxpc3Q6IFtzdHJpbmcsIHN0cmluZyB8IG51bGxdW10pOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBpbm5lckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpbm5lckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCd0b29sdGlwSW5uZXJDb250YWluZXInKVxuICAgICAgICBcbiAgICAgICAgZDMuc2VsZWN0KGlubmVyQ29udGFpbmVyKS5zZWxlY3RBbGwoJ3AnKVxuICAgICAgICAuZGF0YShsYWJlbFZhbHVlTGlzdClcbiAgICAgICAgLmpvaW4oJ3AnKVxuICAgICAgICAuaHRtbChkID0+IHtcbiAgICAgICAgICAgIGlmIChkWzFdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBkWzBdICsgJzogPGI+JyArIGRbMV0gKyAnPC9iPic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJzxpPicgKyBkWzBdICsgJzwvaT4nO1xuICAgICAgICB9KVxuICAgICAgICAuY2xhc3NlZCgndG9vbHRpcERpc3BsYXlSb3cnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlubmVyQ29udGFpbmVyLm91dGVySFRNTDtcbiAgICB9XG59IiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHtTdmdTZWxlY3Rpb259IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcyc7XG5pbXBvcnQge0Jhc2VXaWRnZXR9IGZyb20gJy4vQmFzZVdpZGdldCc7XG5pbXBvcnQgeyBORGltIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJztcbmltcG9ydCB7UG9pbnRDb2xsZWN0aW9ufSBmcm9tICcuLi9EYXRhTW9kZWwvUG9pbnRDb2xsZWN0aW9uJztcbmltcG9ydCB7IERhdGFzZXRTcGVjLCBGYWNldCwgdmFsdWVGaWx0ZXIgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBTY2F0dGVyUGxvdFdpZGdldCBleHRlbmRzIEJhc2VXaWRnZXQ8UG9pbnRDb2xsZWN0aW9uLCBEYXRhc2V0U3BlYz4ge1xuXHRcblx0Y29uc3RydWN0b3IoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgeEtleTogc3RyaW5nLCB5S2V5OiBzdHJpbmcsIGNhbkJydXNoOiBib29sZWFuID0gdHJ1ZSwgaXNDbG9uZTogYm9vbGVhbiA9IGZhbHNlKVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyLCB0cnVlLCBjYW5CcnVzaCk7XG5cdFx0dGhpcy5feEtleSA9IHhLZXk7XG5cdFx0dGhpcy5feUtleSA9IHlLZXk7XG5cdFx0dGhpcy5faXNDbG9uZSA9IGlzQ2xvbmU7XG5cdFx0dGhpcy5zZXRMYWJlbCgpO1xuXHR9XG5cblx0cHJvdGVjdGVkIENsb25lKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiBCYXNlV2lkZ2V0PFBvaW50Q29sbGVjdGlvbiwgRGF0YXNldFNwZWM+XG4gICAge1xuXHRcdGNvbnN0IGNhbkJydXNoID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgU2NhdHRlclBsb3RXaWRnZXQoY29udGFpbmVyLCB0aGlzLnhLZXksICB0aGlzLnlLZXksIGNhbkJydXNoLCB0cnVlKTtcblx0fVxuXHRcblx0cHJvdGVjdGVkIGluaXRQcm9wcyhwcm9wcz86IGFueVtdKTogdm9pZFxuXHR7XG5cdFx0c3VwZXIuaW5pdFByb3BzKCk7XG5cdFx0dGhpcy5fY2FuQnJ1c2ggPSBwcm9wc1swXTtcblx0fVxuXG5cdHByaXZhdGUgX2lzQ2xvbmUgOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGlzQ2xvbmUoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pc0Nsb25lO1xuXHR9XG5cblx0cHJpdmF0ZSBfeEtleSA6IHN0cmluZztcblx0cHVibGljIGdldCB4S2V5KCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl94S2V5O1xuXHR9XG5cblx0cHJpdmF0ZSBfeUtleSA6IHN0cmluZztcblx0cHVibGljIGdldCB5S2V5KCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl95S2V5O1xuXHR9XG5cblx0cHJpdmF0ZSBfc3ZnU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHN2Z1NlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ZnU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfbWFpbkdyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IG1haW5Hcm91cFNlbGVjdCgpIDogU3ZnU2VsZWN0aW9uIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFpbkdyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY2FudmFzRWxlbWVudCA6IEhUTUxDYW52YXNFbGVtZW50O1xuXHRwdWJsaWMgZ2V0IGNhbnZhc0VsZW1lbnQoKSA6IEhUTUxDYW52YXNFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzRWxlbWVudDtcblx0fVxuXG5cdHByaXZhdGUgX2NhbkJydXNoIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBjYW5CcnVzaCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbkJydXNoO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2hHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCBicnVzaEdyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaEdyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeEF4aXNHcm91cFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4QXhpc0dyb3VwU2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94QXhpc0dyb3VwU2VsZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfeExhYmVsVGV4dFNlbGVjdCA6IFN2Z1NlbGVjdGlvbjtcblx0cHVibGljIGdldCB4TGFiZWxUZXh0U2VsZWN0KCkgOiBTdmdTZWxlY3Rpb24ge1xuXHRcdHJldHVybiB0aGlzLl94TGFiZWxUZXh0U2VsZWN0O1xuXHR9XG5cblxuXHRwcml2YXRlIF95QXhpc0dyb3VwU2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHlBeGlzR3JvdXBTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lBeGlzR3JvdXBTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF95TGFiZWxUZXh0U2VsZWN0IDogU3ZnU2VsZWN0aW9uO1xuXHRwdWJsaWMgZ2V0IHlMYWJlbFRleHRTZWxlY3QoKSA6IFN2Z1NlbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3lMYWJlbFRleHRTZWxlY3Q7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVggOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVYKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVg7XG5cdH1cblxuXHRwcml2YXRlIF9zY2FsZVkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgc2NhbGVZKCkgOiBkMy5TY2FsZUxpbmVhcjxudW1iZXIsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl9zY2FsZVk7XG5cdH1cblxuXHRwcml2YXRlIF95QXhpc1BhZGRpbmcgOiAgbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IHlBeGlzUGFkZGluZygpIDogIG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX3lBeGlzUGFkZGluZztcblx0fVxuXG5cdHByaXZhdGUgX2JydXNoIDogZDMuQnJ1c2hCZWhhdmlvcjxhbnk+O1xuXHRwdWJsaWMgZ2V0IGJydXNoKCkgOiBkMy5CcnVzaEJlaGF2aW9yPGFueT4ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaDtcblx0fVxuXG5cdHByb3RlY3RlZCBzZXRNYXJnaW4oKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fbWFyZ2luID0ge1xuXHRcdFx0dG9wOiA4LFxuXHRcdFx0cmlnaHQ6IDgsXG5cdFx0XHRib3R0b206IDU2LFxuXHRcdFx0bGVmdDogODBcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgaW5pdCgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9zdmdTZWxlY3QgPSBkMy5zZWxlY3QodGhpcy5jb250YWluZXIpLmFwcGVuZChcInN2Z1wiKVxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB0aGlzLndpZHRoKVxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQpO1xuXG5cdFx0dGhpcy5fbWFpbkdyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApO1xuXHRcdFxuXHRcdHRoaXMuX2NhbnZhc0VsZW1lbnQgPSB0aGlzLm1haW5Hcm91cFNlbGVjdFxuXHRcdFx0LmFwcGVuZCgnZm9yZWlnbk9iamVjdCcpXG5cdFx0XHRcdC5hdHRyKCd3aWR0aCcsIHRoaXMudml6V2lkdGgpXG5cdFx0XHRcdC5hdHRyKCdoZWlnaHQnLCB0aGlzLnZpekhlaWdodClcblx0XHRcdC5hcHBlbmQoJ3hodG1sOmNhbnZhcycpXG5cdFx0XHRcdC5hdHRyKCd3aWR0aCcsIHRoaXMudml6V2lkdGgpXG5cdFx0XHRcdC5hdHRyKCdoZWlnaHQnLCB0aGlzLnZpekhlaWdodClcblx0XHRcdC5ub2RlKCkgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG5cblx0XHRpZiAodGhpcy5jYW5CcnVzaClcblx0XHR7XG5cdFx0XHR0aGlzLl9icnVzaEdyb3VwU2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKFwiZ1wiKVxuXHRcdFx0XHQuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke3RoaXMubWFyZ2luLmxlZnR9LCAke3RoaXMubWFyZ2luLnRvcH0pYClcblx0XHRcdFx0LmNsYXNzZWQoXCJicnVzaENvbnRhaW5lclwiLCB0cnVlKTtcblxuXHRcdFx0dGhpcy5fYnJ1c2ggPSBkMy5icnVzaCgpXG5cdFx0XHRcdC5leHRlbnQoW1swLCAwXSwgW3RoaXMudml6V2lkdGgsIHRoaXMudml6SGVpZ2h0XV0pXG5cdFx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7IHRoaXMuYnJ1c2hIYW5kbGVyKCkgfSk7XG5cdFx0XG5cdFx0XHR0aGlzLmJydXNoR3JvdXBTZWxlY3QuY2FsbCh0aGlzLmJydXNoKTtcblx0XHR9XG5cdFx0XHRcblx0XHR0aGlzLl95QXhpc1BhZGRpbmcgPSAyMDtcblx0XHRcdFxuXHRcdHRoaXMuX3hBeGlzR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodH0pYClcblx0XHRcdC5jbGFzc2VkKFwibGFiZWxDb2xvclwiLCB0cnVlKTtcblx0XHRcdFxuXHRcdHRoaXMuX3lBeGlzR3JvdXBTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ2cnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbi5sZWZ0fSwgJHt0aGlzLm1hcmdpbi50b3B9KWApXG5cdFx0XHQuY2xhc3NlZChcImxhYmVsQ29sb3JcIiwgdHJ1ZSk7XG5cdH1cblxuXHRwcml2YXRlIHNldExhYmVsKCk6IHZvaWRcblx0e1xuXHRcdGNvbnN0IGJ1ZmZlckZvckF4aXMgPSAzMjtcblx0XHR0aGlzLl94TGFiZWxUZXh0U2VsZWN0ID0gdGhpcy5zdmdTZWxlY3QuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5tYXJnaW4ubGVmdCArIHRoaXMudml6V2lkdGggLyAyfSwgJHt0aGlzLm1hcmdpbi50b3AgKyB0aGlzLnZpekhlaWdodCArIGJ1ZmZlckZvckF4aXN9KWApXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcblx0XHRcdC50ZXh0KHRoaXMueEtleSk7XG5cblx0XHRsZXQgdHJhbnNYID0gdGhpcy5tYXJnaW4ubGVmdCAtIGJ1ZmZlckZvckF4aXMgLSB0aGlzLnlBeGlzUGFkZGluZztcblx0XHRsZXQgdHJhbnNZID0gdGhpcy5tYXJnaW4udG9wICsgdGhpcy52aXpIZWlnaHQgLyAyO1xuXHRcdGxldCB0cmFuc2Zvcm1UZXh0OiBzdHJpbmc7XG5cdFx0aWYgKHRoaXMueUtleS5sZW5ndGggPT09IDEpXG5cdFx0e1xuXHRcdFx0dHJhbnNmb3JtVGV4dCA9IGB0cmFuc2xhdGUoJHt0cmFuc1h9LCAke3RyYW5zWX0pYDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRyYW5zZm9ybVRleHQgPSBgcm90YXRlKC05MCkgdHJhbnNsYXRlKCR7LXRyYW5zWX0sICR7dHJhbnNYfSlgO1xuXHRcdH1cblxuXHRcdHRoaXMuX3lMYWJlbFRleHRTZWxlY3QgPSB0aGlzLnN2Z1NlbGVjdC5hcHBlbmQoJ3RleHQnKVxuXHRcdFx0LmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybVRleHQpXG5cdFx0XHQuY2xhc3NlZCgnYXhpc0xhYmVsJywgdHJ1ZSlcblx0XHRcdC5jbGFzc2VkKCdsYWJlbENvbG9yJywgdHJ1ZSlcblx0XHRcdC50ZXh0KHRoaXMueUtleSk7XG5cdH1cblxuXHRwdWJsaWMgT25EYXRhQ2hhbmdlKClcblx0e1xuXHRcdHRoaXMudXBkYXRlU2NhbGVzKCk7XG5cdFx0dGhpcy5kcmF3UG9pbnRzKCk7XG5cdFx0dGhpcy5kcmF3QXhpcygpO1xuXHR9XG5cblx0cHJpdmF0ZSBkcmF3UG9pbnRzKCk6IHZvaWRcblx0e1xuXHRcdGxldCB2YWxpZFBvaW50cyA9IHRoaXMuZGF0YS5BcnJheS5maWx0ZXIoKHBvaW50OiBORGltKSA9PiBcblx0XHRcdHtcblxuXHRcdFx0XHRyZXR1cm4gIWlzTmFOKHBvaW50LmdldCh0aGlzLnhLZXkpKVxuXHRcdFx0XHRcdCYmICFpc05hTihwb2ludC5nZXQodGhpcy55S2V5KSlcblx0XHRcdFx0XHQmJiBwb2ludC5pbkJydXNoO1xuXHRcdFx0fSk7XG5cblx0XHRjb25zdCBjYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG5cdFx0Y2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwwLCB0aGlzLnZpeldpZHRoLCB0aGlzLnZpekhlaWdodCk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkUG9pbnRzLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdGxldCBwb2ludCA9IHZhbGlkUG9pbnRzW2ldO1xuXHRcdFx0bGV0IHggPSB0aGlzLnNjYWxlWChwb2ludC5nZXQodGhpcy54S2V5KSk7XG5cdFx0XHRsZXQgeSA9IHRoaXMuc2NhbGVZKHBvaW50LmdldCh0aGlzLnlLZXkpKTtcblx0XHRcdGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG5cdFx0XHRjb25zdCByYWRpdXMgPSAwLjU7XG5cdFx0XHRjYW52YXNDb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcblx0XHRcdGNhbnZhc0NvbnRleHQuZmlsbCgpO1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCBkcmF3RmFjZXRlZERhdGEoZmFjZXRMaXN0OiBGYWNldFtdKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5kcmF3RmFjZXRlZERhdGFEZWZhdWx0KGZhY2V0TGlzdCwgXCIzMDBweFwiLCBcIjMwMHB4XCIpO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVTY2FsZXMoKTogdm9pZFxuXHR7XG5cdFx0bGV0IGRhdGE6IFBvaW50Q29sbGVjdGlvbjtcblx0XHRpZiAodGhpcy5pc0Nsb25lKVxuXHRcdHtcblx0XHRcdGRhdGEgPSB0aGlzLmZ1bGxEYXRhO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0ZGF0YSA9IHRoaXMuZGF0YTtcblx0XHR9XG5cdFx0bGV0IG1pbk1heFggPSBkYXRhLmdldE1pbk1heCh0aGlzLnhLZXkpO1xuXHRcdHRoaXMuX3NjYWxlWCA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4obWluTWF4WClcblx0XHRcdC5yYW5nZShbMCwgdGhpcy52aXpXaWR0aF0pO1xuXG5cdFx0bGV0IG1pbk1heFkgPSBkYXRhLmdldE1pbk1heCh0aGlzLnlLZXkpO1xuXHRcdHRoaXMuX3NjYWxlWSA9IGQzLnNjYWxlTGluZWFyKClcblx0XHRcdC5kb21haW4obWluTWF4WSlcblx0XHRcdC5yYW5nZShbdGhpcy52aXpIZWlnaHQsIDBdKTtcblx0fVxuXG5cdHByaXZhdGUgZHJhd0F4aXMoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy54QXhpc0dyb3VwU2VsZWN0XG5cdFx0XHQuY2FsbChkMy5heGlzQm90dG9tKHRoaXMuc2NhbGVYKS50aWNrcyg1KSk7XG5cblx0XHR0aGlzLnlBeGlzR3JvdXBTZWxlY3Rcblx0XHRcdC5jYWxsKGQzLmF4aXNMZWZ0KHRoaXMuc2NhbGVZKS50aWNrcyg1KSk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0Ly8gcmVzaXplIGlzIGhhbmRsZWQgYnkgY3NzIC8gSFRNTFxuXHR9XG5cblx0cHJpdmF0ZSBicnVzaEhhbmRsZXIoKTogIHZvaWRcblx0e1xuXHRcdGNvbnN0IHNlbGVjdGlvbjogW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dIHwgbnVsbCAgfCB1bmRlZmluZWQgPSBkMy5ldmVudC5zZWxlY3Rpb247XG5cdFx0aWYgKHR5cGVvZiBzZWxlY3Rpb24gPT09IFwidW5kZWZpbmVkXCIgfHwgc2VsZWN0aW9uID09PSBudWxsKVxuXHRcdHtcblx0XHRcdHRoaXMuZGF0YS5yZW1vdmVCcnVzaCh0aGlzLkNvbXBvbmVudElkKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0bGV0IFtbbGVmdCwgdG9wXSwgW3JpZ2h0LCBib3R0b21dXSA9IHNlbGVjdGlvbjtcblx0XHRcblx0XHRsZXQgbWluWCA9IHRoaXMuc2NhbGVYLmludmVydChsZWZ0KTtcblx0XHRsZXQgbWF4WCA9IHRoaXMuc2NhbGVYLmludmVydChyaWdodCk7XG5cdFx0bGV0IHhWYWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRoaXMueEtleSxcblx0XHRcdGJvdW5kOiBbbWluWCwgbWF4WF1cblx0XHR9XG5cblx0XHRsZXQgbWluWSA9IHRoaXMuc2NhbGVZLmludmVydChib3R0b20pO1xuXHRcdGxldCBtYXhZID0gdGhpcy5zY2FsZVkuaW52ZXJ0KHRvcCk7XG5cdFx0bGV0IHlWYWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRoaXMueUtleSxcblx0XHRcdGJvdW5kOiBbbWluWSwgbWF4WV1cblx0XHR9XG5cblx0XHR0aGlzLmRhdGEuYWRkQnJ1c2godGhpcy5Db21wb25lbnRJZCwgeFZhbHVlRmlsdGVyLCB5VmFsdWVGaWx0ZXIpO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucyhcIm5vRGlzcFwiKSlcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gaGlkZSBkeW5hbWljYWxseVxuXHRcdHRoaXMuZHJhd1BvaW50cygpO1xuXHR9XG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQge0h0bWxTZWxlY3Rpb24sIFN2Z1NlbGVjdGlvbiwgVG9vbGJhckVsZW1lbnQsIFRvb2xiYXJPcHRpb25TZWxlY3R9IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcyc7XG5pbXBvcnQgeyBEZXZsaWJUU1V0aWwgfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVFNVdGlsJztcbmltcG9ydCB7IEJhc2VXaWRnZXQgfSBmcm9tICcuL0Jhc2VXaWRnZXQnO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vRGF0YU1vZGVsL0N1cnZlTGlzdCc7XG5pbXBvcnQgeyBkYXRhRmlsdGVyLCBEYXRhc2V0U3BlYywgdmFsdWVGaWx0ZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBEYXRhRXZlbnRzIH0gZnJvbSAnLi4vRGF0YU1vZGVsL0RhdGFFdmVudHMnO1xuaW1wb3J0IHsgSURCUERhdGFiYXNlLCBvcGVuREIgfSBmcm9tICdpZGInO1xuXG5leHBvcnQgY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VXaWRnZXQ8Q3VydmVMaXN0LCBEYXRhc2V0U3BlYz4ge1xuXHRcblx0Y29uc3RydWN0b3IoY29udGFpbmVyOiBFbGVtZW50KVxuXHR7XG5cdFx0c3VwZXIoY29udGFpbmVyKTtcblx0fVxuXG5cdHByaXZhdGUgX3VwbG9hZEZpbGVCdXR0b25XcmFwcGVyIDogSFRNTERpdkVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgdXBsb2FkRmlsZUJ1dHRvbldyYXBwZXIoKSA6IEhUTUxEaXZFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fdXBsb2FkRmlsZUJ1dHRvbldyYXBwZXI7XG5cdH1cblx0XG5cdHByaXZhdGUgX3Rvb2xiYXJFbGVtZW50cyA6IFRvb2xiYXJFbGVtZW50W107XG5cdHB1YmxpYyBnZXQgdG9vbGJhckVsZW1lbnRzKCkgOiBUb29sYmFyRWxlbWVudFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fdG9vbGJhckVsZW1lbnRzO1xuXHR9XG5cblx0cHJpdmF0ZSBfd3JhcHBlckRpdiA6IEhUTUxEaXZFbGVtZW50O1xuXHRwdWJsaWMgZ2V0IHdyYXBwZXJEaXYoKSA6IEhUTUxEaXZFbGVtZW50IHtcblx0XHRyZXR1cm4gdGhpcy5fd3JhcHBlckRpdjtcblx0fVxuXG5cdHByaXZhdGUgX21vZGFsUG9wdXBEaXYgOiBIVE1MRGl2RWxlbWVudDtcblx0cHVibGljIGdldCBtb2RhbFBvcHVwRGl2KCkgOiBIVE1MRGl2RWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGFsUG9wdXBEaXY7XG5cdH1cblxuXHRwcml2YXRlIF9tb2RhbEJvb2xlYW5zIDogYm9vbGVhbltdO1xuXHRwdWJsaWMgZ2V0IG1vZGFsQm9vbGVhbnMoKSA6IGJvb2xlYW5bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX21vZGFsQm9vbGVhbnM7XG5cdH1cblxuXHRwcml2YXRlIF95S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHlLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3lLZXk7XG5cdH1cblx0XG5cdHByaXZhdGUgX2RhdGFTdG9yZSA6IElEQlBEYXRhYmFzZTx1bmtub3duPjtcblx0cHVibGljIGdldCBkYXRhU3RvcmUoKSA6IElEQlBEYXRhYmFzZTx1bmtub3duPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGFTdG9yZTtcblx0fVxuXG5cdHByaXZhdGUgaW5pdFRvb2xiYXJFbGVtZW50cygpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl90b29sYmFyRWxlbWVudHMgPSBbXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6ICdvcHRpb25TZWxlY3QnLFxuXHRcdFx0XHRpY29uS2V5czogWydiYXJzJywgJ3N0cmVhbScsICdjbG9uZSddLFxuXHRcdFx0XHRkZWZhdWx0SW5kZXg6IDAsXG5cdFx0XHRcdGNhbGxiYWNrOiBhc3luYyAoc3RhdGU6IG51bWJlcikgPT4ge1xuXHRcdFx0XHRcdGxldCBtb2RlQ2hhbmdlRXZlbnQ6IEN1c3RvbUV2ZW50O1xuXHRcdFx0XHRcdHN3aXRjaCAoc3RhdGUpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdFx0XHRtb2RlQ2hhbmdlRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ21vZGVDaGFuZ2UnLCB7ZGV0YWlsOiB7XG5cdFx0XHRcdFx0XHRcdFx0aW5Db25kZW5zZWRNb2RlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH19KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdG1vZGVDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbW9kZUNoYW5nZScsIHtkZXRhaWw6IHtcblx0XHRcdFx0XHRcdFx0XHRpbkNvbmRlbnNlZE1vZGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH19KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0XHRcdG1vZGVDaGFuZ2VFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnbW9kZUNoYW5nZScsIHtkZXRhaWw6IHtcblx0XHRcdFx0XHRcdFx0XHRpbkNvbmRlbnNlZE1vZGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdGluRXhlbXBsYXJNb2RlOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHR9fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdERldmxpYlRTVXRpbC5sYXVuY2hTcGlubmVyKCk7XG5cdFx0XHRcdFx0YXdhaXQgRGV2bGliVFNVdGlsLm1ha2VBc3luYygoKSA9PiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG1vZGVDaGFuZ2VFdmVudCkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0b29sdGlwczogWydTd2l0Y2ggdG8gQ29uZGVuc2VkIE1vZGUnLCAnU3dpdGNoIHRvIEV4cGFuZGVkIE1vZGUnLCAnU3dpdGNoIHRvIEZyYW1lIE1vZGUnXVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogJ3BvcHVwQnV0dG9uJyxcblx0XHRcdFx0aWNvbktleTogJ2hvbWUnLFxuXHRcdFx0XHRjYWxsYmFjazogKHN0YXRlOiB7c2hvd246IGJvb2xlYW4sIGluZGV4OiBudW1iZXJ9KSA9PiB0aGlzLm9uSG91c2VDbGljayhzdGF0ZSksXG5cdFx0XHRcdHRvb2x0aXA6ICdSZXR1cm4gdG8gb3ZlcnZpZXcgc2NyZWVuJ1xuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogJ3BvcHVwQnV0dG9uJyxcblx0XHRcdFx0aWNvbktleTogJ2ZpbHRlcicsXG5cdFx0XHRcdGNhbGxiYWNrOiAoc3RhdGU6IHtzaG93bjogYm9vbGVhbiwgaW5kZXg6IG51bWJlcn0pID0+IHRoaXMub25EYXRhRmlsdGVyQ2xpY2soc3RhdGUpLFxuXHRcdFx0XHR0b29sdGlwOiAnVmlldyBhbmQgbW9kaWZ5IGRhdGEgZmlsdGVycydcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6ICdwb3B1cEJ1dHRvbicsXG5cdFx0XHRcdGljb25LZXk6ICd0cmFzaCcsXG5cdFx0XHRcdGNhbGxiYWNrOiAoc3RhdGU6IHtzaG93bjogYm9vbGVhbiwgaW5kZXg6IG51bWJlcn0pID0+IHRoaXMub25HYXJiYWdlQ2xpY2soc3RhdGUpLFxuXHRcdFx0XHR0b29sdGlwOiAnRGVsZXRlIGNhY2hlZCBkYXRhJ1xuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogJ3RvZ2dsZUJ1dHRvbicsXG5cdFx0XHRcdGljb25LZXlzOiBbJ2NoYXJ0LWxpbmUnLCAnYmFjb24nXSxcblx0XHRcdFx0Y2FsbGJhY2s6IChzdGF0ZTogYm9vbGVhbikgPT4gdGhpcy5vbkJhY29uQ2xpY2soc3RhdGUpLFxuXHRcdFx0XHR0b29sdGlwczogWydDbGljayB0byBzaG93IHJhdyBkYXRhIGluIGxpbmUgY2hhcnRzLicsICdDbGljayB0byBzbW9vdGggbGluZSBjaGFydHMgd2l0aCBtZWRpYW4gZmlsdGVyLiddXG5cdFx0XHR9XG5cdFx0XVxuXHR9XG5cblx0cHJvdGVjdGVkIGluaXQoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5fd3JhcHBlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0dGhpcy53cmFwcGVyRGl2LmNsYXNzTGlzdC5hZGQoXCJ3cmFwcGVyRGl2XCIpO1xuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMud3JhcHBlckRpdik7XG5cdFx0dGhpcy5feUtleSA9ICdNYXNzX25vcm0nO1xuXHRcdHRoaXMuX21vZGFsQm9vbGVhbnMgPSBbXTtcblxuXHRcdHRoaXMuaW5pdFRvb2xiYXJFbGVtZW50cygpO1xuXHRcdHRoaXMuZHJhd1Rvb2xiYXJFbGVtZW50cygpO1xuXHRcdHRoaXMuaW5pdE1vZGFsUG9wdXAoKTtcblxuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2F2ZXJhZ2VDdXJ2ZUtleUNoYW5nZScsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0e1xuXHRcdFx0dGhpcy5feUtleSA9IGUuZGV0YWlsLnlLZXk7XG5cdFx0fSk7XG4gICAgICAgIG9wZW5EQignbG9vbi1kYicpLnRoZW4oZGF0YVN0b3JlID0+IHRoaXMuX2RhdGFTdG9yZSA9IGRhdGFTdG9yZSk7XG5cdH1cblxuXHRwcml2YXRlIGRyYXdUb29sYmFyRWxlbWVudHMoKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgdG9vbGJhckVsZW1lbnQgb2YgdGhpcy50b29sYmFyRWxlbWVudHMpXG5cdFx0e1xuXHRcdFx0aWYgKHRvb2xiYXJFbGVtZW50LnR5cGUgPT09ICdzaW5nbGUnKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24odG9vbGJhckVsZW1lbnQuaWNvbktleSwgdG9vbGJhckVsZW1lbnQuY2FsbGJhY2spO1xuXHRcdFx0XHRidXR0b24udGl0bGUgPSB0b29sYmFyRWxlbWVudC50b29sdGlwO1xuXHRcdFx0XHRidXR0b24uY2xhc3NMaXN0LmFkZCgnYmlnJyk7XG5cdFx0XHRcdHRoaXMud3JhcHBlckRpdi5hcHBlbmQoYnV0dG9uKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRvb2xiYXJFbGVtZW50LnR5cGUgPT09ICdwb3B1cEJ1dHRvbicpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IHRoaXNJbmRleCA9IHRoaXMubW9kYWxCb29sZWFucy5sZW5ndGg7XG5cdFx0XHRcdHRoaXMubW9kYWxCb29sZWFucy5wdXNoKGZhbHNlKTtcblxuXHRcdFx0XHRsZXQgYnV0dG9uID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24odG9vbGJhckVsZW1lbnQuaWNvbktleSwgbnVsbCk7XG5cdFx0XHRcdGJ1dHRvbi50aXRsZSA9IHRvb2xiYXJFbGVtZW50LnRvb2x0aXA7XG5cdFx0XHRcdGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdiaWcnKTtcblx0XHRcdFx0dGhpcy53cmFwcGVyRGl2LmFwcGVuZChidXR0b24pO1xuXHRcdFx0XHRidXR0b24ub25jbGljayA9ICgpID0+IHRoaXMudG9nZ2xlTW9kYWxCdXR0b24odGhpc0luZGV4LCB0b29sYmFyRWxlbWVudClcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRvb2xiYXJFbGVtZW50LnR5cGUgPT09ICd0b2dnbGVCdXR0b24nKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgYnV0dG9uVHJ1ZSA9IERldmxpYlRTVXRpbC5nZXRJY29uQnV0dG9uKHRvb2xiYXJFbGVtZW50Lmljb25LZXlzWzBdLCBudWxsKTtcblx0XHRcdFx0YnV0dG9uVHJ1ZS50aXRsZSA9IHRvb2xiYXJFbGVtZW50LnRvb2x0aXBzWzBdO1xuXHRcdFx0XHRidXR0b25UcnVlLmNsYXNzTGlzdC5hZGQoJ2JpZycpO1xuXHRcdFx0XHR0aGlzLndyYXBwZXJEaXYuYXBwZW5kKGJ1dHRvblRydWUpO1xuXG5cdFx0XHRcdGxldCBidXR0b25GYWxzZSA9IERldmxpYlRTVXRpbC5nZXRJY29uQnV0dG9uKHRvb2xiYXJFbGVtZW50Lmljb25LZXlzWzFdLCBudWxsKTtcblx0XHRcdFx0YnV0dG9uRmFsc2UudGl0bGUgPSB0b29sYmFyRWxlbWVudC50b29sdGlwc1sxXTtcblx0XHRcdFx0YnV0dG9uRmFsc2UuY2xhc3NMaXN0LmFkZCgnYmlnJyk7XG5cdFx0XHRcdHRoaXMud3JhcHBlckRpdi5hcHBlbmQoYnV0dG9uRmFsc2UpO1xuXHRcdFx0XHREZXZsaWJUU1V0aWwuaGlkZShidXR0b25GYWxzZSk7XG5cblx0XHRcdFx0YnV0dG9uVHJ1ZS5vbmNsaWNrID0gKCkgPT5cblx0XHRcdFx0e1xuXHRcdFx0XHRcdERldmxpYlRTVXRpbC5oaWRlKGJ1dHRvblRydWUpO1xuXHRcdFx0XHRcdERldmxpYlRTVXRpbC5zaG93KGJ1dHRvbkZhbHNlKTtcblx0XHRcdFx0XHR0b29sYmFyRWxlbWVudC5jYWxsYmFjayh0cnVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJ1dHRvbkZhbHNlLm9uY2xpY2sgPSAoKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0RGV2bGliVFNVdGlsLnNob3coYnV0dG9uVHJ1ZSk7XG5cdFx0XHRcdFx0RGV2bGliVFNVdGlsLmhpZGUoYnV0dG9uRmFsc2UpO1xuXHRcdFx0XHRcdHRvb2xiYXJFbGVtZW50LmNhbGxiYWNrKGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0b29sYmFyRWxlbWVudC50eXBlID09PSAnb3B0aW9uU2VsZWN0Jylcblx0XHRcdHtcblx0XHRcdFx0bGV0IGdyb3VwZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdFx0Z3JvdXBlckRpdi5jbGFzc0xpc3QuYWRkKCdvcHRpb25TZWxlY3RHcm91cGVyRGl2Jyk7XG5cdFx0XHRcdGxldCBidXR0b25MaXN0OiBIVE1MQnV0dG9uRWxlbWVudFtdID0gW107XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9vbGJhckVsZW1lbnQuaWNvbktleXMubGVuZ3RoOyBpKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsZXQgaWNvbktleSA9IHRvb2xiYXJFbGVtZW50Lmljb25LZXlzW2ldO1xuXHRcdFx0XHRcdGxldCBidXR0b24gPSBEZXZsaWJUU1V0aWwuZ2V0SWNvbkJ1dHRvbihpY29uS2V5LCBudWxsKTtcblx0XHRcdFx0XHRidXR0b24udGl0bGUgPSB0b29sYmFyRWxlbWVudC50b29sdGlwc1tpXVxuXHRcdFx0XHRcdGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdiaWcnKTtcblx0XHRcdFx0XHRpZiAoaSA9PT0gdG9vbGJhckVsZW1lbnQuZGVmYXVsdEluZGV4KVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRidXR0b25MaXN0LnB1c2goYnV0dG9uKTtcblx0XHRcdFx0XHRncm91cGVyRGl2LmFwcGVuZChidXR0b24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcmVtb3ZlU2VsZWN0ZWQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0Zm9yIChsZXQgYnV0dG9uIG9mIGJ1dHRvbkxpc3QpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0YnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9uTGlzdC5sZW5ndGg7IGkrKylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBidXR0b24gPSBidXR0b25MaXN0W2ldO1xuXHRcdFx0XHRcdGJ1dHRvbi5vbmNsaWNrID0gKCkgPT5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRyZW1vdmVTZWxlY3RlZCgpO1xuXHRcdFx0XHRcdFx0YnV0dG9uLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG5cdFx0XHRcdFx0XHR0b29sYmFyRWxlbWVudC5jYWxsYmFjayhpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlTW9kZVNlbGVjdCcsIChlOiBDdXN0b21FdmVudCkgPT4gXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZW1vdmVTZWxlY3RlZCgpO1xuXHRcdFx0XHRcdGJ1dHRvbkxpc3RbZS5kZXRhaWxdLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLndyYXBwZXJEaXYuYXBwZW5kKGdyb3VwZXJEaXYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0cHJpdmF0ZSB0b2dnbGVNb2RhbEJ1dHRvbihidXR0b25JbmRleDogbnVtYmVyLCB0b29sYmFyRWxlbWVudD86IFRvb2xiYXJFbGVtZW50KTogdm9pZFxuXHR7XG5cblx0XHRpZiAoYnV0dG9uSW5kZXggIT09IC0xICYmIHRoaXMubW9kYWxCb29sZWFuc1tidXR0b25JbmRleF0pXG5cdFx0e1xuXHRcdFx0dGhpcy5tb2RhbEJvb2xlYW5zW2J1dHRvbkluZGV4XSA9IGZhbHNlO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vZGFsQm9vbGVhbnMubGVuZ3RoOyBpKyspXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMubW9kYWxCb29sZWFuc1tpXSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGJ1dHRvbkluZGV4ICE9PSAtMSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5tb2RhbEJvb2xlYW5zW2J1dHRvbkluZGV4XSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2hvdyA9IHRoaXMubW9kYWxCb29sZWFuc1tidXR0b25JbmRleF1cblx0XHRpZiAodG9vbGJhckVsZW1lbnQpXG5cdFx0e1xuXHRcdFx0dG9vbGJhckVsZW1lbnQuY2FsbGJhY2soe3Nob3duOiBzaG93LCBpbmRleDogYnV0dG9uSW5kZXh9KTtcblx0XHR9XG5cdFx0aWYgKHNob3cpXG5cdFx0e1xuXHRcdFx0RGV2bGliVFNVdGlsLnNob3codGhpcy5tb2RhbFBvcHVwRGl2KTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHRoaXMubW9kYWxQb3B1cERpdik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBpbml0TW9kYWxQb3B1cCgpOiB2b2lkXG5cdHtcblx0XHR0aGlzLl9tb2RhbFBvcHVwRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHR0aGlzLm1vZGFsUG9wdXBEaXYuY2xhc3NMaXN0LmFkZChcInRvb2xiYXJQb3B1cFwiKTtcblx0XHREZXZsaWJUU1V0aWwuaGlkZSh0aGlzLm1vZGFsUG9wdXBEaXYpO1xuXHRcdHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubW9kYWxQb3B1cERpdik7XG5cdH1cblxuXHRwcml2YXRlIGdldE9mZnNldEZyb21JbmRleChpbmRleDogbnVtYmVyKTogbnVtYmVyXG5cdHtcblx0XHRsZXQgYnV0dG9uID0gdGhpcy53cmFwcGVyRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IC5iYXNpY0ljb25CdXR0b24nKVtpbmRleF07XG5cdFx0cmV0dXJuIGJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG5cdH1cblxuXHRwcml2YXRlIG9uRGF0YUZpbHRlckNsaWNrKHN0YXRlOiB7c2hvd246IGJvb2xlYW4sIGluZGV4OiBudW1iZXJ9KTogdm9pZFxuXHR7XG5cdFx0dGhpcy5tb2RhbFBvcHVwRGl2LmlubmVySFRNTCA9IG51bGw7XG5cdFx0aWYgKCFzdGF0ZS5zaG93bilcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IG91dGVyID0gZDMuc2VsZWN0KHRoaXMubW9kYWxQb3B1cERpdik7XG5cdFx0b3V0ZXIuY2xhc3NlZCgnbmFycm93JywgZmFsc2UpO1xuXG5cdFx0Ly8gb3V0ZXIubm9kZSgpLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcblx0XHQvLyBvdXRlci5ub2RlKCkuc3R5bGUuYWxpZ25JdGVtcyA9ICdmbGV4LXN0YXJ0Jztcblx0XHRvdXRlci5ub2RlKCkuc3R5bGUudG9wID0gdGhpcy5nZXRPZmZzZXRGcm9tSW5kZXgoc3RhdGUuaW5kZXgpICsgJ3B4JztcblxuXHRcdGxldCBjb250ZW50RGl2ID0gb3V0ZXIuYXBwZW5kKCdkaXYnKVxuXHRcdFx0LmF0dHIoJ3N0eWxlJywgJ2Rpc3BsYXk6IGZsZXg7IHdpZHRoOiAxMDAlJyk7XG5cblx0XHRjb25zdCBzZWxlY3Rpb25EaXYgPSBjb250ZW50RGl2LmFwcGVuZCgnZGl2Jyk7XG5cdFx0Y29uc3QgY29udmVydERpdiA9IGNvbnRlbnREaXYuYXBwZW5kKCdkaXYnKTtcblx0XHRjb25zdCBmaWx0ZXJEaXYgPSBjb250ZW50RGl2LmFwcGVuZCgnZGl2Jyk7XG5cblx0XHRvdXRlci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuYXR0cignc3R5bGUnLCAnZGlzcGxheTogZmxleDsgd2lkdGg6IDEwMCU7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IGFsaWduLWl0ZW1zOiBmbGV4LWVuZDsnKVxuXHRcdFx0LmFwcGVuZCgnYnV0dG9uJylcblx0XHRcdC5jbGFzc2VkKCdkZXZsaWJCdXR0b24nLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoJ2JpZycsIHRydWUpXG5cdFx0XHQub24oJ2NsaWNrJywgKCkgPT5cblx0XHRcdHtcblx0XHRcdFx0dGhpcy50b2dnbGVNb2RhbEJ1dHRvbihzdGF0ZS5pbmRleCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRleHQoJ0Nsb3NlJyk7XG5cdFx0XHRcblx0XHR0aGlzLmRpc3BsYXlGaWx0ZXJzKFxuXHRcdFx0c2VsZWN0aW9uRGl2LFxuXHRcdFx0J0N1cnJlbnQgU2VsZWN0aW9uJyxcblx0XHRcdCdUaGUgY3VycmVudGx5IGhpZ2hsaWdodGVkIHNlbGVjdGlvbiBjb250YWlucyBkYXRhIHRoYXQgbWVldCBhbGwgb2YgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zLicsXG5cdFx0XHR0aGlzLmRhdGEuR2V0QWxsRmlsdGVycygpLFxuXHRcdFx0ZmFsc2UsXG5cdFx0XHRzdGF0ZS5pbmRleCk7XG5cblxuXHRcdGxldCBidXR0b25FbGVtZW50ID0gRGV2bGliVFNVdGlsLmdldEljb25CdXR0b24oJ2xvbmctYXJyb3ctYWx0LXJpZ2h0JywgKCkgPT4gdGhpcy50cmlnZ2VyU2VsZWN0aW9uVG9GaWx0ZXJFdmVudChzdGF0ZS5pbmRleCksICdDb252ZXJ0ICcpO1xuXG5cdFx0Y29udmVydERpdi5hdHRyKCdzdHlsZScsICdhbGlnbi1zZWxmOiBjZW50ZXI7Jykubm9kZSgpLmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuXG5cdFx0dGhpcy5kaXNwbGF5RmlsdGVycyhcblx0XHRcdGZpbHRlckRpdixcblx0XHRcdCdDdXJyZW50IEZpbHRlcnMnLFxuXHRcdFx0J09ubHkgc2hvdyB0cmFja3MgdGhhdCBtZWV0IGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMuJyxcblx0XHRcdHRoaXMuZnVsbERhdGEuR2V0QWxsRmlsdGVycygpLFxuXHRcdFx0dHJ1ZSxcblx0XHRcdHN0YXRlLmluZGV4KTtcblx0fVxuXG5cdHByaXZhdGUgZGlzcGxheUZpbHRlcnMoXG5cdFx0Y29udGFpbmVyU2VsZWN0OiBIdG1sU2VsZWN0aW9uLFxuXHRcdHRpdGxlOiBzdHJpbmcsXG5cdFx0ZGVzY3JpcHRpb246IHN0cmluZyxcblx0XHRmaWx0ZXJMaXN0OiBkYXRhRmlsdGVyW10sXG5cdFx0aXNGaWx0ZXI6IGJvb2xlYW4sXG5cdFx0aW5kZXg6IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdGNvbnRhaW5lclNlbGVjdC5jbGFzc2VkKCdmaWx0ZXJEaXNwbGF5Q29udGFpbmVyJywgdHJ1ZSlcblx0XHQgIC5hcHBlbmQoJ2RpdicpXG5cdFx0XHQudGV4dCh0aXRsZSlcblx0XHRcdC5jbGFzc2VkKCdsYXJnZVRleHQnLCB0cnVlKVxuXHRcdCAgLmFwcGVuZCgnZGl2Jylcblx0XHRcdC50ZXh0KGRlc2NyaXB0aW9uKVxuXHRcdFx0LmNsYXNzZWQoJ3NtYWxsVGV4dCcsIHRydWUpO1xuXHRcdCAgXG5cdFx0bGV0IGZpbHRlclNlbGVjdGlvbiA9IGNvbnRhaW5lclNlbGVjdC5hcHBlbmQoJ3VsJykuY2xhc3NlZCgnbWVkaXVtVGV4dCcsIHRydWUpLnNlbGVjdEFsbCgnbGknKVxuXHRcdFx0LmRhdGEoZmlsdGVyTGlzdClcblx0XHRcdC5qb2luKCdsaScpO1xuXG5cdFx0ZmlsdGVyU2VsZWN0aW9uLmZpbHRlcihkID0+IGQudHlwZSA9PT0gJ2NlbGwnKVxuXHRcdFx0Lmh0bWwoZCA9PiBcblx0XHRcdHtcblx0XHRcdFx0bGV0IGYgPSBkLmZpbHRlciBhcyB2YWx1ZUZpbHRlcjtcblx0XHRcdFx0bGV0IGxvdyA9IGYuYm91bmRbMF0udG9QcmVjaXNpb24oNSk7XG5cdFx0XHRcdGxldCBoaWdoID0gZi5ib3VuZFsxXS50b1ByZWNpc2lvbig1KTtcblx0XHRcdFx0aWYgKGlzRmlsdGVyKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIGBUcmFja3Mgd2hlcmUgPGI+JHtmLmtleX08L2I+IGlzIGluIHJhbmdlIFske2xvd30sICR7aGlnaH1dIGF0IGxlYXN0IG9uY2UuYDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gYENlbGwgaW5zdGFuY2VzIHdoZXJlIDxiPiR7Zi5rZXl9PC9iPiBpcyBpbiByYW5nZSBbJHtsb3d9LCAke2hpZ2h9XWA7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cblx0XHRmaWx0ZXJTZWxlY3Rpb24uZmlsdGVyKGQgPT4gZC50eXBlID09PSAndHJhY2snKVxuXHRcdFx0Lmh0bWwoZCA9PlxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgZiA9IGQuZmlsdGVyIGFzIHZhbHVlRmlsdGVyO1xuXHRcdFx0XHRsZXQgbG93ID0gZi5ib3VuZFswXS50b1ByZWNpc2lvbig1KTtcblx0XHRcdFx0bGV0IGhpZ2ggPSBmLmJvdW5kWzFdLnRvUHJlY2lzaW9uKDUpO1xuXHRcdFx0XHRyZXR1cm4gYFRyYWNrcyB3aXRoIDxiPiR7Zi5rZXl9PC9iPiBpbiByYW5nZSBbJHtsb3d9LCAke2hpZ2h9XWBcblx0XHRcdH0pO1xuXG5cdFx0ZmlsdGVyU2VsZWN0aW9uLmZpbHRlcihkID0+IGQudHlwZSA9PT0gJ2N1cnZlJylcblx0XHRcdC5odG1sKGQgPT4ge1xuXHRcdFx0XHRsZXQgZjEgPSAoZC5maWx0ZXIgYXMgW3ZhbHVlRmlsdGVyLCB2YWx1ZUZpbHRlcl0pWzBdO1xuXHRcdFx0XHRsZXQgbG93MSA9IGYxLmJvdW5kWzBdLnRvUHJlY2lzaW9uKDUpO1xuXHRcdFx0XHRsZXQgaGlnaDEgPSBmMS5ib3VuZFsxXS50b1ByZWNpc2lvbig1KTtcblxuXHRcdFx0XHRsZXQgZjIgPSAoZC5maWx0ZXIgYXMgW3ZhbHVlRmlsdGVyLCB2YWx1ZUZpbHRlcl0pWzFdO1xuXHRcdFx0XHRsZXQgbG93MiA9IGYyLmJvdW5kWzBdLnRvUHJlY2lzaW9uKDUpO1xuXHRcdFx0XHRsZXQgaGlnaDIgPSBmMi5ib3VuZFsxXS50b1ByZWNpc2lvbig1KTtcblxuXHRcdFx0XHRsZXQgZGlzcGxheVN0cmluZzogc3RyaW5nID0gJ1RyYWNrcyB3aGVyZSAnO1xuXHRcdFx0XHRkaXNwbGF5U3RyaW5nICs9IGA8Yj4ke2YxLmtleX08L2I+IGlzIGluIHJhbmdlIFske2xvdzF9LCAke2hpZ2gxfV0gYW5kIGA7XG5cdFx0XHRcdGRpc3BsYXlTdHJpbmcgKz0gYDxiPiR7ZjIua2V5fTwvYj4gaXMgaW4gcmFuZ2UgWyR7bG93Mn0sICR7aGlnaDJ9XWA7XG5cdFx0XHRcdGRpc3BsYXlTdHJpbmcgKz0gJyBhdCBsZWFzdCBvbmNlLic7XG5cdFx0XHRcdHJldHVybiBkaXNwbGF5U3RyaW5nO1xuXHRcdFx0fSk7XG5cdFx0XG5cdFx0aWYgKGlzRmlsdGVyKVxuXHRcdHtcblx0XHRcdGZpbHRlclNlbGVjdGlvbi5hcHBlbmQoJ2J1dHRvbicpXG5cdFx0XHRcdC5jbGFzc2VkKCdiYXNpY0ljb25CdXR0b24nLCB0cnVlKVxuXHRcdFx0XHQub24oJ2NsaWNrJywgZCA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGQudHlwZSA9PT0gJ2N1cnZlJylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLmZ1bGxEYXRhLnJlbW92ZUN1cnZlQnJ1c2goZC5maWx0ZXJLZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChkLnR5cGUgPT09ICd0cmFjaycpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5mdWxsRGF0YS5jdXJ2ZUNvbGxlY3Rpb24ucmVtb3ZlQnJ1c2goZC5maWx0ZXJLZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChkLnR5cGUgPT09ICdjZWxsJylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR0aGlzLmZ1bGxEYXRhLnJlbW92ZUJydXNoKGQuZmlsdGVyS2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRGF0YUV2ZW50cy5hcHBseU5ld0ZpbHRlcikpO1xuXHRcdFx0XHRcdHRoaXMub25EYXRhRmlsdGVyQ2xpY2soe3Nob3duOiB0cnVlLCBpbmRleDogaW5kZXh9KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0Lmh0bWwoJzxpIGNsYXNzPVwiZmFzIGZhLW1pbnVzXCI+PC9pPicpO1xuXHRcdH1cblxuXHR9XG5cblx0cHJpdmF0ZSB0cmlnZ2VyU2VsZWN0aW9uVG9GaWx0ZXJFdmVudChpbmRleDogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoRGF0YUV2ZW50cy5zZWxlY3Rpb25Ub0ZpbHRlcikpO1xuXHRcdHRoaXMub25EYXRhRmlsdGVyQ2xpY2soe3Nob3duOiB0cnVlLCBpbmRleDogaW5kZXh9KTtcblx0fVxuXG5cdHByaXZhdGUgb25Ib3VzZUNsaWNrKHN0YXRlOiB7c2hvd246IGJvb2xlYW4sIGluZGV4OiBudW1iZXJ9KTogdm9pZFxuXHR7XG5cdFx0dGhpcy5tb2RhbFBvcHVwRGl2LmlubmVySFRNTCA9IG51bGw7XG5cdFx0aWYgKCFzdGF0ZS5zaG93bilcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBvdXRlciA9IGQzLnNlbGVjdCh0aGlzLm1vZGFsUG9wdXBEaXYpO1xuXHRcdG91dGVyLmNsYXNzZWQoJ25hcnJvdycsIHRydWUpO1xuXG5cdFx0Ly8gb3V0ZXIubm9kZSgpLnN0eWxlLmZsZXhEaXJlY3Rpb24gPSAnY29sdW1uJztcblx0XHQvLyBvdXRlci5ub2RlKCkuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuXHRcdG91dGVyLm5vZGUoKS5zdHlsZS50b3AgPSB0aGlzLmdldE9mZnNldEZyb21JbmRleChzdGF0ZS5pbmRleCkgKyAncHgnO1xuXG5cdFx0b3V0ZXIuYXBwZW5kKCdkaXYnKVxuXHRcdFx0LmNsYXNzZWQoJ2xhcmdlVGV4dCcsIHRydWUpXG5cdFx0XHQudGV4dCgnUmV0dXJuIHRvIG92ZXJ2aWV3IHBhZ2U/JylcblxuXHRcdGxldCBidXR0b25EaXYgPSBvdXRlci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuYXR0cignc3R5bGUnLCAnZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IHJvdycpO1xuXG5cdFx0YnV0dG9uRGl2LmFwcGVuZCgnYnV0dG9uJylcblx0XHRcdC5jbGFzc2VkKCdkZXZsaWJCdXR0b24nLCB0cnVlKVxuXHRcdFx0LnRleHQoJ05hdmlnYXRlIEhvbWUnKVxuXHRcdFx0Lm9uKCdjbGljaycsICgpID0+IGxvY2F0aW9uLmhyZWYgPSAnL292ZXJ2aWV3Jyk7XG5cblx0XHRidXR0b25EaXYuYXBwZW5kKCdidXR0b24nKVxuXHRcdFx0LmNsYXNzZWQoJ2RldmxpYkJ1dHRvbicsIHRydWUpXG5cdFx0XHQudGV4dCgnU3RheSBIZXJlJylcblx0XHRcdC5vbignY2xpY2snLCAoKSA9PiB0aGlzLnRvZ2dsZU1vZGFsQnV0dG9uKHN0YXRlLmluZGV4KSk7XG5cdH1cblxuXHRwcml2YXRlIG9uR2FyYmFnZUNsaWNrKHN0YXRlOiB7c2hvd246IGJvb2xlYW4sIGluZGV4OiBudW1iZXJ9KTogdm9pZFxuXHR7XG5cdFx0dGhpcy5tb2RhbFBvcHVwRGl2LmlubmVySFRNTCA9IG51bGw7XG5cdFx0aWYgKCFzdGF0ZS5zaG93bilcblx0XHR7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGxldCBvdXRlciA9IGQzLnNlbGVjdCh0aGlzLm1vZGFsUG9wdXBEaXYpO1xuXG5cdFx0b3V0ZXIuY2xhc3NlZCgnbmFycm93JywgdHJ1ZSk7XG5cblx0XHQvLyBvdXRlci5ub2RlKCkuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdjb2x1bW4nO1xuXHRcdC8vIG91dGVyLm5vZGUoKS5zdHlsZS5hbGlnbkl0ZW1zID0gJ2NlbnRlcic7XG5cdFx0XG5cdFx0b3V0ZXIubm9kZSgpLnN0eWxlLnRvcCA9IHRoaXMuZ2V0T2Zmc2V0RnJvbUluZGV4KHN0YXRlLmluZGV4KSArICdweCc7XG5cblx0XHRvdXRlci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgnbGFyZ2VUZXh0JywgdHJ1ZSlcblx0XHRcdC50ZXh0KCdEZWxldGUgQ2FjaGU/Jylcblx0XHRcblx0XHRvdXRlci5hcHBlbmQoJ2RpdicpXG5cdFx0XHQuY2xhc3NlZCgnbWVkaXVtVGV4dCcsIHRydWUpXG5cdFx0XHQudGV4dCgnRGVsZXRlIGNhY2hlIGlmIHlvdXIgZGF0YSBoYXMgYmVlbiB1cGRhdGVkIHNpbmNlIHRoZSBsYXN0IGNhY2hlIHRpbWUuIE90aGVyd2lzZSwgbGVhdmUgdGhlIGNhY2hlIGFzIGlzIHRvIGltcHJvdmUgbG9hZGluZyB0aW1lcy4nKVxuXG5cdFx0b3V0ZXIuYXBwZW5kKCdidXR0b24nKVxuXHRcdFx0LmNsYXNzZWQoJ2RldmxpYkJ1dHRvbicsIHRydWUpXG5cdFx0XHQudGV4dCgnRGVsZXRlIEVudGlyZSBDYWNoZScpXG5cdFx0XHQub24oJ2NsaWNrJywgKCkgPT4gdGhpcy5jbGVhcklEQkNhY2hlKCdhbGwnKSk7XG5cblx0XHRjb25zdCBidXR0b25Hcm91cGVyID0gb3V0ZXIuYXBwZW5kKCdkaXYnKVxuXHRcdFx0LmF0dHIoJ3N0eWxlJywgJ2Rpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiByb3cnKTtcblxuXHRcdGJ1dHRvbkdyb3VwZXIuYXBwZW5kKCdidXR0b24nKVxuXHRcdFx0LmNsYXNzZWQoJ2RldmxpYkJ1dHRvbicsIHRydWUpXG5cdFx0XHQudGV4dCgnRGVsZXRlIENhY2hlZCBUcmFja3MnKVxuXHRcdFx0Lm9uKCdjbGljaycsICgpID0+IHRoaXMuY2xlYXJJREJDYWNoZSgndHJhY2tzJykpO1xuXG5cdFx0YnV0dG9uR3JvdXBlci5hcHBlbmQoJ2J1dHRvbicpXG5cdFx0XHQuY2xhc3NlZCgnZGV2bGliQnV0dG9uJywgdHJ1ZSlcblx0XHRcdC50ZXh0KCdEZWxldGUgQ2FjaGVkIEltYWdlcycpXG5cdFx0XHQub24oJ2NsaWNrJywgKCkgPT4gdGhpcy5jbGVhcklEQkNhY2hlKCdpbWFnZXMnKSk7XG5cdH1cblxuXHRwcml2YXRlIGFzeW5jIGNsZWFySURCQ2FjaGUoZGF0YWJhc2U6ICd0cmFja3MnIHwgJ2ltYWdlcycgfCAnYWxsJyk6IFByb21pc2U8dm9pZD5cblx0e1xuXHRcdGlmICh0aGlzLmRhdGFTdG9yZSlcblx0XHR7XG5cdFx0XHRjb25zdCBrZXkgPSB0aGlzLmRhdGEuU3BlY2lmaWNhdGlvbi5nb29nbGVEcml2ZUlkO1xuXHRcdFx0aWYgKGRhdGFiYXNlID09PSAndHJhY2tzJyB8fCBkYXRhYmFzZSA9PT0gJ2FsbCcpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZGF0YVN0b3JlLmRlbGV0ZSgndHJhY2tzJywga2V5KTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRhYmFzZSA9PT0gJ2ltYWdlcycgfHwgZGF0YWJhc2UgPT09ICdhbGwnKVxuXHRcdFx0e1xuXHRcdFx0XHRsZXQga2V5cyA9IGF3YWl0IHRoaXMuZGF0YVN0b3JlLmdldEFsbEtleXMoJ2ltYWdlcycpO1xuXHRcdFx0XHRmb3IgKGxldCBpbWdLZXkgb2Yga2V5cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChpbWdLZXkudG9TdHJpbmcoKS5pbmNsdWRlcyhrZXkpKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuZGF0YVN0b3JlLmRlbGV0ZSgnaW1hZ2VzJywgaW1nS2V5KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnRvZ2dsZU1vZGFsQnV0dG9uKC0xKTtcblx0fVxuXHRcblx0cHJpdmF0ZSBvbkJhY29uQ2xpY2soc3RhdGU6IGJvb2xlYW4pOiB2b2lkXG5cdHtcblx0XHRjb25zdCBzbW9vdGhDdXJ2ZUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzbW9vdGhDdXJ2ZUNoYW5nZScsIHtkZXRhaWw6ICFzdGF0ZX0pO1xuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoc21vb3RoQ3VydmVFdmVudCk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgT25SZXNpemUoKTogdm9pZFxuXHR7XG5cdFx0Ly8gZG8gbm90aGluZ1xuXHR9XG5cblx0cHJvdGVjdGVkIE9uRGF0YUNoYW5nZSgpOiB2b2lkXG5cdHtcblx0XHQvLyBub3QgcmVsZXZhbnQgZm9yIHRoaXMgY2xhc3Ncblx0fVxuXG5cdHByb3RlY3RlZCBDbG9uZShjb250YWluZXI6IEhUTUxFbGVtZW50KTogQmFzZVdpZGdldDxDdXJ2ZUxpc3QsIERhdGFzZXRTcGVjPlxuXHR7XG5cdFx0Ly8gbm90IHJlbGV2YW50IGZvciB0aGlzIGNsYXNzXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxufSIsImltcG9ydCB7IE5EaW0gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVHlwZXMnXG5pbXBvcnQgeyBDdXJ2ZUNvbGxlY3Rpb25JdGVyYXRvciB9IGZyb20gJy4vQ3VydmVDb2xsZWN0aW9uSXRlcmF0b3InO1xuaW1wb3J0IHsgUG9pbnRDb2xsZWN0aW9uIH0gZnJvbSAnLi9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi9DdXJ2ZUxpc3QnO1xuaW1wb3J0IHsgRmFjZXQsIExvY2F0aW9uTWFwTGlzdCwgRGF0YXNldFNwZWMsIEFwcERhdGEgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3RGYWN0b3J5IH0gZnJvbSAnLi9DdXJ2ZUxpc3RGYWN0b3J5JztcblxuZXhwb3J0IGNsYXNzIEN1cnZlQ29sbGVjdGlvbiBleHRlbmRzIFBvaW50Q29sbGVjdGlvblxue1xuICAgIHB1YmxpYyBDcmVhdGVGaWx0ZXJlZEN1cnZlTGlzdCgpOiBBcHBEYXRhPERhdGFzZXRTcGVjPiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgcHVibGljIEFwcGx5RGVmYXVsdEZpbHRlcnMoKTogdm9pZCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY3VydmVMaXN0OiBDdXJ2ZUxpc3QsIHNwZWM6IERhdGFzZXRTcGVjKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gY3VydmVMaXN0LmN1cnZlTGlzdC5sZW5ndGg7XG5cdFx0dGhpcy5fY3VydmVMaXN0ID0gY3VydmVMaXN0O1xuXHRcdHRoaXMuU3BlY2lmaWNhdGlvbiA9IHNwZWM7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2N1cnZlTGlzdCA6IEN1cnZlTGlzdDtcbiAgICBwdWJsaWMgZ2V0IGN1cnZlTGlzdCgpIDogQ3VydmVMaXN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnZlTGlzdDtcbiAgICB9XG4gICAgXG4gICAgcHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZCB7IH1cblx0cHVibGljIENvbnN1bWVGaWx0ZXJzOiAoQXBwRGF0YTogYW55KSA9PiB2b2lkO1xuXHRwdWJsaWMgQXBwbHlOZXdGaWx0ZXI6ICgpID0+IHZvaWQ7XG5cblx0cHJvdGVjdGVkIGdldEZhY2V0TGlzdChsb2NhdGlvbk1hcDogTG9jYXRpb25NYXBMaXN0KTogRmFjZXRbXVxuXHR7XG4gICAgICAgIGxldCBmYWNldExpc3QgPSBDdXJ2ZUxpc3RGYWN0b3J5LkNyZWF0ZUZhY2V0ZWREYXRhc2V0cyh0aGlzLmN1cnZlTGlzdCwgbG9jYXRpb25NYXApO1xuICAgICAgICBmb3IgKGxldCBmYWNldCBvZiBmYWNldExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZhY2V0LmRhdGEgPSBmYWNldC5kYXRhLmN1cnZlQ29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFjZXRMaXN0O1xuXHR9XG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYXRvcjxORGltPlxuXHR7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUNvbGxlY3Rpb25JdGVyYXRvcih0aGlzLmN1cnZlTGlzdCk7XG5cdH1cblxufSIsImltcG9ydCB7IE5EaW0gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVHlwZXMnO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi9DdXJ2ZUxpc3QnO1xuXG5leHBvcnQgY2xhc3MgQ3VydmVDb2xsZWN0aW9uSXRlcmF0b3IgaW1wbGVtZW50cyBJdGVyYXRvcjxORGltPiB7XG5cdFxuXHRjb25zdHJ1Y3RvcihjdXJ2ZUxpc3Q6IEN1cnZlTGlzdClcblx0e1xuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG5cdFx0dGhpcy5fY3VydmVMaXN0ID0gY3VydmVMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgaW5kZXgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9XG5cblx0cHJpdmF0ZSBfY3VydmVMaXN0IDogQ3VydmVMaXN0O1xuXHRwdWJsaWMgZ2V0IGN1cnZlTGlzdCgpIDogQ3VydmVMaXN0IHtcblx0XHRyZXR1cm4gdGhpcy5fY3VydmVMaXN0O1xuXHR9XG5cblx0cHVibGljIG5leHQoKTogSXRlcmF0b3JSZXN1bHQ8TkRpbT5cblx0e1xuXHRcdGxldCBjdXJ2ZSA9IHRoaXMuY3VydmVMaXN0LmN1cnZlTGlzdFt0aGlzLmluZGV4XTtcblx0XHRsZXQgaXNEb25lOiBib29sZWFuID0gIHRoaXMuaW5kZXggPj0gdGhpcy5jdXJ2ZUxpc3QuY3VydmVMaXN0Lmxlbmd0aDtcblx0XHQrK3RoaXMuX2luZGV4O1xuXHRcdGxldCBpdGVyUmVzdWx0OiBJdGVyYXRvclJlc3VsdDxORGltPiA9IHtcblx0XHRcdHZhbHVlOiBjdXJ2ZSxcblx0XHRcdGRvbmU6IGlzRG9uZVxuXHRcdH1cblx0XHRyZXR1cm4gaXRlclJlc3VsdDtcblx0fVxuXG59IiwiaW1wb3J0IHsgUG9pbnRORCB9IGZyb20gJy4vUG9pbnRORCc7XG5cbmV4cG9ydCBjbGFzcyBDdXJ2ZUl0ZXJhdG9yIGltcGxlbWVudHMgSXRlcmF0b3I8UG9pbnRORD4ge1xuXHRcblx0Y29uc3RydWN0b3IocG9pbnRMaXN0OiBQb2ludE5EW10pXG5cdHtcblx0XHR0aGlzLl9pbmRleCA9IDA7XG5cdFx0dGhpcy5fcG9pbnRMaXN0ID0gcG9pbnRMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5kZXggOiBudW1iZXI7XG5cdHB1YmxpYyBnZXQgaW5kZXgoKSA6IG51bWJlciB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9XG5cblx0cHJpdmF0ZSBfcG9pbnRMaXN0IDogUG9pbnRORFtdO1xuXHRwdWJsaWMgZ2V0IHBvaW50TGlzdCgpIDogUG9pbnRORFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnRMaXN0O1xuXHR9XG5cblx0cHVibGljIG5leHQoKTogSXRlcmF0b3JSZXN1bHQ8UG9pbnRORD5cblx0e1xuXHRcdGxldCBwb2ludDogUG9pbnRORCA9IHRoaXMucG9pbnRMaXN0W3RoaXMuaW5kZXhdO1xuXHRcdGxldCBpc0RvbmU6IGJvb2xlYW4gPSAgdGhpcy5pbmRleCA+PSB0aGlzLnBvaW50TGlzdC5sZW5ndGg7XG5cdFx0Kyt0aGlzLl9pbmRleDtcblx0XHRsZXQgaXRlclJlc3VsdDogSXRlcmF0b3JSZXN1bHQ8UG9pbnRORD4gPSB7XG5cdFx0XHR2YWx1ZTogcG9pbnQsXG5cdFx0XHRkb25lOiBpc0RvbmVcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZXJSZXN1bHQ7XG5cdH1cblxufSIsImltcG9ydCB7IERldmxpYkFsZ28gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliQWxnbyc7XG5pbXBvcnQgeyBDdXJ2ZU5EIH0gZnJvbSAnLi9DdXJ2ZU5EJztcbmltcG9ydCB7IFBvaW50TkQgfSBmcm9tICcuL1BvaW50TkQnO1xuaW1wb3J0IHsgUG9pbnRDb2xsZWN0aW9uIH0gZnJvbSAnLi9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgQ3VydmVMaXN0SXRlcmF0b3IgfSBmcm9tICcuL0N1cnZlTGlzdEl0ZXJhdG9yJztcbmltcG9ydCB7IEN1cnZlQ29sbGVjdGlvbiB9IGZyb20gJy4vQ3VydmVDb2xsZWN0aW9uJztcbmltcG9ydCB7IERhdGFzZXRTcGVjLCBGYWNldCwgQXBwRGF0YSwgTG9jYXRpb25NYXBMaXN0LCBkYXRhRmlsdGVyLCB2YWx1ZUZpbHRlciwgRmFjZXRPcHRpb24gfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBDdXJ2ZUxpc3RGYWN0b3J5IH0gZnJvbSAnLi9DdXJ2ZUxpc3RGYWN0b3J5JztcbmltcG9ydCBkMyA9IHJlcXVpcmUoJ2QzJyk7XG5cbmV4cG9ydCBjbGFzcyBDdXJ2ZUxpc3QgZXh0ZW5kcyBQb2ludENvbGxlY3Rpb24gaW1wbGVtZW50cyBBcHBEYXRhPERhdGFzZXRTcGVjPlxue1xuXG5cdGNvbnN0cnVjdG9yKGN1cnZlTGlzdDogQ3VydmVORFtdLCBzcGVjOiBEYXRhc2V0U3BlYylcblx0e1xuXHRcdHN1cGVyKCk7XG5cdFx0dGhpcy5fY3VydmVMaXN0ID0gY3VydmVMaXN0O1xuXHRcdHRoaXMuX2xlbmd0aCA9IDA7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdHRoaXMuX2N1cnZlTG9va3VwID0gbmV3IE1hcDxzdHJpbmcsIEN1cnZlTkQ+KCk7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0dGhpcy5jdXJ2ZUxvb2t1cC5zZXQoY3VydmUuaWQsIGN1cnZlKTtcblx0XHRcdHRoaXMuX2xlbmd0aCArPSBjdXJ2ZS5sZW5ndGg7XG5cdFx0XHRmb3IgKGxldCBwb2ludCBvZiBjdXJ2ZSlcblx0XHRcdHtcblx0XHRcdFx0dGhpc1tpXSA9IHBvaW50O1xuXHRcdFx0XHQrK2k7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX21pbk1heE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPigpO1xuXHRcdHRoaXMuX2ludmVyc2VMb2NhdGlvbk1hcCA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmdbXT4oKTtcblx0XHR0aGlzLl9hdmVyYWdlRmlsdGVyZWRDdXJ2ZUNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl1bXT4oKTtcblx0XHR0aGlzLl9hdmVyYWdlQ3VydmVDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdW10+KCk7XG5cdFx0dGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAgPSBuZXcgTWFwPG51bWJlciwgTWFwPG51bWJlciwgTWFwPG51bWJlciwgW1BvaW50TkQsIG51bWJlcl0+Pj4oKTtcblx0XHRjb25zdCBsb2NhdGlvblNldCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKylcblx0XHR7XG5cdFx0XHRsZXQgcG9pbnQgPSB0aGlzW2ldIGFzIFBvaW50TkQ7XG5cdFx0XHRsZXQgbG9jID0gcG9pbnQuZ2V0KCdMb2NhdGlvbiBJRCcpO1xuXHRcdFx0bG9jYXRpb25TZXQuYWRkKGxvYyk7XG5cdFx0XHRpZiAoIXRoaXMuX2xvY2F0aW9uRnJhbWVTZWdtZW50TG9va3VwLmhhcyhsb2MpKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9sb2NhdGlvbkZyYW1lU2VnbWVudExvb2t1cC5zZXQobG9jLCBuZXcgTWFwKCkpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbG9jTWFwID0gdGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAuZ2V0KGxvYyk7XG5cdFx0XHRsZXQgZnJhbWUgPSBwb2ludC5nZXQoJ0ZyYW1lIElEJyk7XG5cdFx0XHRpZiAoIWxvY01hcC5oYXMoZnJhbWUpKVxuXHRcdFx0e1xuXHRcdFx0XHRsb2NNYXAuc2V0KGZyYW1lLCBuZXcgTWFwKCkpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3Qgc2VnTWFwID0gbG9jTWFwLmdldChmcmFtZSk7XG5cdFx0XHRsZXQgc2VnbWVudExhYmVsID0gcG9pbnQuZ2V0KCdzZWdtZW50TGFiZWwnKTtcblx0XHRcdHNlZ01hcC5zZXQoc2VnbWVudExhYmVsLCBbcG9pbnQsIGkgKyAxXSk7XG5cdFx0fVxuXHRcdHRoaXMuX2xvY2F0aW9uTGlzdCA9IEFycmF5LmZyb20obG9jYXRpb25TZXQpO1xuXHRcdHRoaXMubG9jYXRpb25MaXN0LnNvcnQoRGV2bGliQWxnby5zb3J0QXNjZW5kKTtcblx0XHR0aGlzLl9jdXJ2ZUNvbGxlY3Rpb24gPSBuZXcgQ3VydmVDb2xsZWN0aW9uKHRoaXMsIHNwZWMpO1xuXHRcdHRoaXMuX2N1cnZlQnJ1c2hMaXN0ID0gbmV3IE1hcDxzdHJpbmcsIFt2YWx1ZUZpbHRlciwgdmFsdWVGaWx0ZXJdPigpO1xuXHRcdHRoaXMuU3BlY2lmaWNhdGlvbiA9IHNwZWM7XG5cdFx0dGhpcy5fY29uZGl0aW9uRmlsdGVyU3RhdGUgPSBuZXcgTWFwPHN0cmluZywgTWFwPHN0cmluZywgYm9vbGVhbj4+KCk7XG5cdFx0Zm9yIChsZXQgeUtleSBvZiB0aGlzLmRlZmF1bHRGYWNldEF4aXNUaWNrcy55QXhpc1RpY2tzKVxuXHRcdHtcblx0XHRcdGxldCB0aGlzTWFwID0gbmV3IE1hcDxzdHJpbmcsIGJvb2xlYW4+KCk7XG5cdFx0XHRmb3IgKGxldCB4S2V5IG9mIHRoaXMuZGVmYXVsdEZhY2V0QXhpc1RpY2tzLnhBeGlzVGlja3MpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXNNYXAuc2V0KHhLZXksIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5jb25kaXRpb25GaWx0ZXJTdGF0ZS5zZXQoeUtleSwgdGhpc01hcCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBfY3VydmVMaXN0IDogQ3VydmVORFtdO1xuXHRwdWJsaWMgZ2V0IGN1cnZlTGlzdCgpIDogQ3VydmVORFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VydmVMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfY3VydmVMb29rdXAgOiBNYXA8c3RyaW5nLCBDdXJ2ZU5EPjtcblx0cHVibGljIGdldCBjdXJ2ZUxvb2t1cCgpIDogTWFwPHN0cmluZywgQ3VydmVORD4ge1xuXHRcdHJldHVybiB0aGlzLl9jdXJ2ZUxvb2t1cDtcblx0fVxuXG5cdHByaXZhdGUgX2N1cnZlQ29sbGVjdGlvbiA6IEN1cnZlQ29sbGVjdGlvbjtcblx0cHVibGljIGdldCBjdXJ2ZUNvbGxlY3Rpb24oKSA6IEN1cnZlQ29sbGVjdGlvbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnZlQ29sbGVjdGlvbjtcblx0fVxuXHRwdWJsaWMgc2V0IGN1cnZlQ29sbGVjdGlvbih2IDogQ3VydmVDb2xsZWN0aW9uKSB7XG5cdFx0dGhpcy5fY3VydmVDb2xsZWN0aW9uID0gdjtcblx0fVx0XG5cblx0cHJpdmF0ZSBfaW5wdXRLZXkgOiBzdHJpbmc7XG5cdHB1YmxpYyBnZXQgaW5wdXRLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX2lucHV0S2V5O1xuXHR9XG5cblx0cHJpdmF0ZSBfbWluTWF4TWFwIDogTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT47XG5cdHB1YmxpYyBnZXQgbWluTWF4TWFwKCkgOiBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPiB7XG5cdFx0aWYgKHRoaXMuX21pbk1heE1hcC5zaXplID09PSAwKVxuXHRcdHtcblx0XHRcdHRoaXMudXBkYXRlTWluTWF4TWFwKClcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21pbk1heE1hcDtcblx0fVxuXG5cdFxuXHRwcml2YXRlIF9pbnZlcnNlTG9jYXRpb25NYXAgOiBNYXA8bnVtYmVyLCBzdHJpbmdbXT47XG5cdHB1YmxpYyBnZXQgaW52ZXJzZUxvY2F0aW9uTWFwKCkgOiBNYXA8bnVtYmVyLCBzdHJpbmdbXT4ge1xuXHRcdGlmICh0aGlzLl9pbnZlcnNlTG9jYXRpb25NYXAuc2l6ZSA9PT0gMClcblx0XHR7XG5cdFx0XHR0aGlzLmdlbmVyYXRlSW52ZXJzZUxvY2F0aW9uTWFwKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlTG9jYXRpb25NYXA7XG5cdH1cblxuXHRwcml2YXRlIF9hdmVyYWdlRmlsdGVyZWRDdXJ2ZUNhY2hlOiBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdW10+O1xuXHRwcml2YXRlIF9hdmVyYWdlQ3VydmVDYWNoZTogTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXVtdPjtcblx0cHVibGljIGdldEF2ZXJhZ2VDdXJ2ZShhdmdLZXk6IHN0cmluZywgZmlsdGVyZWRPbmx5OiBib29sZWFuID0gZmFsc2UsICBzbW9vdGhlZDogYm9vbGVhbiA9IGZhbHNlKTogW251bWJlciwgbnVtYmVyXVtdXG5cdHtcblx0XHRsZXQgY2FjaGVLZXkgPSBhdmdLZXk7XG5cdFx0aWYgKHNtb290aGVkKVxuXHRcdHtcblx0XHRcdGNhY2hlS2V5ID0gY2FjaGVLZXkgKyAnLXNtb290aGVkLW91dC1yZWFsLW5pY2Utbm93Jztcblx0XHR9XG5cdFx0bGV0IGNhY2hlOiBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdW10+XG5cdFx0aWYgKGZpbHRlcmVkT25seSlcblx0XHR7XG5cdFx0XHRjYWNoZSA9IHRoaXMuX2F2ZXJhZ2VGaWx0ZXJlZEN1cnZlQ2FjaGU7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHRjYWNoZSA9IHRoaXMuX2F2ZXJhZ2VDdXJ2ZUNhY2hlO1xuXHRcdH1cblx0XHRpZiAoY2FjaGUuaGFzKGNhY2hlS2V5KSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gY2FjaGUuZ2V0KGNhY2hlS2V5KVxuXHRcdH1cblx0XHRcblx0XHRsZXQgc3VtQ291bnRNYXA6IE1hcDxudW1iZXIsIFtudW1iZXIsIG51bWJlcl0+ID0gbmV3IE1hcDxudW1iZXIsIFtudW1iZXIsIG51bWJlcl0+KCk7XG5cblx0XHRmb3IgKGxldCBwb2ludCBvZiB0aGlzKVxuXHRcdHtcblx0XHRcdGlmIChmaWx0ZXJlZE9ubHkgJiYgIXBvaW50LmluQnJ1c2gpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGZyYW1lID0gcG9pbnQuZ2V0KCdGcmFtZSBJRCcpO1xuXHRcdFx0bGV0IG1hc3MgPSBwb2ludC5nZXQoYXZnS2V5KTtcblx0XHRcdGxldCBbc3VtLCBjb3VudF0gPSBzdW1Db3VudE1hcC5oYXMoZnJhbWUpID8gc3VtQ291bnRNYXAuZ2V0KGZyYW1lKSA6IFswLCAwXTtcblx0XHRcdHN1bUNvdW50TWFwLnNldChmcmFtZSwgW3N1bSArIG1hc3MsIGNvdW50ICsgMV0gKTtcblx0XHR9XG5cdFx0bGV0IGZyYW1lTGlzdCA9IEFycmF5LmZyb20oc3VtQ291bnRNYXAua2V5cygpKS5zb3J0KChhLGIpID0+IGEtYik7XG5cdFx0bGV0IGF2Z0N1cnZlOiBbbnVtYmVyLCBudW1iZXJdW10gPSBmcmFtZUxpc3QubWFwKGZyYW1lID0+IFxuXHRcdFx0e1xuXHRcdFx0XHRsZXQgW3N1bSwgY291bnRdID0gc3VtQ291bnRNYXAuZ2V0KGZyYW1lKTtcblx0XHRcdFx0cmV0dXJuIFtmcmFtZSwgc3VtIC8gY291bnRdO1xuXHRcdFx0fSk7XG5cdFx0aWYgKHNtb290aGVkKVxuXHRcdHtcblx0XHRcdGF2Z0N1cnZlID0gQ3VydmVMaXN0Lm1lZGlhbkZpbHRlcihhdmdDdXJ2ZSk7XG5cdFx0fVxuXHRcdGNhY2hlLnNldChjYWNoZUtleSwgYXZnQ3VydmUpO1xuXHRcdHJldHVybiBhdmdDdXJ2ZTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgbWVkaWFuRmlsdGVyKHBvaW50czogW251bWJlciwgbnVtYmVyXVtdLCB3aW5kb3c6IG51bWJlciA9IDMpOiBbbnVtYmVyLCBudW1iZXJdW11cblx0e1xuXHRcdGNvbnN0IHNtb290aGVkUG9pbnRzOiBbbnVtYmVyLCBudW1iZXJdW10gPSBwb2ludHMubWFwKCh2YWx1ZSwgaW5kZXgpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgW3gsIHldID0gdmFsdWU7XG5cblx0XHRcdGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgaW5kZXggLSB3aW5kb3cpO1xuXHRcdFx0Y29uc3QgZW5kID0gTWF0aC5taW4ocG9pbnRzLmxlbmd0aCwgaW5kZXggKyB3aW5kb3cgKyAxKTtcblx0XHRcdGNvbnN0IHNsaWNlID0gcG9pbnRzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXHRcdFx0bGV0IG5ld1kgPSBkMy5tZWRpYW4oc2xpY2UsIGQgPT4gZFsxXSk7XG5cdFx0XHRyZXR1cm4gW3gsIG5ld1ldO1xuXHRcdH0pO1xuXHRcdHJldHVybiBzbW9vdGhlZFBvaW50cztcblx0fVxuXG5cdHByaXZhdGUgX2RlZmF1bHRGYWNldEF4aXNUaWNrczoge1xuXHRcdHhBeGlzVGlja3M6IHN0cmluZ1tdLFxuXHRcdHlBeGlzVGlja3M6IHN0cmluZ1tdLFxuXHRcdGF4aXNMYWJlbHM6IFtzdHJpbmcsIHN0cmluZ11cblx0fVxuXHRwdWJsaWMgZ2V0IGRlZmF1bHRGYWNldEF4aXNUaWNrcygpOiB7XG5cdFx0eEF4aXNUaWNrczogc3RyaW5nW10sXG5cdFx0eUF4aXNUaWNrczogc3RyaW5nW10sXG5cdFx0YXhpc0xhYmVsczogW3N0cmluZywgc3RyaW5nXVxuXHR9XG5cdHtcblx0XHRpZiAodGhpcy5fZGVmYXVsdEZhY2V0QXhpc1RpY2tzKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9kZWZhdWx0RmFjZXRBeGlzVGlja3Ncblx0XHR9XG5cdFx0bGV0IGZhY2V0T3B0aW9uczogRmFjZXRPcHRpb25bXSA9IHRoaXMuR2V0RmFjZXRPcHRpb25zKCk7XG5cdFx0bGV0IGZpcnN0RmFjZXRPcHRpb24gPSBmYWNldE9wdGlvbnNbMF07XG5cdFx0bGV0IHNlY29uZEZhY2V0T3B0aW9uID0gZmFjZXRPcHRpb25zWzFdO1xuXG5cdFx0Y29uc3QgeUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLlNwZWNpZmljYXRpb24ubG9jYXRpb25NYXBzW2ZpcnN0RmFjZXRPcHRpb24ubmFtZV0pO1xuXHRcdGNvbnN0IHhLZXlzID0gT2JqZWN0LmtleXModGhpcy5TcGVjaWZpY2F0aW9uLmxvY2F0aW9uTWFwc1tzZWNvbmRGYWNldE9wdGlvbi5uYW1lXSk7XG5cdFx0bGV0IGF4aXNMYWJlbHM6IFtzdHJpbmcsIHN0cmluZ10gPSBbZmlyc3RGYWNldE9wdGlvbi5uYW1lLCBzZWNvbmRGYWNldE9wdGlvbi5uYW1lXTtcblxuXG5cdFx0bGV0IHJldHVybk9iamVjdCA9IHtcblx0XHRcdHhBeGlzVGlja3M6IHhLZXlzLFxuXHRcdFx0eUF4aXNUaWNrczogeUtleXMsXG5cdFx0XHRheGlzTGFiZWxzOiBheGlzTGFiZWxzXG5cdFx0fVxuXHRcdHRoaXMuX2RlZmF1bHRGYWNldEF4aXNUaWNrcyA9IHJldHVybk9iamVjdDtcblx0XHRyZXR1cm4gcmV0dXJuT2JqZWN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfZGVmYXVsdEZhY2V0czogIE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIEN1cnZlTGlzdD4+XG5cbiAgICBwdWJsaWMgZ2V0IGRlZmF1bHRGYWNldHMoKTogTWFwPHN0cmluZywgTWFwPHN0cmluZywgQ3VydmVMaXN0Pj5cblx0e1xuXHRcdGlmICh0aGlzLl9kZWZhdWx0RmFjZXRzKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLl9kZWZhdWx0RmFjZXRzXG5cdFx0fVxuXHRcdGNvbnN0IGRydWdJZHggPSAwO1xuXHRcdGNvbnN0IGNvbmNJZHggPSAxO1xuXHRcdGxldCBmYWNldE9wdGlvbnM6IEZhY2V0T3B0aW9uW10gPSB0aGlzLkdldEZhY2V0T3B0aW9ucygpO1xuXHRcdGxldCBmaXJzdEZhY2V0T3B0aW9uID0gZmFjZXRPcHRpb25zW2RydWdJZHhdO1xuXHRcdGxldCBmaXJzdEZhY2V0czogRmFjZXRbXSA9IGZpcnN0RmFjZXRPcHRpb24uR2V0RmFjZXRzKCk7XG5cdFx0bGV0IG5lc3RlZEZhY2V0TWFwOiBNYXA8c3RyaW5nLCBNYXA8c3RyaW5nLCBDdXJ2ZUxpc3Q+PiA9IG5ldyBNYXAoKTtcblx0XHRmb3IgKGxldCB7bmFtZTogY2F0ZWdvcnlOYW1lLCBkYXRhOiBkYXRhfSBvZiBmaXJzdEZhY2V0cylcblx0XHR7XG5cdFx0XHRsZXQgZmFjZXRPcHRpb24gPSBkYXRhLkdldEZhY2V0T3B0aW9ucygpW2NvbmNJZHhdO1xuXHRcdFx0bGV0IHN1YkZhY2V0czogRmFjZXRbXSA9IGZhY2V0T3B0aW9uLkdldEZhY2V0cygpO1xuXHRcdFx0bGV0IHRoaXNEaWN0ID0gbmV3IE1hcDxzdHJpbmcsIEN1cnZlTGlzdD4oKTtcblx0XHRcdGZvciAobGV0IHN1YkZhY2V0IG9mIHN1YkZhY2V0cylcblx0XHRcdHtcblx0XHRcdFx0dGhpc0RpY3Quc2V0KHN1YkZhY2V0Lm5hbWVbMF0sIHN1YkZhY2V0LmRhdGEpO1xuXHRcdFx0fVxuXHRcdFx0bmVzdGVkRmFjZXRNYXAuc2V0KGNhdGVnb3J5TmFtZVswXSwgdGhpc0RpY3QpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RlZmF1bHRGYWNldHMgPSBuZXN0ZWRGYWNldE1hcDtcblx0XHRyZXR1cm4gbmVzdGVkRmFjZXRNYXA7XG4gICAgfVxuXG5cdHByaXZhdGUgY2xlYXJEZWZhdWx0RmFjZXRDYWNoZSgpOiB2b2lkXG5cdHtcblx0XHRmb3IgKGxldCBtYXAgb2YgdGhpcy5kZWZhdWx0RmFjZXRzLnZhbHVlcygpKVxuXHRcdHtcblx0XHRcdGZvciAobGV0IGN1cnZlTGlzdCBvZiBtYXAudmFsdWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGN1cnZlTGlzdC5fYXZlcmFnZUZpbHRlcmVkQ3VydmVDYWNoZS5jbGVhcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8gcHJpdmF0ZSBfbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAgOiBNYXA8c3RyaW5nLCBbUG9pbnRORCwgbnVtYmVyXT47XG5cdHByaXZhdGUgX2xvY2F0aW9uRnJhbWVTZWdtZW50TG9va3VwIDogTWFwPG51bWJlciwgTWFwPG51bWJlciwgTWFwPG51bWJlciwgW1BvaW50TkQsIG51bWJlcl0+Pj47XG5cblx0cHJpdmF0ZSBfbG9jYXRpb25MaXN0IDogbnVtYmVyW107XG5cdHB1YmxpYyBnZXQgbG9jYXRpb25MaXN0KCkgOiBudW1iZXJbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xvY2F0aW9uTGlzdDtcblx0fVx0XG5cblx0cHVibGljIENyZWF0ZUZpbHRlcmVkQ3VydmVMaXN0KCk6IEN1cnZlTGlzdFxuXHR7XG5cdFx0bGV0IGZpbHRlcmVkQ3VydmVBcnJheSA9IHRoaXMuY3VydmVMaXN0LmZpbHRlcihjdXJ2ZSA9PiBjdXJ2ZS5pbkJydXNoKTtcblx0XHRyZXR1cm4gbmV3IEN1cnZlTGlzdChmaWx0ZXJlZEN1cnZlQXJyYXksIHRoaXMuU3BlY2lmaWNhdGlvbik7XG5cdH1cblxuXHRwdWJsaWMgQXBwbHlEZWZhdWx0RmlsdGVycygpOiB2b2lkXG5cdHtcblx0XHRjb25zdCB0cmFja0xlbmd0aEtleSA9ICdUcmFjayBMZW5ndGgnO1xuXG5cdFx0Y29uc3QgW18sIG1heExlbmd0aF0gPSB0aGlzLmN1cnZlQ29sbGVjdGlvbi5nZXRNaW5NYXgodHJhY2tMZW5ndGhLZXkpO1xuXHRcdGNvbnN0IGZpbHRlcjogdmFsdWVGaWx0ZXIgPSB7XG5cdFx0XHRrZXk6IHRyYWNrTGVuZ3RoS2V5LFxuXHRcdFx0Ym91bmQ6IFttYXhMZW5ndGggLyAyLCBtYXhMZW5ndGhdXG5cdFx0fVxuXG5cdFx0Ly8gZGVmYXVsdCB0byBldmVyeSBvdGhlciBzZWNvbmRhcnkgZmlsdGVyLiBlLmcuIGV2ZXJ5IG90aGVyIGNvbmNlbnRyYXRpb25cblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuZGVmYXVsdEZhY2V0QXhpc1RpY2tzLnhBeGlzVGlja3MubGVuZ3RoOyBpKz0yKVxuXHRcdHtcblx0XHRcdGNvbnN0IHhLZXkgPSB0aGlzLmRlZmF1bHRGYWNldEF4aXNUaWNrcy54QXhpc1RpY2tzW2ldO1xuXHRcdFx0Zm9yIChsZXQgeUtleSBvZiB0aGlzLmRlZmF1bHRGYWNldEF4aXNUaWNrcy55QXhpc1RpY2tzKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmNvbmRpdGlvbkZpbHRlclN0YXRlLmdldCh5S2V5KS5zZXQoeEtleSwgZmFsc2UpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuY3VydmVDb2xsZWN0aW9uLmFkZEJydXNoTm9VcGRhdGUoJ2RlZmF1bHQnLCBmaWx0ZXIpO1xuXHR9XG5cblx0cHVibGljIEdldEFsbEZpbHRlcnMoKTogZGF0YUZpbHRlcltdXG5cdHtcblx0XHRsZXQgZGF0YUZpbHRlcnM6IGRhdGFGaWx0ZXJbXSA9IFtdO1xuXHRcdC8vIGN1cnZlIGZpbHRlcnNcblx0XHRmb3IgKGxldCBba2V5LCBmaWx0ZXJzXSBvZiB0aGlzLmN1cnZlQnJ1c2hMaXN0LmVudHJpZXMoKSlcblx0XHR7XG5cdFx0XHRkYXRhRmlsdGVycy5wdXNoKHtcblx0XHRcdFx0dHlwZTogJ2N1cnZlJyxcblx0XHRcdFx0ZmlsdGVyS2V5OiBrZXksXG5cdFx0XHRcdGZpbHRlcjogZmlsdGVyc1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gY2VsbCBmaWx0ZXJzXG5cdFx0Zm9yIChsZXQgW2tleSwgZmlsdGVyTWFwXSBvZiB0aGlzLmJydXNoTGlzdC5lbnRyaWVzKCkpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgW2F0dHJpYnV0ZUtleSwgZXh0ZW50XSBvZiBmaWx0ZXJNYXAuZW50cmllcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRkYXRhRmlsdGVycy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiAnY2VsbCcsXG5cdFx0XHRcdFx0ZmlsdGVyS2V5OiBrZXksXG5cdFx0XHRcdFx0ZmlsdGVyOiB7XG5cdFx0XHRcdFx0XHRrZXk6IGF0dHJpYnV0ZUtleSxcblx0XHRcdFx0XHRcdGJvdW5kOiBleHRlbnRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRyYWNrIGZpbHRlcnNcblx0XHRmb3IgKGxldCBba2V5LCBmaWx0ZXJNYXBdIG9mIHRoaXMuY3VydmVDb2xsZWN0aW9uLmJydXNoTGlzdC5lbnRyaWVzKCkpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgW2F0dHJpYnV0ZUtleSwgZXh0ZW50XSBvZiBmaWx0ZXJNYXAuZW50cmllcygpKVxuXHRcdFx0e1xuXHRcdFx0XHRkYXRhRmlsdGVycy5wdXNoKHtcblx0XHRcdFx0XHR0eXBlOiAndHJhY2snLFxuXHRcdFx0XHRcdGZpbHRlcktleToga2V5LFxuXHRcdFx0XHRcdGZpbHRlcjoge1xuXHRcdFx0XHRcdFx0a2V5OiBhdHRyaWJ1dGVLZXksXG5cdFx0XHRcdFx0XHRib3VuZDogZXh0ZW50XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YUZpbHRlcnM7XG5cdH1cblxuXHRwdWJsaWMgQ29uc3VtZUZpbHRlcnMob3RoZXJDdXJ2ZUxpc3Q6IEN1cnZlTGlzdCk6IHZvaWRcblx0e1xuXG5cdFx0Ly8gY3VydmUgZmlsdGVyc1xuXHRcdGZvciAobGV0IFtrZXksIGZpbHRlcnNdIG9mIG90aGVyQ3VydmVMaXN0LmN1cnZlQnJ1c2hMaXN0LmVudHJpZXMoKSlcblx0XHR7XG5cdFx0XHR0aGlzLmN1cnZlQnJ1c2hMaXN0LnNldChrZXkgKyBEYXRlLm5vdygpLCBmaWx0ZXJzKTtcblx0XHR9XG5cblx0XHQvLyBjZWxsIGZpbHRlcnNcblx0XHRmb3IgKGxldCBba2V5LCBmaWx0ZXJNYXBdIG9mIG90aGVyQ3VydmVMaXN0LmJydXNoTGlzdC5lbnRyaWVzKCkpXG5cdFx0e1xuXHRcdFx0bGV0IHRpbWVkS2V5ID0ga2V5ICsgRGF0ZS5ub3coKTtcblx0XHRcdGZvciAobGV0IFthdHRyaWJ1dGVLZXksIGV4dGVudF0gb2YgZmlsdGVyTWFwLmVudHJpZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5hZGRCcnVzaE5vVXBkYXRlKHRpbWVkS2V5LCB7XG5cdFx0XHRcdFx0a2V5OiBhdHRyaWJ1dGVLZXksXG5cdFx0XHRcdFx0Ym91bmQ6IGV4dGVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0cmFjayBmaWx0ZXJzXG5cdFx0Zm9yIChsZXQgW2tleSwgZmlsdGVyTWFwXSBvZiBvdGhlckN1cnZlTGlzdC5jdXJ2ZUNvbGxlY3Rpb24uYnJ1c2hMaXN0LmVudHJpZXMoKSlcblx0XHR7XG5cdFx0XHRsZXQgdGltZWRLZXkgPSBrZXkgKyBEYXRlLm5vdygpO1xuXHRcdFx0Zm9yIChsZXQgW2F0dHJpYnV0ZUtleSwgZXh0ZW50XSBvZiBmaWx0ZXJNYXAuZW50cmllcygpKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnZlQ29sbGVjdGlvbi5hZGRCcnVzaE5vVXBkYXRlKHRpbWVkS2V5LCB7XG5cdFx0XHRcdFx0a2V5OiBhdHRyaWJ1dGVLZXksXG5cdFx0XHRcdFx0Ym91bmQ6IGV4dGVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgQXBwbHlOZXdGaWx0ZXIoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5PbkJydXNoQ2hhbmdlKCk7XG5cdFx0Y29uc3QgaW5GaWx0ZXJMb2NhdGlvbnM6IFNldDxudW1iZXI+ID0gdGhpcy5nZW5lcmF0ZUluRmlsdGVyTG9jYXRpb25zKCk7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZmlyc3RQb2ludCA9IGN1cnZlLnBvaW50TGlzdFswXTtcblx0XHRcdGNvbnN0IGxvY2F0aW9uID0gZmlyc3RQb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG5cdFx0XHRpZiAoIWluRmlsdGVyTG9jYXRpb25zLmhhcyhsb2NhdGlvbikpXG5cdFx0XHR7XG5cdFx0XHRcdGN1cnZlLmluQnJ1c2ggPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlSW5GaWx0ZXJMb2NhdGlvbnMoKTogU2V0PG51bWJlcj5cblx0e1xuXHRcdGNvbnN0IGluRmlsdGVyU2V0ID0gbmV3IFNldDxudW1iZXI+KCk7XG5cdFx0Y29uc3QgW2xhYmVsMSwgbGFiZWwyXSA9IHRoaXMuZGVmYXVsdEZhY2V0QXhpc1RpY2tzLmF4aXNMYWJlbHNcblx0XHRmb3IgKGxldCBrZXkxIG9mIHRoaXMuY29uZGl0aW9uRmlsdGVyU3RhdGUua2V5cygpKVxuXHRcdHtcblx0XHRcdGxldCBudW1iZXJSYW5nZUxpc3QxID0gdGhpcy5TcGVjaWZpY2F0aW9uLmxvY2F0aW9uTWFwc1tsYWJlbDFdW2tleTFdO1xuXHRcdFx0bGV0IG51bWJlclNldDEgPSBDdXJ2ZUxpc3QubnVtYmVyUmFuZ2VMaXN0VG9TZXQobnVtYmVyUmFuZ2VMaXN0MSk7XG5cdFx0XHRsZXQgcm93TWFwID0gdGhpcy5jb25kaXRpb25GaWx0ZXJTdGF0ZS5nZXQoa2V5MSk7XG5cdFx0XHRmb3IgKGxldCBba2V5MiwgdmFsdWVdIG9mIHJvd01hcC5lbnRyaWVzKCkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxldCBudW1iZXJSYW5nZUxpc3QyID0gdGhpcy5TcGVjaWZpY2F0aW9uLmxvY2F0aW9uTWFwc1tsYWJlbDJdW2tleTJdO1xuXHRcdFx0XHRcdGxldCBudW1iZXJTZXQyID0gQ3VydmVMaXN0Lm51bWJlclJhbmdlTGlzdFRvU2V0KG51bWJlclJhbmdlTGlzdDIpO1xuXHRcdFx0XHRcdGxldCBpbnRlcnNlY3Rpb246IG51bWJlcltdID0gWy4uLm51bWJlclNldDFdLmZpbHRlcih4ID0+IG51bWJlclNldDIuaGFzKHgpKTtcblx0XHRcdFx0XHRmb3IgKGxldCB2YWwgb2YgaW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGluRmlsdGVyU2V0LmFkZCh2YWwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbkZpbHRlclNldDtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIG51bWJlclJhbmdlTGlzdFRvU2V0KG51bWJlclJhbmdlTGlzdDogW251bWJlciwgbnVtYmVyXVtdKTogU2V0PG51bWJlcj5cblx0e1xuXHRcdGNvbnN0IG51bWJlclNldCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuXHRcdGZvciAobGV0IFtsb3csIGhpZ2hdIG9mIG51bWJlclJhbmdlTGlzdClcblx0XHR7XG5cdFx0XHRmb3IgKGxldCBpID0gbG93OyBpIDw9IGhpZ2g7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0bnVtYmVyU2V0LmFkZChpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bWJlclNldDtcblx0fVxuXG5cdHB1YmxpYyBHZXRDZWxsc0F0RnJhbWUobG9jYXRpb25JZDogbnVtYmVyLCBmcmFtZUlkOiBudW1iZXIpOiBQb2ludE5EW11cblx0e1xuXHRcdGlmICh0aGlzLl9sb2NhdGlvbkZyYW1lU2VnbWVudExvb2t1cC5oYXMobG9jYXRpb25JZCkpXG5cdFx0e1xuXHRcdFx0Y29uc3QgZnJhbWVNYXAgPSB0aGlzLl9sb2NhdGlvbkZyYW1lU2VnbWVudExvb2t1cC5nZXQobG9jYXRpb25JZCk7XG5cdFx0XHRpZiAoZnJhbWVNYXAuaGFzKGZyYW1lSWQpKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCBzZWdNYXAgPSBmcmFtZU1hcC5nZXQoZnJhbWVJZCk7XG5cdFx0XHRcdGNvbnN0IHR1cGxlbGlzdCA9IHNlZ01hcC52YWx1ZXMoKTtcblx0XHRcdFx0bGV0IHBvaW50TGlzdDogUG9pbnRORFtdID0gW107XG5cdFx0XHRcdGZvciAobGV0IFtwb2ludCwgX10gb2YgdHVwbGVsaXN0KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cG9pbnRMaXN0LnB1c2gocG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwb2ludExpc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHB1YmxpYyBHZXRDZWxsRnJvbUxhYmVsKGxvY2F0aW9uSWQ6IG51bWJlciwgZnJhbWVJZDogbnVtYmVyLCBzZWdtZW50TGFiZWw6IG51bWJlcik6IFtQb2ludE5ELCBudW1iZXJdIHwgW251bGwsIG51bGxdXG5cdHtcblx0XHRpZiAodGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAuaGFzKGxvY2F0aW9uSWQpKVxuXHRcdHtcblx0XHRcdGNvbnN0IGZyYW1lTWFwID0gdGhpcy5fbG9jYXRpb25GcmFtZVNlZ21lbnRMb29rdXAuZ2V0KGxvY2F0aW9uSWQpO1xuXHRcdFx0aWYgKGZyYW1lTWFwLmhhcyhmcmFtZUlkKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3Qgc2VnTWFwID0gZnJhbWVNYXAuZ2V0KGZyYW1lSWQpO1xuXHRcdFx0XHRpZiAoc2VnTWFwLmhhcyhzZWdtZW50TGFiZWwpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIHNlZ01hcC5nZXQoc2VnbWVudExhYmVsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gW251bGwsIG51bGxdO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2hBcHBsaWVkIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBicnVzaEFwcGxpZWQoKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaEFwcGxpZWQ7XG5cdH1cblx0cHVibGljIHNldCBicnVzaEFwcGxpZWQodiA6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9icnVzaEFwcGxpZWQgPSB2O1xuXHR9XG5cdFxuXHRwcml2YXRlIF9jdXJ2ZUJydXNoTGlzdCA6IE1hcDxzdHJpbmcsIFt2YWx1ZUZpbHRlciwgdmFsdWVGaWx0ZXJdPjtcblx0cHVibGljIGdldCBjdXJ2ZUJydXNoTGlzdCgpIDogTWFwPHN0cmluZywgW3ZhbHVlRmlsdGVyLCB2YWx1ZUZpbHRlcl0+IHtcblx0XHRyZXR1cm4gdGhpcy5fY3VydmVCcnVzaExpc3Q7XG5cdH1cblxuXHRwcml2YXRlIF9jb25kaXRpb25GaWx0ZXJTdGF0ZSA6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIGJvb2xlYW4+Pjtcblx0cHVibGljIGdldCBjb25kaXRpb25GaWx0ZXJTdGF0ZSgpIDogTWFwPHN0cmluZywgTWFwPHN0cmluZywgYm9vbGVhbj4+IHtcblx0XHRyZXR1cm4gdGhpcy5fY29uZGl0aW9uRmlsdGVyU3RhdGU7XG5cdH1cblxuXHRwcm90ZWN0ZWQgZ2V0RmFjZXRMaXN0KGxvY2F0aW9uTWFwOiBMb2NhdGlvbk1hcExpc3QpOiBGYWNldFtdXG5cdHtcblx0XHRyZXR1cm4gQ3VydmVMaXN0RmFjdG9yeS5DcmVhdGVGYWNldGVkRGF0YXNldHModGhpcywgbG9jYXRpb25NYXApO1xuXHR9XG5cblx0cHVibGljIE9uQnJ1c2hDaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5jbGVhckRlZmF1bHRGYWNldENhY2hlKCk7XG5cdFx0dGhpcy5fYXZlcmFnZUZpbHRlcmVkQ3VydmVDYWNoZS5jbGVhcigpO1xuXHRcdGZvciAobGV0IGN1cnZlIG9mIHRoaXMuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGN1cnZlLmluQnJ1c2ggPSB0cnVlO1xuXHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgY3VydmUucG9pbnRMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRwb2ludC5pbkJydXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gc2V0cyBmaWx0ZXIgdmFsdWVzIGF0IHBvaW50IGxldmVsXG5cdFx0Y29uc3QgcG9pbnRCcnVzaEFwcGxpZWQ6IGJvb2xlYW4gPSB0aGlzLlNldEJydXNoVmFsdWVzKCk7XG5cblx0XHQvLyBzZXQgdHJhY2sgdG8gZmFsc2UgaWYgYWxsIHRoZSBwb2ludHMgaW4gYSB0cmFjayBhcmUgYWxzbyBmYWxzZVxuXHRcdGZvciAobGV0IGN1cnZlIG9mIHRoaXMuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGxldCBhbGxQb2ludHNIaWRkZW4gPSB0cnVlO1xuXHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgY3VydmUucG9pbnRMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAocG9pbnQuaW5CcnVzaClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGFsbFBvaW50c0hpZGRlbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoYWxsUG9pbnRzSGlkZGVuKVxuXHRcdFx0e1xuXHRcdFx0XHRjdXJ2ZS5pbkJydXNoID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2V0cyBmaWx0ZXIgdmFsdWVzIGF0IHRyYWNrIGxldmVsXG5cdFx0Y29uc3QgY3VydmVDb2xsZWN0aW9uQnJ1c2hBcHBsaWVkOiBib29sZWFuID0gdGhpcy5jdXJ2ZUNvbGxlY3Rpb24uU2V0QnJ1c2hWYWx1ZXMoKTtcblx0XHRjb25zdCBjdXJ2ZUJydXNoQXBwbGllZDogYm9vbGVhbiA9IHRoaXMuc2V0Q3VydmVCcnVzaFZhbHVlcygpO1xuXHRcdHRoaXMuX2JydXNoQXBwbGllZCA9IHBvaW50QnJ1c2hBcHBsaWVkIHx8IGN1cnZlQnJ1c2hBcHBsaWVkIHx8IGN1cnZlQ29sbGVjdGlvbkJydXNoQXBwbGllZDtcblx0fVxuXG5cdHByaXZhdGUgc2V0Q3VydmVCcnVzaFZhbHVlcygpOiBib29sZWFuXG5cdHtcblx0XHRsZXQgYnJ1c2hBcHBsaWVkID0gZmFsc2U7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0bGV0IGFsbFBvaW50c091dE9mQnJ1c2ggPSB0cnVlO1xuXHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgY3VydmUucG9pbnRMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5pc1BvaW50SW5DdXJ2ZUJydXNoTGlzdChwb2ludCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhbGxQb2ludHNPdXRPZkJydXNoID0gZmFsc2U7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhbGxQb2ludHNPdXRPZkJydXNoKVxuXHRcdFx0e1xuXHRcdFx0XHRjdXJ2ZS5pbkJydXNoID0gZmFsc2U7XG5cdFx0XHRcdGJydXNoQXBwbGllZCA9IHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJydXNoQXBwbGllZDtcblx0fVxuXG5cdHByaXZhdGUgaXNQb2ludEluQ3VydmVCcnVzaExpc3QocG9pbnQ6IFBvaW50TkQpOiBib29sZWFuXG5cdHtcblx0XHRmb3IgKGxldCB2YWx1ZUZpbHRlckxpc3Qgb2YgdGhpcy5jdXJ2ZUJydXNoTGlzdC52YWx1ZXMoKSlcblx0XHR7XG5cdFx0XHRmb3IgKGxldCB2YWx1ZUZpbHRlciBvZiB2YWx1ZUZpbHRlckxpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGlmICghUG9pbnRDb2xsZWN0aW9uLklzSW5CcnVzaChwb2ludCwgdmFsdWVGaWx0ZXIpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cHJpdmF0ZSB1cGRhdGVNaW5NYXhNYXAoKVxuXHR7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgcG9pbnQgb2YgY3VydmUucG9pbnRMaXN0KVxuXHRcdFx0e1xuXHRcdFx0XHRmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgcG9pbnQudmFsdWVNYXApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsZXQgY3VycmVudFZhbCA9IHRoaXMuX21pbk1heE1hcC5nZXQoa2V5KTtcblx0XHRcdFx0XHRsZXQgcG9pbnRWYWwgPSBwb2ludC5nZXQoa2V5KTtcblx0XHRcdFx0XHRpZiAodHlwZW9mIGN1cnJlbnRWYWwgPT09IFwidW5kZWZpbmVkXCIpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0dGhpcy5fbWluTWF4TWFwLnNldChrZXksIFtwb2ludFZhbCwgcG9pbnRWYWxdKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgW2MxLCBjMl0gPSBjdXJyZW50VmFsO1xuXHRcdFx0XHRcdGxldCBuZXdWYWw6IFtudW1iZXIsIG51bWJlcl0gPSBbTWF0aC5taW4oYzEsIHBvaW50VmFsKSwgTWF0aC5tYXgoYzIsIHBvaW50VmFsKV07XG5cdFx0XHRcdFx0dGhpcy5fbWluTWF4TWFwLnNldChrZXksIG5ld1ZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGdlbmVyYXRlSW52ZXJzZUxvY2F0aW9uTWFwKCk6IHZvaWRcblx0e1x0XG5cdFx0Zm9yIChsZXQgY2F0ZWdvcnlOYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuU3BlY2lmaWNhdGlvbi5sb2NhdGlvbk1hcHMpKVxuXHRcdHtcblx0XHRcdGNvbnN0IGNvbmRpdGlvbkJyZWFrZG93biA9IHRoaXMuU3BlY2lmaWNhdGlvbi5sb2NhdGlvbk1hcHNbY2F0ZWdvcnlOYW1lXTtcblx0XHRcdGZvciAobGV0IGNvbmRpdGlvbk5hbWUgb2YgT2JqZWN0LmtleXMoY29uZGl0aW9uQnJlYWtkb3duKSlcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgbnVtYmVyUmFuZ2VMaXN0ID0gY29uZGl0aW9uQnJlYWtkb3duW2NvbmRpdGlvbk5hbWVdO1xuXHRcdFx0XHRmb3IgKGxldCBbbG93LCBoaWdoXSBvZiBudW1iZXJSYW5nZUxpc3QpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gbG93OyBpIDw9IGhpZ2g7IGkrKylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX2ludmVyc2VMb2NhdGlvbk1hcC5oYXMoaSkpXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2ludmVyc2VMb2NhdGlvbk1hcC5zZXQoaSwgW10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5faW52ZXJzZUxvY2F0aW9uTWFwLmdldChpKS5wdXNoKGNvbmRpdGlvbk5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaW5pdFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKTogdm9pZFxuXHR7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y3VydmUuYWRkVmFsdWUoa2V5LCB2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBpc0tleVNldChrZXk6IHN0cmluZyk6IGJvb2xlYW5cblx0e1xuXHRcdGZvciAobGV0IGN1cnZlIG9mIHRoaXMuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGxldCB2YWx1ZTogbnVtYmVyIHwgdW5kZWZpbmVkID0gY3VydmUuZ2V0KGtleSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cHVibGljIHNldElucHV0S2V5KGtleTogc3RyaW5nKTogdm9pZFxuXHR7XG5cdFx0dGhpcy5faW5wdXRLZXkgPSBrZXk7XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0Y3VydmUuc29ydChrZXkpO1xuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyByZW1vdmVDdXJ2ZUJydXNoKGJydXNoS2V5OiBzdHJpbmcpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmN1cnZlQnJ1c2hMaXN0LmRlbGV0ZShicnVzaEtleSk7XG5cdFx0dGhpcy51cGRhdGVCcnVzaCgpO1xuXHR9XG5cblx0cHVibGljIGFkZEN1cnZlQnJ1c2goYnJ1c2hLZXk6IHN0cmluZywgZmlsdGVyczogW3ZhbHVlRmlsdGVyLCB2YWx1ZUZpbHRlcl0pOiB2b2lkXG5cdHtcblx0XHR0aGlzLmN1cnZlQnJ1c2hMaXN0LnNldChicnVzaEtleSwgZmlsdGVycyk7XG5cdFx0dGhpcy51cGRhdGVCcnVzaCgpO1xuXHR9XG5cblx0cHVibGljIHNvcnQoa2V5OiBzdHJpbmcsIGFzY2VuZDogYm9vbGVhbiA9IHRydWUpOiB2b2lkXG5cdHtcblx0XHRsZXQgc29ydEZ1bmN0aW9uID0gRGV2bGliQWxnby5zb3J0T25Qcm9wZXJ0eTxDdXJ2ZU5EPigoY3VydmU6IEN1cnZlTkQpID0+IFxuXHRcdHtcblx0XHRcdHJldHVybiBjdXJ2ZS5nZXQoa2V5KTtcblx0XHR9LCBhc2NlbmQpO1xuXHRcdHRoaXMuY3VydmVMaXN0LnNvcnQoc29ydEZ1bmN0aW9uKTtcblx0fVxuXG5cdHB1YmxpYyBnZXRQb2ludHNBdElucHV0KGlucHV0VmFsdWU6IG51bWJlcik6IFBvaW50TkRbXVxuXHR7XG5cdFx0bGV0IHBvaW50TGlzdDogUG9pbnRORFtdID0gW107XG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0e1xuXHRcdFx0bGV0IHBvaW50ID0gY3VydmUuZ2V0UG9pbnQoaW5wdXRWYWx1ZSk7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhwb2ludCk7XG5cdFx0XHRpZiAocG9pbnQpXG5cdFx0XHR7XG5cdFx0XHRcdHBvaW50TGlzdC5wdXNoKHBvaW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcG9pbnRMaXN0O1xuXHR9XG5cblx0cHVibGljIGNhbGN1bGF0ZURlcHRoKGRlcHRoS2V5OiBzdHJpbmcsIHZhbHVlS2V5OiBzdHJpbmcpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5pc0tleVNldChkZXB0aEtleSkpXG5cdFx0e1xuXHRcdFx0Ly8gZGVwdGggaXMgYWxyZWFkeSBzZXRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5pbml0VmFsdWUoZGVwdGhLZXksIDApO1xuXG5cdFx0Y29uc3QgYWxsQmFuZHMgPSBDdXJ2ZUxpc3QuZ2V0QWxsUG9zc2libGUyQmFuZHModGhpcy5jdXJ2ZUxpc3QpIGFzIFtDdXJ2ZU5ELCBDdXJ2ZU5EXVtdO1xuXHRcdGZvciAobGV0IGJhbmQgb2YgYWxsQmFuZHMpXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgY3VydmUgb2YgdGhpcy5jdXJ2ZUxpc3QpXG5cdFx0XHR7XG5cdFx0XHRcdGNvbnN0IGRlcHRoQ29udHJpYnV0aW9uID0gdGhpcy5nZXREZXB0aENvbnRyaWJ1dGlvbihjdXJ2ZSwgYmFuZCwgdmFsdWVLZXkpO1xuXHRcdFx0XHRjb25zdCBvbGREZXB0aCA9IGN1cnZlLmdldChkZXB0aEtleSk7XG5cdFx0XHRcdGN1cnZlLmFkZFZhbHVlKGRlcHRoS2V5LCBvbGREZXB0aCArIGRlcHRoQ29udHJpYnV0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0b2RvIC0gbm9ybWFsaXplXG5cblx0fVxuXG5cdHByaXZhdGUgZ2V0RGVwdGhDb250cmlidXRpb24oY3VydmU6IEN1cnZlTkQsIFtiMSwgYjJdOiBbQ3VydmVORCwgQ3VydmVORF0sIHZhbHVlS2V5OiBzdHJpbmcpOiBudW1iZXJcblx0e1xuXHRcdGxldCBkZXB0aCA9IDA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjdXJ2ZS5wb2ludExpc3QubGVuZ3RoOyBpKyspXG5cdFx0e1xuXHRcdFx0bGV0IHBvaW50OiBQb2ludE5EID0gY3VydmUucG9pbnRMaXN0W2ldO1xuXHRcdFx0Y29uc3QgdCA9IHBvaW50LmdldCh0aGlzLmlucHV0S2V5KTtcblx0XHRcdGxldCB0aGlzVmFsID0gcG9pbnQuZ2V0KHZhbHVlS2V5KTtcblx0XHRcdGxldCBiMVZhbCA9IGIxLmdldFBvaW50VmFsdWUodCwgdmFsdWVLZXkpO1xuXHRcdFx0bGV0IGIyVmFsID0gYjIuZ2V0UG9pbnRWYWx1ZSh0LCB2YWx1ZUtleSk7XG5cdFx0XHRsZXQgbWluVmFsID0gTWF0aC5taW4oYjFWYWwsIGIyVmFsKTtcblx0XHRcdGxldCBtYXhWYWwgPSBNYXRoLm1heChiMVZhbCwgYjJWYWwpO1xuXHRcdFx0aWYgKG1pblZhbCA8PSB0aGlzVmFsICYmIHRoaXNWYWwgPD0gbWF4VmFsKVxuXHRcdFx0e1xuXHRcdFx0XHRjb25zdCB3ZWlnaHQgPSBjdXJ2ZS5nZXRQb2ludFdlaWdodChpKTtcblx0XHRcdFx0ZGVwdGggKz0gd2VpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVwdGg7XG5cdH1cblxuXHRzdGF0aWMgZ2V0QWxsUG9zc2libGUyQmFuZHMobGlzdDogYW55W10pOiBbYW55LCBhbnldW11cblx0e1xuXHRcdGNvbnN0IGJhbmRMaXN0OiBbYW55LCBhbnldW10gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspXG5cdFx0e1xuXHRcdFx0Zm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGlzdC5sZW5ndGg7IGorKylcblx0XHRcdHtcblx0XHRcdFx0bGV0IGI6IFthbnksIGFueV0gPSBbbGlzdFtpXSwgbGlzdFtqXV07XG5cdFx0XHRcdGJhbmRMaXN0LnB1c2goYik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBiYW5kTGlzdFxuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmF0b3I8UG9pbnRORD5cblx0e1xuXHRcdHJldHVybiBuZXcgQ3VydmVMaXN0SXRlcmF0b3IodGhpcy5jdXJ2ZUxpc3QpO1xuXHR9XG5cbn0iLCJpbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5pbXBvcnQgeyBEZXZsaWJNYXRoIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYk1hdGgnO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi9DdXJ2ZUxpc3QnO1xuaW1wb3J0IHsgQ3VydmVORCB9IGZyb20gJy4vQ3VydmVORCc7XG5pbXBvcnQgeyBQb2ludE5EIH0gZnJvbSAnLi9Qb2ludE5EJztcbmltcG9ydCB7IFN0cmluZ1RvU3RyaW5nT2JqLCBTdHJpbmdUb051bWJlck9iaiwgS2V5ZWRUcmFja0Rlcml2YXRpb25GdW5jdGlvbiwgS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbiB9IGZyb20gJy4uL2RldmxpYi9EZXZMaWJUeXBlcydcbmltcG9ydCB7IERhdGFzZXRTcGVjLCBGYWNldCwgTG9jYXRpb25NYXBMaXN0IH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbnRlcmZhY2UgU3RyaW5nVG9OdW1iZXJPckxpc3Qge1xuICAgIFtrZXk6IHN0cmluZ106IG51bWJlciB8IFN0cmluZ1RvTnVtYmVyT2JqW107XG59XG5cbmV4cG9ydCBjbGFzcyBDdXJ2ZUxpc3RGYWN0b3J5IHtcblxuXHRwdWJsaWMgc3RhdGljIENyZWF0ZUZhY2V0ZWREYXRhc2V0cyhmdWxsRGF0YTogQ3VydmVMaXN0LCBsb2NhdGlvbk1hcDogTG9jYXRpb25NYXBMaXN0KTogRmFjZXRbXVxuXHR7XG5cdFx0bGV0IGxvY1RvQ2F0OiBNYXA8bnVtYmVyLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuXHRcdFxuXHRcdGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhsb2NhdGlvbk1hcCkpXG5cdFx0e1xuXHRcdFx0bGV0IHZhbHVlTGlzdCA9IGxvY2F0aW9uTWFwW2tleV07XG5cdFx0XHRpZiAodmFsdWVMaXN0Lmxlbmd0aCA9PT0gMClcblx0XHRcdHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdMb2NhdGlvbk1hcCB2YWx1ZUxpc3Qgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5Jylcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgdmFsdWVMaXN0WzBdID09PSAnc3RyaW5nJylcblx0XHRcdHtcblx0XHRcdFx0Ly8gdG9kbyB3b3JrIGZvciBsb2NhdGlvbm1hcHRlbWFwbGF0ZSB0eXBlXG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IFtsb3csIGhpZ2hdIG9mIHZhbHVlTGlzdClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSArbG93OyBpIDw9ICtoaWdoOyBpKyspXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bG9jVG9DYXQuc2V0KGksIGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHBvaW50TWFwOiBNYXA8c3RyaW5nLCBDdXJ2ZU5EW10+ID0gbmV3IE1hcCgpO1xuXG5cdFx0Zm9yIChsZXQgY3VydmUgb2YgZnVsbERhdGEuY3VydmVMaXN0KVxuXHRcdHtcblx0XHRcdGxldCBmaXJzdFBvaW50ID0gY3VydmUucG9pbnRMaXN0WzBdO1xuXHRcdFx0bGV0IGxvY2F0aW9uID0gZmlyc3RQb2ludC5nZXQoJ0xvY2F0aW9uIElEJyk7XG5cdFx0XHRsZXQgY2F0ZWdvcnkgPSBsb2NUb0NhdC5nZXQobG9jYXRpb24pO1xuXHRcdFx0aWYgKCFwb2ludE1hcC5oYXMoY2F0ZWdvcnkpKVxuXHRcdFx0e1xuXHRcdFx0XHRwb2ludE1hcC5zZXQoY2F0ZWdvcnksIFtdKTtcblx0XHRcdH1cblx0XHRcdHBvaW50TWFwLmdldChjYXRlZ29yeSkucHVzaChjdXJ2ZSk7XG5cdFx0fVxuXG5cdFx0bGV0IGZhY2V0TGlzdCA9IFtdO1xuXHRcdGZvciAobGV0IFtjYXQsIGxpc3RPZkN1cnZlc10gb2YgcG9pbnRNYXApXG5cdFx0e1xuXHRcdFx0bGV0IGN1cnZlTGlzdCA9IG5ldyBDdXJ2ZUxpc3QobGlzdE9mQ3VydmVzLCBmdWxsRGF0YS5TcGVjaWZpY2F0aW9uKTtcblx0XHRcdGxldCBmYWNldDogRmFjZXQgPSB7XG5cdFx0XHRcdG5hbWU6IFtjYXRdLFxuXHRcdFx0XHRkYXRhOiBjdXJ2ZUxpc3Rcblx0XHRcdH1cblx0XHRcdGZhY2V0TGlzdC5wdXNoKGZhY2V0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhY2V0TGlzdDtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgQ3JlYXRlQ3VydmVMaXN0RnJvbUNTVk9iamVjdChjc3ZPYmplY3Q6IGQzLkRTVlJvd0FycmF5PHN0cmluZz4sIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSwgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9uczogS2V5ZWRQb2ludERlcml2YXRpb25GdW5jdGlvbltdLCBkYXRhU3BlYzogRGF0YXNldFNwZWMsIGlka2V5OiBzdHJpbmcgPSBcImlkXCIsIHRLZXlPcHRpb25zOiBzdHJpbmdbXSA9IFtcIlRpbWUgKGgpXCJdKTogQ3VydmVMaXN0XG5cdHtcblx0XHRjb25zb2xlLmxvZyhjc3ZPYmplY3QpO1xuXHRcdGNvbnN0IGN1cnZlTGlzdDogQ3VydmVORFtdID0gW107XG5cdFx0bGV0IHRLZXk6IHN0cmluZyA9IG51bGw7XG5cdFx0Zm9yIChsZXQga2V5T3B0aW9uIG9mIHRLZXlPcHRpb25zKVxuXHRcdHtcblx0XHRcdGlmIChjc3ZPYmplY3QuY29sdW1ucy5pbmNsdWRlcyhrZXlPcHRpb24pKVxuXHRcdFx0e1xuXHRcdFx0XHR0S2V5ID0ga2V5T3B0aW9uO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHRLZXkgPT0gbnVsbClcblx0XHR7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJEYXRhc2V0IGRvZXMgbm90IGNvbnRhaW4gYW55IHRLZXkgY29sdW1uLiBBbGxvd2VkIEtleXM6IFwiICsgdEtleU9wdGlvbnMudG9TdHJpbmcoKSlcblx0XHR9XG5cblx0XHRsZXQgcG9qb0xpc3QgPSBkMy5uZXN0PFN0cmluZ1RvU3RyaW5nT2JqLCBTdHJpbmdUb051bWJlck9yTGlzdD4oKVxuXHRcdFx0LmtleShkID0+IGRbaWRrZXldKVxuXHRcdFx0LnJvbGx1cCgocm93czogYW55W10pID0+XG5cdFx0XHR7IFxuXHRcdFx0XHRjb25zdCB2YWx1ZXM6IFN0cmluZ1RvTnVtYmVyT3JMaXN0ID0ge307XG5cdFx0XHRcdGNvbnN0IHBvaW50czogU3RyaW5nVG9OdW1iZXJPYmpbXSA9IFtdO1xuXHRcdFx0XHRmb3IgKGxldCByb3cgb2Ygcm93cylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHRWYWx1ZTogc3RyaW5nID0gcm93W3RLZXldO1xuXHRcdFx0XHRcdGlmICghRGV2bGliTWF0aC5pc051bWJlcih0VmFsdWUpKVxuXHRcdFx0XHRcdHtcblxuXHRcdFx0XHRcdFx0Zm9yIChsZXQga2V5IGluIHJvdylcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0aWYgKGtleSA9PT0gaWRrZXkgfHwga2V5ID09PSB0S2V5KVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSByb3dba2V5XTtcblx0XHRcdFx0XHRcdFx0aWYgKCFEZXZsaWJNYXRoLmlzTnVtYmVyKVxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsdWVzW3RWYWx1ZV0gPSArdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IHBvaW50OiBTdHJpbmdUb051bWJlck9iaiA9IHt9O1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQga2V5IGluIHJvdylcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoa2V5ID09PSBpZGtleSlcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwb2ludFtrZXldID0gK3Jvd1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWVzLnBvaW50cyA9IHBvaW50cztcblx0XHRcdFx0Q3VydmVMaXN0RmFjdG9yeS5jYWxjdWxhdGVEZXJpdmVkUG9pbnRWYWx1ZXModmFsdWVzLCBkZXJpdmVkUG9pbnREYXRhRnVuY3Rpb25zKTtcblx0XHRcdFx0Q3VydmVMaXN0RmFjdG9yeS5jYWxjdWxhdGVEZXJpdmVkVHJhY2tWYWx1ZXModmFsdWVzLCBkZXJpdmVkVHJhY2tEYXRhRnVuY3Rpb25zKTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0pXG5cdFx0XHQuZW50cmllcyhjc3ZPYmplY3QpO1xuXG5cdFx0Zm9yIChsZXQgcGxhaW5DdXJ2ZSBvZiBwb2pvTGlzdClcblx0XHR7XG5cdFx0XHRsZXQgbnVtZXJpY0tleSA9ICtwbGFpbkN1cnZlLmtleTtcblx0XHRcdC8vIGpzIGZvcm1hdHMgdGhlIG51bWJlciBhcyAnMTIzLjAnLCBJbnN0ZWFkIEkgd2FudCAnMTIzJ1xuXHRcdFx0Y29uc3QgY3VydmUgPSBuZXcgQ3VydmVORChudW1lcmljS2V5LnRvU3RyaW5nKCkpO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIHBsYWluQ3VydmUudmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdGxldCB2YWx1ZSA9IHBsYWluQ3VydmUudmFsdWVba2V5XTtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGN1cnZlLmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAobGV0IHBvam9Qb2ludCBvZiB2YWx1ZSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gbmV3IFBvaW50TkQocG9qb1BvaW50KTtcblx0XHRcdFx0XHRjdXJ2ZS5hZGRQb2ludChwb2ludCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGN1cnZlTGlzdC5wdXNoKGN1cnZlKTtcblx0XHR9XG5cdFx0Ly8gY29uc29sZS5sb2coY3VydmVMaXN0KTtcblx0XHRjb25zdCBjdXJ2ZUxpc3RPYmogPSBuZXcgQ3VydmVMaXN0KGN1cnZlTGlzdCwgZGF0YVNwZWMpO1xuXHRcdGN1cnZlTGlzdE9iai5zZXRJbnB1dEtleSh0S2V5KTtcblx0XHRyZXR1cm4gY3VydmVMaXN0T2JqO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgY2FsY3VsYXRlRGVyaXZlZFRyYWNrVmFsdWVzKHZhbHVlczogU3RyaW5nVG9OdW1iZXJPckxpc3QsIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnM6IEtleWVkVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25bXSk6IHZvaWRcblx0e1xuXHRcdGxldCBwb2ludHM6IFN0cmluZ1RvTnVtYmVyT2JqW10gPSB2YWx1ZXMucG9pbnRzIGFzIFN0cmluZ1RvTnVtYmVyT2JqW107XG5cdFx0Zm9yIChsZXQgW2F0dHJOYW1lTGlzdCwgZnVuY10gb2YgZGVyaXZlZFRyYWNrRGF0YUZ1bmN0aW9ucylcblx0XHR7XG5cdFx0XHRsZXQgdmFsdWVMaXN0ID0gZnVuYyhwb2ludHMpO1xuXHRcdFx0aWYgKHZhbHVlTGlzdCA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJOYW1lTGlzdC5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0bGV0IGF0dHJOYW1lID0gYXR0ck5hbWVMaXN0W2ldO1xuXHRcdFx0XHRsZXQgdmFsID0gdmFsdWVMaXN0W2ldO1xuXHRcdFx0XHR2YWx1ZXNbYXR0ck5hbWVdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGNhbGN1bGF0ZURlcml2ZWRQb2ludFZhbHVlcyh2YWx1ZXM6IFN0cmluZ1RvTnVtYmVyT3JMaXN0LCBkZXJpdmVkUG9pbnREYXRhRnVuY3Rpb25zOiBLZXllZFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uW10pOiB2b2lkXG5cdHtcblx0XHRsZXQgcG9pbnRzOiBTdHJpbmdUb051bWJlck9ialtdID0gdmFsdWVzLnBvaW50cyBhcyBTdHJpbmdUb051bWJlck9ialtdO1xuXHRcdGZvciAobGV0IFthdHRyTmFtZUxpc3QsIGZ1bmNdIG9mIGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnMpXG5cdFx0e1xuXHRcdFx0bGV0IHZhbHVlTGlzdE9mTGlzdHMgPSBmdW5jKHBvaW50cyk7XG5cdFx0XHRpZiAodmFsdWVMaXN0T2ZMaXN0cyA9PT0gbnVsbClcblx0XHRcdHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJOYW1lTGlzdC5sZW5ndGg7IGkrKylcblx0XHRcdHtcblx0XHRcdFx0bGV0IGF0dHJOYW1lID0gYXR0ck5hbWVMaXN0W2ldO1xuXHRcdFx0XHRsZXQgdmFsdWVMaXN0ID0gdmFsdWVMaXN0T2ZMaXN0c1tpXTtcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBqKyspXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRwb2ludHNbal1bYXR0ck5hbWVdID0gdmFsdWVMaXN0W2pdO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0iLCJpbXBvcnQgeyBQb2ludE5EIH0gZnJvbSAnLi9Qb2ludE5EJztcbmltcG9ydCB7IEN1cnZlTkQgfSBmcm9tICcuL0N1cnZlTkQnO1xuaW1wb3J0IHsgQ3VydmVJdGVyYXRvciB9IGZyb20gJy4vQ3VydmVJdGVyYXRvcic7XG5cbmV4cG9ydCBjbGFzcyBDdXJ2ZUxpc3RJdGVyYXRvciBpbXBsZW1lbnRzIEl0ZXJhdG9yPFBvaW50TkQ+IHtcblx0XG5cdGNvbnN0cnVjdG9yKGN1cnZlTGlzdDogQ3VydmVORFtdKVxuXHR7XG5cdFx0dGhpcy5fY3VydmVMaXN0ID0gY3VydmVMaXN0O1xuXHRcdHRoaXMudXBkYXRlQ3VydmVJdGVyYXRvcigwKTtcblx0fVxuXG5cdHByaXZhdGUgX2luZGV4IDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGluZGV4KCkgOiBudW1iZXIge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxuXG5cdHByaXZhdGUgX2N1cnZlTGlzdCA6IEN1cnZlTkRbXTtcblx0cHVibGljIGdldCBjdXJ2ZUxpc3QoKSA6IEN1cnZlTkRbXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnZlTGlzdDtcblx0fVxuXG5cdHByaXZhdGUgX2N1cnJlbnRDdXJ2ZUl0ZXJhdG9yIDogQ3VydmVJdGVyYXRvcjtcblx0cHVibGljIGdldCBjdXJyZW50Q3VydmVJdGVyYXRvcigpIDogQ3VydmVJdGVyYXRvciB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRDdXJ2ZUl0ZXJhdG9yO1xuXHR9XG5cblx0cHVibGljIG5leHQoKTogSXRlcmF0b3JSZXN1bHQ8UG9pbnRORD5cblx0e1xuXHRcdGxldCBuZXh0UmVzdWx0ID0gdGhpcy5jdXJyZW50Q3VydmVJdGVyYXRvci5uZXh0KCk7XG5cdFx0aWYgKCFuZXh0UmVzdWx0LmRvbmUpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIG5leHRSZXN1bHQ7XG5cdFx0fVxuXHRcdGxldCBuZXdJbmRleCA9IHRoaXMuaW5kZXggKyAxO1xuXHRcdGlmIChuZXdJbmRleCA+PSB0aGlzLmN1cnZlTGlzdC5sZW5ndGgpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZG9uZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGhpcy51cGRhdGVDdXJ2ZUl0ZXJhdG9yKG5ld0luZGV4KTtcblx0XHRyZXR1cm4gdGhpcy5uZXh0KCk7XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZUN1cnZlSXRlcmF0b3IobmV3SW5kZXg6IG51bWJlcik6IHZvaWRcblx0e1xuXHRcdHRoaXMuX2luZGV4ID0gbmV3SW5kZXg7XG5cdFx0bGV0IG5leHRDdXJ2ZSA9IHRoaXMuY3VydmVMaXN0W25ld0luZGV4XTtcblx0XHRpZiAobmV4dEN1cnZlKVxuXHRcdHtcblx0XHRcdHRoaXMuX2N1cnJlbnRDdXJ2ZUl0ZXJhdG9yID0gbmV3IEN1cnZlSXRlcmF0b3IobmV4dEN1cnZlLnBvaW50TGlzdCk7XG5cdFx0fVxuXHR9XG5cblxufSIsImltcG9ydCB7IE5EaW0gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliVHlwZXMnXG5pbXBvcnQgeyBQb2ludE5EIH0gZnJvbSAnLi9Qb2ludE5EJztcbmltcG9ydCB7IERldmxpYkFsZ28gfSBmcm9tICcuLi9kZXZsaWIvRGV2bGliQWxnbyc7XG5pbXBvcnQgeyBQb2ludENvbGxlY3Rpb24gfSBmcm9tICcuL1BvaW50Q29sbGVjdGlvbic7XG5pbXBvcnQgeyBDdXJ2ZUl0ZXJhdG9yIH0gZnJvbSAnLi9DdXJ2ZUl0ZXJhdG9yJztcbmltcG9ydCB7IEFwcERhdGEsIERhdGFzZXRTcGVjLCBGYWNldCB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIEN1cnZlTkQgZXh0ZW5kcyBQb2ludENvbGxlY3Rpb24gaW1wbGVtZW50cyBORGltIHtcblx0cHVibGljIENyZWF0ZUZpbHRlcmVkQ3VydmVMaXN0KCk6IEFwcERhdGE8RGF0YXNldFNwZWM+IHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG5cdH1cblx0cHVibGljIEFwcGx5RGVmYXVsdEZpbHRlcnMoKTogdm9pZCB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuXHR9XG5cdFxuXHRjb25zdHJ1Y3RvcihpZDogc3RyaW5nKSB7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLl9pZCA9IGlkO1xuXHRcdHRoaXMuX3ZhbHVlTWFwID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblx0XHR0aGlzLl9wb2ludExpc3QgPSBbXTtcblx0XHR0aGlzLl9pbkJydXNoID0gdHJ1ZTtcblx0fVxuXG5cdHByaXZhdGUgX2lkIDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGlkKCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fVxuXG5cdHByaXZhdGUgX2lucHV0S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IGlucHV0S2V5KCkgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLl9pbnB1dEtleTtcblx0fVxuXG5cdHByaXZhdGUgX3ZhbHVlTWFwIDogTWFwPHN0cmluZywgbnVtYmVyPjtcblx0cHVibGljIGdldCB2YWx1ZU1hcCgpIDogTWFwPHN0cmluZywgbnVtYmVyPiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlTWFwO1xuXHR9XG5cblx0cHJpdmF0ZSBfcG9pbnRMaXN0IDogUG9pbnRORFtdO1xuXHRwdWJsaWMgZ2V0IHBvaW50TGlzdCgpIDogUG9pbnRORFtdIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnRMaXN0O1xuXHR9XG5cblx0cHJpdmF0ZSBfaW5CcnVzaCA6IGJvb2xlYW47XG5cdHB1YmxpYyBnZXQgaW5CcnVzaCgpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luQnJ1c2g7XG5cdH1cblxuXHRwdWJsaWMgc2V0IGluQnJ1c2godjogYm9vbGVhbikge1xuXHRcdHRoaXMuX2luQnJ1c2ggPSB2O1xuXHRcdGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRMaXN0KVxuXHRcdHtcblx0XHRcdHBvaW50LmluQnJ1c2ggPSB2O1xuXHRcdH1cblx0fVxuXG5cdHByb3RlY3RlZCBnZXRGYWNldExpc3QoKTogRmFjZXRbXVxuXHR7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgSW1wbGVtZW50ZWQuJyk7XG5cdH1cblxuXHRwdWJsaWMgT25CcnVzaENoYW5nZSgpOiB2b2lkIHsgfVxuXHRwdWJsaWMgQ29uc3VtZUZpbHRlcnMoQXBwRGF0YTogYW55KTogdm9pZCB7fTtcblx0cHVibGljIEFwcGx5TmV3RmlsdGVyKCk6IHZvaWQge307XG5cblx0cHVibGljIGFkZFZhbHVlKGtleTogc3RyaW5nLCB2YWx1ZTogbnVtYmVyKVxuXHR7XG5cdFx0dGhpcy52YWx1ZU1hcC5zZXQoa2V5LCB2YWx1ZSk7XG5cdH1cblxuXHRwdWJsaWMgZ2V0KGtleTogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkXG5cdHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZU1hcC5nZXQoa2V5KTtcblx0fVxuXG5cdC8vIGZpbmRzIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aCBnaXZlbiBrZXkuIFdpbGwgaW50ZXJwb2xhdGUuXG5cdHB1YmxpYyBnZXRQb2ludFZhbHVlKGlucHV0VmFsdWU6IG51bWJlciwgb3V0cHV0S2V5OiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWRcblx0e1xuXHRcdGxldCBzb3J0RnVuY3Rpb24gPSBEZXZsaWJBbGdvLmNvbXBhcmVQcm9wZXJ0eTxQb2ludE5EPihpbnB1dFZhbHVlLCAocG9pbnQ6IFBvaW50TkQpID0+IFxuXHRcdHtcblx0XHRcdHJldHVybiBwb2ludC5nZXQodGhpcy5pbnB1dEtleSk7XG5cdFx0fSk7XG5cdFx0bGV0IHBvaW50SW5kZXg6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG5cdFx0cG9pbnRJbmRleCA9IERldmxpYkFsZ28uQmluYXJ5U2VhcmNoSW5kZXgodGhpcy5wb2ludExpc3QsIHNvcnRGdW5jdGlvbik7XG5cblx0XHRpZiAodHlwZW9mIHBvaW50SW5kZXggPT09IFwibnVtYmVyXCIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMucG9pbnRMaXN0W3BvaW50SW5kZXhdLmdldChvdXRwdXRLZXkpO1xuXHRcdH1cblx0XHRjb25zdCBbaWR4MSwgaWR4Ml0gPSBwb2ludEluZGV4O1xuXHRcdGlmIChpZHgxID09PSB1bmRlZmluZWQgfHwgaWR4MiA9PT0gdW5kZWZpbmVkKVxuXHRcdHtcblx0XHRcdC8vIG91dCBvZiBib3VuZHNcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGNvbnN0IHBvaW50MSA9IHRoaXMucG9pbnRMaXN0W2lkeDFdO1xuXHRcdGNvbnN0IHBvaW50MiA9IHRoaXMucG9pbnRMaXN0W2lkeDJdO1xuXG5cdFx0Y29uc3QgdmFsMSA9IHBvaW50MS5nZXQob3V0cHV0S2V5KTtcblx0XHRjb25zdCB2YWwyID0gcG9pbnQyLmdldChvdXRwdXRLZXkpO1xuXG5cdFx0Y29uc3QgdDEgPSBwb2ludDEuZ2V0KHRoaXMuaW5wdXRLZXkpO1xuXHRcdGNvbnN0IHQyID0gcG9pbnQyLmdldCh0aGlzLmlucHV0S2V5KTtcblxuXHRcdGNvbnN0IHREaWZmID0gdDIgLSB0MTtcblx0XHRjb25zdCBwb3J0aW9uID0gKGlucHV0VmFsdWUgLSB0MSkgLyB0RGlmZjtcblx0XHRjb25zdCB2YWxEaWZmID0gdmFsMiAtIHZhbDE7XG5cblx0XHRyZXR1cm4gdmFsMSArIHZhbERpZmYgKiBwb3J0aW9uO1xuXHR9XG5cblx0Ly8gZmluZHMgcG9pbnQgYXQgZ2l2ZW4gaW5wdXQgdGltZS4gV2lsbCBjb25zdHJ1Y3QgYSBuZXcgcG9pbnQgYW5kIGludGVycG9sYXRlIGFsbCB2YWx1ZXMgaWYgaXQgaXMgYmV0d2VlbiBwb2ludHNcblx0cHVibGljIGdldFBvaW50KGlucHV0VmFsdWU6IG51bWJlcik6IFBvaW50TkRcblx0e1xuXHRcdGxldCBzb3J0RnVuY3Rpb24gPSBEZXZsaWJBbGdvLmNvbXBhcmVQcm9wZXJ0eTxQb2ludE5EPihpbnB1dFZhbHVlLCAocG9pbnQ6IFBvaW50TkQpID0+IFxuXHRcdHtcblx0XHRcdHJldHVybiBwb2ludC5nZXQodGhpcy5pbnB1dEtleSk7XG5cdFx0fSk7XG5cdFx0bGV0IHBvaW50SW5kZXg6IG51bWJlciB8IFtudW1iZXIsIG51bWJlcl07XG5cdFx0cG9pbnRJbmRleCA9IERldmxpYkFsZ28uQmluYXJ5U2VhcmNoSW5kZXgodGhpcy5wb2ludExpc3QsIHNvcnRGdW5jdGlvbik7XG5cdFx0aWYgKHR5cGVvZiBwb2ludEluZGV4ID09PSBcIm51bWJlclwiKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnBvaW50TGlzdFtwb2ludEluZGV4XTtcblx0XHR9XG5cdFx0Y29uc3QgW2lkeDEsIGlkeDJdID0gcG9pbnRJbmRleDtcblx0XHRpZiAoaWR4MSA9PT0gdW5kZWZpbmVkIHx8IGlkeDIgPT09IHVuZGVmaW5lZClcblx0XHR7XG5cdFx0XHQvLyBvdXQgb2YgYm91bmRzXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRjb25zdCBwb2ludDEgPSB0aGlzLnBvaW50TGlzdFtpZHgxXTtcblx0XHRjb25zdCBwb2ludDIgPSB0aGlzLnBvaW50TGlzdFtpZHgyXTtcblxuXHRcdGNvbnN0IHQxID0gcG9pbnQxLmdldCh0aGlzLmlucHV0S2V5KTtcblx0XHRjb25zdCB0MiA9IHBvaW50Mi5nZXQodGhpcy5pbnB1dEtleSk7XG5cblx0XHRjb25zdCB0RGlmZiA9IHQyIC0gdDE7XG5cdFx0Y29uc3QgcG9ydGlvbiA9IChpbnB1dFZhbHVlIC0gdDEpIC8gdERpZmY7XG5cblx0XHRsZXQgaW50ZXJwb2xhdGVkUG9pbnQgPSBuZXcgUG9pbnRORCgpO1xuXHRcdGludGVycG9sYXRlZFBvaW50LmFkZFZhbHVlKHRoaXMuaW5wdXRLZXksIGlucHV0VmFsdWUpO1xuXG5cdFx0Zm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHBvaW50MS52YWx1ZU1hcClcblx0XHR7XG5cdFx0XHRsZXQgdmFsMSA9IHBvaW50MS5nZXQoa2V5KTtcblx0XHRcdGxldCB2YWwyID0gcG9pbnQyLmdldChrZXkpO1xuXHRcdFx0bGV0IHZhbERpZmYgPSB2YWwyIC0gdmFsMTtcblx0XHRcdGludGVycG9sYXRlZFBvaW50LmFkZFZhbHVlKGtleSwgdmFsMSArIHZhbERpZmYgKiBwb3J0aW9uKTtcblx0XHR9XG5cdFx0aW50ZXJwb2xhdGVkUG9pbnQuaW5CcnVzaCA9IHBvaW50MS5pbkJydXNoICYmIHBvaW50Mi5pbkJydXNoO1xuXHRcdHJldHVybiBpbnRlcnBvbGF0ZWRQb2ludDtcblx0fVxuXG5cdHB1YmxpYyBnZXRQb2ludFdlaWdodChwb2ludEluZGV4OiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdGNvbnN0IGlkeExlZnQgPSBNYXRoLm1heChwb2ludEluZGV4IC0gMSwgMCk7XG5cdFx0Y29uc3QgaWR4UmlnaHQgPSBNYXRoLm1pbihwb2ludEluZGV4ICsgMSwgdGhpcy5wb2ludExpc3QubGVuZ3RoIC0gMSk7XG5cdFx0Y29uc3QgdExlZnQgPSB0aGlzLnBvaW50TGlzdFtpZHhMZWZ0XS5nZXQodGhpcy5pbnB1dEtleSk7XG5cdFx0Y29uc3QgdFJpZ2h0ID0gdGhpcy5wb2ludExpc3RbaWR4UmlnaHRdLmdldCh0aGlzLmlucHV0S2V5KTtcblx0XHRyZXR1cm4gKHRSaWdodCAtIHRMZWZ0ICkgLyAyO1xuXHR9XG5cblx0cHVibGljIGFkZFBvaW50KHBvaW50OiBQb2ludE5EKTogdm9pZFxuXHR7XG5cdFx0cG9pbnQucGFyZW50ID0gdGhpcztcblx0XHR0aGlzLl9wb2ludExpc3QucHVzaChwb2ludCk7XG5cdFx0dGhpc1t0aGlzLmxlbmd0aF0gPSBwb2ludDtcblx0XHQrK3RoaXMuX2xlbmd0aDtcblx0fVxuXG5cdHB1YmxpYyBzb3J0KGtleTogc3RyaW5nKTogdm9pZFxuXHR7XG5cdFx0bGV0IHNvcnRGdW5jdGlvbiA9IERldmxpYkFsZ28uc29ydE9uUHJvcGVydHk8UG9pbnRORD4oKHBvaW50OiBQb2ludE5EKSA9PiBcblx0XHR7XG5cdFx0XHRyZXR1cm4gcG9pbnQuZ2V0KGtleSk7XG5cdFx0fSk7XG5cdFx0dGhpcy5wb2ludExpc3Quc29ydChzb3J0RnVuY3Rpb24pO1xuXHRcdHRoaXMuX2lucHV0S2V5ID0ga2V5O1xuXHR9XG5cblx0W1N5bWJvbC5pdGVyYXRvcl0oKTogSXRlcmF0b3I8UG9pbnRORD5cblx0e1xuXHRcdHJldHVybiBuZXcgQ3VydmVJdGVyYXRvcih0aGlzLnBvaW50TGlzdCk7XG5cdH1cblxufSIsImV4cG9ydCBlbnVtIERhdGFFdmVudHMge1xuXHRicnVzaENoYW5nZSA9ICdicnVzaENoYW5nZScsXG5cdHNlbGVjdGlvblRvRmlsdGVyID0gJ3NlbGVjdGlvblRvRmlsdGVyJyxcblx0YXBwbHlOZXdGaWx0ZXIgPSAnYXBwbHlOZXdGaWx0ZXInXG59IiwiaW1wb3J0IHsgU3RyaW5nVG9OdW1iZXJPYmosIFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uIH0gZnJvbSAnLi4vZGV2bGliL0RldkxpYlR5cGVzJ1xuXG5leHBvcnQgY2xhc3MgRGVyaXZlZFBvaW50VmFsdWVGdW5jdGlvbnNcbntcbiAgICBwdWJsaWMgc3RhdGljIEdldEZ1bmN0aW9uTGlzdCgpOiBbc3RyaW5nW10sIFBvaW50RGVyaXZhdGlvbkZ1bmN0aW9uXVtdXG4gICAge1xuICAgICAgICBsZXQgZnVuY3Rpb25MaXN0ID0gW107XG4gICAgICAgIGZ1bmN0aW9uTGlzdC5wdXNoKFtbJ01hc3Nfbm9ybSddLCAocG9pbnRMaXN0OiBTdHJpbmdUb051bWJlck9ialtdKSA9PiB0aGlzLm5vcm1BdHRyKCdNYXNzIChwZyknLCBwb2ludExpc3QsIGZhbHNlKV0pO1xuICAgICAgICBmdW5jdGlvbkxpc3QucHVzaChbWydUaW1lX25vcm0nXSwgKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSkgPT4gdGhpcy5ub3JtQXR0cignVGltZSAoaCknLCBwb2ludExpc3QpXSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkxpc3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgbm9ybUF0dHIoYXR0cktleTogc3RyaW5nLCBwb2ludExpc3Q6IFN0cmluZ1RvTnVtYmVyT2JqW10sIHplcm9Ob3JtID0gdHJ1ZSk6IFtudW1iZXJbXV1cbiAgICB7XG4gICAgICAgIGxldCBuZXdWYWx1ZXM6IG51bWJlcltdID0gW107XG4gICAgICAgIGlmIChwb2ludExpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gW25ld1ZhbHVlc107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RWYWw6IG51bWJlciA9IHBvaW50TGlzdFswXVthdHRyS2V5XTtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRMaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgb2xkVmFsID0gcG9pbnRbYXR0cktleV07XG4gICAgICAgICAgICBpZiAoemVyb05vcm0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzLnB1c2gob2xkVmFsIC0gZmlyc3RWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyAgIFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5wdXNoKG9sZFZhbCAvIGZpcnN0VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25ld1ZhbHVlc107XG4gICAgfVxuXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZnVuY3Rpb25OYW1lKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSk6IG51bWJlcltdXG4gICAgLy8ge1xuICAgICAgICBcbiAgICAvLyB9XG5cbn0iLCJpbXBvcnQgeyBTdHJpbmdUb051bWJlck9iaiwgVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb24gfSBmcm9tICcuLi9kZXZsaWIvRGV2TGliVHlwZXMnXG5cbmV4cG9ydCBjbGFzcyBEZXJpdmVkVHJhY2tWYWx1ZUZ1bmN0aW9uc1xue1xuICAgIHB1YmxpYyBzdGF0aWMgR2V0RnVuY3Rpb25MaXN0KCk6IFtzdHJpbmdbXSwgVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25dW11cbiAgICB7XG4gICAgICAgIGxldCBmdW5jdGlvbkxpc3Q6IFtzdHJpbmdbXSwgVHJhY2tEZXJpdmF0aW9uRnVuY3Rpb25dW10gPSBbXTtcbiAgICAgICAgZnVuY3Rpb25MaXN0LnB1c2goW1snVHJhY2sgTGVuZ3RoJ10sIHRoaXMudHJhY2tMZW5ndGhdKTtcbiAgICAgICAgZm9yIChsZXQgdG9BdmVyYWdlIG9mIFsnTWFzcyAocGcpJywgJ3NoYXBlIGZhY3RvcicsICdNYXNzX25vcm0nLCAnTWVhbiBJbnRlbnNpdHknLCAnQXJlYSddKVxuICAgICAgICB7XG4gICAgICAgICAgICBmdW5jdGlvbkxpc3QucHVzaChbWydBdmcuICcgKyB0b0F2ZXJhZ2VdLCAocG9pbnRMaXN0OiBTdHJpbmdUb051bWJlck9ialtdKSA9PiB0aGlzLmF2ZXJhZ2VBdHRyaWJ1dGUocG9pbnRMaXN0LCB0b0F2ZXJhZ2UpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb25MaXN0LnB1c2goW1snR3Jvd3RoIFJhdGUnLCAnSW50ZXJjZXB0JywgJ0luaXRpYWwgTWFzcycsICdFeHBvbmVudGlhbCBHcm93dGggQ29uc3RhbnQnLCAncl9zcXVhcmVkJ10sIHRoaXMuZ3Jvd3RoUmF0ZVN0YXRzXSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkxpc3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgdHJhY2tMZW5ndGgocG9pbnRMaXN0OiBTdHJpbmdUb051bWJlck9ialtdKTogW251bWJlcl1cbiAgICB7XG4gICAgICAgIGxldCBmaXJzdFRpbWUgPSBwb2ludExpc3RbMF1bJ1RpbWUgKGgpJ107XG4gICAgICAgIGxldCBsYXN0VGltZSA9IHBvaW50TGlzdFtwb2ludExpc3QubGVuZ3RoIC0gMV1bJ1RpbWUgKGgpJ107XG4gICAgICAgIHJldHVybiBbbGFzdFRpbWUgLSBmaXJzdFRpbWVdO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGF2ZXJhZ2VBdHRyaWJ1dGUocG9pbnRMaXN0OiBTdHJpbmdUb051bWJlck9ialtdLCBhdHRyaWJ1dGVLZXk6IHN0cmluZyk6IFtudW1iZXJdIHwgbnVsbFxuICAgIHtcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50TGlzdFswXTtcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhmaXJzdFBvaW50KS5pbmNsdWRlcyhhdHRyaWJ1dGVLZXkpKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiBwb2ludExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHBvaW50W2F0dHJpYnV0ZUtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b3RhbCAvIHBvaW50TGlzdC5sZW5ndGhdO1xuICAgIH1cblxuICAgIC8vIHByaXZhdGUgc3RhdGljIGF2ZXJhZ2VNYXNzKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSk6IFtudW1iZXJdXG4gICAgLy8ge1xuICAgIC8vICAgICBsZXQgdG90YWxNYXNzID0gMDtcbiAgICAvLyAgICAgZm9yIChsZXQgcG9pbnQgb2YgcG9pbnRMaXN0KVxuICAgIC8vICAgICB7XG4gICAgLy8gICAgICAgICB0b3RhbE1hc3MgKz0gcG9pbnRbJ01hc3MgKHBnKSddO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHJldHVybiBbdG90YWxNYXNzIC8gcG9pbnRMaXN0Lmxlbmd0aF07XG4gICAgLy8gfVxuXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgYXZlcmFnZVNoYXBlRmFjdG9yKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSk6IFtudW1iZXJdXG4gICAgLy8ge1xuICAgIC8vICAgICBsZXQgdG90YWxTaGFwZUZhY3RvciA9IDA7XG4gICAgLy8gICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50TGlzdClcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICAgdG90YWxTaGFwZUZhY3RvciArPSBwb2ludFsnc2hhcGUgZmFjdG9yJ107XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgcmV0dXJuIFt0b3RhbFNoYXBlRmFjdG9yIC8gcG9pbnRMaXN0Lmxlbmd0aF07XG4gICAgLy8gfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ3Jvd3RoUmF0ZVN0YXRzKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbiAgICB7XG4gICAgICAgIC8vIFJlZmVyZW5jZWQgbWF0aFxuICAgICAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcmRpbmFyeV9sZWFzdF9zcXVhcmVzI1NpbXBsZV9saW5lYXJfcmVncmVzc2lvbl9tb2RlbFxuICAgICAgICBsZXQgc3VtWCA9IDA7XG4gICAgICAgIGxldCBzdW1ZID0gMDtcbiAgICAgICAgbGV0IHN1bVlZID0gMDtcbiAgICAgICAgbGV0IHN1bVhZID0gMDtcbiAgICAgICAgbGV0IHN1bVhYID0gMDtcbiAgICAgICAgbGV0IE4gPSBwb2ludExpc3QubGVuZ3RoO1xuICAgICAgICBpZiAoTiA9PT0gMSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIFsgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4gXTsgLy8gY2FsY3VsYXRpbmcgdGhlIHNsb3BlIG9mIG9uZSBwb2ludCBpcyBhY3R1YWxseSBwb2ludC4uLmxlc3NcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb2ludCBvZiBwb2ludExpc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB4ID0gcG9pbnRbJ1RpbWUgKGgpJ107XG4gICAgICAgICAgICBsZXQgeSA9IHBvaW50WydNYXNzIChwZyknXTtcbiAgICAgICAgICAgIHN1bVggKz0geDtcbiAgICAgICAgICAgIHN1bVkgKz0geTtcbiAgICAgICAgICAgIHN1bVlZICs9IHkqeTtcbiAgICAgICAgICAgIHN1bVhZICs9IHgqeTtcbiAgICAgICAgICAgIHN1bVhYICs9IHgqeDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBOX2ludiA9IDEgLyBOO1xuICAgICAgICBsZXQgY292YXJpYW5jZSA9IHN1bVhZIC0gTl9pbnYgKiBzdW1YICogc3VtWTtcbiAgICAgICAgbGV0IHZhcmlhbmNlID0gc3VtWFggLSBOX2ludiAqIHN1bVggKiBzdW1YO1xuICAgICAgICBsZXQgc2xvcGUgPSBjb3ZhcmlhbmNlIC8gdmFyaWFuY2U7XG4gICAgICAgIGxldCBpbnRlcmNlcHQgPSBOX2ludiAqIChzdW1ZIC0gc2xvcGUgKiBzdW1YKTtcbiAgICAgICAgbGV0IGluaXRpYWxNYXNzID0gcG9pbnRMaXN0WzBdWydUaW1lIChoKSddICogc2xvcGUgKyBpbnRlcmNlcHQ7XG4gICAgICAgIGxldCBleHBvbmVudGlhbEdyb3d0aENvbnN0YW50ID0gc2xvcGUgLyBpbml0aWFsTWFzcztcblxuICAgICAgICAvLyByX3NxdWFyZWQgZXF1YXRpb24gZnJvbSBoZXJlXG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NpbXBsZV9saW5lYXJfcmVncmVzc2lvbiNGaXR0aW5nX3RoZV9yZWdyZXNzaW9uX2xpbmVcbiAgICAgICAgbGV0IHJfdG9wID0gKE5faW52ICogc3VtWFkgLSBOX2ludiAqIHN1bVggKiBOX2ludiAqIHN1bVkpO1xuICAgICAgICBsZXQgcl9ib3QgPSBNYXRoLnNxcnQoIChOX2ludiAqIHN1bVhYIC0gTl9pbnYgKiBzdW1YICogTl9pbnYgKiBzdW1YKSAqIChOX2ludiAqIHN1bVlZIC0gTl9pbnYgKiBzdW1ZICogTl9pbnYgKiBzdW1ZKSApO1xuICAgICAgICBsZXQgcl9zcXVhcmVkID0gTWF0aC5wb3coKHJfdG9wIC8gcl9ib3QpLCAyKTtcbiAgICAgICAgcmV0dXJuIFsgc2xvcGUsIGludGVyY2VwdCwgaW5pdGlhbE1hc3MsIGV4cG9uZW50aWFsR3Jvd3RoQ29uc3RhbnQsIHJfc3F1YXJlZCBdO1xuICAgIH1cblxuXG4gICAgLy8gcHJpdmF0ZSBzdGF0aWMgZnVuY3Rpb25OYW1lKHBvaW50TGlzdDogU3RyaW5nVG9OdW1iZXJPYmpbXSk6IG51bWJlclxuICAgIC8vIHtcbiAgICAgICAgXG4gICAgLy8gfVxuXG59IiwiZXhwb3J0IGNsYXNzIEltYWdlRnJhbWVcbntcbiAgICBjb25zdHJ1Y3RvcihmcmFtZUlkOiBudW1iZXIpXG4gICAge1xuICAgICAgICB0aGlzLl9mcmFtZUlkID0gZnJhbWVJZDtcbiAgICAgICAgdGhpcy5faW5CcnVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaW5CcnVzaCA6IGJvb2xlYW47XG4gICAgcHVibGljIGdldCBpbkJydXNoKCkgOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luQnJ1c2g7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaW5CcnVzaCh2OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2luQnJ1c2ggPSB2O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2luQnJ1c2hDb3VudCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGluQnJ1c2hDb3VudCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luQnJ1c2hDb3VudDtcbiAgICB9XG4gICAgcHVibGljIHNldCBpbkJydXNoQ291bnQodiA6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9pbkJydXNoQ291bnQgPSB2O1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RvdGFsQ291bnQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCB0b3RhbENvdW50KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxDb3VudDtcbiAgICB9XG4gICAgcHVibGljIHNldCB0b3RhbENvdW50KHYgOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdG90YWxDb3VudCA9IHY7XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBnZXQgaW5CcnVzaFBlcmNlbnQoKSA6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsQ291bnQgPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluQnJ1c2hDb3VudCAvIHRoaXMudG90YWxDb3VudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mcmFtZUlkIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgZnJhbWVJZCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lSWQ7XG4gICAgfVxuICAgICAgICBcbn0iLCJpbXBvcnQgeyBJbWFnZUZyYW1lIH0gZnJvbSAnLi9JbWFnZUZyYW1lJ1xuaW1wb3J0IHsgRGV2bGliQWxnbyB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJBbGdvJztcblxuZXhwb3J0IGNsYXNzIEltYWdlTG9jYXRpb25cbntcbiAgICBjb25zdHJ1Y3Rvcihsb2NhdGlvbklkOiBudW1iZXIpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2NhdGlvbklkID0gbG9jYXRpb25JZDtcbiAgICAgICAgdGhpcy5faW5CcnVzaCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZyYW1lTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9mcmFtZUxvb2t1cCA9IG5ldyBNYXA8bnVtYmVyLCBJbWFnZUZyYW1lPigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2luQnJ1c2ggOiBib29sZWFuO1xuICAgIHB1YmxpYyBnZXQgaW5CcnVzaCgpIDogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbkJydXNoO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGluQnJ1c2godjogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9pbkJydXNoID0gdjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbkJydXNoQ291bnQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBpbkJydXNoQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbkJydXNoQ291bnQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaW5CcnVzaENvdW50KHYgOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5faW5CcnVzaENvdW50ID0gdjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF90b3RhbENvdW50IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgdG90YWxDb3VudCgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsQ291bnQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgdG90YWxDb3VudCh2IDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3RvdGFsQ291bnQgPSB2O1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgZ2V0IGluQnJ1c2hQZXJjZW50KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5pbkJydXNoQ291bnQgLyB0aGlzLnRvdGFsQ291bnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25JZCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IGxvY2F0aW9uSWQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbklkO1xuICAgIH1cbiAgICBcbiAgICBwcml2YXRlIF9mcmFtZUxpc3QgOiBJbWFnZUZyYW1lW107XG4gICAgcHVibGljIGdldCBmcmFtZUxpc3QoKSA6IEltYWdlRnJhbWVbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUxpc3Q7XG4gICAgfVxuICAgIFxuICAgIHByaXZhdGUgX2ZyYW1lTG9va3VwIDogTWFwPG51bWJlciwgSW1hZ2VGcmFtZT47XG4gICAgcHVibGljIGdldCBmcmFtZUxvb2t1cCgpIDogTWFwPG51bWJlciwgSW1hZ2VGcmFtZT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVMb29rdXA7XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBhZGRGcmFtZShmcmFtZUlkOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5mcmFtZUxvb2t1cC5oYXMoZnJhbWVJZCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdGcmFtZSA9IG5ldyBJbWFnZUZyYW1lKGZyYW1lSWQpO1xuICAgICAgICB0aGlzLmZyYW1lTGlzdC5wdXNoKG5ld0ZyYW1lKTtcbiAgICAgICAgdGhpcy5mcmFtZUxvb2t1cC5zZXQoZnJhbWVJZCwgbmV3RnJhbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzb3J0RnJhbWVzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZnJhbWVMaXN0LnNvcnQoRGV2bGliQWxnby5zb3J0T25Qcm9wZXJ0eSgoZnJhbWU6IEltYWdlRnJhbWUpID0+IGZyYW1lLmZyYW1lSWQpKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgUG9pbnRDb2xsZWN0aW9uIH0gZnJvbSAnLi9Qb2ludENvbGxlY3Rpb24nO1xuaW1wb3J0IHsgSW1hZ2VMb2NhdGlvbiB9IGZyb20gJy4vSW1hZ2VMb2NhdGlvbic7XG5cbmV4cG9ydCBjbGFzcyBJbWFnZU1ldGFEYXRhXG57ICAgXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLl9sb2NhdGlvbkxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9jYXRpb25Mb29rdXAgPSBuZXcgTWFwPG51bWJlciwgSW1hZ2VMb2NhdGlvbj4oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9sb2NhdGlvbkxpc3QgOiBJbWFnZUxvY2F0aW9uW107XG4gICAgcHVibGljIGdldCBsb2NhdGlvbkxpc3QoKSA6IEltYWdlTG9jYXRpb25bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbkxpc3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbG9jYXRpb25Mb29rdXAgOiBNYXA8bnVtYmVyLCBJbWFnZUxvY2F0aW9uPjtcbiAgICBwdWJsaWMgZ2V0IGxvY2F0aW9uTG9va3VwKCkgOiBNYXA8bnVtYmVyLCBJbWFnZUxvY2F0aW9uPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbkxvb2t1cDtcbiAgICB9XG5cbiAgICBcbiAgICBwcml2YXRlIF9sb2NhdGlvbklkS2V5IDogc3RyaW5nO1xuICAgIHB1YmxpYyBnZXQgbG9jYXRpb25JZEtleSgpIDogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uSWRLZXk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnJhbWVJZEtleSA6IHN0cmluZztcbiAgICBwdWJsaWMgZ2V0IGZyYW1lSWRLZXkoKSA6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUlkS2V5O1xuICAgIH1cbiAgICBcbiAgICBwdWJsaWMgZ2V0QnJ1c2hlZExvY2F0aW9ucygpOiBudW1iZXJbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb25MaXN0LmZpbHRlcihsb2MgPT4gbG9jLmluQnJ1c2gpLm1hcChsb2MgPT4gbG9jLmxvY2F0aW9uSWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRCcnVzaGVkSW1hZ2VDb3VudCgpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGxvYyBvZiB0aGlzLmxvY2F0aW9uTGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgY291bnQgKz0gbG9jLmZyYW1lTGlzdC5maWx0ZXIoZnJhbWUgPT4gZnJhbWUuaW5CcnVzaCkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG5cblxuICAgIHB1YmxpYyB1cGRhdGVJbkJydXNoUHJvcChwb2ludExpc3Q6IFBvaW50Q29sbGVjdGlvbik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucmVzZXRBbGxUb0ZhbHNlKCk7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50TGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGxvY0lkOiBudW1iZXIgPSBwb2ludC5nZXQodGhpcy5sb2NhdGlvbklkS2V5KTtcbiAgICAgICAgICAgIGxldCBmcmFtZUlkOiBudW1iZXIgPSBwb2ludC5nZXQodGhpcy5mcmFtZUlkS2V5KTtcbiAgICAgICAgICAgIGxldCBsb2NhdGlvbiA9IHRoaXMubG9jYXRpb25Mb29rdXAuZ2V0KGxvY0lkKTtcbiAgICAgICAgICAgIGxldCBmcmFtZSA9IGxvY2F0aW9uLmZyYW1lTG9va3VwLmdldChmcmFtZUlkKTtcbiAgICAgICAgICAgIGxvY2F0aW9uLnRvdGFsQ291bnQrKztcbiAgICAgICAgICAgIGZyYW1lLnRvdGFsQ291bnQrKztcbiAgICAgICAgICAgIGlmIChwb2ludC5pbkJydXNoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmluQnJ1c2hDb3VudCsrO1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmluQnJ1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lLmluQnJ1c2hDb3VudCsrO1xuICAgICAgICAgICAgICAgIGZyYW1lLmluQnJ1c2ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNldEFsbFRvRmFsc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgZm9yIChsZXQgbG9jIG9mIHRoaXMubG9jYXRpb25MaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBsb2MuaW5CcnVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgbG9jLmluQnJ1c2hDb3VudCA9IDA7XG4gICAgICAgICAgICBsb2MudG90YWxDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBmcmFtZSBvZiBsb2MuZnJhbWVMaXN0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyYW1lLmluQnJ1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5pbkJydXNoQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZyYW1lLnRvdGFsQ291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHN0YXRpYyBmcm9tUG9pbnRDb2xsZWN0aW9uKHBvaW50TGlzdDogUG9pbnRDb2xsZWN0aW9uLCBsb2NhdGlvbklkS2V5OiBzdHJpbmcgPSAnTG9jYXRpb24gSUQnLCBmcmFtZUlkS2V5OiBzdHJpbmcgPSAnRnJhbWUgSUQnKTogSW1hZ2VNZXRhRGF0YVxuICAgIHtcbiAgICAgICAgbGV0IGltZ01ldGFEYXRhID0gbmV3IEltYWdlTWV0YURhdGEoKTtcbiAgICAgICAgaW1nTWV0YURhdGEuX2xvY2F0aW9uSWRLZXkgPSBsb2NhdGlvbklkS2V5O1xuICAgICAgICBpbWdNZXRhRGF0YS5fZnJhbWVJZEtleSA9IGZyYW1lSWRLZXk7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHBvaW50TGlzdClcbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGxvY0lkOiBudW1iZXIgPSBwb2ludC5nZXQobG9jYXRpb25JZEtleSk7XG4gICAgICAgICAgICBsZXQgZnJhbWVJZDogbnVtYmVyID0gcG9pbnQuZ2V0KGZyYW1lSWRLZXkpO1xuICAgICAgICAgICAgbGV0IGltYWdlTG9jYXRpb246IEltYWdlTG9jYXRpb247XG4gICAgICAgICAgICBpZiAoaW1nTWV0YURhdGEubG9jYXRpb25Mb29rdXAuaGFzKGxvY0lkKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbWFnZUxvY2F0aW9uID0gaW1nTWV0YURhdGEubG9jYXRpb25Mb29rdXAuZ2V0KGxvY0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbWFnZUxvY2F0aW9uID0gbmV3IEltYWdlTG9jYXRpb24obG9jSWQpO1xuICAgICAgICAgICAgICAgIGltZ01ldGFEYXRhLmxvY2F0aW9uTGlzdC5wdXNoKGltYWdlTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGltZ01ldGFEYXRhLmxvY2F0aW9uTG9va3VwLnNldChsb2NJZCwgaW1hZ2VMb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZUxvY2F0aW9uLmFkZEZyYW1lKGZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGltYWdlTG9jYXRpb24gb2YgaW1nTWV0YURhdGEubG9jYXRpb25MaXN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZUxvY2F0aW9uLnNvcnRGcmFtZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpbWdNZXRhRGF0YS51cGRhdGVJbkJydXNoUHJvcChwb2ludExpc3QpO1xuICAgICAgICByZXR1cm4gaW1nTWV0YURhdGE7XG4gICAgfVxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IElEQlBEYXRhYmFzZSwgb3BlbkRCIH0gZnJvbSAnaWRiJztcbmltcG9ydCB7IGxvYWQgfSBmcm9tIFwicHJvdG9idWZqc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlTGFiZWxzXG57XG4gICAgcm93TGlzdDogUm93W11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3dcbntcbiAgICByb3c6IExhYmVsUnVuW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYWJlbFJ1biB7XG4gICAgc3RhcnQ6IG51bWJlcixcbiAgICBsZW5ndGg6IG51bWJlcixcbiAgICBsYWJlbDogbnVtYmVyXG59XG5cblxuZXhwb3J0IGNsYXNzIEltYWdlU3RhY2tEYXRhUmVxdWVzdFxue1xuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihkcml2ZUlkOiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLl9kcml2ZUlkID0gZHJpdmVJZDtcbiAgICAgICAgdGhpcy5fbWV0YURhdGFMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCBtZXRhRGF0YUZpbGVuYW1lID0gYC9kYXRhLyR7ZHJpdmVJZH0vaW1hZ2VNZXRhRGF0YS5qc29uYDtcbiAgICAgICAgb3BlbkRCKCdsb29uLWRiJykudGhlbihhc3luYyBkYXRhU3RvcmUgPT4gXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTdG9yZSA9IGRhdGFTdG9yZTtcbiAgICAgICAgICAgIGxldCBzdG9yZSA9IHRoaXMuZGF0YVN0b3JlLnRyYW5zYWN0aW9uKCdpbWFnZXMnLCAncmVhZG9ubHknKS5vYmplY3RTdG9yZSgnaW1hZ2VzJyk7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHN0b3JlLmdldChtZXRhRGF0YUZpbGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEltYWdlTWV0YURhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZDMuanNvbihtZXRhRGF0YUZpbGVuYW1lKS50aGVuKGRhdGEgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRJbWFnZU1ldGFEYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVN0b3JlLnB1dDxhbnk+KCdpbWFnZXMnLCBkYXRhLCBtZXRhRGF0YUZpbGVuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ibG9iQXJyYXk9IFtdO1xuICAgICAgICB0aGlzLl9sYWJlbEFycmF5PSBbXTtcbiAgICAgICAgdGhpcy5fbWF4QmxvYkNvdW50ID0gMTAwO1xuICAgICAgICB0aGlzLl9uZXh0QmxvYkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fbmV4dExhYmVsSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9tYXhMYWJlbENvdW50ID0gMTAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEltYWdlTWV0YURhdGEoZGF0YTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5fdGlsZVdpZHRoID0gZGF0YS50aWxlV2lkdGg7XG4gICAgICAgIHRoaXMuX3RpbGVIZWlnaHQgPSBkYXRhLnRpbGVIZWlnaHQ7XG4gICAgICAgIHRoaXMuX251bWJlck9mQ29sdW1ucyA9IGRhdGEubnVtYmVyT2ZDb2x1bW5zO1xuICAgICAgICB0aGlzLl90aWxlc1BlckZpbGUgPSBkYXRhLnRpbGVzUGVyRmlsZTtcbiAgICAgICAgdGhpcy5fbWV0YURhdGFMb2FkZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZGF0YS5zY2FsZUZhY3RvcilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBkYXRhLnNjYWxlRmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVGYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIHByaXZhdGUgX21ldGFEYXRhTG9hZGVkIDogYm9vbGVhbjtcbiAgICBwdWJsaWMgZ2V0IG1ldGFEYXRhTG9hZGVkKCkgOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFEYXRhTG9hZGVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RyaXZlSWQgOiBzdHJpbmc7XG4gICAgcHVibGljIGdldCBkcml2ZUlkKCkgOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVJZDtcbiAgICB9ICAgIFxuXG4gICAgcHJpdmF0ZSBfdGlsZVdpZHRoIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgdGlsZVdpZHRoKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVdpZHRoO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RpbGVIZWlnaHQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCB0aWxlSGVpZ2h0KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZUhlaWdodDtcbiAgICB9XG4gICAgXG4gICAgcHJpdmF0ZSBfbnVtYmVyT2ZDb2x1bW5zIDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgbnVtYmVyT2ZDb2x1bW5zKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZDb2x1bW5zO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RpbGVzUGVyRmlsZSA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHRpbGVzUGVyRmlsZSgpIDogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzUGVyRmlsZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXhCbG9iQ291bnQgOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBtYXhCbG9iQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhCbG9iQ291bnQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbWF4TGFiZWxDb3VudCA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IG1heExhYmVsQ291bnQoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhMYWJlbENvdW50O1xuICAgIH1cbiBcbiAgICBwcml2YXRlIF9zY2FsZUZhY3RvciA6IG51bWJlcjtcbiAgICBwdWJsaWMgZ2V0IHNjYWxlRmFjdG9yKCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVGYWN0b3I7XG4gICAgfSAgICBcblxuICAgIC8vIGJsb2IsIGtleSwgdXJsXG4gICAgcHJpdmF0ZSBfYmxvYkFycmF5IDogW0Jsb2IsIHN0cmluZywgc3RyaW5nXVtdO1xuICAgIHB1YmxpYyBnZXQgYmxvYkFycmF5KCkgOiBbQmxvYiwgc3RyaW5nLCBzdHJpbmddW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvYkFycmF5O1xuICAgIH1cblxuICAgIHByaXZhdGUgX25leHRCbG9iSW5kZXggOiBudW1iZXI7XG4gICAgcHVibGljIGdldCBuZXh0QmxvYkluZGV4KCkgOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEJsb2JJbmRleDtcbiAgICB9XG5cbiAgICAvLyByb3dzLCBrZXlcbiAgICBwcml2YXRlIF9sYWJlbEFycmF5IDogW0ltYWdlTGFiZWxzLCBzdHJpbmddW107XG4gICAgcHVibGljIGdldCBsYWJlbEFycmF5KCkgOiBbSW1hZ2VMYWJlbHMsIHN0cmluZ11bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbEFycmF5O1xuICAgIH1cblxuICAgIHByaXZhdGUgX25leHRMYWJlbEluZGV4IDogbnVtYmVyO1xuICAgIHB1YmxpYyBnZXQgbmV4dExhYmVsSW5kZXgoKSA6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0TGFiZWxJbmRleDtcbiAgICB9XG5cblx0cHJpdmF0ZSBfZGF0YVN0b3JlIDogSURCUERhdGFiYXNlPHVua25vd24+O1xuXHRwdWJsaWMgZ2V0IGRhdGFTdG9yZSgpIDogSURCUERhdGFiYXNlPHVua25vd24+IHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YVN0b3JlO1xuXHR9XG5cbiAgICBwdWJsaWMgYXN5bmMgZ2V0SW1hZ2UobG9jYXRpb246IG51bWJlciwgZnJhbWVJbmRleDogbnVtYmVyLCBjYWxsYmFjazogKHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJsb2I6IEJsb2IsIGltYWdlVXJsOiBzdHJpbmcpID0+IHZvaWQpOiBQcm9taXNlPHZvaWQ+XG4gICAge1xuICAgICAgICBpZiAoIXRoaXMubWV0YURhdGFMb2FkZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKGxvY2F0aW9uLCBmcmFtZUluZGV4LCBjYWxsYmFjaylcbiAgICAgICAgICAgIH0sIDUwKTsgLy8gdG9kbyBmYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbdG9wLCBsZWZ0XSA9IHRoaXMuZ2V0VGlsZVRvcExlZnQoZnJhbWVJbmRleCk7XG4gICAgICAgIGxldCBidW5kbGVJbmRleCA9IE1hdGguZmxvb3IoZnJhbWVJbmRleCAvIHRoaXMudGlsZXNQZXJGaWxlKTtcbiAgICAgICAgbGV0IGtleSA9IFtsb2NhdGlvbiwgYnVuZGxlSW5kZXhdLmpvaW4oJy0nKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBjYWNoZWRFbGVtZW50ID0gdGhpcy5ibG9iQXJyYXkuZmluZChkID0+IGRbMV0gPT09IGtleSk7XG4gICAgICAgIGlmIChjYWNoZWRFbGVtZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJ1bldpdGhDYWNoZWRJbWFnZShrZXksIHRvcCwgbGVmdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGltZ1VybCA9IGAvZGF0YS8ke3RoaXMuZHJpdmVJZH0vaW1nXyR7bG9jYXRpb259XyR7YnVuZGxlSW5kZXh9LmpwZ2A7XG5cbiAgICAgICAgY29uc3QgdGhpc0luZGV4ID0gdGhpcy5uZXh0QmxvYkluZGV4O1xuICAgICAgICB0aGlzLmJsb2JBcnJheVt0aGlzSW5kZXhdID0gW251bGwsIGtleSwgbnVsbF07XG4gICAgICAgIHRoaXMuX25leHRCbG9iSW5kZXggPSAodGhpcy5uZXh0QmxvYkluZGV4ICsgMSkgJSB0aGlzLm1heEJsb2JDb3VudDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhU3RvcmUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRyeSBhbmQgZ2V0IGZyb20gZGF0YSBzdG9yZVxuICAgICAgICAgICAgbGV0IHN0b3JlID0gdGhpcy5kYXRhU3RvcmUudHJhbnNhY3Rpb24oJ2ltYWdlcycsICdyZWFkb25seScpLm9iamVjdFN0b3JlKCdpbWFnZXMnKTtcbiAgICAgICAgICAgIGxldCBibG9iID0gYXdhaXQgc3RvcmUuZ2V0KGltZ1VybCk7XG4gICAgICAgICAgICBpZiAoYmxvYilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9iQXJyYXlbdGhpc0luZGV4XSA9IFtibG9iLCBrZXksIHVybF07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodG9wLCBsZWZ0LCBibG9iLCB1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgICB4aHIub25sb2FkID0gKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGJsb2IgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhU3RvcmUpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuZGF0YVN0b3JlLnB1dDxhbnk+KCdpbWFnZXMnLCBibG9iLCBpbWdVcmwpO1xuXHRcdFx0fVxuICAgICAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgdGhpcy5ibG9iQXJyYXlbdGhpc0luZGV4XSA9IFtibG9iLCBrZXksIHVybF07XG4gICAgICAgICAgICBjYWxsYmFjayh0b3AsIGxlZnQsIGJsb2IsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLm9uZXJyb3IgPSAoZSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBGZXRjaGluZzogJyArIGltZ1VybClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICAgICAgfVxuICAgICAgICB4aHIub3BlbignR0VUJywgaW1nVXJsKTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByaXZhdGUgcnVuV2l0aENhY2hlZEltYWdlKGtleTogc3RyaW5nLCB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBjYWxsYmFjazogKHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJsb2I6IEJsb2IsIGltYWdlVXJsOiBzdHJpbmcpID0+IHZvaWQpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgY2FjaGVkRWxlbWVudCA9IHRoaXMuYmxvYkFycmF5LmZpbmQoZCA9PiBkWzFdID09PSBrZXkpO1xuICAgICAgICBpZiAoY2FjaGVkRWxlbWVudFswXSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2FsbGJhY2sodG9wLCBsZWZ0LCBjYWNoZWRFbGVtZW50WzBdLCBjYWNoZWRFbGVtZW50WzJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIGxvYWRpbmcsIHRyeSBhZ2FpbiBsYXRlclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5XaXRoQ2FjaGVkSW1hZ2Uoa2V5LCB0b3AsIGxlZnQsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJbWFnZVByb21pc2UobG9jYXRpb246IG51bWJlciwgZnJhbWVJbmRleDogbnVtYmVyKTogUHJvbWlzZTxbbnVtYmVyLCBudW1iZXIsIEJsb2IsIHN0cmluZ10+XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEltYWdlKGxvY2F0aW9uLCBmcmFtZUluZGV4LCAodG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYmxvYjogQmxvYiwgaW1hZ2VVcmw6IHN0cmluZykgPT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoW3RvcCwgbGVmdCwgYmxvYiwgaW1hZ2VVcmxdKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgZ2V0VGlsZVRvcExlZnQoZnJhbWVJbmRleDogbnVtYmVyKTogW251bWJlciwgbnVtYmVyXVxuXHR7XG5cdFx0Y29uc3QgbGVmdDogbnVtYmVyID0gKGZyYW1lSW5kZXggJSB0aGlzLm51bWJlck9mQ29sdW1ucykgKiB0aGlzLnRpbGVXaWR0aDtcbiAgICAgICAgbGV0IHRvcDogbnVtYmVyID0gTWF0aC5mbG9vcigoZnJhbWVJbmRleCAlIHRoaXMudGlsZXNQZXJGaWxlKSAvIHRoaXMubnVtYmVyT2ZDb2x1bW5zKSAqIHRoaXMudGlsZUhlaWdodDtcblx0XHRyZXR1cm4gW3RvcCwgbGVmdF07XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBnZXRMYWJlbChsb2NhdGlvbjogbnVtYmVyLCBmcmFtZUluZGV4OiBudW1iZXIsIGNhbGxiYWNrOiAocm93RGF0YTogSW1hZ2VMYWJlbHMsIGZpcnN0SW5kZXg6IG51bWJlcikgPT4gdm9pZCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5tZXRhRGF0YUxvYWRlZClcbiAgICAgICAge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGFiZWwobG9jYXRpb24sIGZyYW1lSW5kZXgsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfSwgNTApOyAvLyB0b2RvIGZhbGxiYWNrXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGV0IFt0b3AsIGxlZnRdID0gdGhpcy5nZXRUaWxlVG9wTGVmdChmcmFtZUluZGV4KTtcbiAgICAgICAgbGV0IGZpcnN0SW5kZXg6IG51bWJlciA9IChmcmFtZUluZGV4ICUgdGhpcy50aWxlc1BlckZpbGUpICogdGhpcy50aWxlSGVpZ2h0O1xuICAgICAgICBsZXQgYnVuZGxlSW5kZXggPSBNYXRoLmZsb29yKGZyYW1lSW5kZXggLyB0aGlzLnRpbGVzUGVyRmlsZSk7XG4gICAgICAgIGxldCBrZXkgPSBbbG9jYXRpb24sIGJ1bmRsZUluZGV4XS5qb2luKCctJyk7XG4gICAgICAgIFxuICAgICAgICBsZXQgY2FjaGVkRWxlbWVudCA9IHRoaXMubGFiZWxBcnJheS5maW5kKGQgPT4gZFsxXSA9PT0ga2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZEVsZW1lbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRvZG8gLSBzaW1pbGFyIHJ1bldpdGhDYWNoZWQgbG9naWNcbiAgICAgICAgICAgIHRoaXMucnVuV2l0aENhY2hlZExhYmVsKGtleSwgZmlyc3RJbmRleCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0aGlzSW5kZXggPSB0aGlzLm5leHRMYWJlbEluZGV4O1xuICAgICAgICB0aGlzLl9uZXh0TGFiZWxJbmRleCA9ICh0aGlzLm5leHRMYWJlbEluZGV4ICsgMSkgJSB0aGlzLm1heEJsb2JDb3VudDtcbiAgICAgICAgdGhpcy5sYWJlbEFycmF5W3RoaXNJbmRleF0gPSBbbnVsbCwga2V5XTtcblxuICAgICAgICBjb25zdCBsYWJlbFVybCA9IGAvZGF0YS8ke3RoaXMuZHJpdmVJZH0vbGFiZWxfJHtsb2NhdGlvbn1fJHtidW5kbGVJbmRleH0ucGJgO1xuICAgICAgICBsb2FkKFwiL3N0YXRpYy9wcm90b0RlZnMvUkxFLnByb3RvXCIsIGFzeW5jIChlcnIsIHJvb3QpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT2J0YWluIGEgbWVzc2FnZSB0eXBlXG4gICAgICAgICAgICBsZXQgSW1hZ2VMYWJlbHNNZXNzYWdlID0gcm9vdC5sb29rdXBUeXBlKFwiaW1hZ2VMYWJlbHMuSW1hZ2VMYWJlbHNcIik7XG5cbiAgICAgICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhU3RvcmUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IHN0b3JlID0gdGhpcy5kYXRhU3RvcmUudHJhbnNhY3Rpb24oJ2ltYWdlcycsICdyZWFkb25seScpLm9iamVjdFN0b3JlKCdpbWFnZXMnKTtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBhd2FpdCBzdG9yZS5nZXQobGFiZWxVcmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFidWZmZXIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gYXdhaXQgZDMuYnVmZmVyKGxhYmVsVXJsKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRhdGFTdG9yZS5wdXQ8YW55PignaW1hZ2VzJywgYnVmZmVyLCBsYWJlbFVybCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY29kZSBhbiBVaW50OEFycmF5IChicm93c2VyKSBvciBCdWZmZXIgKG5vZGUpIHRvIGEgbWVzc2FnZVxuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBJbWFnZUxhYmVsc01lc3NhZ2UuZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpIGFzIGFueTtcblxuICAgICAgICAgICAgdGhpcy5sYWJlbEFycmF5W3RoaXNJbmRleF0gPSBbbWVzc2FnZSwga2V5XTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY2FsbGJhY2sobWVzc2FnZSwgZmlyc3RJbmRleCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHJ1bldpdGhDYWNoZWRMYWJlbChrZXk6IHN0cmluZywgZmlyc3RJbmRleDogbnVtYmVyLCBjYWxsYmFjazogKHJvd0RhdGE6IEltYWdlTGFiZWxzLCBmaXJzdEluZGV4OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgY2FjaGVkRWxlbWVudCA9IHRoaXMubGFiZWxBcnJheS5maW5kKGQgPT4gZFsxXSA9PT0ga2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZEVsZW1lbnRbMF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNhY2hlZEVsZW1lbnRbMF0sIGZpcnN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gbG9hZGluZywgdHJ5IGFnYWluIGxhdGVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bldpdGhDYWNoZWRMYWJlbChrZXksIGZpcnN0SW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRMYWJlbFByb21pc2UobG9jYXRpb246IG51bWJlciwgZnJhbWVJbmRleDogbnVtYmVyKTogUHJvbWlzZTxbSW1hZ2VMYWJlbHMsIG51bWJlcl0+XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nZXRMYWJlbChsb2NhdGlvbiwgZnJhbWVJbmRleCwgKHJvd0RhdGE6IEltYWdlTGFiZWxzLCBmaXJzdEluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShbcm93RGF0YSwgZmlyc3RJbmRleF0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRMYWJlbFZhbHVlKHJvd0lkeDogbnVtYmVyLCBjb2xJZHg6IG51bWJlciwgcm93QXJyYXk6IEltYWdlTGFiZWxzKTogbnVtYmVyXG4gICAge1xuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgYm90dGxlbmVjaywgdGhpcyBjb3VsZCBiZSBpbXByb3ZlZCB3aXRoIHF1aWNrc2VhcmNoLlxuICAgICAgICBsZXQgcm93OiBSb3cgPSByb3dBcnJheS5yb3dMaXN0W3Jvd0lkeF07XG4gICAgICAgIGZvciAobGV0IGxhYmVsUnVuIG9mIHJvdy5yb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChsYWJlbFJ1bi5zdGFydCA8PSBjb2xJZHggJiYgY29sSWR4IDwgbGFiZWxSdW4uc3RhcnQgKyBsYWJlbFJ1bi5sZW5ndGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsUnVuLmxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBORGltIH0gZnJvbSAnLi4vZGV2bGliL0RldmxpYlR5cGVzJ1xuaW1wb3J0IHsgRGF0YUV2ZW50cyB9IGZyb20gJy4vRGF0YUV2ZW50cyc7XG5pbXBvcnQgeyBBcHBEYXRhLCBGYWNldE9wdGlvbiwgRmFjZXQsIERhdGFzZXRTcGVjLCBMb2NhdGlvbk1hcExpc3QsIHZhbHVlRmlsdGVyIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb2ludENvbGxlY3Rpb24gaW1wbGVtZW50cyBJdGVyYWJsZTxORGltPiwgQXJyYXlMaWtlPE5EaW0+LCBBcHBEYXRhPERhdGFzZXRTcGVjPiB7XG5cdFxuXHRjb25zdHJ1Y3Rvcihwb2ludExpc3Q6IE5EaW1bXSA9IFtdKVxuXHR7XG5cdFx0dGhpcy5fYXR0cmlidXRlTGlzdCA9IFtdO1xuXHRcdHRoaXMuX2xlbmd0aCA9IHBvaW50TGlzdC5sZW5ndGg7XG5cdFx0dGhpcy5fQXJyYXkgPSBwb2ludExpc3Q7XG5cdFx0dGhpcy5fbWluTWF4Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4oKTtcblx0XHR0aGlzLl9icnVzaExpc3QgPSBuZXcgTWFwPHN0cmluZywgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4+KCk7XG5cdH1cblxuXHRhYnN0cmFjdCBbU3ltYm9sLml0ZXJhdG9yXSgpOiBJdGVyYXRvcjxORGltPjtcblxuXHRwcml2YXRlIF9TcGVjaWZpY2F0aW9uIDogRGF0YXNldFNwZWM7XG5cdHB1YmxpYyBnZXQgU3BlY2lmaWNhdGlvbigpIDogRGF0YXNldFNwZWMge1xuXHRcdHJldHVybiB0aGlzLl9TcGVjaWZpY2F0aW9uO1xuXHR9XG5cdHB1YmxpYyBzZXQgU3BlY2lmaWNhdGlvbih2IDogRGF0YXNldFNwZWMpIHtcblx0XHR0aGlzLl9TcGVjaWZpY2F0aW9uID0gdjtcblx0fVxuXG5cdHByaXZhdGUgX3NvdXJjZUtleSA6IHN0cmluZztcblx0cHVibGljIGdldCBzb3VyY2VLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3NvdXJjZUtleTtcblx0fVxuXHRwdWJsaWMgc2V0IHNvdXJjZUtleSh2OiBzdHJpbmcpIHtcblx0XHR0aGlzLl9zb3VyY2VLZXkgPSB2O1xuXHR9XG5cdFxuXHRwcml2YXRlIF9wb3N0Zml4S2V5IDogc3RyaW5nO1xuXHRwdWJsaWMgZ2V0IHBvc3RmaXhLZXkoKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuX3Bvc3RmaXhLZXk7XG5cdH1cblx0cHVibGljIHNldCBwb3N0Zml4S2V5KHYgOiBzdHJpbmcpIHtcblx0XHR0aGlzLl9wb3N0Zml4S2V5ID0gdjtcblx0fVxuXG5cdHByb3RlY3RlZCBfbGVuZ3RoIDogbnVtYmVyO1xuXHRwdWJsaWMgZ2V0IGxlbmd0aCgpIDogbnVtYmVyIHtcblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9XG5cblx0W246IG51bWJlcl06IE5EaW07XG5cblx0cHJpdmF0ZSBfYXR0cmlidXRlTGlzdCA6IHN0cmluZ1tdO1xuXHRwdWJsaWMgZ2V0IGF0dHJpYnV0ZUxpc3QoKSA6IHN0cmluZ1tdIHtcblx0XHRpZiAodGhpcy5fYXR0cmlidXRlTGlzdC5sZW5ndGggPT09IDApXG5cdFx0e1xuXHRcdFx0dGhpcy5pbml0QXR0cmlidXRlTGlzdCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fYXR0cmlidXRlTGlzdDtcblx0fVxuXG5cblx0cHJpdmF0ZSBfQXJyYXkgOiBORGltW107XG5cdHB1YmxpYyBnZXQgQXJyYXkoKSA6IE5EaW1bXSB7XG5cdFx0aWYgKHRoaXMuX0FycmF5Lmxlbmd0aCA9PT0gMClcblx0XHR7XG5cdFx0XHR0aGlzLl9BcnJheSA9IEFycmF5LmZyb20odGhpcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9BcnJheTtcblx0fVxuXG5cdHByaXZhdGUgX21pbk1heENhY2hlIDogTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT47XG5cdHByaXZhdGUgZ2V0IG1pbk1heENhY2hlKCkgOiBNYXA8c3RyaW5nLCBbbnVtYmVyLCBudW1iZXJdPiB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbk1heENhY2hlO1xuXHR9XG5cblx0cHJpdmF0ZSBfYnJ1c2hMaXN0IDogTWFwPHN0cmluZywgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4+IDtcblx0cHVibGljIGdldCBicnVzaExpc3QoKSA6IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIFtudW1iZXIsIG51bWJlcl0+PiAge1xuXHRcdHJldHVybiB0aGlzLl9icnVzaExpc3Q7XG5cdH1cblxuXHRwdWJsaWMgYWJzdHJhY3QgT25CcnVzaENoYW5nZSgpOiB2b2lkO1xuXHRwdWJsaWMgYWJzdHJhY3QgQ3JlYXRlRmlsdGVyZWRDdXJ2ZUxpc3QoKTogQXBwRGF0YTxEYXRhc2V0U3BlYz47XG5cdHB1YmxpYyBhYnN0cmFjdCBBcHBseURlZmF1bHRGaWx0ZXJzKCk6IHZvaWQ7XG5cdHB1YmxpYyBhYnN0cmFjdCBDb25zdW1lRmlsdGVycyhBcHBEYXRhOiBhbnkpOiB2b2lkO1xuXHRwdWJsaWMgYWJzdHJhY3QgQXBwbHlOZXdGaWx0ZXIoKTogdm9pZDtcblxuXHRwdWJsaWMgR2V0RmFjZXRPcHRpb25zKCk6IEZhY2V0T3B0aW9uW11cblx0e1xuXHRcdGlmICghdGhpcy5TcGVjaWZpY2F0aW9uLmxvY2F0aW9uTWFwcylcblx0XHR7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXHRcdGxldCBmYWNldE9wdGlvbkxpc3QgPSBbXTtcblx0XHRmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5TcGVjaWZpY2F0aW9uLmxvY2F0aW9uTWFwcykpXG5cdFx0e1xuXHRcdFx0bGV0IGxvY2F0aW9uTWFwID0gdGhpcy5TcGVjaWZpY2F0aW9uLmxvY2F0aW9uTWFwc1trZXldO1xuXHRcdFx0bGV0IGZhY2V0T3B0aW9uOiBGYWNldE9wdGlvbiA9IFxuXHRcdFx0e1xuXHRcdFx0XHRuYW1lOiBrZXksXG5cdFx0XHRcdEdldEZhY2V0czogKCkgPT4ge3JldHVybiB0aGlzLmdldEZhY2V0TGlzdChsb2NhdGlvbk1hcCl9XG5cdFx0XHR9XG5cdFx0XHRmYWNldE9wdGlvbkxpc3QucHVzaChmYWNldE9wdGlvbilcblx0XHR9XG5cdFx0cmV0dXJuIGZhY2V0T3B0aW9uTGlzdDtcblx0fVxuXG5cdHByb3RlY3RlZCBhYnN0cmFjdCBnZXRGYWNldExpc3QobG9jYXRpb25NYXA6IExvY2F0aW9uTWFwTGlzdCk6IEZhY2V0W107XG5cblx0cHJpdmF0ZSBpbml0QXR0cmlidXRlTGlzdCgpOiB2b2lkXG5cdHtcblx0XHRsZXQgcG9pbnRMaXN0ID0gWy4uLnRoaXNdO1xuXHRcdGlmIChwb2ludExpc3QubGVuZ3RoID4gMClcblx0XHR7XG5cdFx0XHRsZXQgcG9pbnQgPSBwb2ludExpc3RbMF07XG5cdFx0XHRmb3IgKGxldCBrZXkgb2YgcG9pbnQudmFsdWVNYXAua2V5cygpKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLl9hdHRyaWJ1dGVMaXN0LnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgZ2V0TWluTWF4KGtleTogc3RyaW5nKTogW251bWJlciwgbnVtYmVyXVxuXHR7XG5cdFx0aWYgKHRoaXMubWluTWF4Q2FjaGUuaGFzKGtleSkpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHRoaXMubWluTWF4Q2FjaGUuZ2V0KGtleSk7XG5cdFx0fVxuXHRcdGxldCBtaW5OOiBudW1iZXIgPSBJbmZpbml0eTtcblx0XHRsZXQgbWF4TjogbnVtYmVyID0gLUluZmluaXR5O1xuXG5cdFx0Zm9yIChsZXQgcG9pbnQgb2YgdGhpcylcblx0XHR7XG5cdFx0XHRsZXQgdmFsID0gcG9pbnQudmFsdWVNYXAuZ2V0KGtleSk7XG5cdFx0XHRpZiAodmFsIDwgbWluTilcblx0XHRcdHtcblx0XHRcdFx0bWluTiA9IHZhbDtcblx0XHRcdH1cblx0XHRcdGlmICh2YWwgPiBtYXhOKVxuXHRcdFx0e1xuXHRcdFx0XHRtYXhOID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLm1pbk1heENhY2hlLnNldChrZXksIFttaW5OLCBtYXhOXSk7XG5cdFx0cmV0dXJuIFttaW5OLCBtYXhOXVxuXHR9XG5cblx0cHVibGljIGFkZEJydXNoKGJydXNoS2V5OiBzdHJpbmcsIC4uLmZpbHRlcnM6IHZhbHVlRmlsdGVyW10pOiB2b2lkXG5cdHtcblx0XHR0aGlzLmFkZEJydXNoTm9VcGRhdGUoYnJ1c2hLZXksIC4uLmZpbHRlcnMpO1xuXHRcdHRoaXMudXBkYXRlQnJ1c2goKTtcblx0fVxuXG5cdHB1YmxpYyBhZGRCcnVzaE5vVXBkYXRlKGJydXNoS2V5OiBzdHJpbmcsIC4uLmZpbHRlcnM6IHZhbHVlRmlsdGVyW10pOiB2b2lkXG5cdHtcblx0XHRpZiAoIXRoaXMuYnJ1c2hMaXN0LmhhcyhicnVzaEtleSkpXG5cdFx0e1xuXHRcdFx0dGhpcy5icnVzaExpc3Quc2V0KGJydXNoS2V5LCBuZXcgTWFwPHN0cmluZywgW251bWJlciwgbnVtYmVyXT4oKSk7XG5cdFx0fVxuXHRcdGxldCB0aGlzTWFwID0gdGhpcy5icnVzaExpc3QuZ2V0KGJydXNoS2V5KTtcblx0XHRmb3IgKGxldCBmaWx0ZXIgb2YgZmlsdGVycylcblx0XHR7XG5cdFx0XHR0aGlzTWFwLnNldChmaWx0ZXIua2V5LCBmaWx0ZXIuYm91bmQpXG5cdFx0fVxuXHRcdHJldHVyblxuXHR9XG5cblx0cHVibGljIHJlbW92ZUJydXNoKGJydXNoS2V5OiBhbnkpOiB2b2lkXG5cdHtcblx0XHR0aGlzLmJydXNoTGlzdC5kZWxldGUoYnJ1c2hLZXkpO1xuXHRcdHRoaXMudXBkYXRlQnJ1c2goKTtcblx0fVxuXG5cdHB1YmxpYyBTZXRCcnVzaFZhbHVlcygpOiBib29sZWFuXG5cdHtcblx0XHRsZXQgYnJ1c2hBcHBsaWVkID0gZmFsc2U7XG5cdFx0Zm9yIChsZXQgcG9pbnQgb2YgdGhpcylcblx0XHR7XG5cdFx0XHRmb3IgKGxldCB2YWx1ZUZpbHRlck1hcCBvZiB0aGlzLmJydXNoTGlzdC52YWx1ZXMoKSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgW2tleSwgYm91bmRdIG9mIHZhbHVlRmlsdGVyTWFwKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGV0IHZhbHVlRmlsdGVyID0ge1xuXHRcdFx0XHRcdFx0a2V5OiBrZXksXG5cdFx0XHRcdFx0XHRib3VuZDogYm91bmRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFQb2ludENvbGxlY3Rpb24uSXNJbkJydXNoKHBvaW50LCB2YWx1ZUZpbHRlcikpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0cG9pbnQuaW5CcnVzaCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJ1c2hBcHBsaWVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGJydXNoQXBwbGllZDtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgSXNJbkJydXNoKHBvaW50OiBORGltLCB2YWx1ZUZpbHRlcjogdmFsdWVGaWx0ZXIpOiBib29sZWFuXG5cdHtcblx0XHRsZXQgdjogbnVtYmVyID0gcG9pbnQuZ2V0KHZhbHVlRmlsdGVyLmtleSk7XG5cdFx0bGV0IFtsb3csIGhpZ2hdID0gdmFsdWVGaWx0ZXIuYm91bmQ7XG5cdFx0cmV0dXJuIGxvdyA8PSB2ICYmIHYgPD0gaGlnaCAmJiAhaXNOYU4odik7XG5cdH1cblxuXHRwdWJsaWMgdXBkYXRlQnJ1c2goKTogdm9pZFxuXHR7XG5cdFx0bGV0IGV2ZW50ID0gbmV3IEV2ZW50KERhdGFFdmVudHMuYnJ1c2hDaGFuZ2UpO1xuXHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHR9XG5cbn1cblxuXG4iLCJpbXBvcnQgeyBTdHJpbmdUb051bWJlck9iaiwgTkRpbSB9IGZyb20gJy4uL2RldmxpYi9EZXZsaWJUeXBlcydcbmltcG9ydCB7IEN1cnZlTkQgfSBmcm9tICcuL0N1cnZlTkQnO1xuXG5leHBvcnQgY2xhc3MgUG9pbnRORCBpbXBsZW1lbnRzIE5EaW0ge1xuXG5cdGNvbnN0cnVjdG9yKHBvam8/OiBTdHJpbmdUb051bWJlck9iailcblx0e1xuXHRcdHRoaXMuX3ZhbHVlTWFwID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblx0XHRmb3IgKGxldCBrZXkgaW4gcG9qbylcblx0XHR7XG5cdFx0XHRjb25zdCBtOiBudW1iZXIgPSArcG9qb1trZXldO1xuXHRcdFx0dGhpcy5fdmFsdWVNYXAuc2V0KGtleSwgbSk7XG5cdFx0fVxuXHRcdHRoaXMuX2luQnJ1c2ggPSB0cnVlO1xuXHRcdHRoaXMuX3BhcmVudCA9IG51bGw7XG5cdH1cblxuXHRwcml2YXRlIF92YWx1ZU1hcCA6IE1hcDxzdHJpbmcsIG51bWJlcj47XG5cdHB1YmxpYyBnZXQgdmFsdWVNYXAoKSA6IE1hcDxzdHJpbmcsIG51bWJlcj4ge1xuXHRcdHJldHVybiB0aGlzLl92YWx1ZU1hcDtcblx0fVxuXG5cdHByaXZhdGUgX2luQnJ1c2ggOiBib29sZWFuO1xuXHRwdWJsaWMgZ2V0IGluQnJ1c2goKSA6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLl9pbkJydXNoO1xuXHR9XG5cdHB1YmxpYyBzZXQgaW5CcnVzaCh2OiBib29sZWFuKSB7XG5cdFx0dGhpcy5faW5CcnVzaCA9IHY7XG5cdH1cblx0XG5cdHByaXZhdGUgX3BhcmVudCA6IEN1cnZlTkQgfCBudWxsO1xuXHRwdWJsaWMgZ2V0IHBhcmVudCgpIDogQ3VydmVORCB8IG51bGwge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH1cblx0cHVibGljIHNldCBwYXJlbnQodiA6IEN1cnZlTkQgfCBudWxsKSB7XG5cdFx0dGhpcy5fcGFyZW50ID0gdjtcblx0fVxuXG5cdHB1YmxpYyBhZGRWYWx1ZShrZXk6IHN0cmluZywgdmFsdWU6IG51bWJlcilcblx0e1xuXHRcdHRoaXMudmFsdWVNYXAuc2V0KGtleSwgdmFsdWUpO1xuXHR9XG5cblx0cHVibGljIGdldChrZXk6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZFxuXHR7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWVNYXAuZ2V0KGtleSk7XG5cdH1cbn0iLCJpbXBvcnQge0ZyYW1lLCBEaXJlY3Rpb259IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTGF5b3V0RnJhbWV3b3JrIHtcblx0XG5cdGNvbnN0cnVjdG9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIGluY2x1ZGVCb3JkZXJzOiBib29sZWFuID0gdHJ1ZSlcblx0e1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHR0aGlzLl9pbmNsdWRlQm9yZGVycyA9IGluY2x1ZGVCb3JkZXJzO1xuXHR9XG5cblx0cHJpdmF0ZSBfY29udGFpbmVyIDogSFRNTEVsZW1lbnQ7XG5cdHB1YmxpYyBnZXQgY29udGFpbmVyKCkgOiBIVE1MRWxlbWVudCB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcblx0fVxuXG5cdHByaXZhdGUgX2luY2x1ZGVCb3JkZXJzIDogYm9vbGVhbjtcblx0cHVibGljIGdldCBpbmNsdWRlQm9yZGVycygpIDogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2luY2x1ZGVCb3JkZXJzO1xuXHR9XHRcblxuXHRwdWJsaWMgSW5pdGlhbGl6ZUxheW91dDxDb250ZW50VHlwZT4oZnJhbWU6IEZyYW1lPENvbnRlbnRUeXBlPik6IE1hcDxIVE1MRWxlbWVudCwgQ29udGVudFR5cGU+XG5cdHtcblx0XHRsZXQgZWxlbWVudFRvQ29tcG9uZW50VHlwZSA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIENvbnRlbnRUeXBlPigpO1xuXHRcdHRoaXMuYWRkRnJhbWU8Q29udGVudFR5cGU+KHRoaXMuY29udGFpbmVyLCBmcmFtZSwgZWxlbWVudFRvQ29tcG9uZW50VHlwZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIGVsZW1lbnRUb0NvbXBvbmVudFR5cGU7XG5cdH1cblxuXHRwcml2YXRlIGFkZEZyYW1lPENvbnRlbnRUeXBlPihjb250YWluZXI6IEhUTUxFbGVtZW50LCBmcmFtZTogRnJhbWU8Q29udGVudFR5cGU+LCBsb29rdXA6IE1hcDxFbGVtZW50LCBDb250ZW50VHlwZT4sIHNraXBUaGlzQm9yZGVyOiBib29sZWFuKTogdm9pZFxuXHR7XG5cdFx0Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmFtZVwiKTtcblx0XHRpZiAodGhpcy5pbmNsdWRlQm9yZGVycyAmJiAhc2tpcFRoaXNCb3JkZXIpXG5cdFx0e1xuXHRcdFx0Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dpdGgtYm9yZGVyJyk7XG5cdFx0fVxuXHRcdGxldCBkaXJDbGFzczogc3RyaW5nO1xuXHRcdGxldCBkaXJQb3N0Rml4OiBzdHJpbmc7XG5cdFx0aWYgKGZyYW1lLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLmNvbHVtbilcblx0XHR7XG5cdFx0XHRkaXJDbGFzcyA9IFwiZGlyLWNvbFwiO1xuXHRcdFx0ZGlyUG9zdEZpeCA9IFwid2lkdGhcIjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZnJhbWUuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24ucm93KVxuXHRcdHtcblx0XHRcdGRpckNsYXNzID0gXCJkaXItcm93XCI7XG5cdFx0XHRkaXJQb3N0Rml4ID0gXCJoZWlnaHRcIjtcblx0XHR9XG5cdFx0Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQoZGlyQ2xhc3MpO1xuXHRcdGxldCBpbmxpbmVTdHlsZTogc3RyaW5nID0gXCJcIjtcblx0XHRpZiAodHlwZW9mIGZyYW1lLm1pblNpemUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0e1xuXHRcdFx0aW5saW5lU3R5bGUgKz0gYG1pbi0ke2RpclBvc3RGaXh9OiAke2ZyYW1lLm1pblNpemV9OyBgO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGZyYW1lLm1heFNpemUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0e1xuXHRcdFx0aW5saW5lU3R5bGUgKz0gYG1heC0ke2RpclBvc3RGaXh9OiAke2ZyYW1lLm1heFNpemV9OyBgO1x0XHRcdFxuXHRcdH1cblxuXHRcdGlmIChmcmFtZS53cmFwKVxuXHRcdHtcblx0XHRcdGlubGluZVN0eWxlICs9ICdmbGV4LXdyYXA6IHdyYXA7ICc7XG5cdFx0fVxuXG5cdFx0aWYgKGZyYW1lLm92ZXJmbG93U2Nyb2xsKVxuXHRcdHtcblx0XHRcdGlubGluZVN0eWxlICs9ICdvdmVyZmxvdzogYXV0bzsgJztcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIGZyYW1lLmZyYWN0aW9uID09PSBcInVuZGVmaW5lZFwiKVxuXHRcdHtcblx0XHRcdGZyYW1lLmZyYWN0aW9uID0gMTtcblx0XHR9XG5cdFx0aW5saW5lU3R5bGUgKz0gYGZsZXgtZ3JvdzogJHtmcmFtZS5mcmFjdGlvbn07IGA7XHRcdFx0XG5cblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgaW5saW5lU3R5bGUpO1xuXG5cdFx0aWYgKGZyYW1lLmluc2lkZSBpbnN0YW5jZW9mIEFycmF5KVxuXHRcdHtcblx0XHRcdGxldCBsYXN0Q2hpbGRGcmFtZSA9IGZyYW1lLmluc2lkZVtmcmFtZS5pbnNpZGUubGVuZ3RoIC0gMV07XG5cdFx0XHRmb3IgKGxldCBjaGlsZEZyYW1lIG9mIGZyYW1lLmluc2lkZSlcblx0XHRcdHtcblx0XHRcdFx0bGV0IGNoaWxkQ29udGFpbmVyOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZENvbnRhaW5lcik7XG5cdFx0XHRcdGxldCBpc0xhc3RDaGlsZCA9IGNoaWxkRnJhbWUgPT09IGxhc3RDaGlsZEZyYW1lO1xuXHRcdFx0XHR0aGlzLmFkZEZyYW1lKGNoaWxkQ29udGFpbmVyLCBjaGlsZEZyYW1lLCBsb29rdXAsIGlzTGFzdENoaWxkKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGxvb2t1cC5zZXQoY29udGFpbmVyLCBmcmFtZS5pbnNpZGUpO1xuXHRcdH1cblx0fVxufSIsImV4cG9ydCBjbGFzcyBEZXZsaWJBbGdvIHtcblx0XG5cdHB1YmxpYyBzdGF0aWMgQmluYXJ5U2VhcmNoSW5kZXg8VD4obGlzdDogVFtdLCBjb21wYXJlRnVuY3Rpb246IChlbGVtZW50OiBUKSA9PiBudW1iZXIpOiBudW1iZXIgfCBbbnVtYmVyIHwgdW5kZWZpbmVkLCBudW1iZXIgfCB1bmRlZmluZWRdXG5cdHtcblx0XHRpZiAobGlzdC5sZW5ndGggPT09IDApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG5cdFx0fVxuXHRcdGxldCBmaXJzdEVsZW1lbnQ6IFQgPSBsaXN0WzBdO1xuXHRcdGxldCBjb21wYXJlUmVzdWx0ID0gY29tcGFyZUZ1bmN0aW9uKGZpcnN0RWxlbWVudCk7XG5cdFx0aWYgKGNvbXBhcmVSZXN1bHQgPiAwKVxuXHRcdHtcblx0XHRcdHJldHVybiBbdW5kZWZpbmVkLCAwXTtcblx0XHR9XG5cdFx0bGV0IGxhc3RFbGVtZW50OiBUID0gbGlzdFtsaXN0Lmxlbmd0aCAtIDFdO1xuXHRcdGNvbXBhcmVSZXN1bHQgPSBjb21wYXJlRnVuY3Rpb24obGFzdEVsZW1lbnQpO1xuXHRcdGlmIChjb21wYXJlUmVzdWx0IDwgMClcblx0XHR7XG5cdFx0XHRyZXR1cm4gW2xpc3QubGVuZ3RoIC0gMSwgdW5kZWZpbmVkXTtcblx0XHR9XG5cdFx0cmV0dXJuIERldmxpYkFsZ28uQmluYXJ5U2VhcmNoUmVjdXJzZShsaXN0LCBjb21wYXJlRnVuY3Rpb24sIDAsIGxpc3QubGVuZ3RoIC0gMSk7XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIEJpbmFyeVNlYXJjaFJlY3Vyc2U8VD4obGlzdDogVFtdLCBjb21wYXJlRnVuY3Rpb246IChlbGVtZW50OiBUKSA9PiBudW1iZXIsIGlkeDE6IG51bWJlciwgaWR4MjogbnVtYmVyKTogbnVtYmVyIHwgW251bWJlciwgbnVtYmVyXVxuXHR7XG5cdFx0aWYgKE1hdGguYWJzKGlkeDEgLSBpZHgyKSA9PT0gMSlcblx0XHR7XG5cdFx0XHRyZXR1cm4gW2lkeDEsIGlkeDJdO1xuXHRcdH1cblx0XHQvLyBpZiAoaWR4MSA9PT0gaWR4Milcblx0XHQvLyB7XG5cdFx0Ly8gXHRyZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuXHRcdC8vIH1cblx0XHRsZXQgbWlkSW5kZXggPSBNYXRoLmZsb29yKChpZHgxICsgaWR4MikgLyAyKTtcblx0XHRsZXQgZWxlbWVudDogVCA9IGxpc3RbbWlkSW5kZXhdO1xuXHRcdGxldCBjb21wYXJlUmVzdWx0ID0gY29tcGFyZUZ1bmN0aW9uKGVsZW1lbnQpO1xuXHRcdGlmIChjb21wYXJlUmVzdWx0ID09PSAwKVxuXHRcdHtcblx0XHRcdHJldHVybiBtaWRJbmRleDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY29tcGFyZVJlc3VsdCA+IDApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIERldmxpYkFsZ28uQmluYXJ5U2VhcmNoUmVjdXJzZShsaXN0LCBjb21wYXJlRnVuY3Rpb24sIGlkeDEsIG1pZEluZGV4KTtcdFx0XHRcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY29tcGFyZVJlc3VsdCA8IDApXG5cdFx0e1xuXHRcdFx0cmV0dXJuIERldmxpYkFsZ28uQmluYXJ5U2VhcmNoUmVjdXJzZShsaXN0LCBjb21wYXJlRnVuY3Rpb24sIG1pZEluZGV4LCBpZHgyKTtcblx0XHR9XG5cdH1cblxuXG5cdHB1YmxpYyBzdGF0aWMgY29tcGFyZVByb3BlcnR5PG9ialR5cGU+KG51bTogbnVtYmVyLCBwcm9wZXJ0eUFjY2Vzc29yOiAob2JqVHlwZTogYW55KSA9PiBudW1iZXIsKTogKG9iajogb2JqVHlwZSkgPT4gbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gKGE6IG9ialR5cGUpID0+XG5cdFx0e1xuXHRcdFx0Y29uc3QgYVZhbCA9IHByb3BlcnR5QWNjZXNzb3IoYSk7XG5cdFx0XHRyZXR1cm4gRGV2bGliQWxnby5jb21wYXJlVmFsdWVzKGFWYWwsIG51bSk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzb3J0T25Qcm9wZXJ0eTxvYmpUeXBlPihwcm9wZXJ0eUFjY2Vzc29yOiAob2JqVHlwZTogb2JqVHlwZSkgPT4gbnVtYmVyLCBhc2NlbmQgPSB0cnVlKTogKGE6IG9ialR5cGUsIGI6IG9ialR5cGUpID0+IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIChhOiBvYmpUeXBlLCBiOiBvYmpUeXBlKSA9PlxuXHRcdHtcblx0XHRcdGNvbnN0IGFWYWwgPSBwcm9wZXJ0eUFjY2Vzc29yKGEpO1xuXHRcdFx0Y29uc3QgYlZhbCA9IHByb3BlcnR5QWNjZXNzb3IoYik7XG5cdFx0XHRpZiAoYXNjZW5kKVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gRGV2bGliQWxnby5zb3J0QXNjZW5kKGFWYWwsIGJWYWwpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gRGV2bGliQWxnby5zb3J0RGVzY2VuZChhVmFsLCBiVmFsKTtcdFx0XHRcdFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc29ydEFzY2VuZChhVmFsOiBudW1iZXIsIGJWYWw6IG51bWJlcik6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIERldmxpYkFsZ28uY29tcGFyZVZhbHVlcyhhVmFsLCBiVmFsKTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc29ydERlc2NlbmQoYVZhbDogbnVtYmVyLCBiVmFsOiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiBEZXZsaWJBbGdvLmNvbXBhcmVWYWx1ZXMoYlZhbCwgYVZhbCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBjb21wYXJlVmFsdWVzKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyXG5cdHtcblx0XHRcdGxldCBkaWZmID0gYSAtIGI7XG5cdFx0XHRpZiAoTWF0aC5hYnMoZGlmZikgPiAwKVxuXHRcdFx0e1xuXHRcdFx0XHRkaWZmIC89IE1hdGguYWJzKGRpZmYpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxufSIsImV4cG9ydCBjbGFzcyBEZXZsaWJNYXRoXG57XG5cblx0cHVibGljIHN0YXRpYyBzdW1OKC4uLm51bWJlcnM6IG51bWJlcltdKTogbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gbnVtYmVycy5yZWR1Y2UoIChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGIgKTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc3VtKGFycjogbnVtYmVyW10pOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiBEZXZsaWJNYXRoLnN1bU4oLi4uYXJyKTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgYXZlcmFnZU4oLi4ubnVtYmVyczogbnVtYmVyW10pOiBudW1iZXJcblx0e1xuXHRcdGNvbnN0IHN1bSA9IERldmxpYk1hdGguc3VtKG51bWJlcnMpO1xuXHRcdHJldHVybiBzdW0gLyBudW1iZXJzLmxlbmd0aDtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgYXZlcmFnZShhcnI6IG51bWJlcltdKTogbnVtYmVyXG5cdHtcblx0XHRyZXR1cm4gRGV2bGliTWF0aC5hdmVyYWdlTiguLi5hcnIpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBtZWFuU3F1YXJlZEVycm9yKG51bWJlcnM6IG51bWJlcltdLCB2OiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdGNvbnN0IHNxdWFyZWRFcnJvcnM6IG51bWJlcltdID0gbnVtYmVycy5tYXAoIChhOiBudW1iZXIpID0+IE1hdGgucG93KGEgLSB2LCAgMikgKTtcblx0XHRyZXR1cm4gRGV2bGliTWF0aC5hdmVyYWdlKHNxdWFyZWRFcnJvcnMpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyB2YXJpYW5jZU4oLi4ubnVtYmVyczogbnVtYmVyW10pOiBudW1iZXJcblx0e1xuXHRcdGxldCBhdmcgPSBEZXZsaWJNYXRoLmF2ZXJhZ2UobnVtYmVycyk7XG5cdFx0cmV0dXJuIERldmxpYk1hdGgubWVhblNxdWFyZWRFcnJvcihudW1iZXJzLCBhdmcpO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyB2YXJpYW5jZShudW1iZXJzOiBudW1iZXJbXSk6IG51bWJlclxuXHR7XG5cdFx0cmV0dXJuIERldmxpYk1hdGgudmFyaWFuY2VOKC4uLm51bWJlcnMpO1xuXHR9XG5cblx0Ly8gcmV0dXJucyBhIG51bWJlciBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4XSBpbmNsdXNpdmUgb24gYm90aCBlbmRzLlxuXHRwdWJsaWMgc3RhdGljIHJhbmRvbUludChtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4ICsgMSkpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgbkNob29zZVR3byhuOiBudW1iZXIpOiBudW1iZXJcblx0e1xuXHRcdHJldHVybiBuICogKG4tMSkgLyAyLjBcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgaXNOdW1iZXIodGV4dDogc3RyaW5nKTogYm9vbGVhblxuXHR7XG5cdFx0aWYgKHRleHQgPT09IFwiXCIpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gIWlzTmFOKE51bWJlcih0ZXh0KSlcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgY2xhbXAodmFsOiBudW1iZXIsIFttaW5WYWwsIG1heFZhbF06IFtudW1iZXIsIG51bWJlcl0pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pblZhbCksIG1heFZhbCk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgaW1hZ2UgfSBmcm9tIFwiZDNcIjtcblxuZXhwb3J0IGNsYXNzIERldmxpYlRTVXRpbCB7XG5cblx0cHVibGljIHN0YXRpYyBhc3luYyBhc3luY1NldFRpbWVvdXQoZjogRnVuY3Rpb24sIG1pbGxpRGVsYXk6IG51bWJlcik6IFByb21pc2U8YW55PlxuXHR7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PlxuXHRcdHtcblx0XHRcdHNldFRpbWVvdXQoXG5cdFx0XHRcdCgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmKCk7XG5cdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRtaWxsaURlbGF5XG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBhc3luYyBtYWtlQXN5bmMoZjogRnVuY3Rpb24pOiBQcm9taXNlPGFueT5cblx0e1xuXHRcdHJldHVybiBEZXZsaWJUU1V0aWwuYXN5bmNTZXRUaW1lb3V0KGYsIDApO1xuXHR9XG5cblx0cHVibGljIHN0YXRpYyBnZXRJY29uQnV0dG9uKGljb25LZXk6IHN0cmluZywgY2FsbGJhY2s6IChldjogTW91c2VFdmVudCkgPT4gdm9pZCwgdGV4dD86IHN0cmluZyk6IEhUTUxCdXR0b25FbGVtZW50XG5cdHtcblx0XHRsZXQgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG5cdFx0YnRuLmNsYXNzTGlzdC5hZGQoJ2Jhc2ljSWNvbkJ1dHRvbicpO1xuXHRcdGxldCBpY29uID0gRGV2bGliVFNVdGlsLmdldEZvbnRBd2Vzb21lSWNvbihpY29uS2V5KTtcblx0XHRpZiAodGV4dClcblx0XHR7XG5cdFx0XHRpZiAoIXRleHQuZW5kc1dpdGgoJyAnKSlcblx0XHRcdHtcblx0XHRcdFx0dGV4dCArPSAnICc7XG5cdFx0XHR9XG5cdFx0XHRidG4uYXBwZW5kKHRleHQpO1xuXHRcdFx0YnRuLmNsYXNzTGlzdC5hZGQoJ3dpdGhUZXh0Jyk7XG5cdFx0fVxuXHRcdGJ0bi5hcHBlbmRDaGlsZChpY29uKTtcblx0XHRidG4ub25jbGljayA9IGNhbGxiYWNrO1xuXHRcdHJldHVybiBidG47XG5cdH1cblxuXHRwdWJsaWMgc3RhdGljIGdldEZvbnRBd2Vzb21lSWNvbihpY29uS2V5OiBzdHJpbmcpOiBIVE1MRWxlbWVudFxuXHR7XG5cdFx0Ly8gPGkgY2xhc3M9XCJmYXMgZmEte2ljb259XCI+PC9pPlxuXHRcdGxldCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XG5cdFx0aWNvbi5jbGFzc0xpc3QuYWRkKCdmYXMnKTtcblx0XHRpY29uLmNsYXNzTGlzdC5hZGQoJ2ZhLScgKyBpY29uS2V5KTtcblx0XHRyZXR1cm4gaWNvbjtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc2hvdyhlbGVtZW50OiBFbGVtZW50KTogdm9pZFxuXHR7XG5cdFx0ZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdub0Rpc3AnKTtcblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgaGlkZShlbGVtZW50OiBFbGVtZW50KTogdm9pZFxuXHR7XG5cdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdub0Rpc3AnKTtcblx0fVxuXHRwdWJsaWMgc3RhdGljIGxhdW5jaFNwaW5uZXIoKTogdm9pZFxuXHR7XG5cdFx0Y29uc3Qgb3V0ZXJJZCA9ICdsb2FkaW5nU3Bpbm5lckNvbnRhaW5lcic7XG5cdFx0aWYgKCFEZXZsaWJUU1V0aWwuc3Bpbm5lckluRG9tKCkpXG5cdFx0e1xuXHRcdFx0bGV0IG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRvdXRlci5jbGFzc0xpc3QuYWRkKCdzcGlubmVyT3V0ZXInKTtcblx0XHRcdG91dGVyLmlkID0gb3V0ZXJJZDtcblx0XHRcdFxuXHRcdFx0bGV0IGltZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0aW1nRGl2LmNsYXNzTGlzdC5hZGQoJ3NwaW5uZXJXcmFwcGVyJyk7XG5cblx0XHRcdGxldCBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXHRcdFx0aW5uZXIuY2xhc3NMaXN0LmFkZCgnc3Bpbm5lcicpO1xuXHRcdFx0aW5uZXIuc3JjID0gJy9zcGlubmVyLmdpZic7XG5cdFx0XHRpbWdEaXYuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuXHRcdFx0b3V0ZXIuYXBwZW5kQ2hpbGQoaW1nRGl2KTtcblx0XHRcdFxuXHRcdFx0bGV0IGF0dHJpYnV0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdFx0YXR0cmlidXRpb24uY2xhc3NMaXN0LmFkZCgnYXR0cmlidXRpb25MaW5rJyk7XG5cdFx0XHRhdHRyaWJ1dGlvbi5ocmVmID0gJ2h0dHBzOi8vbG9hZGluZy5pby9hc3NldC80NDI0NzMnO1xuXHRcdFx0YXR0cmlidXRpb24uaW5uZXJUZXh0ID0gXCJpY29uICdEb3VibGUgUmluZycgZnJvbSBsb2FkaW5nLmlvXCI7XG5cdFx0XHRcblx0XHRcdG91dGVyLmFwcGVuZENoaWxkKGF0dHJpYnV0aW9uKTtcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXHRcdH1cblx0XHRpZiAoIURldmxpYlRTVXRpbC5zcGlubmVyU3Bpbm5pbmcoKSlcblx0XHR7XG5cdFx0XHREZXZsaWJUU1V0aWwuc2hvdyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvdXRlcklkKSk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzdG9wU3Bpbm5lcigpOiB2b2lkXG5cdHtcblx0XHRsZXQgc3Bpbm5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FkaW5nU3Bpbm5lckNvbnRhaW5lcicpO1xuXHRcdGlmIChzcGlubmVyKVxuXHRcdHtcblx0XHRcdERldmxpYlRTVXRpbC5oaWRlKHNwaW5uZXIpO1xuXHRcdH1cblx0fVxuXG5cdHB1YmxpYyBzdGF0aWMgc3Bpbm5lckluRG9tKCk6IGJvb2xlYW5cblx0e1xuXHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hZGluZ1NwaW5uZXJDb250YWluZXInKSAhPT0gbnVsbFxuXHR9XG5cblx0cHVibGljIHN0YXRpYyBzcGlubmVyU3Bpbm5pbmcoKTogYm9vbGVhblxuXHR7XG5cdFx0bGV0IG91dGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYWRpbmdTcGlubmVyQ29udGFpbmVyJyk7XG5cdFx0aWYgKG91dGVyICYmICFvdXRlci5jbGFzc0xpc3QuY29udGFpbnMoJ25vRGlzcCcpKVxuXHRcdHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxufSIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IGxvYWQgfSBmcm9tIFwicHJvdG9idWZqc1wiO1xuaW1wb3J0IHsgQ3VydmVMaXN0IH0gZnJvbSAnLi4vc3JjL0RhdGFNb2RlbC9DdXJ2ZUxpc3QnO1xuaW1wb3J0IHsgQ3VydmVMaXN0RmFjdG9yeSB9IGZyb20gJy4uL3NyYy9EYXRhTW9kZWwvQ3VydmVMaXN0RmFjdG9yeSc7XG5pbXBvcnQgeyBEZXJpdmVkVHJhY2tWYWx1ZUZ1bmN0aW9ucyB9IGZyb20gJy4uL3NyYy9EYXRhTW9kZWwvRGVyaXZlZFRyYWNrVmFsdWVGdW5jdGlvbnMnO1xuaW1wb3J0IHsgRGVyaXZlZFBvaW50VmFsdWVGdW5jdGlvbnMgfSBmcm9tICcuLi9zcmMvRGF0YU1vZGVsL0Rlcml2ZWRQb2ludFZhbHVlRnVuY3Rpb25zJztcbmltcG9ydCB7IEFwcCB9IGZyb20gJy4vQXBwJztcbmltcG9ydCB7IERhdGFzZXRTcGVjIH0gZnJvbSAnLi90eXBlcyc7XG5cbmxldCBtZXRhQ29udGFpbmVyOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtZXRhQ29udGFpbmVyJyk7XG5cbmxldCBkZXJpdmVkVHJhY2tEYXRhRnVuY3Rpb25zID0gRGVyaXZlZFRyYWNrVmFsdWVGdW5jdGlvbnMuR2V0RnVuY3Rpb25MaXN0KCk7XG5sZXQgZGVyaXZlZFBvaW50RGF0YUZ1bmN0aW9ucyA9IERlcml2ZWRQb2ludFZhbHVlRnVuY3Rpb25zLkdldEZ1bmN0aW9uTGlzdCgpO1xubGV0IGFwcDogQXBwPEN1cnZlTGlzdCwgRGF0YXNldFNwZWM+ID0gbmV3IEFwcDxDdXJ2ZUxpc3QsIERhdGFzZXRTcGVjPihtZXRhQ29udGFpbmVyLCBDdXJ2ZUxpc3RGYWN0b3J5LkNyZWF0ZUN1cnZlTGlzdEZyb21DU1ZPYmplY3QsIGRlcml2ZWRUcmFja0RhdGFGdW5jdGlvbnMsIGRlcml2ZWRQb2ludERhdGFGdW5jdGlvbnMpO1xud2luZG93Lm9ucmVzaXplID0gKCkgPT4gYXBwLk9uV2luZG93UmVzaXplKCk7XG5cbmQzLmpzb24oJy9zdGF0aWMvbGF5b3V0cy9kZWZhdWx0TGF5b3V0Lmpzb24nKS50aGVuKGFzeW5jIChkYXRhOiBhbnkpID0+XG57XG4gICAgYXdhaXQgYXBwLkluaXREYXRhU3RvcmUoKTtcbiAgICBhcHAuSW5pdGlhbGl6ZUxheW91dChkYXRhKTtcbiAgICBjb25zdCBkYXRhc2V0SWQ6IHN0cmluZyA9IG1ldGFDb250YWluZXIuZGF0YXNldC5kYXRhc2V0O1xuICAgIGFwcC5Mb2FkRGF0YXNldChkYXRhc2V0SWQpO1xufSk7XG4iLCJleHBvcnQgaW50ZXJmYWNlIEZyYW1lPFQ+IHtcblx0ZnJhY3Rpb24/OiBudW1iZXIsIC8vIGlmIG5vIGZyYWN0aW9uIGlzIHNwZWNpZmllZCwgaXQgaXMgYXNzdW1lZCB0byBiZSBlcXVhbCB3ZWlnaHRcblx0bWluU2l6ZT86IHN0cmluZyxcblx0bWF4U2l6ZT86IHN0cmluZyxcblx0d3JhcD86IGJvb2xlYW4sXG5cdG92ZXJmbG93U2Nyb2xsPzogYm9vbGVhbixcblx0ZGlyZWN0aW9uOiBEaXJlY3Rpb24sXG5cdGluc2lkZTogRnJhbWU8VD5bXSB8IFRcbn1cblxuZXhwb3J0IGVudW0gRGlyZWN0aW9uIHtcblx0cm93ID0gXCJyb3dcIixcblx0Y29sdW1uID0gXCJjb2xcIlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudEluaXRJbmZvIHtcblx0dHlwZTogQ29tcG9uZW50VHlwZSxcblx0aW5pdEFyZ3M6IEFyZ3VtZW50c1xufVxuXG5leHBvcnQgZW51bSBDb21wb25lbnRUeXBlIHtcblx0VG9vbGJhciA9IFwiVG9vbGJhclwiLFxuXHRQbG90MmRQYXRoc1dpZGdldCA9IFwiUGxvdDJkUGF0aHNXaWRnZXRcIixcblx0TWV0cmljRGlzdHJpYnV0aW9uV2lkZ2V0ID0gXCJNZXRyaWNEaXN0cmlidXRpb25XaWRnZXRcIixcblx0SW1hZ2VTZWxlY3Rpb25XaWRnZXQgPSBcIkltYWdlU2VsZWN0aW9uV2lkZ2V0XCIsXG5cdEltYWdlU3RhY2tXaWRnZXQgPSBcIkltYWdlU3RhY2tXaWRnZXRcIixcblx0RGV0YWlsZWREaXN0cmlidXRpb24gPSBcIkRldGFpbGVkRGlzdHJpYnV0aW9uXCJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcmd1bWVudHMge1xuXHRbYXJnTmFtZTogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBlbnVtIE1ldHJpY0Rpc3RyaWJ1dGlvblN1YkNvbXBvbmVudFR5cGVzIHtcblx0QmFzaXNTZWxlY3QgPSBcIkJhc2lzU2VsZWN0XCIsXG5cdFNjYXR0ZXJwbG90U2VsZWN0ID0gXCJTY2F0dGVycGxvdFNlbGVjdFwiLFxuXHREaXN0cmlidXRpb25QbG90ID0gXCJEaXN0cmlidXRpb25QbG90XCIsXG5cdFNjYXR0ZXJwbG90ID0gXCJTY2F0dGVycGxvdFwiLFxuXHRUaXRsZSA9IFwiVGl0bGVcIlxufVxuXG5leHBvcnQgZW51bSBNZXRyaWNEaXN0cmlidXRpb25Db2xsZWN0aW9uTGV2ZWwge1xuXHRQb2ludCA9IFwiUG9pbnRcIixcblx0Q3VydmUgPSBcIkN1cnZlXCJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQXBwRGF0YTxTcGVjVHlwZT4ge1xuXHRHZXRGYWNldE9wdGlvbnM6ICgpID0+IEZhY2V0T3B0aW9uW107XG5cdE9uQnJ1c2hDaGFuZ2U6ICgpID0+IHZvaWQ7XG5cdENyZWF0ZUZpbHRlcmVkQ3VydmVMaXN0OiAoKSA9PiBBcHBEYXRhPFNwZWNUeXBlPjtcblx0QXBwbHlEZWZhdWx0RmlsdGVyczogKCkgPT4gdm9pZDtcblx0Q29uc3VtZUZpbHRlcnM6IChBcHBEYXRhKSA9PiB2b2lkO1xuXHRBcHBseU5ld0ZpbHRlcigpO1xuXHRTcGVjaWZpY2F0aW9uOiBTcGVjVHlwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGYWNldE9wdGlvbiB7XG5cdG5hbWU6IHN0cmluZyxcblx0R2V0RmFjZXRzOiAoKSA9PiBGYWNldFtdXG5cbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmFjZXQge1xuXHRuYW1lOiBzdHJpbmdbXSxcblx0ZGF0YTogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YXNldFNwZWMge1xuXHR1bmlxdWVJZDogc3RyaW5nLFxuICAgIGRpc3BsYXlOYW1lOiBzdHJpbmcsXG4gICAgZ29vZ2xlRHJpdmVJZDogc3RyaW5nLFxuXHRmb2xkZXJQYXRoOiBzdHJpbmcsXG5cdGxvY2F0aW9uTWFwczogTG9jYXRpb25NYXBzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYXRpb25NYXBzIHtcblx0W21hcE5hbWU6IHN0cmluZ106IExvY2F0aW9uTWFwTGlzdFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvY2F0aW9uTWFwTGlzdFxue1xuXHRbY2F0ZWdvcnlOYW1lOiBzdHJpbmddOiBbbnVtYmVyLCBudW1iZXJdW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbWFnZVN0YWNrTWV0YURhdGFcbntcblx0dXJsOiBzdHJpbmcsXG5cdHRpbGVXaWR0aDogbnVtYmVyLFxuXHR0aWxlSGVpZ2h0OiBudW1iZXIsXG5cdG51bWJlck9mVGlsZXM6IG51bWJlcixcblx0bnVtYmVyT2ZDb2x1bW5zOiBudW1iZXIsXG5cdHNjYWxlRmFjdG9yPzogbnVtYmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlY3QgPSBbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV07XG5cbmV4cG9ydCBpbnRlcmZhY2UgdmFsdWVGaWx0ZXIge1xuXHRrZXk6IHN0cmluZyxcblx0Ym91bmQ6IFtudW1iZXIsIG51bWJlcl1cbn1cblxuZXhwb3J0IHR5cGUgZGF0YUZpbHRlciA9IHRyYWNrRmlsdGVyIHwgY2VsbEZpbHRlciB8IGN1cnZlRmlsdGVyO1xuXG5leHBvcnQgaW50ZXJmYWNlIHRyYWNrRmlsdGVyIHtcblx0dHlwZTogJ3RyYWNrJyxcblx0ZmlsdGVyS2V5OiBzdHJpbmcsXG5cdGZpbHRlcjogdmFsdWVGaWx0ZXIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgY2VsbEZpbHRlciB7XG5cdHR5cGU6ICdjZWxsJyxcblx0ZmlsdGVyS2V5OiBzdHJpbmcsXG5cdGZpbHRlcjogdmFsdWVGaWx0ZXIsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgY3VydmVGaWx0ZXIge1xuXHR0eXBlOiAnY3VydmUnLFxuXHRmaWx0ZXJLZXk6IHN0cmluZyxcblx0ZmlsdGVyOiBbdmFsdWVGaWx0ZXIsIHZhbHVlRmlsdGVyXSxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBjb25kaXRpb25FeGVtcGxhcjxkYXRhVHlwZT4ge1xuXHRkYXRhOiBkYXRhVHlwZSxcblx0dHlwZTogJ2F1dG8nIHwgJ21hbnVhbCcsXG5cdGFuY2hvclZhbD86IG51bWJlclxufSJdfQ==
